(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x6) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x6, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x6)(function(x6) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x6 + '" is not supported');
  });
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
    mod4
  ));

  // node_modules/@jrc03c/js-math-tools/dist/js-math-tools.import.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber(x6) {
    return typeof x6 === "number" && !isNaN(x6) || typeof x6 === "bigint";
  }
  var isBrowser = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError = class extends Error {
    constructor(message) {
      if (isBrowser()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert(isTrue, message) {
    if (!isTrue)
      throw new MathError(message);
  }
  var arrayTypes = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined(x6) {
    return x6 === null || typeof x6 === "undefined";
  }
  var typeStrings = arrayTypes.map((s25) => s25.name);
  function isArray(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined(obj.constructor)) {
        return arrayTypes.indexOf(obj.constructor) > -1 || typeStrings.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e28) {
      return false;
    }
  }
  function isDataFrame(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e28) {
      return false;
    }
  }
  function isFunction(fn2) {
    return typeof fn2 === "function";
  }
  function isObject(x6) {
    return typeof x6 === "object" && !isUndefined(x6) && !isArray(x6);
  }
  function isSeries(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e28) {
      return false;
    }
  }
  function indexOf(x6, fn2) {
    if (isDataFrame(x6)) {
      const index = indexOf(x6.values, fn2);
      if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      if (index.length > 1 && isNumber(index[1]) && index[1] >= 0 && index[1] < x6.columns.length) {
        index[1] = x6.columns[index[1]];
      }
      return index;
    }
    if (isSeries(x6)) {
      const index = indexOf(x6.values, fn2);
      if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      return index;
    }
    assert(isObject(x6) || isArray(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper54(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return [key];
          }
          const results = helper54(value, fn22, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return [i];
          }
          const results = helper54(value, fn22, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn22(x22)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const paths = helper54(x6, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy(x6) {
    function helper54(x22) {
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        if (isArray(x22)) {
          if (!(x22 instanceof Array)) {
            return x22.slice();
          }
          return x22.map((v) => copy(v));
        }
        if (isSeries(x22)) {
          const out32 = x22.copy();
          out32.values = copy(out32.values);
          return out32;
        }
        if (isDataFrame(x22)) {
          const out32 = x22.copy();
          out32.values = copy(x22.values);
          return out32;
        }
        if (x22 instanceof Date) {
          return new Date(x22.getTime());
        }
        x22 = decycle(x22);
        const out24 = {};
        Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
          out24[key] = copy(x22[key]);
        });
        return out24;
      } else {
        return x22;
      }
    }
    return helper54(decycle(x6));
  }
  function decycle(x6) {
    function helper54(x22, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x22) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x22;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x22 ? "/" : "/" + indexOf(orig, x22).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x22 === "object") {
        if (x22 === null)
          return null;
        checked.push(x22);
        if (isArray(x22)) {
          if (typeof x22.constructor !== "undefined" && x22.constructor.name !== "Array") {
            return x22.slice();
          }
          return x22.map((v, i) => helper54(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
            x22[key] = helper54(x22[key], checked, currentPath + "/" + key.toString());
          });
          return x22;
        }
      } else {
        return x22;
      }
    }
    const orig = x6;
    let out24 = helper54(orig);
    if (isDataFrame(x6)) {
      const temp = x6.copy();
      temp._values = out24.values;
      temp._columns = out24.columns;
      temp._index = out24.index;
      out24 = temp;
    }
    if (isSeries(x6)) {
      const temp = x6.copy();
      temp.name = out24.name;
      temp._values = out24.values;
      temp._index = out24.index;
      out24 = temp;
    }
    return out24;
  }
  function isDate(x6) {
    return x6 instanceof Date && x6.toString() !== "Invalid Date";
  }
  var numberTypes = ["number", "int", "float", "bigint"];
  function isEqual(a, b) {
    function helper54(a22, b22) {
      const aType = typeof a22;
      const bType = typeof b22;
      if (aType !== bType && !numberTypes.includes(aType) && !numberTypes.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a22 === b22;
      if (aType === "symbol")
        return a22 === b22;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a22.toString();
          const bString = b22.toString();
          return aString === bString;
        } catch (e28) {
          return false;
        }
      }
      if (aType === "string")
        return a22 === b22;
      if (aType === "function")
        return a22 === b22;
      if (aType === "object") {
        if (a22 === null || b22 === null) {
          return a22 === null && b22 === null;
        } else {
          if (isDate(a22)) {
            if (isDate(b22)) {
              return a22.getTime() === b22.getTime();
            } else {
              return false;
            }
          } else if (isDate(b22)) {
            return false;
          }
          if (a22 instanceof RegExp && b22 instanceof RegExp) {
            return a22.toString() === b22.toString();
          }
          if (isArray(a22) !== isArray(b22)) {
            return false;
          }
          const aKeys = Object.keys(a22).concat(Object.getOwnPropertySymbols(a22));
          const bKeys = Object.keys(b22).concat(Object.getOwnPropertySymbols(b22));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper54(a22[key], b22[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper54(a, b);
    } catch (e28) {
      return helper54(decycle(a), decycle(b));
    }
  }
  function makeKey(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY = makeKey(16);
  var UNDEFINED_KEY = makeKey(16);
  var INFINITY_KEY = makeKey(16);
  var MINUS_INFINITY_KEY = makeKey(16);
  var SYMBOL_KEY = makeKey(16);
  var Counter = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x6) {
      for (const v of x6) {
        if (isArray(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY : isUndefined(value) ? UNDEFINED_KEY : isFunction(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY : value === Infinity ? INFINITY_KEY : value === -Infinity ? MINUS_INFINITY_KEY : typeof value === "bigint" ? value.toString() : isDataFrame(value) ? value.toJSONString() : isSeries(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count24) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count24;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out24 = {};
      this.values.forEach((value) => {
        out24[value] = this.get(value);
      });
      return out24;
    }
  };
  function flatten(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return flatten(arr.values);
    }
    assert(isArray(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper54(arr2) {
      let out24 = [];
      arr2.forEach((child) => {
        if (isArray(child)) {
          out24 = out24.concat(helper54(child));
        } else {
          out24.push(child);
        }
      });
      return out24;
    }
    return helper54(arr);
  }
  function stats(x6, options) {
    options = options || {};
    const counts = new Counter();
    const out24 = {};
    const xflat = flatten(x6);
    const xnums = [];
    let max24 = -Infinity;
    let min24 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum24 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber(v)) {
        try {
          if (v > max24) {
            max24 = v;
          }
          if (v < min24) {
            min24 = v;
          }
          sum24 += Number(v);
          xnums.push(v);
        } catch (e28) {
          max24 = NaN;
          min24 = NaN;
          sum24 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean24 = sum24 / xnums.length;
    out24.counts = counts;
    out24.max = max24;
    out24.mean = mean24;
    out24.min = min24;
    out24.n = xflat.length;
    out24.sum = sum24;
    if (isNaN(out24.mean)) {
      out24.max = NaN;
      out24.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out24.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode24 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode24.push(pair[0]);
        } else {
          break;
        }
      }
      out24.mode = mode24.toSorted();
    }
    if (options.median) {
      if (isNaN(mean24)) {
        out24.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out24.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out24.median = BigInt(out24.median);
            } catch (e28) {
            }
          }
        } else {
          out24.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance24 = 0;
      for (const v of xnums) {
        variance24 += Math.pow(Number(v) - mean24, 2);
      }
      variance24 /= xnums.length;
      const stdev24 = Math.sqrt(variance24);
      out24.stdev = stdev24;
      out24.variance = variance24;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out24.sum = BigInt(out24.sum);
      } catch (e28) {
      }
      try {
        out24.mean = BigInt(out24.mean);
      } catch (e28) {
      }
      if (options.mode) {
        out24.mode = out24.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e28) {
            return v;
          }
        });
      }
    }
    return out24;
  }
  function count(arr, matcher) {
    const { counts } = stats(arr);
    if (!isUndefined(matcher)) {
      if (isFunction(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper(x6) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return helper(x6.values);
    }
    if (isArray(x6)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x6) {
        if (helper(v)) {
          return true;
        }
        if (isArray(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged(x6) {
    return helper(decycle(x6));
  }
  function isNested(x6) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return isNested(x6.values);
    }
    assert(isArray(x6), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x6.length; i++) {
      if (isArray(x6[i])) {
        return true;
      }
    }
    return false;
  }
  var error = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray(shape24) {
    assert(!isUndefined(shape24), error);
    if (!isArray(shape24))
      shape24 = [shape24];
    assert(!isNested(shape24), error);
    assert(shape24.length > 0, error);
    let s25 = shape24[0];
    if (typeof s25 === "bigint")
      s25 = Number(s25);
    assert(isNumber(s25), error);
    assert(s25 >= 0, error);
    assert(Math.floor(s25) === s25, error);
    assert(s25 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape24.length === 1) {
      const out24 = [];
      for (let i = 0; i < s25; i++)
        out24.push(void 0);
      return out24;
    } else {
      const out24 = [];
      for (let i = 0; i < s25; i++) {
        out24.push(ndarray(shape24.slice(1)));
      }
      return out24;
    }
  }
  function reverse(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      const out32 = arr.copy();
      out32.values = reverse(out32.values);
      out32.index = reverse(out32.index);
      return out32;
    }
    assert(isArray(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out24.push(arr[i]);
    return out24;
  }
  function range(a, b, step = 1) {
    assert(!isUndefined(a) && !isUndefined(b) && !isUndefined(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert(isNumber(a) && isNumber(b) && isNumber(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out24 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out24.push(BigInt(i));
        } catch (e28) {
          out24.push(i);
        }
      } else {
        out24.push(i);
      }
    }
    if (shouldReverse)
      out24 = reverse(out24);
    return out24;
  }
  function makeKey2(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY2 = makeKey2(256);
  var UNDEFINED_KEY2 = makeKey2(256);
  var INFINITY_KEY2 = makeKey2(256);
  var MINUS_INFINITY_KEY2 = makeKey2(256);
  var SYMBOL_KEY2 = makeKey2(256);
  function set(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return set(arr.values);
    }
    assert(isArray(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = {};
    flatten(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY2 : isUndefined(item) ? UNDEFINED_KEY2 : isFunction(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY2 : item === Infinity ? INFINITY_KEY2 : item === -Infinity ? MINUS_INFINITY_KEY2 : typeof item === "bigint" ? item.toString() : isDataFrame(item) ? item.toJSONString() : isSeries(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out24.push(item);
      temp[key] = true;
    });
    return out24;
  }
  function helper2(x6) {
    if (isArray(x6)) {
      const childShapes = helper2(x6[0]);
      return [x6.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape(x6) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return shape(x6.values);
    }
    assert(isArray(x6), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper2(x6);
  }
  function dfAppend(df2, x6, axis) {
    if (isUndefined(axis)) {
      axis = 0;
    }
    assert(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray(x6)) {
      assert(!isJagged(x6), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape(x6);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out24 = df2.copy();
          out24._values.push(x6);
          const maxRowLength = Math.max(df2.shape[1], xShape[0]);
          out24._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out24 = df2.copy();
          range(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray(df2.shape[1]));
            }
            out24._values[i].push(x6[i]);
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < out24._values[0].length) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x6.map((row) => row.length).concat([df2.shape[1]]));
          const out24 = df2.copy();
          out24._values = out24._values.concat(x6).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxRowLength = Math.max(...x6.map((row) => row.length)) + df2.shape[1];
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out24 = df2.copy();
          range(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray(df2.shape[1]));
            }
            out24._values[i] = out24._values[i].concat(x6[i]);
            while (out24._values[i].length < maxRowLength) {
              out24._values[i].push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else {
        throw new MathError("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries(x6)) {
      const out24 = dfAppend(df2, x6.values, axis);
      if (axis === 0) {
        out24.index[out24.index.length - 1] = out24.index.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      } else {
        out24.columns[out24.columns.length - 1] = out24.columns.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      }
      return out24;
    } else if (isDataFrame(x6)) {
      if (axis === 0) {
        const out24 = df2.copy();
        const maxRowLength = set(out24._columns.concat(x6._columns)).length;
        out24._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x6.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out24._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out24._values.push(temp.concat(rowCopy._values));
        }, 1);
        out24._columns = out24._columns.concat(x6._columns.filter((c) => out24._columns.indexOf(c) < 0));
        while (out24._index.length < out24._values.length) {
          const newRowName = "row" + out24._index.length;
          out24._index.push(newRowName + (df2._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out24;
      } else {
        const out24 = df2.copy();
        out24._index.forEach((rowName, i) => {
          const xIndex = x6._index.indexOf(rowName);
          if (xIndex > -1) {
            out24._values[i] = out24._values[i].concat(x6._values[xIndex]);
          } else {
            out24._values[i] = out24._values[i].concat(ndarray(x6.shape[1]));
          }
        });
        x6._index.forEach((rowName, i) => {
          const outIndex = out24._index.indexOf(rowName);
          if (outIndex < 0) {
            out24._index.push(rowName);
            out24._values.push(ndarray(out24._columns.length).concat(x6._values[i]));
          }
        });
        out24._columns = out24._columns.concat(x6._columns.map((c) => c + (out24._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out24;
      }
    } else {
      throw new MathError("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply(DataFrame24, Series24, df2, fn2, axis) {
    axis = axis || 0;
    assert(isFunction(fn2), "The first parameter to the `apply` method must be a function.");
    assert(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df2.columns.forEach((colName, i) => {
        const series = new Series24(df2.values.map((row) => row[i]));
        series.name = colName;
        series.index = df2.index;
        const value = fn2(series, i, df2);
        if (value instanceof Series24) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df2.index;
        return out24;
      } else {
        const out24 = new Series24(df2.columns.map((colName) => temp[colName]));
        out24.index = df2.columns;
        return out24;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df2.values.map((row, i) => {
        const series = new Series24(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const value = fn2(series, i, df2);
        if (isUndefined(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray(value);
        }
        if (value instanceof Series24) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df2.index;
        out24.columns = df2.columns;
        return out24;
      } else {
        const out24 = new Series24(temp);
        out24.index = df2.index;
        return out24;
      }
    }
  }
  function isString(s25) {
    return typeof s25 === "string";
  }
  function dfAssign(DataFrame24, Series24, df2, p12, p22) {
    const isDataFrame24 = (x6) => x6 instanceof DataFrame24;
    const isSeries24 = (x6) => x6 instanceof Series24;
    if (!isUndefined(p22)) {
      assert(isString(p12), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert(isArray(p22) && !isJagged(p22) && shape(p22).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out24 = df2.append(p22, 1);
      out24.columns[out24.columns.length - 1] = p12;
      return out24;
    } else {
      if (isDataFrame24(p12)) {
        return df2.append(p12, 1);
      } else if (isSeries24(p12)) {
        return df2.append(p12, 1);
      } else if (isObject(p12)) {
        const maxColumnLength = Math.max(...Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).map((key) => p12[key].length));
        Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).forEach((key) => {
          while (p12[key].length < maxColumnLength) {
            p12[key].push(void 0);
          }
        });
        return df2.append(new DataFrame24(p12), 1);
      } else {
        throw new MathError("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy(DataFrame24, df2) {
    if (df2.isEmpty)
      return new DataFrame24();
    const out24 = new DataFrame24(copy(df2.values));
    out24.columns = df2.columns.slice();
    out24.index = df2.index.slice();
    return out24;
  }
  function dfDrop(DataFrame24, Series24, df2, rows, cols) {
    if (isUndefined(rows))
      rows = [];
    if (isUndefined(cols))
      cols = [];
    if (isString(rows) || isNumber(rows))
      rows = [rows];
    if (isString(cols) || isNumber(cols))
      cols = [cols];
    assert(isArray(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert(isArray(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert(shape(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert(shape(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df2.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df2.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out24 = df2.get(outIndex, outColumns);
    if (out24 instanceof Series24) {
      let temp = new DataFrame24();
      temp = temp.assign(out24);
      if (df2.index.indexOf(out24.name) > -1)
        temp = temp.transpose();
      out24 = temp;
    }
    return out24;
  }
  function isInteger(x6) {
    return isNumber(x6) && (x6 >= 0 ? Math.floor(x6) === x6 : Math.ceil(x6) === x6);
  }
  function isWholeNumber(x6) {
    return isInteger(x6) && x6 >= 0;
  }
  function dfDropMissing(DataFrame24, Series24, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert(isWholeNumber(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper54(values) {
      if (threshold > 0) {
        let count24 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined(value))
            count24++;
          if (count24 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out24 = df2.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out24 = out24.assign(tempID, out24.index);
      const newValues = out24.values.map(helper54).filter((row) => row.length > 0);
      if (shape(newValues).length < 2)
        return new DataFrame24();
      out24.values = newValues;
      let newIndex = out24.get(null, tempID);
      if (isUndefined(newIndex))
        return new DataFrame24();
      if (isString(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series24)
        newIndex = newIndex.values;
      out24.index = newIndex;
      out24 = out24.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out24.columns.forEach((colName, i) => {
        const values = out24.values.map((row) => row[i]);
        const newValues = helper54(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame24();
      }
      const newOut = new DataFrame24(temp);
      newOut.index = out24.index;
      return newOut;
    }
    return out24;
  }
  function dropNaN(x6) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return x6.dropNaN(...Object.values(arguments).slice(1));
    }
    assert(isArray(x6), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x6.forEach((v) => {
      try {
        return out24.push(dropNaN(v));
      } catch (e28) {
        if (isNumber(v)) {
          return out24.push(v);
        }
      }
    });
    return out24;
  }
  function dfDropNaN(DataFrame24, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert(isWholeNumber(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper54(values) {
      const numericalValues = dropNaN(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out24 = df2.copy();
    if (axis === 0) {
      const rowsToKeep = out24.index.filter((row) => {
        const values = out24.get(row, null).values;
        return helper54(values);
      });
      if (rowsToKeep.length > 0)
        return out24.get(rowsToKeep, null);
      else
        return new DataFrame24();
    } else if (axis === 1) {
      const colsToKeep = out24.columns.filter((col) => {
        const values = out24.get(null, col).values;
        return helper54(values);
      });
      if (colsToKeep.length > 0)
        return out24.get(null, colsToKeep);
      else
        return new DataFrame24();
    }
    return out24;
  }
  function arrayToObject(x6) {
    const out24 = {};
    flatten(x6).forEach((value, i) => {
      out24[value] = i;
    });
    return out24;
  }
  function undoArrayToObject(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter(DataFrame24, Series24, df2, fn2, axis) {
    assert(isFunction(fn2), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined(axis))
      axis = 0;
    assert(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out24 = df2.copy();
    if (out24.isEmpty)
      return out24;
    const index = arrayToObject(out24.index);
    const columns = arrayToObject(out24.columns);
    if (axis === 0) {
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count24++;
        } else {
          delete index[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject(index)[0];
        temp.index = undoArrayToObject(columns);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject(index);
    } else if (axis === 1) {
      out24 = out24.transpose();
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df2.columns[i];
        series.index = df2.index;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count24++;
        } else {
          delete columns[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject(columns)[0];
        temp.index = undoArrayToObject(index);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject(columns);
      out24 = out24.transpose();
    }
    return out24;
  }
  function dfGet(df2, rows, cols) {
    if (isString(rows) || isNumber(rows))
      rows = [rows];
    if (isString(cols) || isNumber(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set((rows || []).concat(cols || []).map((v) => typeof v));
    assert(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined(rows)) {
      rows = rows.map((r) => {
        if (isString(r)) {
          assert(df2.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber(r)) {
          assert(r >= 0, `Index ${r} is out of bounds!`);
          assert(Math.floor(r) === r, `Row numbers must be integers!`);
          assert(r < df2.index.length, `Index ${r} is out of bounds!`);
          return df2.index[r];
        }
      });
    }
    if (!isUndefined(cols)) {
      cols = cols.map((c) => {
        if (isString(c)) {
          assert(df2.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber(c)) {
          assert(c >= 0, `Column ${c} is out of bounds!`);
          assert(Math.floor(c) === c, `Column numbers must be integers!`);
          assert(c < df2.columns.length, `Column ${c} is out of bounds!`);
          return df2.columns[c];
        }
      });
    }
    return df2.getSubsetByNames(rows, cols);
  }
  function alphaSort(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e28) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort(arr, fn2) {
    if (isUndefined(fn2))
      fn2 = alphaSort;
    if (isDataFrame(arr) || isSeries(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert(isArray(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert(isFunction(fn2), "The second parameter of the `sort` function must be a comparison function!");
    const out24 = arr.slice();
    out24.sort(fn2);
    return out24;
  }
  function camelify(text) {
    const temp = text.toLowerCase();
    let out24 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out24 += char;
      } else {
        out24 += " ";
      }
    }
    const words = out24.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies(DataFrame24, df2, columns) {
    if (isUndefined(columns)) {
      columns = df2.columns;
    } else if (isString(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert(isString(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df2.columns.indexOf(col);
      assert(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df2.values.map((row) => row[colIndex]);
      const valuesSet = sort(set(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out24 = new DataFrame24(temp);
    out24.index = df2.index;
    return out24;
  }
  function dfGetSubsetByIndices(df2, rowIndices, colIndices) {
    const dataShape = df2.shape;
    if (isUndefined(rowIndices))
      rowIndices = range(0, dataShape[0]);
    if (isUndefined(colIndices))
      colIndices = range(0, dataShape[1]);
    if (isNumber(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber(colIndices))
      colIndices = [colIndices];
    assert(isArray(rowIndices) && isArray(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert(shape(rowIndices).length === 1 && shape(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert(isWholeNumber(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert(rowIndex < df2.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert(isWholeNumber(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert(colIndex < df2.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df2.index[i]);
    const cols = colIndices.map((i) => df2.columns[i]);
    return df2.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames(DataFrame24, Series24, df2, rows, cols) {
    if (isUndefined(rows))
      rows = df2.index;
    if (isUndefined(cols))
      cols = df2.columns;
    if (isString(rows))
      rows = [rows];
    if (isString(cols))
      cols = [cols];
    assert(isArray(rows) && isArray(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert(shape(rows).length === 1 && shape(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert(isString(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert(df2.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert(isString(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert(df2.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df2.values[df2.index.indexOf(row)][df2.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series24(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series24(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out24 = new DataFrame24(values);
    out24.columns = cols;
    out24.index = rows;
    return out24;
  }
  function dfPrint(DataFrame24, Series24, df2) {
    function truncate(s25, maxLength2) {
      if (isString(s25)) {
        if (s25.length > maxLength2) {
          return s25.substring(0, maxLength2 - 3) + "...";
        } else {
          return s25;
        }
      } else {
        return s25;
      }
    }
    if (df2.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df2;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df2.index.length ? null : range(0, halfMaxRows).concat(range(df2.index.length - halfMaxRows, df2.index.length));
    const tempColumns = maxColumns > df2.columns.length ? null : range(0, halfMaxColumns).concat(range(df2.columns.length - halfMaxColumns, df2.columns.length));
    let temp = df2.get(tempRows, tempColumns);
    if (temp instanceof Series24) {
      if (df2.shape[0] === 1) {
        temp = new DataFrame24([temp.values]);
        temp.index = df2.index;
        temp.columns = new Series24(df2.columns).get(tempColumns).values;
      } else if (df2.shape[1] === 1) {
        temp = new DataFrame24([temp.values]).transpose();
        temp.index = new Series24(df2.index).get(tempRows).values;
        temp.columns = df2.columns;
      }
    }
    if (maxRows <= df2.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df2.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series24) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df2.shape, "\n");
    return df2;
  }
  function leftPad(x6, maxLength) {
    assert(isNumber(x6), "The `leftPad` function only works on numbers!");
    let out24 = x6.toString();
    while (out24.length < maxLength)
      out24 = "0" + out24;
    return out24;
  }
  function dfResetIndex(df2, shouldSkipCopying) {
    const out24 = shouldSkipCopying ? df2 : df2.copy();
    out24.index = range(0, df2.shape[0]).map((i) => {
      return "row" + leftPad(i, (out24.index.length - 1).toString().length);
    });
    return out24;
  }
  function product(arr, shouldDropNaNs) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return product(arr.values, shouldDropNaNs);
    }
    assert(isArray(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten(arr);
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of temp) {
        if (!isNumber(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e28) {
        }
      }
      return out24;
    } catch (e28) {
      return NaN;
    }
  }
  function isNaturalNumber(x6) {
    return isInteger(x6) && x6 > 0;
  }
  function reshape(x6, newShape) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return reshape(x6.values, newShape);
    }
    assert(isArray(x6), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber(newShape))
      newShape = [newShape];
    assert(isArray(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert(shape(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert(isNaturalNumber(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten(x6);
    }
    const temp = flatten(x6);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert(product(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out24 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out24.push(reshape(row, newShape.slice(1)));
    }
    return out24;
  }
  var MAX = Math.pow(2, 64);
  var s = [];
  seed(Math.floor(Math.random() * MAX));
  function splitmix64(state, n) {
    state = uint(state);
    function helper54() {
      state += uint("0x9e3779b97f4a7c15");
      let z10 = copy(state);
      z10 = (z10 ^ z10 >> BigInt(30)) * uint("0xbf58476d1ce4e5b9");
      z10 = (z10 ^ z10 >> BigInt(27)) * uint("0x94d049bb133111eb");
      return z10 ^ z10 >> BigInt(31);
    }
    const out24 = [];
    for (let i = 0; i < n; i++)
      out24.push(helper54());
    return out24;
  }
  function uint(x6) {
    return BigInt.asUintN(64, BigInt(x6));
  }
  function rotl(x6, k6) {
    x6 = uint(x6);
    k6 = BigInt(k6);
    return uint(uint(x6 << k6) | uint(x6 >> uint(BigInt(64) - k6)));
  }
  function seed(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined(val)) {
      assert(isNumber(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix64(Math.floor(val), 4);
      s[0] = temp[0];
      s[1] = temp[1];
      s[2] = temp[2];
      s[3] = temp[3];
    } else {
      return copy(s);
    }
  }
  function next() {
    const result = uint(rotl(s[0] + s[3], 23) + s[0]);
    const t = uint(s[1] << BigInt(17));
    s[2] = uint(s[2] ^ s[0]);
    s[3] = uint(s[3] ^ s[1]);
    s[1] = uint(s[1] ^ s[2]);
    s[0] = uint(s[0] ^ s[3]);
    s[2] = uint(s[2] ^ t);
    s[3] = rotl(s[3], 45);
    return Math.floor(Number(result)) / MAX;
  }
  function random(shape24) {
    if (isUndefined(shape24))
      return next();
    if (!isArray(shape24))
      shape24 = [shape24];
    return reshape(ndarray(product(shape24)).map(next), shape24);
  }
  function shuffle(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert(isArray(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random() * temp.length);
      out24.push(temp.splice(index, 1)[0]);
    }
    return out24;
  }
  function dfShuffle(df2, axis) {
    if (isUndefined(axis))
      axis = 0;
    assert(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df2.get(axis === 0 ? shuffle(df2.index) : null, axis === 1 ? shuffle(df2.columns) : null);
  }
  function isBoolean(x6) {
    return typeof x6 === "boolean";
  }
  function dfSort(df2, a, b) {
    if (isFunction(a)) {
      return dfSortByFunction(df2, a, b);
    } else {
      return dfSortByColumns(df2, a, b);
    }
  }
  function dfSortByFunction(df2, fn2, axis) {
    axis = isUndefined(axis) ? 0 : axis;
    assert(isFunction(fn2), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert(isNumber(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort(df2.index, (a, b) => {
        return fn2(df2.get(a, null), df2.get(b, null));
      });
      return df2.get(index, null);
    } else {
      const columns = sort(df2.columns, (a, b) => {
        return fn2(df2.get(null, a), df2.get(null, b));
      });
      return df2.get(null, columns);
    }
  }
  function dfSortByColumns(df2, cols, directions) {
    let out24 = df2.copy();
    const indexID = random().toString();
    out24 = out24.assign(indexID, out24.index);
    if (isUndefined(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber(cols) || isString(cols)) {
      cols = [cols];
      if (isBoolean(directions) || isString(directions))
        directions = [directions];
    }
    assert(isArray(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert(shape(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined(directions))
      directions = range(0, cols.length).map(() => true);
    assert(isArray(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert(shape(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert(isString(col) || isNumber(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString(col)) {
        const index = out24.columns.indexOf(col);
        assert(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber(col)) {
        assert(isWholeNumber(col), "Column indices must be whole numbers!");
        assert(col < out24.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert(isString(dir) || isBoolean(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString(dir)) {
        const value = dir.trim().toLowerCase();
        assert(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean(dir)) {
        return dir;
      }
    });
    out24.values = sort(out24.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out24.columns.indexOf(indexID);
    out24.index = out24.values.map((row) => row[indexNumber]);
    out24 = out24.dropColumns(indexID);
    return out24;
  }
  function dfToDetailedObject(df2, axis) {
    if (isUndefined(axis)) {
      axis = 0;
    } else {
      assert(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out24 = {};
    if (axis === 0) {
      df2.index.forEach((rowName, i) => {
        const temp = {};
        df2.columns.forEach((colName, j) => {
          temp[colName] = df2.values[i][j];
        });
        out24[rowName] = temp;
      });
    } else {
      df2.columns.forEach((colName, j) => {
        const temp = {};
        df2.index.forEach((rowName, i) => {
          temp[rowName] = df2.values[i][j];
        });
        out24[colName] = temp;
      });
    }
    return out24;
  }
  function dfToJSONString(df2, axis) {
    return JSON.stringify(df2.toObject(axis));
  }
  async function dfToJSON(df2, filename, axis) {
    const out24 = dfToJSONString(df2, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out24)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e28) {
      browserError = e28;
    }
    try {
      const fs2 = await import("node:fs");
      const path = await import("node:path");
      fs2.writeFileSync(path.resolve(filename), out24, "utf8");
      wroteToDiskInNode = true;
    } catch (e28) {
      nodeError = e28;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError(nodeError);
      } else {
        throw new MathError("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df2;
  }
  function dfToObject(df2) {
    const out24 = {};
    df2.columns.forEach((col) => {
      out24[col] = df2.get(col).values;
    });
    return out24;
  }
  function transpose(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return arr.transpose();
    }
    assert(isArray(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape(arr);
    assert(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse(arr);
    } else if (theShape.length === 2) {
      const out24 = ndarray(reverse(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out24[col][row] = arr[row][col];
        }
      }
      return out24;
    }
  }
  function seriesAppend(Series24, series, x6) {
    if (isSeries(x6)) {
      return new Series24(series.values.concat(x6.values));
    }
    if (isArray(x6)) {
      const xShape = shape(x6);
      assert(xShape.length === 1 && !isNested(xShape), "Only vectors can be appended to Series!");
      const out24 = series.copy();
      x6.forEach((v, i) => {
        out24._values.push(v);
        out24._index.push("item" + (series.values.length + i));
      });
      return out24;
    }
    return seriesAppend(series, [x6]);
  }
  function seriesApply(series, fn2) {
    assert(isFunction(fn2), "The parameter to the `apply` method must be a function.");
    const out24 = series.copy();
    out24._values = out24._values.map((v, i) => fn2(v, i));
    return out24;
  }
  function seriesDropMissing(series) {
    const out24 = series.copy();
    const outIndex = [];
    out24._values = out24.values.filter((v, i) => {
      if (isUndefined(v)) {
        return false;
      } else {
        outIndex.push(out24.index[i]);
        return true;
      }
    });
    out24._index = outIndex;
    return out24;
  }
  function seriesDropNaN(Series24, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out24 = new Series24(values);
    out24.name = series.name;
    out24.index = index;
    return out24;
  }
  function seriesFilter(Series24, series, fn2) {
    let out24 = series.copy();
    const index = copy(out24.index);
    const indicesToRemove = [];
    const newValues = out24.values.filter((value, i) => {
      const shouldKeep = fn2(value, i, out24.values);
      if (!shouldKeep)
        indicesToRemove.push(out24.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out24 = new Series24();
      out24.name = series.name;
      return out24;
    }
    out24.values = newValues;
    out24.index = index;
    return out24;
  }
  function seriesGet(series, indices) {
    if (isString(indices) || isNumber(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set((indices || []).map((v) => typeof v));
    assert(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert(i >= 0, `Index ${i} is out of bounds!`);
          assert(Math.floor(i) === i, `Indices must be integers!`);
          assert(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices(series, indices) {
    const dataShape = series.shape;
    if (isUndefined(indices))
      indices = range(0, dataShape[0]);
    assert(isArray(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert(shape(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert(isWholeNumber(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames(Series24, series, indices) {
    if (isUndefined(indices))
      indices = series.index;
    assert(isArray(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert(shape(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert(isString(name), "The `indices` array must contain only strings.");
      assert(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out24 = new Series24(values);
    out24.index = indices;
    out24.name = series.name;
    return out24;
  }
  function seriesPrint(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range(0, maxRows / 2).concat(range(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out24 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out24[temp.index[i]] = obj;
    });
    console.table(out24);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle(series) {
    const out24 = series.copy();
    return out24.get(shuffle(out24.index));
  }
  function seriesSort(Series24, series, fn2) {
    fn2 = fn2 || ((a, b) => a < b ? -1 : 1);
    assert(isUndefined(fn2) || isFunction(fn2), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose([series.values, series.index]);
    const temp = sort(pairs, (aPair, bPair) => {
      return fn2(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out24 = new Series24();
    out24._values = newValues;
    out24._index = newIndex;
    out24.name = series.name;
    return out24;
  }
  function seriesSortByIndex(Series24, series) {
    let temp = transpose([series.values, series.index]);
    temp = transpose(sort(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out24 = new Series24(temp[0]);
    out24.index = temp[1];
    out24.name = series.name;
    return out24;
  }
  function seriesToObject(series) {
    const out24 = {};
    out24[series.name] = {};
    series.index.forEach((index, i) => {
      out24[series.name][index] = series.values[i];
    });
    return out24;
  }
  var SERIES_SYMBOL = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass(DataFrame24) {
    class Series24 {
      static [Symbol.hasInstance](x6) {
        try {
          return !!x6._symbol && x6._symbol === SERIES_SYMBOL;
        } catch (e28) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x6) {
            assert(isArray(x6), "The new values must be a 1-dimensional array!");
            const dataShape = shape(x6);
            assert(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad(i, (x6.length - 1).toString().length);
              }));
            }
            this._values = x6;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x6) {
            assert(isArray(x6), "The new index must be a 1-dimensional array of strings!");
            assert(x6.length === this.shape[0], "The new index must be the same length as the old index!");
            assert(shape(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
            x6.forEach((value) => {
              assert(isString(value), "All of the row names must be strings!");
            });
            this._index = x6;
          }
        });
        if (data) {
          if (data instanceof Series24) {
            this.name = data.name;
            this.values = copy(data.values);
            this.index = copy(data.index);
          } else if (isArray(data)) {
            const dataShape = shape(data);
            assert(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert(shape(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined(v)).length === 0;
      }
      clear() {
        const out24 = this.copy();
        out24.values.forEach((v, i) => {
          out24.values[i] = void 0;
        });
        return out24;
      }
      get(indices) {
        return seriesGet(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames(Series24, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out24 = new Series24(reverse(this.values));
        out24.index = reverse(this.index);
        out24.name = this.name;
        return out24;
      }
      resetIndex() {
        const out24 = this.copy();
        out24.index = range(0, this.shape[0]).map((i) => {
          return "item" + leftPad(i, (out24.index.length - 1).toString().length);
        });
        return out24;
      }
      copy() {
        const out24 = new Series24();
        out24._values = copy(this.values);
        out24._index = copy(this.index);
        out24.name = this.name;
        return out24;
      }
      append(x6) {
        return seriesAppend(Series24, this, x6);
      }
      apply(fn2) {
        return seriesApply(this, fn2);
      }
      concat(x6) {
        return this.append(x6);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN(Series24, this);
      }
      toObject() {
        return seriesToObject(this);
      }
      print() {
        return seriesPrint(this);
      }
      shuffle() {
        return seriesShuffle(this);
      }
      sort(direction) {
        return seriesSort(Series24, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex(Series24, this);
      }
      filter(fn2) {
        return seriesFilter(Series24, this, fn2);
      }
      toDataFrame() {
        const out24 = new DataFrame24(transpose([this.values]));
        out24.columns = [this.name];
        out24.index = this.index;
        return out24;
      }
      transpose() {
        const out24 = this.copy();
        out24.values = reverse(out24.values);
        out24.index = reverse(out24.index);
        return out24;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series24;
  }
  var DATAFRAME_SYMBOL = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey3(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out24 = "";
    for (let i = 0; i < n; i++)
      out24 += alpha[Math.floor(random() * alpha.length)];
    return out24;
  }
  var DataFrame = class {
    static [Symbol.hasInstance](x6) {
      try {
        return !!x6._symbol && x6._symbol === DATAFRAME_SYMBOL;
      } catch (e28) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x6) {
          assert(isArray(x6), "The new values must be a 2-dimensional array!");
          const dataShape = shape(x6);
          assert(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x6;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x6) {
          assert(isArray(x6), "The new columns list must be a 1-dimensional array of strings!");
          assert(this.isEmpty || x6.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert(shape(x6).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey3(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count(x6);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey3(8);
            }
            return v;
          });
          this._columns = x6;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x6) {
          assert(isArray(x6), "The new index must be a 1-dimensional array of strings!");
          assert(this.isEmpty || x6.length === this.shape[0], "The new index must be the same length as the old index!");
          assert(shape(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey3(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count(x6);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey3(8);
            }
            return v;
          });
          this._index = x6;
        }
      });
      assert(isUndefined(data) || isObject(data) || isArray(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame) {
          this.values = copy(data.values);
          this.columns = copy(data.columns);
          this.index = copy(data.index);
        } else if (isArray(data)) {
          const dataShape = shape(data);
          assert(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert(!isJagged(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose(temp);
          const dataShape = shape(this.values);
          this._index = range(0, dataShape[0]).map((i) => {
            return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out24 = new DataFrame(ndarray(this.shape));
      out24.columns = this.columns.slice();
      out24.index = this.index.slice();
      return out24;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e28) {
          return this.get(rows, null);
        }
      }
      return dfGet(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames(DataFrame, Series, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies(DataFrame, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies(DataFrame, this, columns);
    }
    transpose() {
      const out24 = new DataFrame(transpose(this.values));
      out24.columns = this.index.slice();
      out24.index = this.columns.slice();
      return out24;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy(DataFrame, this);
    }
    assign(p12, p22) {
      return dfAssign(DataFrame, Series, this, p12, p22);
    }
    apply(fn2, axis) {
      return dfApply(DataFrame, Series, this, fn2, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing(DataFrame, Series, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN(DataFrame, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop(DataFrame, Series, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject(this, axis);
    }
    toObject() {
      return dfToObject(this);
    }
    toJSONString(axis) {
      return dfToJSONString(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON(this, filename, axis);
    }
    print() {
      return dfPrint(DataFrame, Series, this);
    }
    sort(cols, directions) {
      return dfSort(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn2, axis) {
      return dfFilter(DataFrame, Series, this, fn2, axis);
    }
    shuffle(axis) {
      return dfShuffle(this, axis);
    }
    append(x6, axis) {
      return dfAppend(this, x6, axis);
    }
    concat(x6, axis) {
      return this.append(x6, axis);
    }
    join(x6, axis) {
      return this.append(x6, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series = createSeriesClass(DataFrame);
  function max(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).max;
  }
  function vectorize(fn2) {
    assert(isFunction(fn2), "You must pass a function into the `vectorize` function!");
    return function helper54() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray(arg)) {
          return true;
        } else if (isSeries(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s25, i) => {
        assert(isEqual(isArray(s25) ? shape(s25) : s25.shape, isArray(childArrays[i + 1]) ? shape(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn2.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out24 = range(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper54(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual(shape(dataframes[0]), shape(out24))) {
              const temp = new DataFrame(out24);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame(out24);
            }
          } catch (e28) {
            return out24;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out24.length) {
              const temp = new Series(out24);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series(out24);
            }
          } catch (e28) {
            return out24;
          }
        }
        return out24;
      } else {
        return fn2(...arguments);
      }
    };
  }
  function abs(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6 < 0 ? -x6 : x6;
      } else {
        return Math.abs(x6);
      }
    } catch (e28) {
      return NaN;
    }
  }
  var vabs = vectorize(abs);
  function add() {
    try {
      let out24 = 0;
      let resultShouldBeABigInt = false;
      const x6 = Object.values(arguments);
      for (let v of x6) {
        if (!isNumber(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e28) {
        }
      }
      return out24;
    } catch (e28) {
      return NaN;
    }
  }
  var vadd = vectorize(add);
  function apply(x6, fn2) {
    try {
      return fn2(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vapply = vectorize(apply);
  function arccos(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.acos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varccos = vectorize(arccos);
  function arcsin(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.asin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varcsin = vectorize(arcsin);
  function arctan(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.atan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varctan = vectorize(arctan);
  function argmax(x6, shouldDropNaNs) {
    if (isDataFrame(x6)) {
      const index = argmax(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries(x6)) {
      const index = argmax(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert(isArray(x6), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf(x6, max(x6, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function min(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).min;
  }
  function argmin(x6, shouldDropNaNs) {
    if (isDataFrame(x6)) {
      const index = argmin(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries(x6)) {
      const index = argmin(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert(isArray(x6), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf(x6, min(x6, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function cast(value, type) {
    if (isDataFrame(value) || isSeries(value)) {
      return value.apply((item) => cast(item, type));
    }
    if (isArray(value)) {
      return value.map((v) => cast(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined(value)) {
        return NaN;
      }
      const booleanValue = cast(value, "boolean");
      if (isBoolean(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e28) {
        const dateValue = cast(value, "date");
        if (isDate(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out24 = parseFloat(value);
      if (isNaN(out24))
        return NaN;
      return out24;
    }
    if (type === "int") {
      const out24 = cast(value, "number");
      return out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
    }
    if (type === "float") {
      return cast(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean(value)) {
        return value;
      }
      if (isNumber(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e28) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate(value)) {
        return value;
      }
      if (isUndefined(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out24 = new Date(value);
        if (!isDate(out24))
          return null;
        return out24;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject(value)) {
        return value;
      }
      const booleanValue = cast(value, "boolean");
      if (isBoolean(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast(value, "number");
        if (isNumber(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e28) {
      }
      const dateValue = cast(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out24 = JSON.parse(value);
        if (isArray(out24)) {
          return out24.map((v) => cast(v, type));
        } else {
          return out24;
        }
      } catch (e28) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined(value)) {
        if (isEqual(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.ceil(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vceil = vectorize(ceil);
  function chop(x6, threshold) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      if (isUndefined(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber(threshold)) {
        return NaN;
      }
      return vabs(x6) < threshold ? 0 : x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vchop = vectorize(chop);
  function int(x6) {
    if (isDataFrame(x6) || isSeries(x6)) {
      const out24 = x6.copy();
      out24.values = int(out24.values);
      return out24;
    }
    if (isArray(x6)) {
      return x6.map((v) => int(v));
    } else {
      try {
        const out24 = JSON.parse(x6);
        if (isNumber(out24)) {
          return typeof out24 === "bigint" ? Number(out24) : out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
        }
        return NaN;
      } catch (e28) {
        return NaN;
      }
    }
  }
  var vint = vectorize(int);
  function clamp(x6, a, b) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (!isNumber(a))
        return NaN;
      if (!isNumber(b))
        return NaN;
      if (typeof x6 === "bigint") {
        return BigInt(clamp(vint(x6), a, b));
      }
      if (x6 < a)
        return a;
      if (x6 > b)
        return b;
      return x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vclamp = vectorize(clamp);
  function combinationsIterator(x6, r) {
    function* helper54(x22, r22) {
      if (r22 > x22.length) {
        yield x22;
      } else if (r22 <= 0) {
        yield [];
      } else if (x22.length < 2) {
        yield x22;
      } else {
        for (let i = 0; i < x22.length; i++) {
          const item = x22[i];
          const after = x22.slice(i + 1);
          if (after.length < r22 - 1) {
            continue;
          }
          if (r22 - 1 >= 0) {
            for (const child of combinationsIterator(after, r22 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame(x6) || isSeries(x6)) {
      return combinationsIterator(x6.values, r);
    }
    assert(isArray(x6), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert(isNumber(r) && vint(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten(x6), r);
  }
  function combinations(x6, r) {
    const out24 = [];
    for (const combo of combinationsIterator(x6, r)) {
      out24.push(combo.slice());
    }
    return out24;
  }
  function intersect() {
    const arrays = Object.values(arguments).map((x6) => {
      if (isDataFrame(x6) || isSeries(x6)) {
        return set(x6.values);
      }
      assert(isArray(x6), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set(x6);
    });
    const all = set(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual(other, v)) > -1);
    });
  }
  var _IndexMatcher = class {
    constructor(mode24) {
      assert(isUndefined(mode24) || mode24 === _IndexMatcher.DROP_NAN_MODE || mode24 === _IndexMatcher.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined(mode24) ? mode24 : _IndexMatcher.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x6) => {
        if (isArray(x6)) {
          const xshape = shape(x6);
          if (xshape.length === 1) {
            x6 = new Series(x6);
          } else if (xshape.length === 2) {
            x6 = new DataFrame(x6);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert(isDataFrame(x6) || isSeries(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher.DROP_MISSING_MODE) {
          indices.push(x6.dropMissing().index);
        } else {
          indices.push(x6.dropNaN().index);
        }
      });
      this.index = intersect(...indices);
      return this;
    }
    transform() {
      assert(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out24 = Object.values(arguments).map((x6) => {
        if (isArray(x6)) {
          const xshape = shape(x6);
          if (xshape.length === 1) {
            return new Series(x6).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame(x6).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert(isDataFrame(x6) || isSeries(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x6.get(this.index, null);
      });
      return out24.length === 1 ? out24[0] : out24;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher = _IndexMatcher;
  __publicField(IndexMatcher, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField(IndexMatcher, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries(x6)) {
      return covariance(x6.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries(y)) {
      return covariance(x6, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert(isArray(x6) && isArray(y) && shape(x6).length === 1 && shape(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert(x6.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance(...new IndexMatcher().fitAndTransform(x6, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats(x6, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx2 = Number(xstats.mean);
      const my2 = Number(ystats.mean);
      if (!isNumber(mx2) || !isNumber(my2)) {
        return NaN;
      }
      const n = Math.max(x6.length, y.length);
      let out24 = 0;
      for (let i = 0; i < n; i++) {
        let vx2 = x6[i];
        let vy2 = y[i];
        if (!isNumber(vx2))
          return NaN;
        if (!isNumber(vy2))
          return NaN;
        if (typeof vx2 === "bigint") {
          vx2 = Number(vx2);
        }
        if (typeof vy2 === "bigint") {
          vy2 = Number(vy2);
        }
        out24 += (vx2 - mx2) * (vy2 - my2);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out24 / x6.length, xstats, ystats];
      } else {
        return out24 / x6.length;
      }
    } catch (e28) {
      return NaN;
    }
  }
  function correl(x6, y, shouldDropNaNs) {
    if (isSeries(x6)) {
      return correl(x6.values, y, shouldDropNaNs);
    }
    if (isSeries(y)) {
      return correl(x6, y.values, shouldDropNaNs);
    }
    assert(isArray(x6) && isArray(y) && shape(x6).length === 1 && shape(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert(x6.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e28) {
      return NaN;
    }
  }
  function cos(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.cos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vcos = vectorize(cos);
  var dataTypes = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff(a, b) {
    if (isDataFrame(a) || isSeries(a)) {
      return diff(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return diff(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set(a);
    const bTemp = set(b);
    const out24 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual(other, item)) < 0) {
        out24.push(item);
      }
    });
    return out24;
  }
  function pow(x6, p) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (!isNumber(p))
        return NaN;
      if (typeof x6 === "bigint" || typeof p === "bigint") {
        const out24 = pow(Number(x6), Number(p));
        try {
          return BigInt(out24);
        } catch (e28) {
          return out24;
        }
      }
      return Math.pow(x6, p);
    } catch (e28) {
      return NaN;
    }
  }
  var vpow = vectorize(pow);
  function sqrt(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        const out24 = sqrt(Number(x6));
        try {
          return BigInt(out24);
        } catch (e28) {
          return out24;
        }
      }
      return Math.sqrt(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsqrt = vectorize(sqrt);
  function multiply() {
    try {
      const x6 = Object.values(arguments);
      if (x6.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of x6) {
        if (!isNumber(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e28) {
        }
      }
      return out24;
    } catch (e28) {
      return NaN;
    }
  }
  var vmultiply = vectorize(multiply);
  function scale() {
    return vmultiply(...arguments);
  }
  function subtract(a, b) {
    return vadd(a, scale(b, -1));
  }
  function sum(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).sum;
  }
  function distance(a, b) {
    if (isNumber(a) && isNumber(b)) {
      return vabs(a - b);
    }
    if (isDataFrame(a) || isSeries(a)) {
      return distance(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return distance(a, b.values);
    }
    if (isArray(a) && isArray(b)) {
      assert(isEqual(shape(a), shape(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt(sum(vpow(subtract(a, b), 2)));
    } catch (e28) {
      return NaN;
    }
  }
  function divide(a, b) {
    return scale(a, vpow(b, -1));
  }
  function dot(a, b) {
    if (isDataFrame(a)) {
      const temp = dot(a.values, b);
      if (shape(temp).length === 1) {
        const out24 = new Series(temp);
        out24.name = isSeries(b) ? b.name : out24.name;
        out24.index = a.index.slice();
        return out24;
      } else {
        const out24 = new DataFrame(temp);
        out24.index = a.index.slice();
        if (isDataFrame(b)) {
          out24.columns = b.columns.slice();
        }
        return out24;
      }
    }
    if (isDataFrame(b)) {
      const temp = dot(a, b.values);
      if (shape(temp).length === 1) {
        const out24 = new Series(temp);
        out24.name = isSeries(a) ? a.name : out24.name;
        out24.index = b.columns.slice();
        return out24;
      } else {
        const out24 = new DataFrame(temp);
        out24.columns = b.columns.slice();
        return out24;
      }
    }
    if (isSeries(a)) {
      return dot(a.values, b);
    }
    if (isSeries(b)) {
      return dot(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape(a);
    const bShape = shape(b);
    assert(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum(scale(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose(b).map((col) => dot(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose(b);
      const out24 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot(a[i], bTranspose[j]));
        }
        out24.push(row);
      }
      return out24;
    }
  }
  function dropMissing(x6) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return x6.dropMissing(...Object.values(arguments).slice(1));
    }
    assert(isArray(x6), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x6.forEach((v) => {
      try {
        return out24.push(dropMissing(v));
      } catch (e28) {
        if (!isUndefined(v)) {
          out24.push(v);
        }
      }
    });
    return out24;
  }
  function dropMissingPairwise(a, b) {
    if (isDataFrame(a) || isSeries(a)) {
      return dropMissingPairwise(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return dropMissingPairwise(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert(isEqual(shape(a), shape(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (!isUndefined(a[i]) && !isUndefined(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise(a, b) {
    if (isDataFrame(a) || isSeries(a)) {
      return dropNaNPairwise(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return dropNaNPairwise(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert(isEqual(shape(a), shape(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (isNumber(a[i]) && isNumber(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined(x6) {
    return dropMissing(x6);
  }
  function every(x6, fn2) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return every(x6.values, fn2);
    }
    assert(isArray(x6), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert(isFunction(fn2), "The second argument passed into the `every` function must be a function!");
    for (const v of x6) {
      if (isArray(v)) {
        if (!every(v, fn2)) {
          return false;
        }
      } else {
        if (!fn2(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        if (x6 === 0n) {
          return 1n;
        } else {
          x6 = Number(x6);
        }
      }
      return Math.exp(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vexp = vectorize(exp);
  function factorial(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial(vint(n)));
      }
      if (n !== vint(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial(n - 1);
    } catch (e28) {
      return NaN;
    }
  }
  var vfactorial = vectorize(factorial);
  function find(x6, fn2) {
    if (isDataFrame(x6)) {
      return find(x6.values, fn2);
    }
    if (isSeries(x6)) {
      return find(x6.values, fn2);
    }
    assert(isObject(x6) || isArray(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper54(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return value;
          }
          const result = helper54(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return value;
          }
          const result = helper54(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn22(x22)) {
          return x22;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    return helper54(x6, safeFn);
  }
  function findAll(x6, fn2) {
    if (isDataFrame(x6)) {
      return findAll(x6.values, fn2);
    }
    if (isSeries(x6)) {
      return findAll(x6.values, fn2);
    }
    assert(isObject(x6) || isArray(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper54(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        const out24 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else if (isArray(x22)) {
        checked.push(x22);
        const out24 = [];
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else {
        if (fn22(x22)) {
          return [x22];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const results = helper54(x6, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float(x6) {
    try {
      if (x6 === "Infinity") {
        return Infinity;
      }
      if (x6 === "-Infinity") {
        return -Infinity;
      }
      const out24 = JSON.parse(x6);
      if (isNumber(out24))
        return out24;
      return NaN;
    } catch (e28) {
      return NaN;
    }
  }
  var vfloat = vectorize(float);
  function floor(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6;
      }
      return Math.floor(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vfloor = vectorize(floor);
  function zeros(shape24) {
    if (isNumber(shape24))
      shape24 = [shape24];
    const out24 = [];
    const n = product(shape24);
    for (let i = 0; i < n; i++)
      out24.push(0);
    return reshape(out24, shape24);
  }
  function identity(size) {
    if (typeof size === "bigint") {
      size = vint(size);
    }
    assert(!isUndefined(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert(isNumber(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert(vint(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out24 = zeros([size, size]);
    for (let i = 0; i < size; i++)
      out24[i][i] = 1;
    return out24;
  }
  var booleanValues = ["true", "false", "yes", "no"];
  var nullValues = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint(results.value) === results.value;
      } else {
        results.isInteger = every(results.values, (v) => isNumber(v) ? vint(v) === v : true);
      }
    }
    return results;
  }
  function inferType(arr) {
    if (isDataFrame(arr)) {
      const out24 = arr.copy();
      const results = inferType(arr.values);
      out24.values = results.values;
      return checkIfInteger({ type: results.type, values: out24 });
    }
    if (isSeries(arr)) {
      const out24 = arr.copy();
      const results = inferType(arr.values);
      out24.values = results.values;
      return checkIfInteger({ type: results.type, values: out24 });
    }
    if (!isArray(arr)) {
      const out24 = inferType([arr]);
      out24.value = out24.values[0];
      delete out24.values;
      return checkIfInteger(out24);
    }
    assert(isArray(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate(temp)) {
            return "date";
          }
        }
      } catch (e28) {
      }
      if (!isString(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e28) {
        const vDate = new Date(v);
        if (isDate(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger({
      type: primaryType,
      values: vapply(arr, (v) => cast(v, primaryType))
    });
  }
  function inverse(x6) {
    if (isDataFrame(x6)) {
      const out24 = x6.copy();
      out24.values = inverse(out24.values);
      return out24;
    }
    assert(isArray(x6), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape(x6);
    assert(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x6;
    } else if (xShape[0] === 1) {
      assert(x6[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x6[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x6[0][0];
      let b = x6[0][1];
      let c = x6[1][0];
      let d = x6[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det2 = a * d - b * c;
      assert(det2 !== 0, "This matrix cannot be inverted!");
      const out24 = [
        [d, -b],
        [-c, a]
      ];
      return scale(out24, 1 / det2);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber(a) || isNumber(b) ? scale(a, b) : dot(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x6.slice(0, divider).map((row) => row.slice(0, divider));
          const B10 = x6.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C5 = x6.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x6.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse(A);
          const CompInv = inverse(vadd(D, times(-1, times(times(C5, AInv), B10))));
          const topLeft = vadd(AInv, times(times(times(times(AInv, B10), CompInv), C5), AInv));
          const topRight = times(-1, times(times(AInv, B10), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C5), AInv));
          const bottomRight = CompInv;
          const out24 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out24;
        } catch (e28) {
        }
      }
      assert(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser2 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp(a, b, f) {
    try {
      if (!isNumber(a))
        return NaN;
      if (!isNumber(b))
        return NaN;
      if (!isNumber(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = lerp(Number(a), Number(b), f);
        try {
          return BigInt(out24);
        } catch (e28) {
          return out24;
        }
      }
      return f * (b - a) + a;
    } catch (e28) {
      return NaN;
    }
  }
  var vlerp = vectorize(lerp);
  function log(x6, base) {
    try {
      base = isUndefined(base) ? Math.E : base;
      if (!isNumber(x6))
        return NaN;
      if (!isNumber(base))
        return NaN;
      if (typeof x6 === "bigint" || typeof base === "bigint") {
        const out24 = log(Number(x6), Number(base));
        try {
          return BigInt(out24);
        } catch (e28) {
          return out24;
        }
      }
      return Math.log(x6) / Math.log(base);
    } catch (e28) {
      return NaN;
    }
  }
  var vlog = vectorize(log);
  function mean(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).mean;
  }
  function median(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod(a, b) {
    try {
      if (!isNumber(a))
        return NaN;
      if (!isNumber(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = mod(Number(a), Number(b));
        try {
          return BigInt(out24);
        } catch (e28) {
          return out24;
        }
      }
      return a % b;
    } catch (e28) {
      return NaN;
    }
  }
  var vmod = vectorize(mod);
  function mode(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper3() {
    const u12 = random();
    const u22 = random();
    return Math.sqrt(-2 * Math.log(u12)) * Math.cos(2 * Math.PI * u22);
  }
  function normal(shape24) {
    if (isUndefined(shape24))
      return helper3();
    return vapply(ndarray(shape24), helper3);
  }
  function ones(shape24) {
    return vapply(ndarray(shape24), () => 1);
  }
  function permutationsIterator(x6, r) {
    function* helper54(x22, r22) {
      r22 = r22 || x22.length;
      if (x22.length === 1) {
        yield [x22];
        return;
      }
      for (const c of combinations(x22, r22)) {
        if (!c.slice)
          continue;
        const state = zeros(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame(x6) || isSeries(x6)) {
      return permutationsIterator(x6.values, r);
    }
    assert(isArray(x6), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined(r)) {
      r = x6.length;
    }
    assert(isNumber(r) && vint(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten(x6), r);
  }
  function permutations(x6, r) {
    const out24 = [];
    for (const perm of permutationsIterator(x6, r)) {
      out24.push(perm.slice());
    }
    return out24;
  }
  function print() {
    Object.keys(arguments).forEach((key) => {
      const x6 = arguments[key];
      if (isArray(x6)) {
        if (!isJagged(x6)) {
          const xShape = shape(x6);
          if (xShape.length === 1) {
            new Series(x6).print();
          } else if (xShape.length == 2) {
            new DataFrame(x6).print();
          } else {
            console.log(x6);
          }
        } else {
          console.log(x6);
        }
      } else if (isDataFrame(x6) || isSeries(x6)) {
        x6.print();
      } else {
        console.log(x6);
      }
    });
  }
  var helper4 = vectorize((x6, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x6, a, b, c, d]) {
        if (!isNumber(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x6 = Number(x6);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x6 - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out24 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e28) {
        }
      }
      return out24;
    } catch (e28) {
      return NaN;
    }
  });
  function remap(x6, a, b, c, d) {
    if (isArray(x6) && isUndefined(c) && isUndefined(d)) {
      c = a;
      d = b;
      const results = stats(x6);
      a = results.min;
      b = results.max;
    }
    return helper4(x6, a, b, c, d);
  }
  function round(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.round(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vround = vectorize(round);
  function sign(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return BigInt(sign(Number(x6)));
      if (x6 < 0)
        return -1;
      if (x6 > 0)
        return 1;
      return 0;
    } catch (e28) {
      return NaN;
    }
  }
  var vsign = vectorize(sign);
  function sin(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.sin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsin = vectorize(sin);
  function some(x6, fn2) {
    if (isDataFrame(x6) || isSeries(x6)) {
      return some(x6.values, fn2);
    }
    assert(isArray(x6), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert(isFunction(fn2), "The second argument passed into the `some` function must be a function!");
    for (const v of x6) {
      if (isArray(v)) {
        if (some(v, fn2)) {
          return true;
        }
      } else {
        if (fn2(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev(x6) {
    return std(x6);
  }
  function tan(x6) {
    try {
      if (!isNumber(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.tan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vtan = vectorize(tan);
  function timeSync(fn2, args) {
    assert(isFunction(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn2(...args);
    } else {
      fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync(fn2, args) {
    assert(isFunction(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn2(...args);
    } else {
      await fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union() {
    return set([...arguments].map((v) => {
      if (isArray(v))
        return v;
      if (isDataFrame(v))
        return v.values;
      if (isSeries(v))
        return v.values;
      return [v];
    }));
  }
  function variance(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip() {
    const out24 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame(arr) || isSeries(arr)) {
        arr = arr.values;
      }
      assert(isArray(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range(0, max(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined(value) ? void 0 : value);
      });
      out24.push(row);
    });
    return out24;
  }
  var out = {
    abs: vabs,
    add: vadd,
    apply: vapply,
    arccos: varccos,
    arcsin: varcsin,
    arctan: varctan,
    argmax,
    argmin,
    assert,
    cast,
    ceil: vceil,
    chop: vchop,
    clamp: vclamp,
    combinations,
    combinationsIterator,
    copy,
    correl,
    cos: vcos,
    count,
    covariance,
    DataFrame,
    dataTypes,
    decycle,
    diff,
    distance,
    divide,
    dot,
    dropMissing,
    dropMissingPairwise,
    dropNaN,
    dropNaNPairwise,
    dropUndefined,
    every,
    exp: vexp,
    factorial: vfactorial,
    find,
    findAll,
    flatten,
    float: vfloat,
    floor: vfloor,
    identity,
    IndexMatcher,
    indexOf,
    inferType,
    int: vint,
    intersect,
    inverse,
    isArray,
    isBoolean,
    isBrowser: isBrowser2,
    isDataFrame,
    isDate,
    isEqual,
    isFunction,
    isJagged,
    isNested,
    isNumber,
    isObject,
    isSeries,
    isString,
    isUndefined,
    lerp: vlerp,
    log: vlog,
    MathError,
    max,
    mean,
    median,
    min,
    mod: vmod,
    mode,
    multiply: vmultiply,
    ndarray,
    normal,
    ones,
    permutations,
    permutationsIterator,
    pow: vpow,
    print,
    product,
    random,
    range,
    remap,
    reshape,
    reverse,
    round: vround,
    scale,
    seed,
    Series,
    set,
    shape,
    shuffle,
    sign: vsign,
    sin: vsin,
    some,
    sort,
    sqrt: vsqrt,
    stats,
    std,
    stdev,
    subtract,
    sum,
    tan: vtan,
    timeAsync,
    timeSync,
    time: timeSync,
    transpose,
    union,
    variance,
    vectorize,
    zeros,
    zip,
    dump() {
      const context3 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context3) {
        throw new out.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out).forEach((key) => {
        try {
          Object.defineProperty(context3, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out[key]
          });
        } catch (e28) {
          context3[key] = out[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out;
  }

  // node_modules/@jrc03c/bee/dist/bee.import.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber2(x6) {
    return typeof x6 === "number" && !isNaN(x6) || typeof x6 === "bigint";
  }
  var isBrowser3 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError2 = class extends Error {
    constructor(message) {
      if (isBrowser3()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert2(isTrue, message) {
    if (!isTrue)
      throw new MathError2(message);
  }
  var arrayTypes2 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined2(x6) {
    return x6 === null || typeof x6 === "undefined";
  }
  var typeStrings2 = arrayTypes2.map((s222) => s222.name);
  function isArray2(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined2(obj.constructor)) {
        return arrayTypes2.indexOf(obj.constructor) > -1 || typeStrings2.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e28) {
      return false;
    }
  }
  function isDataFrame2(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e28) {
      return false;
    }
  }
  function isFunction2(fn2) {
    return typeof fn2 === "function";
  }
  function isObject2(x6) {
    return typeof x6 === "object" && !isUndefined2(x6) && !isArray2(x6);
  }
  function isSeries2(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e28) {
      return false;
    }
  }
  function indexOf2(x6, fn2) {
    if (isDataFrame2(x6)) {
      const index = indexOf2(x6.values, fn2);
      if (index.length > 0 && isNumber2(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      if (index.length > 1 && isNumber2(index[1]) && index[1] >= 0 && index[1] < x6.columns.length) {
        index[1] = x6.columns[index[1]];
      }
      return index;
    }
    if (isSeries2(x6)) {
      const index = indexOf2(x6.values, fn2);
      if (index.length > 0 && isNumber2(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      return index;
    }
    assert2(isObject2(x6) || isArray2(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction2(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject2(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return [key];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray2(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return [i];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn22(x22)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const paths = helper522(x6, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy2(x6) {
    function helper522(x22) {
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        if (isArray2(x22)) {
          if (!(x22 instanceof Array)) {
            return x22.slice();
          }
          return x22.map((v) => copy2(v));
        }
        if (isSeries2(x22)) {
          const out32 = x22.copy();
          out32.values = copy2(out32.values);
          return out32;
        }
        if (isDataFrame2(x22)) {
          const out32 = x22.copy();
          out32.values = copy2(x22.values);
          return out32;
        }
        if (x22 instanceof Date) {
          return new Date(x22.getTime());
        }
        x22 = decycle2(x22);
        const out222 = {};
        Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
          out222[key] = copy2(x22[key]);
        });
        return out222;
      } else {
        return x22;
      }
    }
    return helper522(decycle2(x6));
  }
  function decycle2(x6) {
    function helper522(x22, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x22) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x22;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x22 ? "/" : "/" + indexOf2(orig, x22).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x22 === "object") {
        if (x22 === null)
          return null;
        checked.push(x22);
        if (isArray2(x22)) {
          if (typeof x22.constructor !== "undefined" && x22.constructor.name !== "Array") {
            return x22.slice();
          }
          return x22.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
            x22[key] = helper522(x22[key], checked, currentPath + "/" + key.toString());
          });
          return x22;
        }
      } else {
        return x22;
      }
    }
    const orig = x6;
    let out222 = helper522(orig);
    if (isDataFrame2(x6)) {
      const temp = x6.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries2(x6)) {
      const temp = x6.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate2(x6) {
    return x6 instanceof Date && x6.toString() !== "Invalid Date";
  }
  var numberTypes2 = ["number", "int", "float", "bigint"];
  function isEqual2(a, b) {
    function helper522(a22, b22) {
      const aType = typeof a22;
      const bType = typeof b22;
      if (aType !== bType && !numberTypes2.includes(aType) && !numberTypes2.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a22 === b22;
      if (aType === "symbol")
        return a22 === b22;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a22.toString();
          const bString = b22.toString();
          return aString === bString;
        } catch (e28) {
          return false;
        }
      }
      if (aType === "string")
        return a22 === b22;
      if (aType === "function")
        return a22 === b22;
      if (aType === "object") {
        if (a22 === null || b22 === null) {
          return a22 === null && b22 === null;
        } else {
          if (isDate2(a22)) {
            if (isDate2(b22)) {
              return a22.getTime() === b22.getTime();
            } else {
              return false;
            }
          } else if (isDate2(b22)) {
            return false;
          }
          if (a22 instanceof RegExp && b22 instanceof RegExp) {
            return a22.toString() === b22.toString();
          }
          if (isArray2(a22) !== isArray2(b22)) {
            return false;
          }
          const aKeys = Object.keys(a22).concat(Object.getOwnPropertySymbols(a22));
          const bKeys = Object.keys(b22).concat(Object.getOwnPropertySymbols(b22));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a22[key], b22[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e28) {
      return helper522(decycle2(a), decycle2(b));
    }
  }
  function makeKey4(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY3 = makeKey4(16);
  var UNDEFINED_KEY3 = makeKey4(16);
  var INFINITY_KEY3 = makeKey4(16);
  var MINUS_INFINITY_KEY3 = makeKey4(16);
  var SYMBOL_KEY3 = makeKey4(16);
  var Counter2 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x6) {
      for (const v of x6) {
        if (isArray2(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY3 : isUndefined2(value) ? UNDEFINED_KEY3 : isFunction2(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY3 : value === Infinity ? INFINITY_KEY3 : value === -Infinity ? MINUS_INFINITY_KEY3 : typeof value === "bigint" ? value.toString() : isDataFrame2(value) ? value.toJSONString() : isSeries2(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined2(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return flatten2(arr.values);
    }
    assert2(isArray2(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray2(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats2(x6, options) {
    options = options || {};
    const counts = new Counter2();
    const out222 = {};
    const xflat = flatten2(x6);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber2(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e28) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e28) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e28) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e28) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e28) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count2(arr, matcher) {
    const { counts } = stats2(arr);
    if (!isUndefined2(matcher)) {
      if (isFunction2(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual2(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper5(x6) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return helper5(x6.values);
    }
    if (isArray2(x6)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x6) {
        if (helper5(v)) {
          return true;
        }
        if (isArray2(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged2(x6) {
    return helper5(decycle2(x6));
  }
  function isNested2(x6) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return isNested2(x6.values);
    }
    assert2(isArray2(x6), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x6.length; i++) {
      if (isArray2(x6[i])) {
        return true;
      }
    }
    return false;
  }
  var error2 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray2(shape222) {
    assert2(!isUndefined2(shape222), error2);
    if (!isArray2(shape222))
      shape222 = [shape222];
    assert2(!isNested2(shape222), error2);
    assert2(shape222.length > 0, error2);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert2(isNumber2(s222), error2);
    assert2(s222 >= 0, error2);
    assert2(Math.floor(s222) === s222, error2);
    assert2(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray2(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      const out32 = arr.copy();
      out32.values = reverse2(out32.values);
      out32.index = reverse2(out32.index);
      return out32;
    }
    assert2(isArray2(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range2(a, b, step = 1) {
    assert2(!isUndefined2(a) && !isUndefined2(b) && !isUndefined2(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert2(isNumber2(a) && isNumber2(b) && isNumber2(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert2(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e28) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse2(out222);
    return out222;
  }
  function makeKey22(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY22 = makeKey22(256);
  var UNDEFINED_KEY22 = makeKey22(256);
  var INFINITY_KEY22 = makeKey22(256);
  var MINUS_INFINITY_KEY22 = makeKey22(256);
  var SYMBOL_KEY22 = makeKey22(256);
  function set2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return set2(arr.values);
    }
    assert2(isArray2(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten2(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY22 : isUndefined2(item) ? UNDEFINED_KEY22 : isFunction2(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY22 : item === Infinity ? INFINITY_KEY22 : item === -Infinity ? MINUS_INFINITY_KEY22 : typeof item === "bigint" ? item.toString() : isDataFrame2(item) ? item.toJSONString() : isSeries2(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper22(x6) {
    if (isArray2(x6)) {
      const childShapes = helper22(x6[0]);
      return [x6.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape2(x6) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return shape2(x6.values);
    }
    assert2(isArray2(x6), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper22(x6);
  }
  function dfAppend2(df2, x6, axis) {
    if (isUndefined2(axis)) {
      axis = 0;
    }
    assert2(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray2(x6)) {
      assert2(!isJagged2(x6), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape2(x6);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df2.copy();
          out222._values.push(x6);
          const maxRowLength = Math.max(df2.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range2(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray2(df2.shape[1]));
            }
            out222._values[i].push(x6[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x6.map((row) => row.length).concat([df2.shape[1]]));
          const out222 = df2.copy();
          out222._values = out222._values.concat(x6).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x6.map((row) => row.length)) + df2.shape[1];
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range2(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray2(df2.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x6[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError2("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries2(x6)) {
      const out222 = dfAppend2(df2, x6.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      }
      return out222;
    } else if (isDataFrame2(x6)) {
      if (axis === 0) {
        const out222 = df2.copy();
        const maxRowLength = set2(out222._columns.concat(x6._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x6.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x6._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df2._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df2.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x6._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x6._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray2(x6.shape[1]));
          }
        });
        x6._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray2(out222._columns.length).concat(x6._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x6._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError2("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply2(DataFrame222, Series222, df2, fn2, axis) {
    axis = axis || 0;
    assert2(isFunction2(fn2), "The first parameter to the `apply` method must be a function.");
    assert2(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df2.columns.forEach((colName, i) => {
        const series = new Series222(df2.values.map((row) => row[i]));
        series.name = colName;
        series.index = df2.index;
        const value = fn2(series, i, df2);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined2(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray2(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        return out222;
      } else {
        const out222 = new Series222(df2.columns.map((colName) => temp[colName]));
        out222.index = df2.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df2.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const value = fn2(series, i, df2);
        if (isUndefined2(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray2(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        out222.columns = df2.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df2.index;
        return out222;
      }
    }
  }
  function isString2(s222) {
    return typeof s222 === "string";
  }
  function dfAssign2(DataFrame222, Series222, df2, p12, p22) {
    const isDataFrame222 = (x6) => x6 instanceof DataFrame222;
    const isSeries222 = (x6) => x6 instanceof Series222;
    if (!isUndefined2(p22)) {
      assert2(isString2(p12), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert2(isArray2(p22) && !isJagged2(p22) && shape2(p22).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df2.append(p22, 1);
      out222.columns[out222.columns.length - 1] = p12;
      return out222;
    } else {
      if (isDataFrame222(p12)) {
        return df2.append(p12, 1);
      } else if (isSeries222(p12)) {
        return df2.append(p12, 1);
      } else if (isObject2(p12)) {
        const maxColumnLength = Math.max(...Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).map((key) => p12[key].length));
        Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).forEach((key) => {
          while (p12[key].length < maxColumnLength) {
            p12[key].push(void 0);
          }
        });
        return df2.append(new DataFrame222(p12), 1);
      } else {
        throw new MathError2("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy2(DataFrame222, df2) {
    if (df2.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy2(df2.values));
    out222.columns = df2.columns.slice();
    out222.index = df2.index.slice();
    return out222;
  }
  function dfDrop2(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined2(rows))
      rows = [];
    if (isUndefined2(cols))
      cols = [];
    if (isString2(rows) || isNumber2(rows))
      rows = [rows];
    if (isString2(cols) || isNumber2(cols))
      cols = [cols];
    assert2(isArray2(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert2(isArray2(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert2(shape2(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert2(shape2(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df2.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df2.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df2.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df2.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger2(x6) {
    return isNumber2(x6) && (x6 >= 0 ? Math.floor(x6) === x6 : Math.ceil(x6) === x6);
  }
  function isWholeNumber2(x6) {
    return isInteger2(x6) && x6 >= 0;
  }
  function dfDropMissing2(DataFrame222, Series222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert2(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert2(isWholeNumber2(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert2(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined2(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined2(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined2(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df2.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape2(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined2(newIndex))
        return new DataFrame222();
      if (isString2(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN2(x6) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return x6.dropNaN(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(x6), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropNaN2(v));
      } catch (e28) {
        if (isNumber2(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN2(DataFrame222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert2(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert2(isWholeNumber2(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert2(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN2(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df2.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject2(x6) {
    const out222 = {};
    flatten2(x6).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject2(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter2(DataFrame222, Series222, df2, fn2, axis) {
    assert2(isFunction2(fn2), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined2(axis))
      axis = 0;
    assert2(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df2.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject2(out222.index);
    const columns = arrayToObject2(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject2(index)[0];
        temp.index = undoArrayToObject2(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject2(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.columns[i];
        series.index = df2.index;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject2(columns)[0];
        temp.index = undoArrayToObject2(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject2(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet2(df2, rows, cols) {
    if (isString2(rows) || isNumber2(rows))
      rows = [rows];
    if (isString2(cols) || isNumber2(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set2((rows || []).concat(cols || []).map((v) => typeof v));
    assert2(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert2(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert2(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert2(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined2(rows)) {
      rows = rows.map((r) => {
        if (isString2(r)) {
          assert2(df2.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber2(r)) {
          assert2(r >= 0, `Index ${r} is out of bounds!`);
          assert2(Math.floor(r) === r, `Row numbers must be integers!`);
          assert2(r < df2.index.length, `Index ${r} is out of bounds!`);
          return df2.index[r];
        }
      });
    }
    if (!isUndefined2(cols)) {
      cols = cols.map((c) => {
        if (isString2(c)) {
          assert2(df2.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber2(c)) {
          assert2(c >= 0, `Column ${c} is out of bounds!`);
          assert2(Math.floor(c) === c, `Column numbers must be integers!`);
          assert2(c < df2.columns.length, `Column ${c} is out of bounds!`);
          return df2.columns[c];
        }
      });
    }
    return df2.getSubsetByNames(rows, cols);
  }
  function alphaSort2(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e28) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort2(arr, fn2) {
    if (isUndefined2(fn2))
      fn2 = alphaSort2;
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert2(isFunction2(fn2), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn2);
    return out222;
  }
  function camelify2(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies2(DataFrame222, df2, columns) {
    if (isUndefined2(columns)) {
      columns = df2.columns;
    } else if (isString2(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert2(isString2(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df2.columns.indexOf(col);
      assert2(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df2.values.map((row) => row[colIndex]);
      const valuesSet = sort2(set2(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify2(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df2.index;
    return out222;
  }
  function dfGetSubsetByIndices2(df2, rowIndices, colIndices) {
    const dataShape = df2.shape;
    if (isUndefined2(rowIndices))
      rowIndices = range2(0, dataShape[0]);
    if (isUndefined2(colIndices))
      colIndices = range2(0, dataShape[1]);
    if (isNumber2(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber2(colIndices))
      colIndices = [colIndices];
    assert2(isArray2(rowIndices) && isArray2(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert2(shape2(rowIndices).length === 1 && shape2(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert2(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert2(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert2(isWholeNumber2(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert2(rowIndex < df2.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert2(isWholeNumber2(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert2(colIndex < df2.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df2.index[i]);
    const cols = colIndices.map((i) => df2.columns[i]);
    return df2.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames2(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined2(rows))
      rows = df2.index;
    if (isUndefined2(cols))
      cols = df2.columns;
    if (isString2(rows))
      rows = [rows];
    if (isString2(cols))
      cols = [cols];
    assert2(isArray2(rows) && isArray2(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert2(shape2(rows).length === 1 && shape2(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert2(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert2(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert2(isString2(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert2(df2.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert2(isString2(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert2(df2.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df2.values[df2.index.indexOf(row)][df2.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint2(DataFrame222, Series222, df2) {
    function truncate(s222, maxLength2) {
      if (isString2(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df2.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df2;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df2.index.length ? null : range2(0, halfMaxRows).concat(range2(df2.index.length - halfMaxRows, df2.index.length));
    const tempColumns = maxColumns > df2.columns.length ? null : range2(0, halfMaxColumns).concat(range2(df2.columns.length - halfMaxColumns, df2.columns.length));
    let temp = df2.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df2.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df2.index;
        temp.columns = new Series222(df2.columns).get(tempColumns).values;
      } else if (df2.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df2.index).get(tempRows).values;
        temp.columns = df2.columns;
      }
    }
    if (maxRows <= df2.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range2(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df2.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df2.shape, "\n");
    return df2;
  }
  function leftPad2(x6, maxLength) {
    assert2(isNumber2(x6), "The `leftPad` function only works on numbers!");
    let out222 = x6.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex2(df2, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df2 : df2.copy();
    out222.index = range2(0, df2.shape[0]).map((i) => {
      return "row" + leftPad2(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product2(arr, shouldDropNaNs) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return product2(arr.values, shouldDropNaNs);
    }
    assert2(isArray2(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten2(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber2(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  function isNaturalNumber2(x6) {
    return isInteger2(x6) && x6 > 0;
  }
  function reshape2(x6, newShape) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return reshape2(x6.values, newShape);
    }
    assert2(isArray2(x6), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber2(newShape))
      newShape = [newShape];
    assert2(isArray2(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert2(shape2(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert2(isNaturalNumber2(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten2(x6);
    }
    const temp = flatten2(x6);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert2(product2(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape2(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX2 = Math.pow(2, 64);
  var s2 = [];
  seed2(Math.floor(Math.random() * MAX2));
  function splitmix642(state, n) {
    state = uint2(state);
    function helper522() {
      state += uint2("0x9e3779b97f4a7c15");
      let z10 = copy2(state);
      z10 = (z10 ^ z10 >> BigInt(30)) * uint2("0xbf58476d1ce4e5b9");
      z10 = (z10 ^ z10 >> BigInt(27)) * uint2("0x94d049bb133111eb");
      return z10 ^ z10 >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint2(x6) {
    return BigInt.asUintN(64, BigInt(x6));
  }
  function rotl2(x6, k6) {
    x6 = uint2(x6);
    k6 = BigInt(k6);
    return uint2(uint2(x6 << k6) | uint2(x6 >> uint2(BigInt(64) - k6)));
  }
  function seed2(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined2(val)) {
      assert2(isNumber2(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix642(Math.floor(val), 4);
      s2[0] = temp[0];
      s2[1] = temp[1];
      s2[2] = temp[2];
      s2[3] = temp[3];
    } else {
      return copy2(s2);
    }
  }
  function next2() {
    const result = uint2(rotl2(s2[0] + s2[3], 23) + s2[0]);
    const t = uint2(s2[1] << BigInt(17));
    s2[2] = uint2(s2[2] ^ s2[0]);
    s2[3] = uint2(s2[3] ^ s2[1]);
    s2[1] = uint2(s2[1] ^ s2[2]);
    s2[0] = uint2(s2[0] ^ s2[3]);
    s2[2] = uint2(s2[2] ^ t);
    s2[3] = rotl2(s2[3], 45);
    return Math.floor(Number(result)) / MAX2;
  }
  function random2(shape222) {
    if (isUndefined2(shape222))
      return next2();
    if (!isArray2(shape222))
      shape222 = [shape222];
    return reshape2(ndarray2(product2(shape222)).map(next2), shape222);
  }
  function shuffle2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random2() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle2(df2, axis) {
    if (isUndefined2(axis))
      axis = 0;
    assert2(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df2.get(axis === 0 ? shuffle2(df2.index) : null, axis === 1 ? shuffle2(df2.columns) : null);
  }
  function isBoolean2(x6) {
    return typeof x6 === "boolean";
  }
  function dfSort2(df2, a, b) {
    if (isFunction2(a)) {
      return dfSortByFunction2(df2, a, b);
    } else {
      return dfSortByColumns2(df2, a, b);
    }
  }
  function dfSortByFunction2(df2, fn2, axis) {
    axis = isUndefined2(axis) ? 0 : axis;
    assert2(isFunction2(fn2), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert2(isNumber2(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort2(df2.index, (a, b) => {
        return fn2(df2.get(a, null), df2.get(b, null));
      });
      return df2.get(index, null);
    } else {
      const columns = sort2(df2.columns, (a, b) => {
        return fn2(df2.get(null, a), df2.get(null, b));
      });
      return df2.get(null, columns);
    }
  }
  function dfSortByColumns2(df2, cols, directions) {
    let out222 = df2.copy();
    const indexID = random2().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined2(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber2(cols) || isString2(cols)) {
      cols = [cols];
      if (isBoolean2(directions) || isString2(directions))
        directions = [directions];
    }
    assert2(isArray2(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert2(shape2(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined2(directions))
      directions = range2(0, cols.length).map(() => true);
    assert2(isArray2(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert2(shape2(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert2(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert2(isString2(col) || isNumber2(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString2(col)) {
        const index = out222.columns.indexOf(col);
        assert2(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber2(col)) {
        assert2(isWholeNumber2(col), "Column indices must be whole numbers!");
        assert2(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert2(isString2(dir) || isBoolean2(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString2(dir)) {
        const value = dir.trim().toLowerCase();
        assert2(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean2(dir)) {
        return dir;
      }
    });
    out222.values = sort2(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject2(df2, axis) {
    if (isUndefined2(axis)) {
      axis = 0;
    } else {
      assert2(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df2.index.forEach((rowName, i) => {
        const temp = {};
        df2.columns.forEach((colName, j) => {
          temp[colName] = df2.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df2.columns.forEach((colName, j) => {
        const temp = {};
        df2.index.forEach((rowName, i) => {
          temp[rowName] = df2.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString2(df2, axis) {
    return JSON.stringify(df2.toObject(axis));
  }
  async function dfToJSON2(df2, filename, axis) {
    const out222 = dfToJSONString2(df2, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e28) {
      browserError = e28;
    }
    try {
      const fs2 = await import("node:fs");
      const path = await import("node:path");
      fs2.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e28) {
      nodeError = e28;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError2(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError2(nodeError);
      } else {
        throw new MathError2("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df2;
  }
  function dfToObject2(df2) {
    const out222 = {};
    df2.columns.forEach((col) => {
      out222[col] = df2.get(col).values;
    });
    return out222;
  }
  function transpose2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return arr.transpose();
    }
    assert2(isArray2(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape2(arr);
    assert2(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse2(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray2(reverse2(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend2(Series222, series, x6) {
    if (isSeries2(x6)) {
      return new Series222(series.values.concat(x6.values));
    }
    if (isArray2(x6)) {
      const xShape = shape2(x6);
      assert2(xShape.length === 1 && !isNested2(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x6.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend2(series, [x6]);
  }
  function seriesApply2(series, fn2) {
    assert2(isFunction2(fn2), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn2(v, i));
    return out222;
  }
  function seriesDropMissing2(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined2(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN2(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber2(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter2(Series222, series, fn2) {
    let out222 = series.copy();
    const index = copy2(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn2(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet2(series, indices) {
    if (isString2(indices) || isNumber2(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set2((indices || []).map((v) => typeof v));
    assert2(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert2(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert2(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert2(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined2(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert2(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert2(i >= 0, `Index ${i} is out of bounds!`);
          assert2(Math.floor(i) === i, `Indices must be integers!`);
          assert2(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices2(series, indices) {
    const dataShape = series.shape;
    if (isUndefined2(indices))
      indices = range2(0, dataShape[0]);
    assert2(isArray2(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert2(shape2(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert2(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert2(isWholeNumber2(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert2(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames2(Series222, series, indices) {
    if (isUndefined2(indices))
      indices = series.index;
    assert2(isArray2(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert2(shape2(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert2(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert2(isString2(name), "The `indices` array must contain only strings.");
      assert2(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint2(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range2(0, maxRows / 2).concat(range2(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy2(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle2(series) {
    const out222 = series.copy();
    return out222.get(shuffle2(out222.index));
  }
  function seriesSort2(Series222, series, fn2) {
    fn2 = fn2 || ((a, b) => a < b ? -1 : 1);
    assert2(isUndefined2(fn2) || isFunction2(fn2), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose2([series.values, series.index]);
    const temp = sort2(pairs, (aPair, bPair) => {
      return fn2(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex2(Series222, series) {
    let temp = transpose2([series.values, series.index]);
    temp = transpose2(sort2(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject2(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL2 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass2(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x6) {
        try {
          return !!x6._symbol && x6._symbol === SERIES_SYMBOL2;
        } catch (e28) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL2
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x6) {
            assert2(isArray2(x6), "The new values must be a 1-dimensional array!");
            const dataShape = shape2(x6);
            assert2(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range2(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad2(i, (x6.length - 1).toString().length);
              }));
            }
            this._values = x6;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x6) {
            assert2(isArray2(x6), "The new index must be a 1-dimensional array of strings!");
            assert2(x6.length === this.shape[0], "The new index must be the same length as the old index!");
            assert2(shape2(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
            x6.forEach((value) => {
              assert2(isString2(value), "All of the row names must be strings!");
            });
            this._index = x6;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy2(data.values);
            this.index = copy2(data.index);
          } else if (isArray2(data)) {
            const dataShape = shape2(data);
            assert2(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert2(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert2(shape2(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape2(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined2(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet2(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames2(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices2(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse2(this.values));
        out222.index = reverse2(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range2(0, this.shape[0]).map((i) => {
          return "item" + leftPad2(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy2(this.values);
        out222._index = copy2(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x6) {
        return seriesAppend2(Series222, this, x6);
      }
      apply(fn2) {
        return seriesApply2(this, fn2);
      }
      concat(x6) {
        return this.append(x6);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing2(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN2(Series222, this);
      }
      toObject() {
        return seriesToObject2(this);
      }
      print() {
        return seriesPrint2(this);
      }
      shuffle() {
        return seriesShuffle2(this);
      }
      sort(direction) {
        return seriesSort2(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex2(Series222, this);
      }
      filter(fn2) {
        return seriesFilter2(Series222, this, fn2);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose2([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse2(out222.values);
        out222.index = reverse2(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL2 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey32(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random2() * alpha.length)];
    return out222;
  }
  var DataFrame2 = class {
    static [Symbol.hasInstance](x6) {
      try {
        return !!x6._symbol && x6._symbol === DATAFRAME_SYMBOL2;
      } catch (e28) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL2
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined2(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x6) {
          assert2(isArray2(x6), "The new values must be a 2-dimensional array!");
          const dataShape = shape2(x6);
          assert2(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range2(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad2(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range2(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad2(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x6;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x6) {
          assert2(isArray2(x6), "The new columns list must be a 1-dimensional array of strings!");
          assert2(this.isEmpty || x6.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert2(shape2(x6).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey32(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count2(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey32(8);
            }
            return v;
          });
          this._columns = x6;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x6) {
          assert2(isArray2(x6), "The new index must be a 1-dimensional array of strings!");
          assert2(this.isEmpty || x6.length === this.shape[0], "The new index must be the same length as the old index!");
          assert2(shape2(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey32(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count2(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey32(8);
            }
            return v;
          });
          this._index = x6;
        }
      });
      assert2(isUndefined2(data) || isObject2(data) || isArray2(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame2) {
          this.values = copy2(data.values);
          this.columns = copy2(data.columns);
          this.index = copy2(data.index);
        } else if (isArray2(data)) {
          const dataShape = shape2(data);
          assert2(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert2(!isJagged2(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined2(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert2(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose2(temp);
          const dataShape = shape2(this.values);
          this._index = range2(0, dataShape[0]).map((i) => {
            return "row" + leftPad2(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape2(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame2(ndarray2(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e28) {
          return this.get(rows, null);
        }
      }
      return dfGet2(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames2(DataFrame2, Series2, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices2(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies2(DataFrame2, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies2(DataFrame2, this, columns);
    }
    transpose() {
      const out222 = new DataFrame2(transpose2(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex2(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy2(DataFrame2, this);
    }
    assign(p12, p22) {
      return dfAssign2(DataFrame2, Series2, this, p12, p22);
    }
    apply(fn2, axis) {
      return dfApply2(DataFrame2, Series2, this, fn2, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing2(DataFrame2, Series2, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN2(DataFrame2, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop2(DataFrame2, Series2, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject2(this, axis);
    }
    toObject() {
      return dfToObject2(this);
    }
    toJSONString(axis) {
      return dfToJSONString2(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON2(this, filename, axis);
    }
    print() {
      return dfPrint2(DataFrame2, Series2, this);
    }
    sort(cols, directions) {
      return dfSort2(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn2, axis) {
      return dfFilter2(DataFrame2, Series2, this, fn2, axis);
    }
    shuffle(axis) {
      return dfShuffle2(this, axis);
    }
    append(x6, axis) {
      return dfAppend2(this, x6, axis);
    }
    concat(x6, axis) {
      return this.append(x6, axis);
    }
    join(x6, axis) {
      return this.append(x6, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series2 = createSeriesClass2(DataFrame2);
  function max2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).max;
  }
  function vectorize2(fn2) {
    assert2(isFunction2(fn2), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray2(arg)) {
          return true;
        } else if (isSeries2(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame2(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert2(isEqual2(isArray2(s222) ? shape2(s222) : s222.shape, isArray2(childArrays[i + 1]) ? shape2(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn2.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max2(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range2(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray2(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries2(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame2(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual2(shape2(dataframes[0]), shape2(out222))) {
              const temp = new DataFrame2(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame2(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series2(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series2(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn2(...arguments);
      }
    };
  }
  function abs2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6 < 0 ? -x6 : x6;
      } else {
        return Math.abs(x6);
      }
    } catch (e28) {
      return NaN;
    }
  }
  var vabs2 = vectorize2(abs2);
  function add2() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x6 = Object.values(arguments);
      for (let v of x6) {
        if (!isNumber2(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vadd2 = vectorize2(add2);
  function apply2(x6, fn2) {
    try {
      return fn2(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vapply2 = vectorize2(apply2);
  function arccos2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.acos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varccos2 = vectorize2(arccos2);
  function arcsin2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.asin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varcsin2 = vectorize2(arcsin2);
  function arctan2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.atan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varctan2 = vectorize2(arctan2);
  function argmax2(x6, shouldDropNaNs) {
    if (isDataFrame2(x6)) {
      const index = argmax2(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries2(x6)) {
      const index = argmax2(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert2(isArray2(x6), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf2(x6, max2(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function min2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).min;
  }
  function argmin2(x6, shouldDropNaNs) {
    if (isDataFrame2(x6)) {
      const index = argmin2(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries2(x6)) {
      const index = argmin2(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert2(isArray2(x6), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf2(x6, min2(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function cast2(value, type) {
    if (isDataFrame2(value) || isSeries2(value)) {
      return value.apply((item) => cast2(item, type));
    }
    if (isArray2(value)) {
      return value.map((v) => cast2(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined2(value)) {
        return NaN;
      }
      const booleanValue = cast2(value, "boolean");
      if (isBoolean2(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e28) {
        const dateValue = cast2(value, "date");
        if (isDate2(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast2(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast2(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast2(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean2(value)) {
        return value;
      }
      if (isNumber2(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e28) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate2(value)) {
        return value;
      }
      if (isUndefined2(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate2(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject2(value)) {
        return value;
      }
      const booleanValue = cast2(value, "boolean");
      if (isBoolean2(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast2(value, "number");
        if (isNumber2(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e28) {
      }
      const dateValue = cast2(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray2(out222)) {
          return out222.map((v) => cast2(v, type));
        } else {
          return out222;
        }
      } catch (e28) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined2(value)) {
        if (isEqual2(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.ceil(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vceil2 = vectorize2(ceil2);
  function chop2(x6, threshold) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      if (isUndefined2(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber2(threshold)) {
        return NaN;
      }
      return vabs2(x6) < threshold ? 0 : x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vchop2 = vectorize2(chop2);
  function int2(x6) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      const out222 = x6.copy();
      out222.values = int2(out222.values);
      return out222;
    }
    if (isArray2(x6)) {
      return x6.map((v) => int2(v));
    } else {
      try {
        const out222 = JSON.parse(x6);
        if (isNumber2(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e28) {
        return NaN;
      }
    }
  }
  var vint2 = vectorize2(int2);
  function clamp2(x6, a, b) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (!isNumber2(a))
        return NaN;
      if (!isNumber2(b))
        return NaN;
      if (typeof x6 === "bigint") {
        return BigInt(clamp2(vint2(x6), a, b));
      }
      if (x6 < a)
        return a;
      if (x6 > b)
        return b;
      return x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vclamp2 = vectorize2(clamp2);
  function combinationsIterator2(x6, r) {
    function* helper522(x22, r22) {
      if (r22 > x22.length) {
        yield x22;
      } else if (r22 <= 0) {
        yield [];
      } else if (x22.length < 2) {
        yield x22;
      } else {
        for (let i = 0; i < x22.length; i++) {
          const item = x22[i];
          const after = x22.slice(i + 1);
          if (after.length < r22 - 1) {
            continue;
          }
          if (r22 - 1 >= 0) {
            for (const child of combinationsIterator2(after, r22 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return combinationsIterator2(x6.values, r);
    }
    assert2(isArray2(x6), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert2(isNumber2(r) && vint2(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten2(x6), r);
  }
  function combinations2(x6, r) {
    const out222 = [];
    for (const combo of combinationsIterator2(x6, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect2() {
    const arrays = Object.values(arguments).map((x6) => {
      if (isDataFrame2(x6) || isSeries2(x6)) {
        return set2(x6.values);
      }
      assert2(isArray2(x6), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set2(x6);
    });
    const all = set2(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual2(other, v)) > -1);
    });
  }
  var _IndexMatcher2 = class {
    constructor(mode222) {
      assert2(isUndefined2(mode222) || mode222 === _IndexMatcher2.DROP_NAN_MODE || mode222 === _IndexMatcher2.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined2(mode222) ? mode222 : _IndexMatcher2.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x6) => {
        if (isArray2(x6)) {
          const xshape = shape2(x6);
          if (xshape.length === 1) {
            x6 = new Series2(x6);
          } else if (xshape.length === 2) {
            x6 = new DataFrame2(x6);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert2(isDataFrame2(x6) || isSeries2(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher2.DROP_MISSING_MODE) {
          indices.push(x6.dropMissing().index);
        } else {
          indices.push(x6.dropNaN().index);
        }
      });
      this.index = intersect2(...indices);
      return this;
    }
    transform() {
      assert2(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x6) => {
        if (isArray2(x6)) {
          const xshape = shape2(x6);
          if (xshape.length === 1) {
            return new Series2(x6).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame2(x6).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert2(isDataFrame2(x6) || isSeries2(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x6.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher2 = _IndexMatcher2;
  __publicField2(IndexMatcher2, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField2(IndexMatcher2, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance2(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries2(x6)) {
      return covariance2(x6.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries2(y)) {
      return covariance2(x6, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert2(isArray2(x6) && isArray2(y) && shape2(x6).length === 1 && shape2(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert2(x6.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance2(...new IndexMatcher2().fitAndTransform(x6, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats2(x6, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats2(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx2 = Number(xstats.mean);
      const my2 = Number(ystats.mean);
      if (!isNumber2(mx2) || !isNumber2(my2)) {
        return NaN;
      }
      const n = Math.max(x6.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx2 = x6[i];
        let vy2 = y[i];
        if (!isNumber2(vx2))
          return NaN;
        if (!isNumber2(vy2))
          return NaN;
        if (typeof vx2 === "bigint") {
          vx2 = Number(vx2);
        }
        if (typeof vy2 === "bigint") {
          vy2 = Number(vy2);
        }
        out222 += (vx2 - mx2) * (vy2 - my2);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x6.length, xstats, ystats];
      } else {
        return out222 / x6.length;
      }
    } catch (e28) {
      return NaN;
    }
  }
  function correl2(x6, y, shouldDropNaNs) {
    if (isSeries2(x6)) {
      return correl2(x6.values, y, shouldDropNaNs);
    }
    if (isSeries2(y)) {
      return correl2(x6, y.values, shouldDropNaNs);
    }
    assert2(isArray2(x6) && isArray2(y) && shape2(x6).length === 1 && shape2(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert2(x6.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance2(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e28) {
      return NaN;
    }
  }
  function cos2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.cos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vcos2 = vectorize2(cos2);
  var dataTypes2 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff2(a, b) {
    if (isDataFrame2(a) || isSeries2(a)) {
      return diff2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return diff2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set2(a);
    const bTemp = set2(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual2(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow2(x6, p) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (!isNumber2(p))
        return NaN;
      if (typeof x6 === "bigint" || typeof p === "bigint") {
        const out222 = pow2(Number(x6), Number(p));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.pow(x6, p);
    } catch (e28) {
      return NaN;
    }
  }
  var vpow2 = vectorize2(pow2);
  function sqrt2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        const out222 = sqrt2(Number(x6));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.sqrt(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsqrt2 = vectorize2(sqrt2);
  function multiply2() {
    try {
      const x6 = Object.values(arguments);
      if (x6.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x6) {
        if (!isNumber2(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vmultiply2 = vectorize2(multiply2);
  function scale2() {
    return vmultiply2(...arguments);
  }
  function subtract2(a, b) {
    return vadd2(a, scale2(b, -1));
  }
  function sum2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).sum;
  }
  function distance2(a, b) {
    if (isNumber2(a) && isNumber2(b)) {
      return vabs2(a - b);
    }
    if (isDataFrame2(a) || isSeries2(a)) {
      return distance2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return distance2(a, b.values);
    }
    if (isArray2(a) && isArray2(b)) {
      assert2(isEqual2(shape2(a), shape2(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt2(sum2(vpow2(subtract2(a, b), 2)));
    } catch (e28) {
      return NaN;
    }
  }
  function divide2(a, b) {
    return scale2(a, vpow2(b, -1));
  }
  function dot2(a, b) {
    if (isDataFrame2(a)) {
      const temp = dot2(a.values, b);
      if (shape2(temp).length === 1) {
        const out222 = new Series2(temp);
        out222.name = isSeries2(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame2(temp);
        out222.index = a.index.slice();
        if (isDataFrame2(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame2(b)) {
      const temp = dot2(a, b.values);
      if (shape2(temp).length === 1) {
        const out222 = new Series2(temp);
        out222.name = isSeries2(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame2(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries2(a)) {
      return dot2(a.values, b);
    }
    if (isSeries2(b)) {
      return dot2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape2(a);
    const bShape = shape2(b);
    assert2(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert2(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum2(scale2(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose2(b).map((col) => dot2(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot2(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose2(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot2(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing2(x6) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return x6.dropMissing(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(x6), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropMissing2(v));
      } catch (e28) {
        if (!isUndefined2(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise2(a, b) {
    if (isDataFrame2(a) || isSeries2(a)) {
      return dropMissingPairwise2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return dropMissingPairwise2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert2(isEqual2(shape2(a), shape2(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise2(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (!isUndefined2(a[i]) && !isUndefined2(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise2(a, b) {
    if (isDataFrame2(a) || isSeries2(a)) {
      return dropNaNPairwise2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return dropNaNPairwise2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert2(isEqual2(shape2(a), shape2(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise2(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (isNumber2(a[i]) && isNumber2(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined2(x6) {
    return dropMissing2(x6);
  }
  function every2(x6, fn2) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return every2(x6.values, fn2);
    }
    assert2(isArray2(x6), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert2(isFunction2(fn2), "The second argument passed into the `every` function must be a function!");
    for (const v of x6) {
      if (isArray2(v)) {
        if (!every2(v, fn2)) {
          return false;
        }
      } else {
        if (!fn2(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        if (x6 === 0n) {
          return 1n;
        } else {
          x6 = Number(x6);
        }
      }
      return Math.exp(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vexp2 = vectorize2(exp2);
  function factorial2(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial2(vint2(n)));
      }
      if (n !== vint2(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial2(n - 1);
    } catch (e28) {
      return NaN;
    }
  }
  var vfactorial2 = vectorize2(factorial2);
  function find2(x6, fn2) {
    if (isDataFrame2(x6)) {
      return find2(x6.values, fn2);
    }
    if (isSeries2(x6)) {
      return find2(x6.values, fn2);
    }
    assert2(isObject2(x6) || isArray2(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction2(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject2(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray2(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn22(x22)) {
          return x22;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    return helper522(x6, safeFn);
  }
  function findAll2(x6, fn2) {
    if (isDataFrame2(x6)) {
      return findAll2(x6.values, fn2);
    }
    if (isSeries2(x6)) {
      return findAll2(x6.values, fn2);
    }
    assert2(isObject2(x6) || isArray2(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction2(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject2(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray2(x22)) {
        checked.push(x22);
        const out222 = [];
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn22(x22)) {
          return [x22];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const results = helper522(x6, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float2(x6) {
    try {
      if (x6 === "Infinity") {
        return Infinity;
      }
      if (x6 === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x6);
      if (isNumber2(out222))
        return out222;
      return NaN;
    } catch (e28) {
      return NaN;
    }
  }
  var vfloat2 = vectorize2(float2);
  function floor2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6;
      }
      return Math.floor(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vfloor2 = vectorize2(floor2);
  function zeros2(shape222) {
    if (isNumber2(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product2(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape2(out222, shape222);
  }
  function identity2(size) {
    if (typeof size === "bigint") {
      size = vint2(size);
    }
    assert2(!isUndefined2(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert2(isNumber2(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert2(vint2(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert2(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros2([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues2 = ["true", "false", "yes", "no"];
  var nullValues2 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger2(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint2(results.value) === results.value;
      } else {
        results.isInteger = every2(results.values, (v) => isNumber2(v) ? vint2(v) === v : true);
      }
    }
    return results;
  }
  function inferType2(arr) {
    if (isDataFrame2(arr)) {
      const out222 = arr.copy();
      const results = inferType2(arr.values);
      out222.values = results.values;
      return checkIfInteger2({ type: results.type, values: out222 });
    }
    if (isSeries2(arr)) {
      const out222 = arr.copy();
      const results = inferType2(arr.values);
      out222.values = results.values;
      return checkIfInteger2({ type: results.type, values: out222 });
    }
    if (!isArray2(arr)) {
      const out222 = inferType2([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger2(out222);
    }
    assert2(isArray2(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten2(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate2(temp)) {
            return "date";
          }
        }
      } catch (e28) {
      }
      if (!isString2(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues2.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues2.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber2(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray2(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e28) {
        const vDate = new Date(v);
        if (isDate2(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count2(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger2({
      type: primaryType,
      values: vapply2(arr, (v) => cast2(v, primaryType))
    });
  }
  function inverse2(x6) {
    if (isDataFrame2(x6)) {
      const out222 = x6.copy();
      out222.values = inverse2(out222.values);
      return out222;
    }
    assert2(isArray2(x6), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape2(x6);
    assert2(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert2(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert2(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x6;
    } else if (xShape[0] === 1) {
      assert2(x6[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x6[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x6[0][0];
      let b = x6[0][1];
      let c = x6[1][0];
      let d = x6[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det2 = a * d - b * c;
      assert2(det2 !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale2(out222, 1 / det2);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber2(a) || isNumber2(b) ? scale2(a, b) : dot2(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x6.slice(0, divider).map((row) => row.slice(0, divider));
          const B10 = x6.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C5 = x6.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x6.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse2(A);
          const CompInv = inverse2(vadd2(D, times(-1, times(times(C5, AInv), B10))));
          const topLeft = vadd2(AInv, times(times(times(times(AInv, B10), CompInv), C5), AInv));
          const topRight = times(-1, times(times(AInv, B10), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C5), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e28) {
        }
      }
      assert2(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser22 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp2(a, b, f) {
    try {
      if (!isNumber2(a))
        return NaN;
      if (!isNumber2(b))
        return NaN;
      if (!isNumber2(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp2(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e28) {
      return NaN;
    }
  }
  var vlerp2 = vectorize2(lerp2);
  function log2(x6, base) {
    try {
      base = isUndefined2(base) ? Math.E : base;
      if (!isNumber2(x6))
        return NaN;
      if (!isNumber2(base))
        return NaN;
      if (typeof x6 === "bigint" || typeof base === "bigint") {
        const out222 = log2(Number(x6), Number(base));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.log(x6) / Math.log(base);
    } catch (e28) {
      return NaN;
    }
  }
  var vlog2 = vectorize2(log2);
  function mean2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).mean;
  }
  function median2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod2(a, b) {
    try {
      if (!isNumber2(a))
        return NaN;
      if (!isNumber2(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod2(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return a % b;
    } catch (e28) {
      return NaN;
    }
  }
  var vmod2 = vectorize2(mod2);
  function mode2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper32() {
    const u12 = random2();
    const u22 = random2();
    return Math.sqrt(-2 * Math.log(u12)) * Math.cos(2 * Math.PI * u22);
  }
  function normal2(shape222) {
    if (isUndefined2(shape222))
      return helper32();
    return vapply2(ndarray2(shape222), helper32);
  }
  function ones2(shape222) {
    return vapply2(ndarray2(shape222), () => 1);
  }
  function permutationsIterator2(x6, r) {
    function* helper522(x22, r22) {
      r22 = r22 || x22.length;
      if (x22.length === 1) {
        yield [x22];
        return;
      }
      for (const c of combinations2(x22, r22)) {
        if (!c.slice)
          continue;
        const state = zeros2(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return permutationsIterator2(x6.values, r);
    }
    assert2(isArray2(x6), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined2(r)) {
      r = x6.length;
    }
    assert2(isNumber2(r) && vint2(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten2(x6), r);
  }
  function permutations2(x6, r) {
    const out222 = [];
    for (const perm of permutationsIterator2(x6, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print2() {
    Object.keys(arguments).forEach((key) => {
      const x6 = arguments[key];
      if (isArray2(x6)) {
        if (!isJagged2(x6)) {
          const xShape = shape2(x6);
          if (xShape.length === 1) {
            new Series2(x6).print();
          } else if (xShape.length == 2) {
            new DataFrame2(x6).print();
          } else {
            console.log(x6);
          }
        } else {
          console.log(x6);
        }
      } else if (isDataFrame2(x6) || isSeries2(x6)) {
        x6.print();
      } else {
        console.log(x6);
      }
    });
  }
  var helper42 = vectorize2((x6, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x6, a, b, c, d]) {
        if (!isNumber2(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x6 = Number(x6);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x6 - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  });
  function remap2(x6, a, b, c, d) {
    if (isArray2(x6) && isUndefined2(c) && isUndefined2(d)) {
      c = a;
      d = b;
      const results = stats2(x6);
      a = results.min;
      b = results.max;
    }
    return helper42(x6, a, b, c, d);
  }
  function round2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.round(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vround2 = vectorize2(round2);
  function sign2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return BigInt(sign2(Number(x6)));
      if (x6 < 0)
        return -1;
      if (x6 > 0)
        return 1;
      return 0;
    } catch (e28) {
      return NaN;
    }
  }
  var vsign2 = vectorize2(sign2);
  function sin2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.sin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsin2 = vectorize2(sin2);
  function some2(x6, fn2) {
    if (isDataFrame2(x6) || isSeries2(x6)) {
      return some2(x6.values, fn2);
    }
    assert2(isArray2(x6), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert2(isFunction2(fn2), "The second argument passed into the `some` function must be a function!");
    for (const v of x6) {
      if (isArray2(v)) {
        if (some2(v, fn2)) {
          return true;
        }
      } else {
        if (fn2(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev2(x6) {
    return std2(x6);
  }
  function tan2(x6) {
    try {
      if (!isNumber2(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.tan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vtan2 = vectorize2(tan2);
  function timeSync2(fn2, args) {
    assert2(isFunction2(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn2(...args);
    } else {
      fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync2(fn2, args) {
    assert2(isFunction2(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn2(...args);
    } else {
      await fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union2() {
    return set2([...arguments].map((v) => {
      if (isArray2(v))
        return v;
      if (isDataFrame2(v))
        return v.values;
      if (isSeries2(v))
        return v.values;
      return [v];
    }));
  }
  function variance2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip2() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame2(arr) || isSeries2(arr)) {
        arr = arr.values;
      }
      assert2(isArray2(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range2(0, max2(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined2(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out2 = {
    abs: vabs2,
    add: vadd2,
    apply: vapply2,
    arccos: varccos2,
    arcsin: varcsin2,
    arctan: varctan2,
    argmax: argmax2,
    argmin: argmin2,
    assert: assert2,
    cast: cast2,
    ceil: vceil2,
    chop: vchop2,
    clamp: vclamp2,
    combinations: combinations2,
    combinationsIterator: combinationsIterator2,
    copy: copy2,
    correl: correl2,
    cos: vcos2,
    count: count2,
    covariance: covariance2,
    DataFrame: DataFrame2,
    dataTypes: dataTypes2,
    decycle: decycle2,
    diff: diff2,
    distance: distance2,
    divide: divide2,
    dot: dot2,
    dropMissing: dropMissing2,
    dropMissingPairwise: dropMissingPairwise2,
    dropNaN: dropNaN2,
    dropNaNPairwise: dropNaNPairwise2,
    dropUndefined: dropUndefined2,
    every: every2,
    exp: vexp2,
    factorial: vfactorial2,
    find: find2,
    findAll: findAll2,
    flatten: flatten2,
    float: vfloat2,
    floor: vfloor2,
    identity: identity2,
    IndexMatcher: IndexMatcher2,
    indexOf: indexOf2,
    inferType: inferType2,
    int: vint2,
    intersect: intersect2,
    inverse: inverse2,
    isArray: isArray2,
    isBoolean: isBoolean2,
    isBrowser: isBrowser22,
    isDataFrame: isDataFrame2,
    isDate: isDate2,
    isEqual: isEqual2,
    isFunction: isFunction2,
    isJagged: isJagged2,
    isNested: isNested2,
    isNumber: isNumber2,
    isObject: isObject2,
    isSeries: isSeries2,
    isString: isString2,
    isUndefined: isUndefined2,
    lerp: vlerp2,
    log: vlog2,
    MathError: MathError2,
    max: max2,
    mean: mean2,
    median: median2,
    min: min2,
    mod: vmod2,
    mode: mode2,
    multiply: vmultiply2,
    ndarray: ndarray2,
    normal: normal2,
    ones: ones2,
    permutations: permutations2,
    permutationsIterator: permutationsIterator2,
    pow: vpow2,
    print: print2,
    product: product2,
    random: random2,
    range: range2,
    remap: remap2,
    reshape: reshape2,
    reverse: reverse2,
    round: vround2,
    scale: scale2,
    seed: seed2,
    Series: Series2,
    set: set2,
    shape: shape2,
    shuffle: shuffle2,
    sign: vsign2,
    sin: vsin2,
    some: some2,
    sort: sort2,
    sqrt: vsqrt2,
    stats: stats2,
    std: std2,
    stdev: stdev2,
    subtract: subtract2,
    sum: sum2,
    tan: vtan2,
    timeAsync: timeAsync2,
    timeSync: timeSync2,
    time: timeSync2,
    transpose: transpose2,
    union: union2,
    variance: variance2,
    vectorize: vectorize2,
    zeros: zeros2,
    zip: zip2,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out2.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out2).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out2[key]
          });
        } catch (e28) {
          context22[key] = out2[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out2;
  }
  function makeKey42(keyLength, keySeed, charset) {
    if (arguments.length === 2) {
      if (isNumber2(arguments[1])) {
        charset = null;
      } else {
        charset = keySeed;
        keySeed = null;
      }
    }
    assert2(
      isNumber2(keyLength) && vint2(keyLength) === keyLength,
      "`keyLength` must be an integer!"
    );
    if (keySeed) {
      assert2(
        isNumber2(keySeed) && vint2(keySeed) === keySeed,
        "`keySeed` must be an integer!"
      );
      seed2(keySeed);
    }
    if (charset) {
      assert2(isString2(charset), "`charset` must be a string!");
    }
    let out222 = "";
    charset = charset || "abcdefg1234567890";
    for (let i = 0; i < keyLength; i++) {
      out222 += charset[vint2(random2() * charset.length)];
    }
    return out222;
  }
  if (typeof window !== "undefined") {
    window.makeKey = makeKey42;
  }
  function camelify22(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    text = text.trim();
    let out222 = "";
    let shouldCapitalizeNextCharacter = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char.match(/[A-Za-z0-9]/g)) {
        if (out222.length === 0) {
          out222 += char.toLowerCase();
        } else if (shouldCapitalizeNextCharacter) {
          out222 += char.toUpperCase();
        } else {
          out222 += char;
        }
        shouldCapitalizeNextCharacter = false;
      } else if (!char.includes("'") && !char.includes("\u2019") && !char.includes("\u275C")) {
        shouldCapitalizeNextCharacter = true;
      }
    }
    return out222;
  }
  var __defProp22 = Object.defineProperty;
  var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField22 = (obj, key, value) => {
    __defNormalProp22(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber22(x6) {
    return typeof x6 === "number" && !isNaN(x6) || typeof x6 === "bigint";
  }
  var isBrowser32 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError22 = class extends Error {
    constructor(message) {
      if (isBrowser32()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert22(isTrue, message) {
    if (!isTrue)
      throw new MathError22(message);
  }
  var arrayTypes22 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined22(x6) {
    return x6 === null || typeof x6 === "undefined";
  }
  var typeStrings22 = arrayTypes22.map((s222) => s222.name);
  function isArray22(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined22(obj.constructor)) {
        return arrayTypes22.indexOf(obj.constructor) > -1 || typeStrings22.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e28) {
      return false;
    }
  }
  function isDataFrame22(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e28) {
      return false;
    }
  }
  function isFunction22(fn2) {
    return typeof fn2 === "function";
  }
  function isObject22(x6) {
    return typeof x6 === "object" && !isUndefined22(x6) && !isArray22(x6);
  }
  function isSeries22(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e28) {
      return false;
    }
  }
  function indexOf22(x6, fn2) {
    if (isDataFrame22(x6)) {
      const index = indexOf22(x6.values, fn2);
      if (index.length > 0 && isNumber22(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      if (index.length > 1 && isNumber22(index[1]) && index[1] >= 0 && index[1] < x6.columns.length) {
        index[1] = x6.columns[index[1]];
      }
      return index;
    }
    if (isSeries22(x6)) {
      const index = indexOf22(x6.values, fn2);
      if (index.length > 0 && isNumber22(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      return index;
    }
    assert22(isObject22(x6) || isArray22(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction22(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject22(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return [key];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray22(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return [i];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn22(x22)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const paths = helper522(x6, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy22(x6) {
    function helper522(x22) {
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        if (isArray22(x22)) {
          if (!(x22 instanceof Array)) {
            return x22.slice();
          }
          return x22.map((v) => copy22(v));
        }
        if (isSeries22(x22)) {
          const out32 = x22.copy();
          out32.values = copy22(out32.values);
          return out32;
        }
        if (isDataFrame22(x22)) {
          const out32 = x22.copy();
          out32.values = copy22(x22.values);
          return out32;
        }
        if (x22 instanceof Date) {
          return new Date(x22.getTime());
        }
        x22 = decycle22(x22);
        const out222 = {};
        Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
          out222[key] = copy22(x22[key]);
        });
        return out222;
      } else {
        return x22;
      }
    }
    return helper522(decycle22(x6));
  }
  function decycle22(x6) {
    function helper522(x22, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x22) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x22;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x22 ? "/" : "/" + indexOf22(orig, x22).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x22 === "object") {
        if (x22 === null)
          return null;
        checked.push(x22);
        if (isArray22(x22)) {
          if (typeof x22.constructor !== "undefined" && x22.constructor.name !== "Array") {
            return x22.slice();
          }
          return x22.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
            x22[key] = helper522(x22[key], checked, currentPath + "/" + key.toString());
          });
          return x22;
        }
      } else {
        return x22;
      }
    }
    const orig = x6;
    let out222 = helper522(orig);
    if (isDataFrame22(x6)) {
      const temp = x6.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries22(x6)) {
      const temp = x6.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate22(x6) {
    return x6 instanceof Date && x6.toString() !== "Invalid Date";
  }
  var numberTypes22 = ["number", "int", "float", "bigint"];
  function isEqual22(a, b) {
    function helper522(a22, b22) {
      const aType = typeof a22;
      const bType = typeof b22;
      if (aType !== bType && !numberTypes22.includes(aType) && !numberTypes22.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a22 === b22;
      if (aType === "symbol")
        return a22 === b22;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a22.toString();
          const bString = b22.toString();
          return aString === bString;
        } catch (e28) {
          return false;
        }
      }
      if (aType === "string")
        return a22 === b22;
      if (aType === "function")
        return a22 === b22;
      if (aType === "object") {
        if (a22 === null || b22 === null) {
          return a22 === null && b22 === null;
        } else {
          if (isDate22(a22)) {
            if (isDate22(b22)) {
              return a22.getTime() === b22.getTime();
            } else {
              return false;
            }
          } else if (isDate22(b22)) {
            return false;
          }
          if (a22 instanceof RegExp && b22 instanceof RegExp) {
            return a22.toString() === b22.toString();
          }
          if (isArray22(a22) !== isArray22(b22)) {
            return false;
          }
          const aKeys = Object.keys(a22).concat(Object.getOwnPropertySymbols(a22));
          const bKeys = Object.keys(b22).concat(Object.getOwnPropertySymbols(b22));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a22[key], b22[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e28) {
      return helper522(decycle22(a), decycle22(b));
    }
  }
  function makeKey5(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY32 = makeKey5(16);
  var UNDEFINED_KEY32 = makeKey5(16);
  var INFINITY_KEY32 = makeKey5(16);
  var MINUS_INFINITY_KEY32 = makeKey5(16);
  var SYMBOL_KEY32 = makeKey5(16);
  var Counter22 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x6) {
      for (const v of x6) {
        if (isArray22(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY32 : isUndefined22(value) ? UNDEFINED_KEY32 : isFunction22(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY32 : value === Infinity ? INFINITY_KEY32 : value === -Infinity ? MINUS_INFINITY_KEY32 : typeof value === "bigint" ? value.toString() : isDataFrame22(value) ? value.toJSONString() : isSeries22(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined22(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return flatten22(arr.values);
    }
    assert22(isArray22(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray22(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats22(x6, options) {
    options = options || {};
    const counts = new Counter22();
    const out222 = {};
    const xflat = flatten22(x6);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber22(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e28) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e28) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e28) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e28) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e28) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count22(arr, matcher) {
    const { counts } = stats22(arr);
    if (!isUndefined22(matcher)) {
      if (isFunction22(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual22(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper52(x6) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return helper52(x6.values);
    }
    if (isArray22(x6)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x6) {
        if (helper52(v)) {
          return true;
        }
        if (isArray22(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged22(x6) {
    return helper52(decycle22(x6));
  }
  function isNested22(x6) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return isNested22(x6.values);
    }
    assert22(isArray22(x6), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x6.length; i++) {
      if (isArray22(x6[i])) {
        return true;
      }
    }
    return false;
  }
  var error22 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray22(shape222) {
    assert22(!isUndefined22(shape222), error22);
    if (!isArray22(shape222))
      shape222 = [shape222];
    assert22(!isNested22(shape222), error22);
    assert22(shape222.length > 0, error22);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert22(isNumber22(s222), error22);
    assert22(s222 >= 0, error22);
    assert22(Math.floor(s222) === s222, error22);
    assert22(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray22(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      const out32 = arr.copy();
      out32.values = reverse22(out32.values);
      out32.index = reverse22(out32.index);
      return out32;
    }
    assert22(isArray22(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range22(a, b, step = 1) {
    assert22(!isUndefined22(a) && !isUndefined22(b) && !isUndefined22(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert22(isNumber22(a) && isNumber22(b) && isNumber22(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert22(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e28) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse22(out222);
    return out222;
  }
  function makeKey222(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY222 = makeKey222(256);
  var UNDEFINED_KEY222 = makeKey222(256);
  var INFINITY_KEY222 = makeKey222(256);
  var MINUS_INFINITY_KEY222 = makeKey222(256);
  var SYMBOL_KEY222 = makeKey222(256);
  function set22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return set22(arr.values);
    }
    assert22(isArray22(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten22(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY222 : isUndefined22(item) ? UNDEFINED_KEY222 : isFunction22(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY222 : item === Infinity ? INFINITY_KEY222 : item === -Infinity ? MINUS_INFINITY_KEY222 : typeof item === "bigint" ? item.toString() : isDataFrame22(item) ? item.toJSONString() : isSeries22(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper222(x6) {
    if (isArray22(x6)) {
      const childShapes = helper222(x6[0]);
      return [x6.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape22(x6) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return shape22(x6.values);
    }
    assert22(isArray22(x6), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper222(x6);
  }
  function dfAppend22(df2, x6, axis) {
    if (isUndefined22(axis)) {
      axis = 0;
    }
    assert22(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray22(x6)) {
      assert22(!isJagged22(x6), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape22(x6);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df2.copy();
          out222._values.push(x6);
          const maxRowLength = Math.max(df2.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range22(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray22(df2.shape[1]));
            }
            out222._values[i].push(x6[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x6.map((row) => row.length).concat([df2.shape[1]]));
          const out222 = df2.copy();
          out222._values = out222._values.concat(x6).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x6.map((row) => row.length)) + df2.shape[1];
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range22(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray22(df2.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x6[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError22("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries22(x6)) {
      const out222 = dfAppend22(df2, x6.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      }
      return out222;
    } else if (isDataFrame22(x6)) {
      if (axis === 0) {
        const out222 = df2.copy();
        const maxRowLength = set22(out222._columns.concat(x6._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x6.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x6._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df2._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df2.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x6._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x6._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray22(x6.shape[1]));
          }
        });
        x6._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray22(out222._columns.length).concat(x6._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x6._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError22("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply22(DataFrame222, Series222, df2, fn2, axis) {
    axis = axis || 0;
    assert22(isFunction22(fn2), "The first parameter to the `apply` method must be a function.");
    assert22(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df2.columns.forEach((colName, i) => {
        const series = new Series222(df2.values.map((row) => row[i]));
        series.name = colName;
        series.index = df2.index;
        const value = fn2(series, i, df2);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined22(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray22(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        return out222;
      } else {
        const out222 = new Series222(df2.columns.map((colName) => temp[colName]));
        out222.index = df2.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df2.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const value = fn2(series, i, df2);
        if (isUndefined22(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray22(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        out222.columns = df2.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df2.index;
        return out222;
      }
    }
  }
  function isString22(s222) {
    return typeof s222 === "string";
  }
  function dfAssign22(DataFrame222, Series222, df2, p12, p22) {
    const isDataFrame222 = (x6) => x6 instanceof DataFrame222;
    const isSeries222 = (x6) => x6 instanceof Series222;
    if (!isUndefined22(p22)) {
      assert22(isString22(p12), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert22(isArray22(p22) && !isJagged22(p22) && shape22(p22).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df2.append(p22, 1);
      out222.columns[out222.columns.length - 1] = p12;
      return out222;
    } else {
      if (isDataFrame222(p12)) {
        return df2.append(p12, 1);
      } else if (isSeries222(p12)) {
        return df2.append(p12, 1);
      } else if (isObject22(p12)) {
        const maxColumnLength = Math.max(...Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).map((key) => p12[key].length));
        Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).forEach((key) => {
          while (p12[key].length < maxColumnLength) {
            p12[key].push(void 0);
          }
        });
        return df2.append(new DataFrame222(p12), 1);
      } else {
        throw new MathError22("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy22(DataFrame222, df2) {
    if (df2.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy22(df2.values));
    out222.columns = df2.columns.slice();
    out222.index = df2.index.slice();
    return out222;
  }
  function dfDrop22(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined22(rows))
      rows = [];
    if (isUndefined22(cols))
      cols = [];
    if (isString22(rows) || isNumber22(rows))
      rows = [rows];
    if (isString22(cols) || isNumber22(cols))
      cols = [cols];
    assert22(isArray22(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert22(isArray22(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert22(shape22(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert22(shape22(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df2.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df2.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df2.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df2.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger22(x6) {
    return isNumber22(x6) && (x6 >= 0 ? Math.floor(x6) === x6 : Math.ceil(x6) === x6);
  }
  function isWholeNumber22(x6) {
    return isInteger22(x6) && x6 >= 0;
  }
  function dfDropMissing22(DataFrame222, Series222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert22(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert22(isWholeNumber22(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert22(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined22(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined22(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined22(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df2.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape22(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined22(newIndex))
        return new DataFrame222();
      if (isString22(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN22(x6) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return x6.dropNaN(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(x6), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropNaN22(v));
      } catch (e28) {
        if (isNumber22(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN22(DataFrame222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert22(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert22(isWholeNumber22(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert22(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN22(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df2.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject22(x6) {
    const out222 = {};
    flatten22(x6).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject22(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter22(DataFrame222, Series222, df2, fn2, axis) {
    assert22(isFunction22(fn2), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined22(axis))
      axis = 0;
    assert22(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df2.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject22(out222.index);
    const columns = arrayToObject22(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject22(index)[0];
        temp.index = undoArrayToObject22(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject22(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.columns[i];
        series.index = df2.index;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject22(columns)[0];
        temp.index = undoArrayToObject22(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject22(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet22(df2, rows, cols) {
    if (isString22(rows) || isNumber22(rows))
      rows = [rows];
    if (isString22(cols) || isNumber22(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set22((rows || []).concat(cols || []).map((v) => typeof v));
    assert22(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert22(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert22(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert22(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined22(rows)) {
      rows = rows.map((r) => {
        if (isString22(r)) {
          assert22(df2.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber22(r)) {
          assert22(r >= 0, `Index ${r} is out of bounds!`);
          assert22(Math.floor(r) === r, `Row numbers must be integers!`);
          assert22(r < df2.index.length, `Index ${r} is out of bounds!`);
          return df2.index[r];
        }
      });
    }
    if (!isUndefined22(cols)) {
      cols = cols.map((c) => {
        if (isString22(c)) {
          assert22(df2.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber22(c)) {
          assert22(c >= 0, `Column ${c} is out of bounds!`);
          assert22(Math.floor(c) === c, `Column numbers must be integers!`);
          assert22(c < df2.columns.length, `Column ${c} is out of bounds!`);
          return df2.columns[c];
        }
      });
    }
    return df2.getSubsetByNames(rows, cols);
  }
  function alphaSort22(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e28) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort22(arr, fn2) {
    if (isUndefined22(fn2))
      fn2 = alphaSort22;
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert22(isFunction22(fn2), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn2);
    return out222;
  }
  function camelify222(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies22(DataFrame222, df2, columns) {
    if (isUndefined22(columns)) {
      columns = df2.columns;
    } else if (isString22(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert22(isString22(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df2.columns.indexOf(col);
      assert22(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df2.values.map((row) => row[colIndex]);
      const valuesSet = sort22(set22(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify222(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df2.index;
    return out222;
  }
  function dfGetSubsetByIndices22(df2, rowIndices, colIndices) {
    const dataShape = df2.shape;
    if (isUndefined22(rowIndices))
      rowIndices = range22(0, dataShape[0]);
    if (isUndefined22(colIndices))
      colIndices = range22(0, dataShape[1]);
    if (isNumber22(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber22(colIndices))
      colIndices = [colIndices];
    assert22(isArray22(rowIndices) && isArray22(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert22(shape22(rowIndices).length === 1 && shape22(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert22(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert22(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert22(isWholeNumber22(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert22(rowIndex < df2.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert22(isWholeNumber22(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert22(colIndex < df2.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df2.index[i]);
    const cols = colIndices.map((i) => df2.columns[i]);
    return df2.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames22(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined22(rows))
      rows = df2.index;
    if (isUndefined22(cols))
      cols = df2.columns;
    if (isString22(rows))
      rows = [rows];
    if (isString22(cols))
      cols = [cols];
    assert22(isArray22(rows) && isArray22(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert22(shape22(rows).length === 1 && shape22(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert22(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert22(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert22(isString22(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert22(df2.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert22(isString22(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert22(df2.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df2.values[df2.index.indexOf(row)][df2.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint22(DataFrame222, Series222, df2) {
    function truncate(s222, maxLength2) {
      if (isString22(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df2.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df2;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df2.index.length ? null : range22(0, halfMaxRows).concat(range22(df2.index.length - halfMaxRows, df2.index.length));
    const tempColumns = maxColumns > df2.columns.length ? null : range22(0, halfMaxColumns).concat(range22(df2.columns.length - halfMaxColumns, df2.columns.length));
    let temp = df2.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df2.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df2.index;
        temp.columns = new Series222(df2.columns).get(tempColumns).values;
      } else if (df2.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df2.index).get(tempRows).values;
        temp.columns = df2.columns;
      }
    }
    if (maxRows <= df2.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range22(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df2.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df2.shape, "\n");
    return df2;
  }
  function leftPad22(x6, maxLength) {
    assert22(isNumber22(x6), "The `leftPad` function only works on numbers!");
    let out222 = x6.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex22(df2, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df2 : df2.copy();
    out222.index = range22(0, df2.shape[0]).map((i) => {
      return "row" + leftPad22(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product22(arr, shouldDropNaNs) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return product22(arr.values, shouldDropNaNs);
    }
    assert22(isArray22(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten22(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber22(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  function isNaturalNumber22(x6) {
    return isInteger22(x6) && x6 > 0;
  }
  function reshape22(x6, newShape) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return reshape22(x6.values, newShape);
    }
    assert22(isArray22(x6), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber22(newShape))
      newShape = [newShape];
    assert22(isArray22(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert22(shape22(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert22(isNaturalNumber22(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten22(x6);
    }
    const temp = flatten22(x6);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert22(product22(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape22(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX22 = Math.pow(2, 64);
  var s22 = [];
  seed22(Math.floor(Math.random() * MAX22));
  function splitmix6422(state, n) {
    state = uint22(state);
    function helper522() {
      state += uint22("0x9e3779b97f4a7c15");
      let z10 = copy22(state);
      z10 = (z10 ^ z10 >> BigInt(30)) * uint22("0xbf58476d1ce4e5b9");
      z10 = (z10 ^ z10 >> BigInt(27)) * uint22("0x94d049bb133111eb");
      return z10 ^ z10 >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint22(x6) {
    return BigInt.asUintN(64, BigInt(x6));
  }
  function rotl22(x6, k6) {
    x6 = uint22(x6);
    k6 = BigInt(k6);
    return uint22(uint22(x6 << k6) | uint22(x6 >> uint22(BigInt(64) - k6)));
  }
  function seed22(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined22(val)) {
      assert22(isNumber22(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix6422(Math.floor(val), 4);
      s22[0] = temp[0];
      s22[1] = temp[1];
      s22[2] = temp[2];
      s22[3] = temp[3];
    } else {
      return copy22(s22);
    }
  }
  function next22() {
    const result = uint22(rotl22(s22[0] + s22[3], 23) + s22[0]);
    const t = uint22(s22[1] << BigInt(17));
    s22[2] = uint22(s22[2] ^ s22[0]);
    s22[3] = uint22(s22[3] ^ s22[1]);
    s22[1] = uint22(s22[1] ^ s22[2]);
    s22[0] = uint22(s22[0] ^ s22[3]);
    s22[2] = uint22(s22[2] ^ t);
    s22[3] = rotl22(s22[3], 45);
    return Math.floor(Number(result)) / MAX22;
  }
  function random22(shape222) {
    if (isUndefined22(shape222))
      return next22();
    if (!isArray22(shape222))
      shape222 = [shape222];
    return reshape22(ndarray22(product22(shape222)).map(next22), shape222);
  }
  function shuffle22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random22() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle22(df2, axis) {
    if (isUndefined22(axis))
      axis = 0;
    assert22(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df2.get(axis === 0 ? shuffle22(df2.index) : null, axis === 1 ? shuffle22(df2.columns) : null);
  }
  function isBoolean22(x6) {
    return typeof x6 === "boolean";
  }
  function dfSort22(df2, a, b) {
    if (isFunction22(a)) {
      return dfSortByFunction22(df2, a, b);
    } else {
      return dfSortByColumns22(df2, a, b);
    }
  }
  function dfSortByFunction22(df2, fn2, axis) {
    axis = isUndefined22(axis) ? 0 : axis;
    assert22(isFunction22(fn2), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert22(isNumber22(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort22(df2.index, (a, b) => {
        return fn2(df2.get(a, null), df2.get(b, null));
      });
      return df2.get(index, null);
    } else {
      const columns = sort22(df2.columns, (a, b) => {
        return fn2(df2.get(null, a), df2.get(null, b));
      });
      return df2.get(null, columns);
    }
  }
  function dfSortByColumns22(df2, cols, directions) {
    let out222 = df2.copy();
    const indexID = random22().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined22(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber22(cols) || isString22(cols)) {
      cols = [cols];
      if (isBoolean22(directions) || isString22(directions))
        directions = [directions];
    }
    assert22(isArray22(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert22(shape22(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined22(directions))
      directions = range22(0, cols.length).map(() => true);
    assert22(isArray22(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert22(shape22(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert22(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert22(isString22(col) || isNumber22(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString22(col)) {
        const index = out222.columns.indexOf(col);
        assert22(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber22(col)) {
        assert22(isWholeNumber22(col), "Column indices must be whole numbers!");
        assert22(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert22(isString22(dir) || isBoolean22(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString22(dir)) {
        const value = dir.trim().toLowerCase();
        assert22(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean22(dir)) {
        return dir;
      }
    });
    out222.values = sort22(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject22(df2, axis) {
    if (isUndefined22(axis)) {
      axis = 0;
    } else {
      assert22(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df2.index.forEach((rowName, i) => {
        const temp = {};
        df2.columns.forEach((colName, j) => {
          temp[colName] = df2.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df2.columns.forEach((colName, j) => {
        const temp = {};
        df2.index.forEach((rowName, i) => {
          temp[rowName] = df2.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString22(df2, axis) {
    return JSON.stringify(df2.toObject(axis));
  }
  async function dfToJSON22(df2, filename, axis) {
    const out222 = dfToJSONString22(df2, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e28) {
      browserError = e28;
    }
    try {
      const fs2 = await import("node:fs");
      const path = await import("node:path");
      fs2.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e28) {
      nodeError = e28;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError22(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError22(nodeError);
      } else {
        throw new MathError22("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df2;
  }
  function dfToObject22(df2) {
    const out222 = {};
    df2.columns.forEach((col) => {
      out222[col] = df2.get(col).values;
    });
    return out222;
  }
  function transpose22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return arr.transpose();
    }
    assert22(isArray22(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape22(arr);
    assert22(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse22(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray22(reverse22(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend22(Series222, series, x6) {
    if (isSeries22(x6)) {
      return new Series222(series.values.concat(x6.values));
    }
    if (isArray22(x6)) {
      const xShape = shape22(x6);
      assert22(xShape.length === 1 && !isNested22(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x6.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend22(series, [x6]);
  }
  function seriesApply22(series, fn2) {
    assert22(isFunction22(fn2), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn2(v, i));
    return out222;
  }
  function seriesDropMissing22(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined22(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN22(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber22(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter22(Series222, series, fn2) {
    let out222 = series.copy();
    const index = copy22(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn2(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet22(series, indices) {
    if (isString22(indices) || isNumber22(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set22((indices || []).map((v) => typeof v));
    assert22(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert22(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert22(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert22(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined22(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert22(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert22(i >= 0, `Index ${i} is out of bounds!`);
          assert22(Math.floor(i) === i, `Indices must be integers!`);
          assert22(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices22(series, indices) {
    const dataShape = series.shape;
    if (isUndefined22(indices))
      indices = range22(0, dataShape[0]);
    assert22(isArray22(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert22(shape22(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert22(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert22(isWholeNumber22(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert22(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames22(Series222, series, indices) {
    if (isUndefined22(indices))
      indices = series.index;
    assert22(isArray22(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert22(shape22(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert22(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert22(isString22(name), "The `indices` array must contain only strings.");
      assert22(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint22(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range22(0, maxRows / 2).concat(range22(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy22(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle22(series) {
    const out222 = series.copy();
    return out222.get(shuffle22(out222.index));
  }
  function seriesSort22(Series222, series, fn2) {
    fn2 = fn2 || ((a, b) => a < b ? -1 : 1);
    assert22(isUndefined22(fn2) || isFunction22(fn2), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose22([series.values, series.index]);
    const temp = sort22(pairs, (aPair, bPair) => {
      return fn2(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex22(Series222, series) {
    let temp = transpose22([series.values, series.index]);
    temp = transpose22(sort22(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject22(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL22 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass22(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x6) {
        try {
          return !!x6._symbol && x6._symbol === SERIES_SYMBOL22;
        } catch (e28) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL22
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x6) {
            assert22(isArray22(x6), "The new values must be a 1-dimensional array!");
            const dataShape = shape22(x6);
            assert22(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range22(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad22(i, (x6.length - 1).toString().length);
              }));
            }
            this._values = x6;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x6) {
            assert22(isArray22(x6), "The new index must be a 1-dimensional array of strings!");
            assert22(x6.length === this.shape[0], "The new index must be the same length as the old index!");
            assert22(shape22(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
            x6.forEach((value) => {
              assert22(isString22(value), "All of the row names must be strings!");
            });
            this._index = x6;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy22(data.values);
            this.index = copy22(data.index);
          } else if (isArray22(data)) {
            const dataShape = shape22(data);
            assert22(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert22(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert22(shape22(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape22(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined22(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet22(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames22(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices22(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse22(this.values));
        out222.index = reverse22(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range22(0, this.shape[0]).map((i) => {
          return "item" + leftPad22(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy22(this.values);
        out222._index = copy22(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x6) {
        return seriesAppend22(Series222, this, x6);
      }
      apply(fn2) {
        return seriesApply22(this, fn2);
      }
      concat(x6) {
        return this.append(x6);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing22(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN22(Series222, this);
      }
      toObject() {
        return seriesToObject22(this);
      }
      print() {
        return seriesPrint22(this);
      }
      shuffle() {
        return seriesShuffle22(this);
      }
      sort(direction) {
        return seriesSort22(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex22(Series222, this);
      }
      filter(fn2) {
        return seriesFilter22(Series222, this, fn2);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose22([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse22(out222.values);
        out222.index = reverse22(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL22 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey322(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random22() * alpha.length)];
    return out222;
  }
  var DataFrame22 = class {
    static [Symbol.hasInstance](x6) {
      try {
        return !!x6._symbol && x6._symbol === DATAFRAME_SYMBOL22;
      } catch (e28) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL22
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined22(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x6) {
          assert22(isArray22(x6), "The new values must be a 2-dimensional array!");
          const dataShape = shape22(x6);
          assert22(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range22(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad22(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range22(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad22(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x6;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x6) {
          assert22(isArray22(x6), "The new columns list must be a 1-dimensional array of strings!");
          assert22(this.isEmpty || x6.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert22(shape22(x6).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey322(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count22(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey322(8);
            }
            return v;
          });
          this._columns = x6;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x6) {
          assert22(isArray22(x6), "The new index must be a 1-dimensional array of strings!");
          assert22(this.isEmpty || x6.length === this.shape[0], "The new index must be the same length as the old index!");
          assert22(shape22(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey322(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count22(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey322(8);
            }
            return v;
          });
          this._index = x6;
        }
      });
      assert22(isUndefined22(data) || isObject22(data) || isArray22(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame22) {
          this.values = copy22(data.values);
          this.columns = copy22(data.columns);
          this.index = copy22(data.index);
        } else if (isArray22(data)) {
          const dataShape = shape22(data);
          assert22(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert22(!isJagged22(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined22(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert22(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose22(temp);
          const dataShape = shape22(this.values);
          this._index = range22(0, dataShape[0]).map((i) => {
            return "row" + leftPad22(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape22(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame22(ndarray22(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e28) {
          return this.get(rows, null);
        }
      }
      return dfGet22(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames22(DataFrame22, Series22, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices22(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies22(DataFrame22, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies22(DataFrame22, this, columns);
    }
    transpose() {
      const out222 = new DataFrame22(transpose22(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex22(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy22(DataFrame22, this);
    }
    assign(p12, p22) {
      return dfAssign22(DataFrame22, Series22, this, p12, p22);
    }
    apply(fn2, axis) {
      return dfApply22(DataFrame22, Series22, this, fn2, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing22(DataFrame22, Series22, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN22(DataFrame22, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop22(DataFrame22, Series22, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject22(this, axis);
    }
    toObject() {
      return dfToObject22(this);
    }
    toJSONString(axis) {
      return dfToJSONString22(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON22(this, filename, axis);
    }
    print() {
      return dfPrint22(DataFrame22, Series22, this);
    }
    sort(cols, directions) {
      return dfSort22(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn2, axis) {
      return dfFilter22(DataFrame22, Series22, this, fn2, axis);
    }
    shuffle(axis) {
      return dfShuffle22(this, axis);
    }
    append(x6, axis) {
      return dfAppend22(this, x6, axis);
    }
    concat(x6, axis) {
      return this.append(x6, axis);
    }
    join(x6, axis) {
      return this.append(x6, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series22 = createSeriesClass22(DataFrame22);
  function max22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).max;
  }
  function vectorize22(fn2) {
    assert22(isFunction22(fn2), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray22(arg)) {
          return true;
        } else if (isSeries22(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame22(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert22(isEqual22(isArray22(s222) ? shape22(s222) : s222.shape, isArray22(childArrays[i + 1]) ? shape22(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn2.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max22(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range22(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray22(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries22(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame22(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual22(shape22(dataframes[0]), shape22(out222))) {
              const temp = new DataFrame22(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame22(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series22(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series22(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn2(...arguments);
      }
    };
  }
  function abs22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6 < 0 ? -x6 : x6;
      } else {
        return Math.abs(x6);
      }
    } catch (e28) {
      return NaN;
    }
  }
  var vabs22 = vectorize22(abs22);
  function add22() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x6 = Object.values(arguments);
      for (let v of x6) {
        if (!isNumber22(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vadd22 = vectorize22(add22);
  function apply22(x6, fn2) {
    try {
      return fn2(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vapply22 = vectorize22(apply22);
  function arccos22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.acos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varccos22 = vectorize22(arccos22);
  function arcsin22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.asin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varcsin22 = vectorize22(arcsin22);
  function arctan22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.atan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varctan22 = vectorize22(arctan22);
  function argmax22(x6, shouldDropNaNs) {
    if (isDataFrame22(x6)) {
      const index = argmax22(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries22(x6)) {
      const index = argmax22(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert22(isArray22(x6), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf22(x6, max22(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function min22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).min;
  }
  function argmin22(x6, shouldDropNaNs) {
    if (isDataFrame22(x6)) {
      const index = argmin22(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries22(x6)) {
      const index = argmin22(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert22(isArray22(x6), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf22(x6, min22(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function cast22(value, type) {
    if (isDataFrame22(value) || isSeries22(value)) {
      return value.apply((item) => cast22(item, type));
    }
    if (isArray22(value)) {
      return value.map((v) => cast22(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined22(value)) {
        return NaN;
      }
      const booleanValue = cast22(value, "boolean");
      if (isBoolean22(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e28) {
        const dateValue = cast22(value, "date");
        if (isDate22(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast22(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast22(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast22(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean22(value)) {
        return value;
      }
      if (isNumber22(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e28) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate22(value)) {
        return value;
      }
      if (isUndefined22(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate22(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject22(value)) {
        return value;
      }
      const booleanValue = cast22(value, "boolean");
      if (isBoolean22(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast22(value, "number");
        if (isNumber22(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e28) {
      }
      const dateValue = cast22(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray22(out222)) {
          return out222.map((v) => cast22(v, type));
        } else {
          return out222;
        }
      } catch (e28) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined22(value)) {
        if (isEqual22(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.ceil(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vceil22 = vectorize22(ceil22);
  function chop22(x6, threshold) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      if (isUndefined22(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber22(threshold)) {
        return NaN;
      }
      return vabs22(x6) < threshold ? 0 : x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vchop22 = vectorize22(chop22);
  function int22(x6) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      const out222 = x6.copy();
      out222.values = int22(out222.values);
      return out222;
    }
    if (isArray22(x6)) {
      return x6.map((v) => int22(v));
    } else {
      try {
        const out222 = JSON.parse(x6);
        if (isNumber22(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e28) {
        return NaN;
      }
    }
  }
  var vint22 = vectorize22(int22);
  function clamp22(x6, a, b) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (!isNumber22(a))
        return NaN;
      if (!isNumber22(b))
        return NaN;
      if (typeof x6 === "bigint") {
        return BigInt(clamp22(vint22(x6), a, b));
      }
      if (x6 < a)
        return a;
      if (x6 > b)
        return b;
      return x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vclamp22 = vectorize22(clamp22);
  function combinationsIterator22(x6, r) {
    function* helper522(x22, r22) {
      if (r22 > x22.length) {
        yield x22;
      } else if (r22 <= 0) {
        yield [];
      } else if (x22.length < 2) {
        yield x22;
      } else {
        for (let i = 0; i < x22.length; i++) {
          const item = x22[i];
          const after = x22.slice(i + 1);
          if (after.length < r22 - 1) {
            continue;
          }
          if (r22 - 1 >= 0) {
            for (const child of combinationsIterator22(after, r22 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return combinationsIterator22(x6.values, r);
    }
    assert22(isArray22(x6), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert22(isNumber22(r) && vint22(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten22(x6), r);
  }
  function combinations22(x6, r) {
    const out222 = [];
    for (const combo of combinationsIterator22(x6, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect22() {
    const arrays = Object.values(arguments).map((x6) => {
      if (isDataFrame22(x6) || isSeries22(x6)) {
        return set22(x6.values);
      }
      assert22(isArray22(x6), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set22(x6);
    });
    const all = set22(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual22(other, v)) > -1);
    });
  }
  var _IndexMatcher22 = class {
    constructor(mode222) {
      assert22(isUndefined22(mode222) || mode222 === _IndexMatcher22.DROP_NAN_MODE || mode222 === _IndexMatcher22.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined22(mode222) ? mode222 : _IndexMatcher22.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x6) => {
        if (isArray22(x6)) {
          const xshape = shape22(x6);
          if (xshape.length === 1) {
            x6 = new Series22(x6);
          } else if (xshape.length === 2) {
            x6 = new DataFrame22(x6);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert22(isDataFrame22(x6) || isSeries22(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher22.DROP_MISSING_MODE) {
          indices.push(x6.dropMissing().index);
        } else {
          indices.push(x6.dropNaN().index);
        }
      });
      this.index = intersect22(...indices);
      return this;
    }
    transform() {
      assert22(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x6) => {
        if (isArray22(x6)) {
          const xshape = shape22(x6);
          if (xshape.length === 1) {
            return new Series22(x6).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame22(x6).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert22(isDataFrame22(x6) || isSeries22(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x6.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher22 = _IndexMatcher22;
  __publicField22(IndexMatcher22, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField22(IndexMatcher22, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance22(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries22(x6)) {
      return covariance22(x6.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries22(y)) {
      return covariance22(x6, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert22(isArray22(x6) && isArray22(y) && shape22(x6).length === 1 && shape22(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert22(x6.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance22(...new IndexMatcher22().fitAndTransform(x6, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats22(x6, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats22(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx2 = Number(xstats.mean);
      const my2 = Number(ystats.mean);
      if (!isNumber22(mx2) || !isNumber22(my2)) {
        return NaN;
      }
      const n = Math.max(x6.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx2 = x6[i];
        let vy2 = y[i];
        if (!isNumber22(vx2))
          return NaN;
        if (!isNumber22(vy2))
          return NaN;
        if (typeof vx2 === "bigint") {
          vx2 = Number(vx2);
        }
        if (typeof vy2 === "bigint") {
          vy2 = Number(vy2);
        }
        out222 += (vx2 - mx2) * (vy2 - my2);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x6.length, xstats, ystats];
      } else {
        return out222 / x6.length;
      }
    } catch (e28) {
      return NaN;
    }
  }
  function correl22(x6, y, shouldDropNaNs) {
    if (isSeries22(x6)) {
      return correl22(x6.values, y, shouldDropNaNs);
    }
    if (isSeries22(y)) {
      return correl22(x6, y.values, shouldDropNaNs);
    }
    assert22(isArray22(x6) && isArray22(y) && shape22(x6).length === 1 && shape22(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert22(x6.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance22(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e28) {
      return NaN;
    }
  }
  function cos22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.cos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vcos22 = vectorize22(cos22);
  var dataTypes22 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff22(a, b) {
    if (isDataFrame22(a) || isSeries22(a)) {
      return diff22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return diff22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set22(a);
    const bTemp = set22(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual22(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow22(x6, p) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (!isNumber22(p))
        return NaN;
      if (typeof x6 === "bigint" || typeof p === "bigint") {
        const out222 = pow22(Number(x6), Number(p));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.pow(x6, p);
    } catch (e28) {
      return NaN;
    }
  }
  var vpow22 = vectorize22(pow22);
  function sqrt22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        const out222 = sqrt22(Number(x6));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.sqrt(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsqrt22 = vectorize22(sqrt22);
  function multiply22() {
    try {
      const x6 = Object.values(arguments);
      if (x6.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x6) {
        if (!isNumber22(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vmultiply22 = vectorize22(multiply22);
  function scale22() {
    return vmultiply22(...arguments);
  }
  function subtract22(a, b) {
    return vadd22(a, scale22(b, -1));
  }
  function sum22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).sum;
  }
  function distance22(a, b) {
    if (isNumber22(a) && isNumber22(b)) {
      return vabs22(a - b);
    }
    if (isDataFrame22(a) || isSeries22(a)) {
      return distance22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return distance22(a, b.values);
    }
    if (isArray22(a) && isArray22(b)) {
      assert22(isEqual22(shape22(a), shape22(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt22(sum22(vpow22(subtract22(a, b), 2)));
    } catch (e28) {
      return NaN;
    }
  }
  function divide22(a, b) {
    return scale22(a, vpow22(b, -1));
  }
  function dot22(a, b) {
    if (isDataFrame22(a)) {
      const temp = dot22(a.values, b);
      if (shape22(temp).length === 1) {
        const out222 = new Series22(temp);
        out222.name = isSeries22(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame22(temp);
        out222.index = a.index.slice();
        if (isDataFrame22(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame22(b)) {
      const temp = dot22(a, b.values);
      if (shape22(temp).length === 1) {
        const out222 = new Series22(temp);
        out222.name = isSeries22(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame22(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries22(a)) {
      return dot22(a.values, b);
    }
    if (isSeries22(b)) {
      return dot22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape22(a);
    const bShape = shape22(b);
    assert22(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert22(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum22(scale22(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose22(b).map((col) => dot22(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot22(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose22(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot22(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing22(x6) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return x6.dropMissing(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(x6), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropMissing22(v));
      } catch (e28) {
        if (!isUndefined22(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise22(a, b) {
    if (isDataFrame22(a) || isSeries22(a)) {
      return dropMissingPairwise22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return dropMissingPairwise22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert22(isEqual22(shape22(a), shape22(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise22(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (!isUndefined22(a[i]) && !isUndefined22(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise22(a, b) {
    if (isDataFrame22(a) || isSeries22(a)) {
      return dropNaNPairwise22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return dropNaNPairwise22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert22(isEqual22(shape22(a), shape22(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise22(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (isNumber22(a[i]) && isNumber22(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined22(x6) {
    return dropMissing22(x6);
  }
  function every22(x6, fn2) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return every22(x6.values, fn2);
    }
    assert22(isArray22(x6), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert22(isFunction22(fn2), "The second argument passed into the `every` function must be a function!");
    for (const v of x6) {
      if (isArray22(v)) {
        if (!every22(v, fn2)) {
          return false;
        }
      } else {
        if (!fn2(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        if (x6 === 0n) {
          return 1n;
        } else {
          x6 = Number(x6);
        }
      }
      return Math.exp(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vexp22 = vectorize22(exp22);
  function factorial22(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial22(vint22(n)));
      }
      if (n !== vint22(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial22(n - 1);
    } catch (e28) {
      return NaN;
    }
  }
  var vfactorial22 = vectorize22(factorial22);
  function find22(x6, fn2) {
    if (isDataFrame22(x6)) {
      return find22(x6.values, fn2);
    }
    if (isSeries22(x6)) {
      return find22(x6.values, fn2);
    }
    assert22(isObject22(x6) || isArray22(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction22(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject22(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray22(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn22(x22)) {
          return x22;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    return helper522(x6, safeFn);
  }
  function findAll22(x6, fn2) {
    if (isDataFrame22(x6)) {
      return findAll22(x6.values, fn2);
    }
    if (isSeries22(x6)) {
      return findAll22(x6.values, fn2);
    }
    assert22(isObject22(x6) || isArray22(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction22(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject22(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray22(x22)) {
        checked.push(x22);
        const out222 = [];
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn22(x22)) {
          return [x22];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const results = helper522(x6, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float22(x6) {
    try {
      if (x6 === "Infinity") {
        return Infinity;
      }
      if (x6 === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x6);
      if (isNumber22(out222))
        return out222;
      return NaN;
    } catch (e28) {
      return NaN;
    }
  }
  var vfloat22 = vectorize22(float22);
  function floor22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6;
      }
      return Math.floor(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vfloor22 = vectorize22(floor22);
  function zeros22(shape222) {
    if (isNumber22(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product22(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape22(out222, shape222);
  }
  function identity22(size) {
    if (typeof size === "bigint") {
      size = vint22(size);
    }
    assert22(!isUndefined22(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert22(isNumber22(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert22(vint22(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert22(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros22([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues22 = ["true", "false", "yes", "no"];
  var nullValues22 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger22(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint22(results.value) === results.value;
      } else {
        results.isInteger = every22(results.values, (v) => isNumber22(v) ? vint22(v) === v : true);
      }
    }
    return results;
  }
  function inferType22(arr) {
    if (isDataFrame22(arr)) {
      const out222 = arr.copy();
      const results = inferType22(arr.values);
      out222.values = results.values;
      return checkIfInteger22({ type: results.type, values: out222 });
    }
    if (isSeries22(arr)) {
      const out222 = arr.copy();
      const results = inferType22(arr.values);
      out222.values = results.values;
      return checkIfInteger22({ type: results.type, values: out222 });
    }
    if (!isArray22(arr)) {
      const out222 = inferType22([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger22(out222);
    }
    assert22(isArray22(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten22(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate22(temp)) {
            return "date";
          }
        }
      } catch (e28) {
      }
      if (!isString22(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues22.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues22.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber22(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray22(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e28) {
        const vDate = new Date(v);
        if (isDate22(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count22(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger22({
      type: primaryType,
      values: vapply22(arr, (v) => cast22(v, primaryType))
    });
  }
  function inverse22(x6) {
    if (isDataFrame22(x6)) {
      const out222 = x6.copy();
      out222.values = inverse22(out222.values);
      return out222;
    }
    assert22(isArray22(x6), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape22(x6);
    assert22(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert22(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert22(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x6;
    } else if (xShape[0] === 1) {
      assert22(x6[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x6[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x6[0][0];
      let b = x6[0][1];
      let c = x6[1][0];
      let d = x6[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det2 = a * d - b * c;
      assert22(det2 !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale22(out222, 1 / det2);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber22(a) || isNumber22(b) ? scale22(a, b) : dot22(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x6.slice(0, divider).map((row) => row.slice(0, divider));
          const B10 = x6.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C5 = x6.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x6.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse22(A);
          const CompInv = inverse22(vadd22(D, times(-1, times(times(C5, AInv), B10))));
          const topLeft = vadd22(AInv, times(times(times(times(AInv, B10), CompInv), C5), AInv));
          const topRight = times(-1, times(times(AInv, B10), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C5), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e28) {
        }
      }
      assert22(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser222 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp22(a, b, f) {
    try {
      if (!isNumber22(a))
        return NaN;
      if (!isNumber22(b))
        return NaN;
      if (!isNumber22(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp22(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e28) {
      return NaN;
    }
  }
  var vlerp22 = vectorize22(lerp22);
  function log22(x6, base) {
    try {
      base = isUndefined22(base) ? Math.E : base;
      if (!isNumber22(x6))
        return NaN;
      if (!isNumber22(base))
        return NaN;
      if (typeof x6 === "bigint" || typeof base === "bigint") {
        const out222 = log22(Number(x6), Number(base));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.log(x6) / Math.log(base);
    } catch (e28) {
      return NaN;
    }
  }
  var vlog22 = vectorize22(log22);
  function mean22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).mean;
  }
  function median22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod22(a, b) {
    try {
      if (!isNumber22(a))
        return NaN;
      if (!isNumber22(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod22(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return a % b;
    } catch (e28) {
      return NaN;
    }
  }
  var vmod22 = vectorize22(mod22);
  function mode22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper322() {
    const u12 = random22();
    const u22 = random22();
    return Math.sqrt(-2 * Math.log(u12)) * Math.cos(2 * Math.PI * u22);
  }
  function normal22(shape222) {
    if (isUndefined22(shape222))
      return helper322();
    return vapply22(ndarray22(shape222), helper322);
  }
  function ones22(shape222) {
    return vapply22(ndarray22(shape222), () => 1);
  }
  function permutationsIterator22(x6, r) {
    function* helper522(x22, r22) {
      r22 = r22 || x22.length;
      if (x22.length === 1) {
        yield [x22];
        return;
      }
      for (const c of combinations22(x22, r22)) {
        if (!c.slice)
          continue;
        const state = zeros22(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return permutationsIterator22(x6.values, r);
    }
    assert22(isArray22(x6), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined22(r)) {
      r = x6.length;
    }
    assert22(isNumber22(r) && vint22(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten22(x6), r);
  }
  function permutations22(x6, r) {
    const out222 = [];
    for (const perm of permutationsIterator22(x6, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print22() {
    Object.keys(arguments).forEach((key) => {
      const x6 = arguments[key];
      if (isArray22(x6)) {
        if (!isJagged22(x6)) {
          const xShape = shape22(x6);
          if (xShape.length === 1) {
            new Series22(x6).print();
          } else if (xShape.length == 2) {
            new DataFrame22(x6).print();
          } else {
            console.log(x6);
          }
        } else {
          console.log(x6);
        }
      } else if (isDataFrame22(x6) || isSeries22(x6)) {
        x6.print();
      } else {
        console.log(x6);
      }
    });
  }
  var helper422 = vectorize22((x6, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x6, a, b, c, d]) {
        if (!isNumber22(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x6 = Number(x6);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x6 - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  });
  function remap22(x6, a, b, c, d) {
    if (isArray22(x6) && isUndefined22(c) && isUndefined22(d)) {
      c = a;
      d = b;
      const results = stats22(x6);
      a = results.min;
      b = results.max;
    }
    return helper422(x6, a, b, c, d);
  }
  function round22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.round(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vround22 = vectorize22(round22);
  function sign22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return BigInt(sign22(Number(x6)));
      if (x6 < 0)
        return -1;
      if (x6 > 0)
        return 1;
      return 0;
    } catch (e28) {
      return NaN;
    }
  }
  var vsign22 = vectorize22(sign22);
  function sin22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.sin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsin22 = vectorize22(sin22);
  function some22(x6, fn2) {
    if (isDataFrame22(x6) || isSeries22(x6)) {
      return some22(x6.values, fn2);
    }
    assert22(isArray22(x6), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert22(isFunction22(fn2), "The second argument passed into the `some` function must be a function!");
    for (const v of x6) {
      if (isArray22(v)) {
        if (some22(v, fn2)) {
          return true;
        }
      } else {
        if (fn2(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev22(x6) {
    return std22(x6);
  }
  function tan22(x6) {
    try {
      if (!isNumber22(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.tan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vtan22 = vectorize22(tan22);
  function timeSync22(fn2, args) {
    assert22(isFunction22(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn2(...args);
    } else {
      fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync22(fn2, args) {
    assert22(isFunction22(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn2(...args);
    } else {
      await fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union22() {
    return set22([...arguments].map((v) => {
      if (isArray22(v))
        return v;
      if (isDataFrame22(v))
        return v.values;
      if (isSeries22(v))
        return v.values;
      return [v];
    }));
  }
  function variance22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip22() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame22(arr) || isSeries22(arr)) {
        arr = arr.values;
      }
      assert22(isArray22(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range22(0, max22(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined22(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out22 = {
    abs: vabs22,
    add: vadd22,
    apply: vapply22,
    arccos: varccos22,
    arcsin: varcsin22,
    arctan: varctan22,
    argmax: argmax22,
    argmin: argmin22,
    assert: assert22,
    cast: cast22,
    ceil: vceil22,
    chop: vchop22,
    clamp: vclamp22,
    combinations: combinations22,
    combinationsIterator: combinationsIterator22,
    copy: copy22,
    correl: correl22,
    cos: vcos22,
    count: count22,
    covariance: covariance22,
    DataFrame: DataFrame22,
    dataTypes: dataTypes22,
    decycle: decycle22,
    diff: diff22,
    distance: distance22,
    divide: divide22,
    dot: dot22,
    dropMissing: dropMissing22,
    dropMissingPairwise: dropMissingPairwise22,
    dropNaN: dropNaN22,
    dropNaNPairwise: dropNaNPairwise22,
    dropUndefined: dropUndefined22,
    every: every22,
    exp: vexp22,
    factorial: vfactorial22,
    find: find22,
    findAll: findAll22,
    flatten: flatten22,
    float: vfloat22,
    floor: vfloor22,
    identity: identity22,
    IndexMatcher: IndexMatcher22,
    indexOf: indexOf22,
    inferType: inferType22,
    int: vint22,
    intersect: intersect22,
    inverse: inverse22,
    isArray: isArray22,
    isBoolean: isBoolean22,
    isBrowser: isBrowser222,
    isDataFrame: isDataFrame22,
    isDate: isDate22,
    isEqual: isEqual22,
    isFunction: isFunction22,
    isJagged: isJagged22,
    isNested: isNested22,
    isNumber: isNumber22,
    isObject: isObject22,
    isSeries: isSeries22,
    isString: isString22,
    isUndefined: isUndefined22,
    lerp: vlerp22,
    log: vlog22,
    MathError: MathError22,
    max: max22,
    mean: mean22,
    median: median22,
    min: min22,
    mod: vmod22,
    mode: mode22,
    multiply: vmultiply22,
    ndarray: ndarray22,
    normal: normal22,
    ones: ones22,
    permutations: permutations22,
    permutationsIterator: permutationsIterator22,
    pow: vpow22,
    print: print22,
    product: product22,
    random: random22,
    range: range22,
    remap: remap22,
    reshape: reshape22,
    reverse: reverse22,
    round: vround22,
    scale: scale22,
    seed: seed22,
    Series: Series22,
    set: set22,
    shape: shape22,
    shuffle: shuffle22,
    sign: vsign22,
    sin: vsin22,
    some: some22,
    sort: sort22,
    sqrt: vsqrt22,
    stats: stats22,
    std: std22,
    stdev: stdev22,
    subtract: subtract22,
    sum: sum22,
    tan: vtan22,
    timeAsync: timeAsync22,
    timeSync: timeSync22,
    time: timeSync22,
    transpose: transpose22,
    union: union22,
    variance: variance22,
    vectorize: vectorize22,
    zeros: zeros22,
    zip: zip22,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out22.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out22).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out22[key]
          });
        } catch (e28) {
          context22[key] = out22[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out22;
  }
  var context = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : void 0;
  function convertObjectToTypedArray(x6) {
    const typedArrayConstructorSymbol = Symbol.for("@TypedArrayConstructor");
    const typedArrayConstructorString = "Symbol(@TypedArrayConstructor)";
    const typedArrayConstructorKey = typedArrayConstructorSymbol in x6 ? typedArrayConstructorSymbol : typedArrayConstructorString in x6 ? typedArrayConstructorString : void 0;
    if (typedArrayConstructorKey) {
      if (!("values" in x6)) {
        throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");
      }
      if (x6[typedArrayConstructorKey] === "ArrayBuffer") {
        return new Uint8Array(x6.values).buffer;
      }
      return new context[x6[typedArrayConstructorKey]](x6.values);
    }
    if (isArray22(x6) && x6.constructor.name === "Array") {
      return x6;
    }
    throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!");
  }
  function convertTypedArrayToObject(x6) {
    if (x6 instanceof ArrayBuffer || x6 instanceof BigInt64Array || x6 instanceof BigUint64Array || x6 instanceof Float32Array || x6 instanceof Float64Array || x6 instanceof Int16Array || x6 instanceof Int32Array || x6 instanceof Int8Array || x6 instanceof Uint16Array || x6 instanceof Uint32Array || x6 instanceof Uint8Array || x6 instanceof Uint8ClampedArray) {
      return {
        [Symbol.for("@TypedArrayConstructor")]: x6.constructor.name,
        values: x6 instanceof ArrayBuffer ? Array.from(new Uint8Array(x6)) : Array.from(x6)
      };
    }
    if (isArray22(x6)) {
      return x6.map((v) => {
        try {
          return convertTypedArrayToObject(v);
        } catch (e28) {
          return v;
        }
      });
    }
    if (typeof x6 === "object" & x6 !== null) {
      if (isDate22(x6)) {
        return new Date(x6.getTime());
      }
      const out222 = {};
      Object.keys(x6).forEach((key) => {
        try {
          out222[key] = convertTypedArrayToObject(x6[key]);
        } catch (e28) {
          out222[key] = x6[key];
        }
      });
      return out222;
    }
    throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.");
  }
  function isANumberString(x6) {
    x6 = x6.trim();
    return !!(x6.match(/^-?\d+(\.\d+)?$/g) || x6.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g) || x6.match(/^-?\.\d+$/g) || x6 === "NaN");
  }
  var punctuation = "!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";
  function replaceAll(text, a, b) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    if (typeof a !== "string") {
      throw new Error("`a` must be a string!");
    }
    if (typeof b !== "string") {
      throw new Error("`b` must be a string!");
    }
    return text.split(a).join(b);
  }
  var doubleSpace = "  ";
  var singleSpace = " ";
  function strip(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    let out222 = "";
    for (let i = 0; i < text.length; i++) {
      const char = text[i].toLowerCase();
      if (punctuation.includes(char)) {
        out222 += singleSpace;
      } else {
        out222 += char;
      }
    }
    while (out222.includes(doubleSpace)) {
      out222 = replaceAll(out222, doubleSpace, singleSpace);
    }
    return out222.trim();
  }
  function indent(text, chars) {
    chars = chars || "";
    return text.split("\n").map((line) => {
      if (line.trim().length > 0) {
        return chars + line;
      } else {
        return line;
      }
    }).join("\n");
  }
  function kebabify(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("-");
  }
  var specials = {
    "@Infinity": Infinity,
    "@NegativeInfinity": -Infinity,
    "@NaN": NaN,
    "@undefined": void 0
  };
  function fixUndefineds(x6) {
    if (typeof x6 === "object") {
      if (x6 === null) {
        return x6;
      }
      if (isArray22(x6)) {
        for (let i = 0; i < x6.length; i++) {
          x6[i] = fixUndefineds(x6[i]);
        }
      } else {
        Object.keys(x6).concat(Object.getOwnPropertySymbols(x6)).forEach((key) => {
          x6[key] = fixUndefineds(x6[key]);
        });
      }
      return x6;
    } else {
      if (typeof x6 === "undefined") {
        return void 0;
      }
      if (x6 === "Symbol(@undefined)") {
        return void 0;
      }
      return x6;
    }
  }
  function parseAsBigInt(x6) {
    if (typeof x6 === "bigint") {
      return x6;
    } else if (typeof x6 === "string") {
      if (x6.match(/^\s*?-?\d+n\s*?$/g)) {
        try {
          return BigInt(x6.split("n")[0]);
        } catch (e28) {
          return NaN;
        }
      } else {
        return NaN;
      }
    } else {
      return NaN;
    }
  }
  function parseAsNumber(x6) {
    if (typeof x6 !== "string") {
      if (typeof x6 === "number") {
        return x6;
      } else {
        return;
      }
    }
    if (isANumberString(x6)) {
      return parseFloat(x6);
    }
  }
  function parseAsString(x6) {
    if (typeof x6 !== "string") {
      return;
    }
    const replacement = "@jrc03c/js-text-tools/newline-replacer";
    x6 = x6.replaceAll("\n", replacement);
    if (x6.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)) {
      let out222 = x6.replace("Symbol(@String):", "");
      if (out222.match(/^".*?"$/g)) {
        try {
          return JSON.parse(out222);
        } catch (e28) {
          out222 = out222.substring(1, out222.length - 1);
        }
      }
      out222 = out222.replaceAll(replacement, "\n");
      return out222;
    }
  }
  function parseAsSymbol(x6) {
    if (typeof x6 !== "string") {
      if (typeof x6 === "symbol") {
        return { out: x6, isASymbol: true };
      } else {
        return;
      }
    }
    if (x6.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)) {
      const xTemp = x6.replace(/^.*?Symbol\(/g, "").replace(/\).*?$/g, "");
      if (xTemp in specials) {
        return { out: specials[xTemp], isASymbol: true };
      }
      return { out: Symbol.for(xTemp), isASymbol: true };
    }
  }
  function parseAsRegex(x6) {
    if (typeof x6 !== "string") {
      if (x6 instanceof RegExp) {
        return x6;
      } else {
        return;
      }
    }
    const xTrimmed = x6.trim();
    if (xTrimmed.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g)) {
      try {
        const pattern = xTrimmed.replace(/^\//g, "").replace(/\/(d|g|i|m|s|u|v|y)*?$/g, "");
        const flags = xTrimmed.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);
        return new RegExp(pattern, flags);
      } catch (e28) {
      }
    }
  }
  function parseWithJSONParse(x6) {
    if (typeof x6 !== "string") {
      if (typeof x6 === "object") {
        return x6;
      } else {
        return "Symbol(@undefined)";
      }
    }
    try {
      let out222 = JSON.parse(x6, (key, value) => {
        try {
          const out32 = parse(value);
          return typeof out32 === "undefined" ? "Symbol(@undefined)" : out32;
        } catch (e28) {
          return typeof value === "undefined" ? "Symbol(@undefined)" : value;
        }
      });
      if (isArray22(out222)) {
        out222 = fixUndefineds(out222);
      }
      return out222;
    } catch (e28) {
      return x6;
    }
  }
  function parseAsDate(x6) {
    if (typeof x6 !== "string") {
      if (x6 instanceof Date && x6.toString() !== "Invalid Date") {
        return x6;
      } else {
        return;
      }
    }
    try {
      const d = new Date(Date.parse(x6));
      if (d.toString() !== "Invalid Date") {
        return d;
      }
    } catch (e28) {
    }
  }
  function parseObjectKeysAndValues(x6) {
    if (typeof x6 === "object") {
      if (x6 !== null) {
        return fixUndefineds(x6);
      }
      return;
    }
    Object.keys(x6).concat(Object.getOwnPropertySymbols(x6)).forEach((key) => {
      try {
        let origKey = key;
        try {
          key = parse(key);
        } catch (e28) {
        }
        x6[key] = parse(x6[origKey]);
        if (key !== origKey) {
          delete x6[origKey];
        }
      } catch (e28) {
      }
    });
    return fixUndefineds(x6);
  }
  function parse(x6) {
    function helper522(x22) {
      if (typeof x22 === "string") {
        let out222 = parseAsString(x22);
        if (typeof out222 === "string") {
          return out222;
        }
        const results = parseAsSymbol(x22);
        out222 = results ? results.out : void 0;
        if (results && results.isASymbol) {
          return out222;
        }
        out222 = parseAsRegex(x22);
        if (out222 instanceof RegExp) {
          return out222;
        }
        out222 = parseAsBigInt(x22);
        if (typeof out222 === "bigint") {
          return out222;
        }
        out222 = parseAsNumber(x22);
        if (typeof out222 === "number") {
          return out222;
        }
        out222 = parseAsDate(x22);
        if (out222 instanceof Date) {
          return out222;
        }
        out222 = parseWithJSONParse(x22);
        if (typeof out222 !== "undefined") {
          if (out222 === "Symbol(@undefined)") {
            return void 0;
          } else {
            return out222;
          }
        }
        return x22;
      }
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        let out222;
        try {
          out222 = convertObjectToTypedArray(x22);
          if (isArray22(out222))
            return out222;
        } catch (e28) {
        }
        out222 = parseObjectKeysAndValues(x22);
        if (out222) {
          try {
            return convertObjectToTypedArray(out222);
          } catch (e28) {
            return out222;
          }
        }
        return x22;
      }
      return x22;
    }
    return helper522(x6);
  }
  function pascalify(text) {
    const out222 = camelify22(text);
    return out222[0].toUpperCase() + out222.slice(1);
  }
  function snakeify(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("_");
  }
  function prefix(s222, n) {
    if (!s222 || n <= 0)
      return "";
    return range22(0, n).map(() => s222).join("");
  }
  function stringify(x6, indent22) {
    assert22(isString22(indent22) || isUndefined22(indent22), "The second parameter to the `stringify` function must be undefined or a string!");
    const newline = indent22 ? "\n" : "";
    function helper522(x22, indent3, depth) {
      depth = depth || 0;
      if (typeof x22 === "bigint") {
        return JSON.stringify(x22.toString() + "n");
      }
      if (typeof x22 === "number") {
        if (x22 === Infinity) {
          return '"Symbol(@Infinity)"';
        }
        if (x22 === -Infinity) {
          return '"Symbol(@NegativeInfinity)"';
        }
        if (isNaN(x22)) {
          return '"Symbol(@NaN)"';
        }
        return x22.toString();
      }
      if (typeof x22 === "string") {
        return JSON.stringify("Symbol(@String):" + x22);
      }
      if (typeof x22 === "boolean") {
        return x22.toString();
      }
      if (typeof x22 === "undefined") {
        return '"Symbol(@undefined)"';
      }
      if (typeof x22 === "symbol") {
        return JSON.stringify(x22.toString());
      }
      if (typeof x22 === "function") {
        return JSON.stringify(x22.toString());
      }
      if (x22 instanceof RegExp) {
        return x22.toString();
      }
      if (typeof x22 === "object") {
        if (x22 === null) {
          return "null";
        }
        if (isDate22(x22)) {
          return JSON.stringify(x22.toJSON());
        }
        if (isArray22(x22)) {
          if (x22.length === 0) {
            return prefix(indent3, depth - 1) + "[]";
          }
          if (!(x22 instanceof Array)) {
            return helper522(convertTypedArrayToObject(x22), null, indent3);
          }
          return prefix(indent3, depth - 1) + "[" + newline + x22.map((v) => {
            let child = (() => {
              try {
                return helper522(convertTypedArrayToObject(v), indent3, depth + 1);
              } catch (e28) {
                return helper522(v, indent3, depth + 1);
              }
            })();
            if (isString22(child))
              child = child.trim();
            return prefix(indent3, depth + 1) + child;
          }).join("," + newline) + newline + prefix(indent3, depth) + "]";
        }
        if (Object.keys(x22).length + Object.getOwnPropertySymbols(x22).length === 0) {
          return prefix(indent3, depth - 1) + "{}";
        }
        return prefix(indent3, depth - 1) + "{" + newline + Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).map((key) => {
          let child = (() => {
            try {
              return helper522(convertTypedArrayToObject(x22[key]), indent3, depth + 1);
            } catch (e28) {
              return helper522(x22[key], indent3, depth + 1);
            }
          })();
          if (isString22(child))
            child = child.trim();
          const stringifiedKey = typeof key === "symbol" ? helper522(key) : JSON.stringify(key);
          return prefix(indent3, depth + 1) + stringifiedKey + ":" + (indent3 ? " " : "") + child;
        }).join("," + newline) + newline + prefix(indent3, depth) + "}";
      }
      return "undefined";
    }
    return helper522(decycle22(x6), indent22);
  }
  function unindent(text) {
    const lines = text.split("\n");
    const indentations = lines.filter((line) => line.trim().length > 0).map((line) => line.split("").findIndex((char) => !char.match(/\s/g)));
    const minIndentation = Math.min(...indentations);
    return lines.map((line) => line.substring(minIndentation)).join("\n");
  }
  function wrap(raw, maxLineLength) {
    if (typeof raw !== "string") {
      throw new Error("The first argument to the `wrap` function must be a string!");
    }
    if (typeof maxLineLength === "undefined" || maxLineLength === null) {
      if (typeof process !== "undefined" && typeof process.stdout !== "undefined" && typeof process.stdout.columns === "number") {
        maxLineLength = process.stdout.columns > 80 ? 80 : process.stdout.columns;
      } else {
        maxLineLength = 80;
      }
    }
    if (isNaN(maxLineLength) || typeof maxLineLength !== "number") {
      throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");
    }
    const out222 = [];
    raw.split("\n").forEach((line) => {
      if (line.trim().length === 0) {
        return out222.push("");
      }
      const indentation = line.split(/[^\s]/g)[0];
      const words = line.replace(indentation, "").split(" ");
      let temp = indentation;
      words.forEach((word) => {
        const newLine = temp + (temp.trim().length > 0 ? " " : "") + word;
        if (newLine.length > maxLineLength) {
          out222.push(temp);
          temp = indentation + word;
        } else {
          temp = newLine;
        }
      });
      if (temp.length > 0) {
        out222.push(temp);
      }
    });
    return out222.join("\n");
  }
  if (typeof window !== "undefined") {
    window.JSTextTools = {
      camelify: camelify22,
      convertObjectToTypedArray,
      convertTypedArrayToObject,
      indent,
      isANumberString,
      kebabify,
      parse,
      pascalify,
      punctuation,
      replaceAll,
      snakeify,
      stringify,
      strip,
      unindent,
      wrap
    };
  }
  Array.prototype.remove = function(x6) {
    let index = this.indexOf(x6);
    while (index > -1) {
      this.splice(index, 1);
      index = this.indexOf(x6);
    }
    return this;
  };
  var alive = {};
  var SubscriptionService = class {
    context = void 0;
    rejects = [];
    resolves = [];
    unsubs = [];
    constructor() {
      this.context = globalThis;
      const id2 = makeKey42(8);
      Object.defineProperty(this, "id", {
        configurable: false,
        enumerable: true,
        get: () => id2,
        set() {
          throw new Error(
            `The \`id\` property of this SubscriptionService instance is read-only!`
          );
        }
      });
      alive[this.id] = true;
    }
    get hasBeenDestroyed() {
      return !alive[this.id];
    }
    set hasBeenDestroyed(value) {
      throw new Error(
        `The \`hasBeenDestroyed\` property of this SubscriptionService instance is read-only! To destroy this SubscriptionService instance, invoke its \`destroy\` method.`
      );
    }
    destroy(error32) {
      if (this.hasBeenDestroyed) {
        throw new Error(
          `This SubscriptionService instance has already been destroyed!`
        );
      }
      delete alive[this.id];
      this.unsubs.forEach((unsub) => unsub());
      if (error32) {
        this.rejects.forEach((reject) => reject(error32));
      } else {
        this.resolves.forEach((resolve) => resolve());
      }
      delete this.context;
      delete this.rejects;
      delete this.resolves;
      delete this.unsubs;
    }
    emit(signal, payload) {
      if (this.hasBeenDestroyed) {
        throw new Error(
          `This SubscriptionService instance has already been destroyed!`
        );
      }
      return new Promise((resolve, reject) => {
        try {
          const cbid = makeKey42(8);
          const callback = (event) => {
            if (event.data.signal === cbid) {
              this.context.removeEventListener("message", callback);
              this.resolves.remove(resolve);
              this.rejects.remove(reject);
              let out32 = event.data.payload;
              try {
                out32 = parse(out32);
              } catch (e28) {
              }
              return resolve(out32);
            }
          };
          this.context.addEventListener("message", callback);
          this.resolves.push(resolve);
          this.rejects.push(reject);
          try {
            payload = stringify(payload);
          } catch (e28) {
          }
          this.context.postMessage({
            cbid,
            signal,
            payload
          });
        } catch (e28) {
          this.resolves.remove(resolve);
          this.rejects.remove(reject);
          return reject(e28);
        }
      });
    }
    on(signal, callback) {
      if (this.hasBeenDestroyed) {
        throw new Error(
          `This SubscriptionService instance has already been destroyed!`
        );
      }
      const inner = (event) => {
        if (event.data.signal === signal) {
          const cbid = event.data.cbid;
          let payload = event.data.payload;
          try {
            payload = parse(payload);
          } catch (e28) {
          }
          const request = { data: payload };
          const response = {
            send: (result) => {
              try {
                result = stringify(result);
              } catch (e28) {
              }
              if (!this.hasBeenDestroyed) {
                this.context.postMessage({
                  signal: cbid,
                  payload: result
                });
              }
            }
          };
          callback(request, response);
        }
      };
      const unsub = () => {
        this.context.removeEventListener("message", inner);
        this.unsubs.remove(unsub);
      };
      this.unsubs.push(unsub);
      this.context.addEventListener("message", inner);
      return unsub;
    }
  };
  var Drone = class extends SubscriptionService {
    constructor(path) {
      super();
      if (typeof window === "undefined") {
        if (typeof path !== "undefined") {
          throw new Error(
            "You must not pass a `path` to a `Drone` created in a web worker context! (Passing a `path` only makes sense when creating a `Drone` in a window context.)"
          );
        }
      } else if (typeof path === "undefined") {
        throw new Error("You must pass a `path` into the `Drone` constructor!");
      }
      if (path) {
        this.context = new Worker(path);
      }
    }
    get isDead() {
      return this.hasBeenDestroyed;
    }
    set isDead(value) {
      throw new Error(
        `The \`isDead\` property of this Drone instance is read-only! To destroy this Drone instance, invoke its \`destroy\` method.`
      );
    }
    propose(signal, payload) {
      return this.emit(signal, payload);
    }
    destroy() {
      if (this.context instanceof Worker) {
        this.context.terminate();
      }
      return super.destroy();
    }
  };
  var Queen = class extends SubscriptionService {
    hive = [];
    constructor(path, n) {
      super();
      if (path) {
        n = n || 1;
        this.addDrones(path, n);
      }
    }
    get isDead() {
      return this.hasBeenDestroyed;
    }
    set isDead(value) {
      throw new Error(
        `The \`isDead\` property of this Queen instance is read-only! To destroy this Queen instance, invoke her \`destroy\` method.`
      );
    }
    addDrone(path) {
      if (this.isDead) {
        throw new Error("The queen is dead!");
      }
      const drone2 = new Drone(path);
      this.hive.push(drone2);
      return drone2;
    }
    addDrones(path, n) {
      const out32 = [];
      for (let i = 0; i < n; i++) {
        out32.push(this.addDrone(path));
      }
      return out32;
    }
    removeDrone(drone2) {
      if (this.isDead) {
        throw new Error("The queen is dead!");
      }
      drone2.destroy();
      this.hive.remove(drone2);
      return this;
    }
    removeDrones(drones) {
      drones.forEach((drone2) => this.removeDrone(drone2));
      return this;
    }
    on(signal, callback, specificDrones) {
      if (typeof specificDrones !== "undefined" && specificDrones instanceof Drone) {
        specificDrones = [specificDrones];
      }
      const unsubs = (specificDrones || this.hive).map((drone2) => {
        return drone2.on(signal, callback);
      });
      const unsub = () => unsubs.forEach((unsub2) => unsub2());
      this.unsubs.push(unsub);
      return unsub;
    }
    emit(signal, payload, specificDrones) {
      if (this.isDead) {
        throw new Error("The queen is dead!");
      }
      if (typeof specificDrones !== "undefined" && specificDrones instanceof Drone) {
        specificDrones = [specificDrones];
      }
      const drones = specificDrones || this.hive;
      if (drones.length === 0) {
        throw new Error(
          `The queen issued a "${signal}" command, but there are no drones in the hive!`
        );
      }
      return new Promise((resolve, reject) => {
        try {
          const results = new Array(drones.length);
          const promises = drones.map((drone2, i) => {
            return new Promise((resolve2, reject2) => {
              try {
                this.resolves.push(resolve2);
                this.rejects.push(reject2);
                drone2.emit(signal, payload).then((result) => {
                  if (!this.hasBeenDestroyed) {
                    this.resolves.remove(resolve2);
                    this.rejects.remove(reject2);
                    results[i] = result;
                    resolve2();
                  }
                });
              } catch (e28) {
                this.resolves.remove(resolve2);
                this.rejects.remove(reject2);
                return reject2(e28);
              }
            });
          });
          this.resolves.push(resolve);
          this.rejects.push(reject);
          Promise.all(promises).then(() => {
            if (!this.hasBeenDestroyed) {
              this.resolves.remove(resolve);
              this.rejects.remove(reject);
              if (results.length === 1) {
                return resolve(results[0]);
              } else {
                return resolve(results);
              }
            }
          });
        } catch (e28) {
          this.resolves.remove(resolve);
          this.rejects.remove(reject);
          return reject(e28);
        }
      });
    }
    command() {
      return this.emit(...arguments);
    }
    destroy(error32) {
      if (this.isDead) {
        throw new Error("The queen is dead!");
      }
      const out32 = super.destroy(error32);
      this.hive.forEach((drone2) => {
        drone2.destroy(error32);
      });
      delete this.hive;
      return out32;
    }
  };
  var Bee = { Drone, Queen };
  if (typeof globalThis !== "undefined") {
    globalThis.Bee = Bee;
  }
  if (typeof window !== "undefined") {
    window.Bee = Bee;
  }

  // dist/tf-k-means.import.min.mjs
  var kB = Object.create;
  var hv = Object.defineProperty;
  var EB = Object.getOwnPropertyDescriptor;
  var AB = Object.getOwnPropertyNames;
  var DB = Object.getPrototypeOf;
  var $B = Object.prototype.hasOwnProperty;
  var Hn = (e28, t) => () => (t || e28((t = { exports: {} }).exports, t), t.exports);
  var lo = (e28, t) => {
    for (var r in t) hv(e28, r, { get: t[r], enumerable: true });
  };
  var FB = (e28, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function") for (let o of AB(t)) !$B.call(e28, o) && o !== r && hv(e28, o, { get: () => t[o], enumerable: !(n = EB(t, o)) || n.enumerable });
    return e28;
  };
  var ff = (e28, t, r) => (r = e28 != null ? kB(DB(e28)) : {}, FB(t || !e28 || !e28.__esModule ? hv(r, "default", { value: e28, enumerable: true }) : r, e28));
  var wT = Hn((ist, bT) => {
    bT.exports = We;
    var mo = null;
    try {
      mo = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    function We(e28, t, r) {
      this.low = e28 | 0, this.high = t | 0, this.unsigned = !!r;
    }
    We.prototype.__isLong__;
    Object.defineProperty(We.prototype, "__isLong__", { value: true });
    function Fn(e28) {
      return (e28 && e28.__isLong__) === true;
    }
    We.isLong = Fn;
    var cT = {}, pT = {};
    function dl(e28, t) {
      var r, n, o;
      return t ? (e28 >>>= 0, (o = 0 <= e28 && e28 < 256) && (n = pT[e28], n) ? n : (r = Ue(e28, (e28 | 0) < 0 ? -1 : 0, true), o && (pT[e28] = r), r)) : (e28 |= 0, (o = -128 <= e28 && e28 < 128) && (n = cT[e28], n) ? n : (r = Ue(e28, e28 < 0 ? -1 : 0, false), o && (cT[e28] = r), r));
    }
    We.fromInt = dl;
    function fo(e28, t) {
      if (isNaN(e28)) return t ? hl : ho;
      if (t) {
        if (e28 < 0) return hl;
        if (e28 >= dT) return xT;
      } else {
        if (e28 <= -fT) return $n;
        if (e28 + 1 >= fT) return yT;
      }
      return e28 < 0 ? fo(-e28, t).neg() : Ue(e28 % gp | 0, e28 / gp | 0, t);
    }
    We.fromNumber = fo;
    function Ue(e28, t, r) {
      return new We(e28, t, r);
    }
    We.fromBits = Ue;
    var _y = Math.pow;
    function Uv(e28, t, r) {
      if (e28.length === 0) throw Error("empty string");
      if (e28 === "NaN" || e28 === "Infinity" || e28 === "+Infinity" || e28 === "-Infinity") return ho;
      if (typeof t == "number" ? (r = t, t = false) : t = !!t, r = r || 10, r < 2 || 36 < r) throw RangeError("radix");
      var n;
      if ((n = e28.indexOf("-")) > 0) throw Error("interior hyphen");
      if (n === 0) return Uv(e28.substring(1), t, r).neg();
      for (var o = fo(_y(r, 8)), s10 = ho, i = 0; i < e28.length; i += 8) {
        var a = Math.min(8, e28.length - i), u = parseInt(e28.substring(i, i + a), r);
        if (a < 8) {
          var l = fo(_y(r, a));
          s10 = s10.mul(l).add(fo(u));
        } else s10 = s10.mul(o), s10 = s10.add(fo(u));
      }
      return s10.unsigned = t, s10;
    }
    We.fromString = Uv;
    function zo(e28, t) {
      return typeof e28 == "number" ? fo(e28, t) : typeof e28 == "string" ? Uv(e28, t) : Ue(e28.low, e28.high, typeof t == "boolean" ? t : e28.unsigned);
    }
    We.fromValue = zo;
    var mT = 65536, QG = 1 << 24, gp = mT * mT, dT = gp * gp, fT = dT / 2, hT = dl(QG), ho = dl(0);
    We.ZERO = ho;
    var hl = dl(0, true);
    We.UZERO = hl;
    var dp = dl(1);
    We.ONE = dp;
    var gT = dl(1, true);
    We.UONE = gT;
    var Wv = dl(-1);
    We.NEG_ONE = Wv;
    var yT = Ue(-1, 2147483647, false);
    We.MAX_VALUE = yT;
    var xT = Ue(-1, -1, true);
    We.MAX_UNSIGNED_VALUE = xT;
    var $n = Ue(0, -2147483648, false);
    We.MIN_VALUE = $n;
    var yt = We.prototype;
    yt.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    yt.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * gp + (this.low >>> 0) : this.high * gp + (this.low >>> 0);
    };
    yt.toString = function(t) {
      if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) if (this.eq($n)) {
        var r = fo(t), n = this.div(r), o = n.mul(r).sub(this);
        return n.toString(t) + o.toInt().toString(t);
      } else return "-" + this.neg().toString(t);
      for (var s10 = fo(_y(t, 6), this.unsigned), i = this, a = ""; ; ) {
        var u = i.div(s10), l = i.sub(u.mul(s10)).toInt() >>> 0, c = l.toString(t);
        if (i = u, i.isZero()) return c + a;
        for (; c.length < 6; ) c = "0" + c;
        a = "" + c + a;
      }
    };
    yt.getHighBits = function() {
      return this.high;
    };
    yt.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    };
    yt.getLowBits = function() {
      return this.low;
    };
    yt.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    };
    yt.getNumBitsAbs = function() {
      if (this.isNegative()) return this.eq($n) ? 64 : this.neg().getNumBitsAbs();
      for (var t = this.high != 0 ? this.high : this.low, r = 31; r > 0 && !(t & 1 << r); r--) ;
      return this.high != 0 ? r + 33 : r + 1;
    };
    yt.isZero = function() {
      return this.high === 0 && this.low === 0;
    };
    yt.eqz = yt.isZero;
    yt.isNegative = function() {
      return !this.unsigned && this.high < 0;
    };
    yt.isPositive = function() {
      return this.unsigned || this.high >= 0;
    };
    yt.isOdd = function() {
      return (this.low & 1) === 1;
    };
    yt.isEven = function() {
      return (this.low & 1) === 0;
    };
    yt.equals = function(t) {
      return Fn(t) || (t = zo(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? false : this.high === t.high && this.low === t.low;
    };
    yt.eq = yt.equals;
    yt.notEquals = function(t) {
      return !this.eq(t);
    };
    yt.neq = yt.notEquals;
    yt.ne = yt.notEquals;
    yt.lessThan = function(t) {
      return this.comp(t) < 0;
    };
    yt.lt = yt.lessThan;
    yt.lessThanOrEqual = function(t) {
      return this.comp(t) <= 0;
    };
    yt.lte = yt.lessThanOrEqual;
    yt.le = yt.lessThanOrEqual;
    yt.greaterThan = function(t) {
      return this.comp(t) > 0;
    };
    yt.gt = yt.greaterThan;
    yt.greaterThanOrEqual = function(t) {
      return this.comp(t) >= 0;
    };
    yt.gte = yt.greaterThanOrEqual;
    yt.ge = yt.greaterThanOrEqual;
    yt.compare = function(t) {
      if (Fn(t) || (t = zo(t)), this.eq(t)) return 0;
      var r = this.isNegative(), n = t.isNegative();
      return r && !n ? -1 : !r && n ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;
    };
    yt.comp = yt.compare;
    yt.negate = function() {
      return !this.unsigned && this.eq($n) ? $n : this.not().add(dp);
    };
    yt.neg = yt.negate;
    yt.add = function(t) {
      Fn(t) || (t = zo(t));
      var r = this.high >>> 16, n = this.high & 65535, o = this.low >>> 16, s10 = this.low & 65535, i = t.high >>> 16, a = t.high & 65535, u = t.low >>> 16, l = t.low & 65535, c = 0, p = 0, m = 0, f = 0;
      return f += s10 + l, m += f >>> 16, f &= 65535, m += o + u, p += m >>> 16, m &= 65535, p += n + a, c += p >>> 16, p &= 65535, c += r + i, c &= 65535, Ue(m << 16 | f, c << 16 | p, this.unsigned);
    };
    yt.subtract = function(t) {
      return Fn(t) || (t = zo(t)), this.add(t.neg());
    };
    yt.sub = yt.subtract;
    yt.multiply = function(t) {
      if (this.isZero()) return ho;
      if (Fn(t) || (t = zo(t)), mo) {
        var r = mo.mul(this.low, this.high, t.low, t.high);
        return Ue(r, mo.get_high(), this.unsigned);
      }
      if (t.isZero()) return ho;
      if (this.eq($n)) return t.isOdd() ? $n : ho;
      if (t.eq($n)) return this.isOdd() ? $n : ho;
      if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();
      if (t.isNegative()) return this.mul(t.neg()).neg();
      if (this.lt(hT) && t.lt(hT)) return fo(this.toNumber() * t.toNumber(), this.unsigned);
      var n = this.high >>> 16, o = this.high & 65535, s10 = this.low >>> 16, i = this.low & 65535, a = t.high >>> 16, u = t.high & 65535, l = t.low >>> 16, c = t.low & 65535, p = 0, m = 0, f = 0, h = 0;
      return h += i * c, f += h >>> 16, h &= 65535, f += s10 * c, m += f >>> 16, f &= 65535, f += i * l, m += f >>> 16, f &= 65535, m += o * c, p += m >>> 16, m &= 65535, m += s10 * l, p += m >>> 16, m &= 65535, m += i * u, p += m >>> 16, m &= 65535, p += n * c + o * l + s10 * u + i * a, p &= 65535, Ue(f << 16 | h, p << 16 | m, this.unsigned);
    };
    yt.mul = yt.multiply;
    yt.divide = function(t) {
      if (Fn(t) || (t = zo(t)), t.isZero()) throw Error("division by zero");
      if (mo) {
        if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1) return this;
        var r = (this.unsigned ? mo.div_u : mo.div_s)(this.low, this.high, t.low, t.high);
        return Ue(r, mo.get_high(), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? hl : ho;
      var n, o, s10;
      if (this.unsigned) {
        if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return hl;
        if (t.gt(this.shru(1))) return gT;
        s10 = hl;
      } else {
        if (this.eq($n)) {
          if (t.eq(dp) || t.eq(Wv)) return $n;
          if (t.eq($n)) return dp;
          var i = this.shr(1);
          return n = i.div(t).shl(1), n.eq(ho) ? t.isNegative() ? dp : Wv : (o = this.sub(t.mul(n)), s10 = n.add(o.div(t)), s10);
        } else if (t.eq($n)) return this.unsigned ? hl : ho;
        if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();
        if (t.isNegative()) return this.div(t.neg()).neg();
        s10 = ho;
      }
      for (o = this; o.gte(t); ) {
        n = Math.max(1, Math.floor(o.toNumber() / t.toNumber()));
        for (var a = Math.ceil(Math.log(n) / Math.LN2), u = a <= 48 ? 1 : _y(2, a - 48), l = fo(n), c = l.mul(t); c.isNegative() || c.gt(o); ) n -= u, l = fo(n, this.unsigned), c = l.mul(t);
        l.isZero() && (l = dp), s10 = s10.add(l), o = o.sub(c);
      }
      return s10;
    };
    yt.div = yt.divide;
    yt.modulo = function(t) {
      if (Fn(t) || (t = zo(t)), mo) {
        var r = (this.unsigned ? mo.rem_u : mo.rem_s)(this.low, this.high, t.low, t.high);
        return Ue(r, mo.get_high(), this.unsigned);
      }
      return this.sub(this.div(t).mul(t));
    };
    yt.mod = yt.modulo;
    yt.rem = yt.modulo;
    yt.not = function() {
      return Ue(~this.low, ~this.high, this.unsigned);
    };
    yt.and = function(t) {
      return Fn(t) || (t = zo(t)), Ue(this.low & t.low, this.high & t.high, this.unsigned);
    };
    yt.or = function(t) {
      return Fn(t) || (t = zo(t)), Ue(this.low | t.low, this.high | t.high, this.unsigned);
    };
    yt.xor = function(t) {
      return Fn(t) || (t = zo(t)), Ue(this.low ^ t.low, this.high ^ t.high, this.unsigned);
    };
    yt.shiftLeft = function(t) {
      return Fn(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? Ue(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : Ue(0, this.low << t - 32, this.unsigned);
    };
    yt.shl = yt.shiftLeft;
    yt.shiftRight = function(t) {
      return Fn(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? Ue(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : Ue(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    yt.shr = yt.shiftRight;
    yt.shiftRightUnsigned = function(t) {
      if (Fn(t) && (t = t.toInt()), t &= 63, t === 0) return this;
      var r = this.high;
      if (t < 32) {
        var n = this.low;
        return Ue(n >>> t | r << 32 - t, r >>> t, this.unsigned);
      } else return t === 32 ? Ue(r, 0, this.unsigned) : Ue(r >>> t - 32, 0, this.unsigned);
    };
    yt.shru = yt.shiftRightUnsigned;
    yt.shr_u = yt.shiftRightUnsigned;
    yt.toSigned = function() {
      return this.unsigned ? Ue(this.low, this.high, false) : this;
    };
    yt.toUnsigned = function() {
      return this.unsigned ? this : Ue(this.low, this.high, true);
    };
    yt.toBytes = function(t) {
      return t ? this.toBytesLE() : this.toBytesBE();
    };
    yt.toBytesLE = function() {
      var t = this.high, r = this.low;
      return [r & 255, r >>> 8 & 255, r >>> 16 & 255, r >>> 24, t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24];
    };
    yt.toBytesBE = function() {
      var t = this.high, r = this.low;
      return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255, r >>> 24, r >>> 16 & 255, r >>> 8 & 255, r & 255];
    };
    We.fromBytes = function(t, r, n) {
      return n ? We.fromBytesLE(t, r) : We.fromBytesBE(t, r);
    };
    We.fromBytesLE = function(t, r) {
      return new We(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, r);
    };
    We.fromBytesBE = function(t, r) {
      return new We(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], r);
    };
  });
  var ok = Hn(() => {
  });
  var sk = Hn(() => {
  });
  var Ek = Hn((kk, jN) => {
    (function(e28, t, r) {
      function n(a) {
        var u = this, l = i();
        u.next = function() {
          var c = 2091639 * u.s0 + u.c * 23283064365386963e-26;
          return u.s0 = u.s1, u.s1 = u.s2, u.s2 = c - (u.c = c | 0);
        }, u.c = 1, u.s0 = l(" "), u.s1 = l(" "), u.s2 = l(" "), u.s0 -= l(a), u.s0 < 0 && (u.s0 += 1), u.s1 -= l(a), u.s1 < 0 && (u.s1 += 1), u.s2 -= l(a), u.s2 < 0 && (u.s2 += 1), l = null;
      }
      function o(a, u) {
        return u.c = a.c, u.s0 = a.s0, u.s1 = a.s1, u.s2 = a.s2, u;
      }
      function s10(a, u) {
        var l = new n(a), c = u && u.state, p = l.next;
        return p.int32 = function() {
          return l.next() * 4294967296 | 0;
        }, p.double = function() {
          return p() + (p() * 2097152 | 0) * 11102230246251565e-32;
        }, p.quick = p, c && (typeof c == "object" && o(c, l), p.state = function() {
          return o(l, {});
        }), p;
      }
      function i() {
        var a = 4022871197, u = function(l) {
          l = String(l);
          for (var c = 0; c < l.length; c++) {
            a += l.charCodeAt(c);
            var p = 0.02519603282416938 * a;
            a = p >>> 0, p -= a, p *= a, a = p >>> 0, p -= a, a += p * 4294967296;
          }
          return (a >>> 0) * 23283064365386963e-26;
        };
        return u;
      }
      t && t.exports ? t.exports = s10 : r && r.amd ? r(function() {
        return s10;
      }) : this.alea = s10;
    })(kk, typeof jN == "object" && jN, typeof define == "function" && define);
  });
  var Dk = Hn((Ak, HN) => {
    (function(e28, t, r) {
      function n(i) {
        var a = this, u = "";
        a.x = 0, a.y = 0, a.z = 0, a.w = 0, a.next = function() {
          var c = a.x ^ a.x << 11;
          return a.x = a.y, a.y = a.z, a.z = a.w, a.w ^= a.w >>> 19 ^ c ^ c >>> 8;
        }, i === (i | 0) ? a.x = i : u += i;
        for (var l = 0; l < u.length + 64; l++) a.x ^= u.charCodeAt(l) | 0, a.next();
      }
      function o(i, a) {
        return a.x = i.x, a.y = i.y, a.z = i.z, a.w = i.w, a;
      }
      function s10(i, a) {
        var u = new n(i), l = a && a.state, c = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var p = u.next() >>> 11, m = (u.next() >>> 0) / 4294967296, f = (p + m) / (1 << 21);
          while (f === 0);
          return f;
        }, c.int32 = u.next, c.quick = c, l && (typeof l == "object" && o(l, u), c.state = function() {
          return o(u, {});
        }), c;
      }
      t && t.exports ? t.exports = s10 : r && r.amd ? r(function() {
        return s10;
      }) : this.xor128 = s10;
    })(Ak, typeof HN == "object" && HN, typeof define == "function" && define);
  });
  var Fk = Hn(($k, KN) => {
    (function(e28, t, r) {
      function n(i) {
        var a = this, u = "";
        a.next = function() {
          var c = a.x ^ a.x >>> 2;
          return a.x = a.y, a.y = a.z, a.z = a.w, a.w = a.v, (a.d = a.d + 362437 | 0) + (a.v = a.v ^ a.v << 4 ^ (c ^ c << 1)) | 0;
        }, a.x = 0, a.y = 0, a.z = 0, a.w = 0, a.v = 0, i === (i | 0) ? a.x = i : u += i;
        for (var l = 0; l < u.length + 64; l++) a.x ^= u.charCodeAt(l) | 0, l == u.length && (a.d = a.x << 10 ^ a.x >>> 4), a.next();
      }
      function o(i, a) {
        return a.x = i.x, a.y = i.y, a.z = i.z, a.w = i.w, a.v = i.v, a.d = i.d, a;
      }
      function s10(i, a) {
        var u = new n(i), l = a && a.state, c = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var p = u.next() >>> 11, m = (u.next() >>> 0) / 4294967296, f = (p + m) / (1 << 21);
          while (f === 0);
          return f;
        }, c.int32 = u.next, c.quick = c, l && (typeof l == "object" && o(l, u), c.state = function() {
          return o(u, {});
        }), c;
      }
      t && t.exports ? t.exports = s10 : r && r.amd ? r(function() {
        return s10;
      }) : this.xorwow = s10;
    })($k, typeof KN == "object" && KN, typeof define == "function" && define);
  });
  var Ok = Hn((_k, qN) => {
    (function(e28, t, r) {
      function n(i) {
        var a = this;
        a.next = function() {
          var l = a.x, c = a.i, p, m, f;
          return p = l[c], p ^= p >>> 7, m = p ^ p << 24, p = l[c + 1 & 7], m ^= p ^ p >>> 10, p = l[c + 3 & 7], m ^= p ^ p >>> 3, p = l[c + 4 & 7], m ^= p ^ p << 7, p = l[c + 7 & 7], p = p ^ p << 13, m ^= p ^ p << 9, l[c] = m, a.i = c + 1 & 7, m;
        };
        function u(l, c) {
          var p, m, f = [];
          if (c === (c | 0)) m = f[0] = c;
          else for (c = "" + c, p = 0; p < c.length; ++p) f[p & 7] = f[p & 7] << 15 ^ c.charCodeAt(p) + f[p + 1 & 7] << 13;
          for (; f.length < 8; ) f.push(0);
          for (p = 0; p < 8 && f[p] === 0; ++p) ;
          for (p == 8 ? m = f[7] = -1 : m = f[p], l.x = f, l.i = 0, p = 256; p > 0; --p) l.next();
        }
        u(a, i);
      }
      function o(i, a) {
        return a.x = i.x.slice(), a.i = i.i, a;
      }
      function s10(i, a) {
        i == null && (i = +/* @__PURE__ */ new Date());
        var u = new n(i), l = a && a.state, c = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var p = u.next() >>> 11, m = (u.next() >>> 0) / 4294967296, f = (p + m) / (1 << 21);
          while (f === 0);
          return f;
        }, c.int32 = u.next, c.quick = c, l && (l.x && o(l, u), c.state = function() {
          return o(u, {});
        }), c;
      }
      t && t.exports ? t.exports = s10 : r && r.amd ? r(function() {
        return s10;
      }) : this.xorshift7 = s10;
    })(_k, typeof qN == "object" && qN, typeof define == "function" && define);
  });
  var Pk = Hn((Rk, XN) => {
    (function(e28, t, r) {
      function n(i) {
        var a = this;
        a.next = function() {
          var l = a.w, c = a.X, p = a.i, m, f;
          return a.w = l = l + 1640531527 | 0, f = c[p + 34 & 127], m = c[p = p + 1 & 127], f ^= f << 13, m ^= m << 17, f ^= f >>> 15, m ^= m >>> 12, f = c[p] = f ^ m, a.i = p, f + (l ^ l >>> 16) | 0;
        };
        function u(l, c) {
          var p, m, f, h, d, g = [], y = 128;
          for (c === (c | 0) ? (m = c, c = null) : (c = c + "\0", m = 0, y = Math.max(y, c.length)), f = 0, h = -32; h < y; ++h) c && (m ^= c.charCodeAt((h + 32) % c.length)), h === 0 && (d = m), m ^= m << 10, m ^= m >>> 15, m ^= m << 4, m ^= m >>> 13, h >= 0 && (d = d + 1640531527 | 0, p = g[h & 127] ^= m + d, f = p == 0 ? f + 1 : 0);
          for (f >= 128 && (g[(c && c.length || 0) & 127] = -1), f = 127, h = 4 * 128; h > 0; --h) m = g[f + 34 & 127], p = g[f = f + 1 & 127], m ^= m << 13, p ^= p << 17, m ^= m >>> 15, p ^= p >>> 12, g[f] = m ^ p;
          l.w = d, l.X = g, l.i = f;
        }
        u(a, i);
      }
      function o(i, a) {
        return a.i = i.i, a.w = i.w, a.X = i.X.slice(), a;
      }
      function s10(i, a) {
        i == null && (i = +/* @__PURE__ */ new Date());
        var u = new n(i), l = a && a.state, c = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var p = u.next() >>> 11, m = (u.next() >>> 0) / 4294967296, f = (p + m) / (1 << 21);
          while (f === 0);
          return f;
        }, c.int32 = u.next, c.quick = c, l && (l.X && o(l, u), c.state = function() {
          return o(u, {});
        }), c;
      }
      t && t.exports ? t.exports = s10 : r && r.amd ? r(function() {
        return s10;
      }) : this.xor4096 = s10;
    })(Rk, typeof XN == "object" && XN, typeof define == "function" && define);
  });
  var Mk = Hn((Lk, YN) => {
    (function(e28, t, r) {
      function n(i) {
        var a = this, u = "";
        a.next = function() {
          var c = a.b, p = a.c, m = a.d, f = a.a;
          return c = c << 25 ^ c >>> 7 ^ p, p = p - m | 0, m = m << 24 ^ m >>> 8 ^ f, f = f - c | 0, a.b = c = c << 20 ^ c >>> 12 ^ p, a.c = p = p - m | 0, a.d = m << 16 ^ p >>> 16 ^ f, a.a = f - c | 0;
        }, a.a = 0, a.b = 0, a.c = -1640531527, a.d = 1367130551, i === Math.floor(i) ? (a.a = i / 4294967296 | 0, a.b = i | 0) : u += i;
        for (var l = 0; l < u.length + 20; l++) a.b ^= u.charCodeAt(l) | 0, a.next();
      }
      function o(i, a) {
        return a.a = i.a, a.b = i.b, a.c = i.c, a.d = i.d, a;
      }
      function s10(i, a) {
        var u = new n(i), l = a && a.state, c = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var p = u.next() >>> 11, m = (u.next() >>> 0) / 4294967296, f = (p + m) / (1 << 21);
          while (f === 0);
          return f;
        }, c.int32 = u.next, c.quick = c, l && (typeof l == "object" && o(l, u), c.state = function() {
          return o(u, {});
        }), c;
      }
      t && t.exports ? t.exports = s10 : r && r.amd ? r(function() {
        return s10;
      }) : this.tychei = s10;
    })(Lk, typeof YN == "object" && YN, typeof define == "function" && define);
  });
  var zk = Hn(() => {
  });
  var Vk = Hn((Bk, Qy) => {
    (function(e28, t, r) {
      var n = 256, o = 6, s10 = 52, i = "random", a = r.pow(n, o), u = r.pow(2, s10), l = u * 2, c = n - 1, p;
      function m(v, w, N) {
        var E = [];
        w = w == true ? { entropy: true } : w || {};
        var A = g(d(w.entropy ? [v, b(t)] : v ?? y(), 3), E), D = new f(E), R = function() {
          for (var L = D.g(o), G = a, W = 0; L < u; ) L = (L + W) * n, G *= n, W = D.g(1);
          for (; L >= l; ) L /= 2, G /= 2, W >>>= 1;
          return (L + W) / G;
        };
        return R.int32 = function() {
          return D.g(4) | 0;
        }, R.quick = function() {
          return D.g(4) / 4294967296;
        }, R.double = R, g(b(D.S), t), (w.pass || N || function(L, G, W, U) {
          return U && (U.S && h(U, D), L.state = function() {
            return h(D, {});
          }), W ? (r[i] = L, G) : L;
        })(R, A, "global" in w ? w.global : this == r, w.state);
      }
      function f(v) {
        var w, N = v.length, E = this, A = 0, D = E.i = E.j = 0, R = E.S = [];
        for (N || (v = [N++]); A < n; ) R[A] = A++;
        for (A = 0; A < n; A++) R[A] = R[D = c & D + v[A % N] + (w = R[A])], R[D] = w;
        (E.g = function(L) {
          for (var G, W = 0, U = E.i, H = E.j, j = E.S; L--; ) G = j[U = c & U + 1], W = W * n + j[c & (j[U] = j[H = c & H + G]) + (j[H] = G)];
          return E.i = U, E.j = H, W;
        })(n);
      }
      function h(v, w) {
        return w.i = v.i, w.j = v.j, w.S = v.S.slice(), w;
      }
      function d(v, w) {
        var N = [], E = typeof v, A;
        if (w && E == "object") for (A in v) try {
          N.push(d(v[A], w - 1));
        } catch {
        }
        return N.length ? N : E == "string" ? v : v + "\0";
      }
      function g(v, w) {
        for (var N = v + "", E, A = 0; A < N.length; ) w[c & A] = c & (E ^= w[c & A] * 19) + N.charCodeAt(A++);
        return b(w);
      }
      function y() {
        try {
          var v;
          return p && (v = p.randomBytes) ? v = v(n) : (v = new Uint8Array(n), (e28.crypto || e28.msCrypto).getRandomValues(v)), b(v);
        } catch {
          var w = e28.navigator, N = w && w.plugins;
          return [+/* @__PURE__ */ new Date(), e28, N, e28.screen, b(t)];
        }
      }
      function b(v) {
        return String.fromCharCode.apply(0, v);
      }
      if (g(r.random(), t), typeof Qy == "object" && Qy.exports) {
        Qy.exports = m;
        try {
          p = zk();
        } catch {
        }
      } else typeof define == "function" && define.amd ? define(function() {
        return m;
      }) : r["seed" + i] = m;
    })(typeof self < "u" ? self : Bk, [], Math);
  });
  var Zf = Hn((Vbt, Gk) => {
    var sj = Ek(), ij = Dk(), aj = Fk(), uj = Ok(), lj = Pk(), cj = Mk(), Fl = Vk();
    Fl.alea = sj;
    Fl.xor128 = ij;
    Fl.xorwow = aj;
    Fl.xorshift7 = uj;
    Fl.xor4096 = lj;
    Fl.tychei = cj;
    Gk.exports = Fl;
  });
  var RD = Hn(() => {
  });
  var _B = Object.defineProperty;
  var OB = (e28, t, r) => t in e28 ? _B(e28, t, { enumerable: true, configurable: true, writable: true, value: r }) : e28[t] = r;
  var EI = (e28, t, r) => (OB(e28, typeof t != "symbol" ? t + "" : t, r), r);
  function dt(e28) {
    return typeof e28 == "number" && !isNaN(e28) || typeof e28 == "bigint";
  }
  var RB = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var Ca = class extends Error {
    constructor(e28) {
      RB() ? super(e28) : super(`

\x1B[31m` + e28 + `
\x1B[0m`);
    }
  };
  function B(e28, t) {
    if (!e28) throw new Ca(t);
  }
  var AI = [Array, ArrayBuffer, BigInt64Array, BigUint64Array, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray];
  function It(e28) {
    return e28 === null || typeof e28 > "u";
  }
  var PB = AI.map((e28) => e28.name);
  function it(e28) {
    try {
      return e28 instanceof Array ? true : It(e28.constructor) ? false : AI.indexOf(e28.constructor) > -1 || PB.indexOf(e28.constructor.name) > -1;
    } catch {
      return false;
    }
  }
  function Tt(e28) {
    try {
      return !!e28._symbol && e28._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch {
      return false;
    }
  }
  function ur(e28) {
    return typeof e28 == "function";
  }
  function ps(e28) {
    return typeof e28 == "object" && !It(e28) && !it(e28);
  }
  function At(e28) {
    try {
      return !!e28._symbol && e28._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch {
      return false;
    }
  }
  function bc(e28, t) {
    if (Tt(e28)) {
      let s10 = bc(e28.values, t);
      return s10.length > 0 && dt(s10[0]) && s10[0] >= 0 && s10[0] < e28.index.length && (s10[0] = e28.index[s10[0]]), s10.length > 1 && dt(s10[1]) && s10[1] >= 0 && s10[1] < e28.columns.length && (s10[1] = e28.columns[s10[1]]), s10;
    }
    if (At(e28)) {
      let s10 = bc(e28.values, t);
      return s10.length > 0 && dt(s10[0]) && s10[0] >= 0 && s10[0] < e28.index.length && (s10[0] = e28.index[s10[0]]), s10;
    }
    if (B(ps(e28) || it(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"), !ur(t)) {
      let s10 = t;
      t = (i) => i === s10;
    }
    function r(s10, i, a) {
      if (a = a || [], a.indexOf(s10) > -1) return null;
      if (ps(s10)) {
        a.push(s10);
        let u = Object.keys(s10).concat(Object.getOwnPropertySymbols(s10));
        for (let l = 0; l < u.length; l++) {
          let c = u[l], p = s10[c];
          if (i(p)) return [c];
          let m = r(p, i, a);
          if (m && m.length > 0) return [c].concat(m);
        }
      } else if (it(s10)) {
        a.push(s10);
        for (let u = 0; u < s10.length; u++) {
          let l = s10[u];
          if (i(l)) return [u];
          let c = r(l, i, a);
          if (c && c.length > 0) return [u].concat(c);
        }
      } else if (i(s10)) return [];
      return null;
    }
    function n(s10) {
      try {
        return t(s10);
      } catch {
        return false;
      }
    }
    let o = r(e28, n);
    return o && o.length > 0 ? o : null;
  }
  function Xr(e28) {
    function t(r) {
      if (typeof r == "object") {
        if (r === null) return null;
        if (it(r)) return r instanceof Array ? r.map((o) => Xr(o)) : r.slice();
        if (At(r)) {
          let o = r.copy();
          return o.values = Xr(o.values), o;
        }
        if (Tt(r)) {
          let o = r.copy();
          return o.values = Xr(r.values), o;
        }
        if (r instanceof Date) return new Date(r.getTime());
        r = wc(r);
        let n = {};
        return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach((o) => {
          n[o] = Xr(r[o]);
        }), n;
      } else return r;
    }
    return t(wc(e28));
  }
  function wc(e28) {
    function t(o, s10, i) {
      if (s10 = s10 || [], i = i || "", s10.indexOf(o) > -1) {
        let a = i.split("/").slice(i.startsWith("/") ? 1 : 0);
        if (a.some((l, c) => {
          let p = a.slice(0, a.length - c - 1), m = r;
          return p.forEach((f) => {
            m = m[f];
          }), m === o;
        })) return `<reference to "${r === o ? "/" : "/" + bc(r, o).join("/")}">`;
      }
      return typeof o == "object" ? o === null ? null : (s10.push(o), it(o) ? typeof o.constructor < "u" && o.constructor.name !== "Array" ? o.slice() : o.map((a, u) => t(a, s10, i + "/" + u)) : (Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach((a) => {
        o[a] = t(o[a], s10, i + "/" + a.toString());
      }), o)) : o;
    }
    let r = e28, n = t(r);
    if (Tt(e28)) {
      let o = e28.copy();
      o._values = n.values, o._columns = n.columns, o._index = n.index, n = o;
    }
    if (At(e28)) {
      let o = e28.copy();
      o.name = n.name, o._values = n.values, o._index = n.index, n = o;
    }
    return n;
  }
  function Hs(e28) {
    return e28 instanceof Date && e28.toString() !== "Invalid Date";
  }
  var bI = ["number", "int", "float", "bigint"];
  function on(e28, t) {
    function r(n, o) {
      let s10 = typeof n, i = typeof o;
      if (s10 !== i && !bI.includes(s10) && !bI.includes(i)) return false;
      if (s10 === "undefined" && i === "undefined") return true;
      if (s10 === "boolean" || s10 === "symbol") return n === o;
      if (s10 === "number" || s10 === "bigint") try {
        let a = n.toString(), u = o.toString();
        return a === u;
      } catch {
        return false;
      }
      if (s10 === "string" || s10 === "function") return n === o;
      if (s10 === "object") {
        if (n === null || o === null) return n === null && o === null;
        {
          if (Hs(n)) return Hs(o) ? n.getTime() === o.getTime() : false;
          if (Hs(o)) return false;
          if (n instanceof RegExp && o instanceof RegExp) return n.toString() === o.toString();
          if (it(n) !== it(o)) return false;
          let a = Object.keys(n).concat(Object.getOwnPropertySymbols(n)), u = Object.keys(o).concat(Object.getOwnPropertySymbols(o));
          if (a.length !== u.length) return false;
          for (let l = 0; l < a.length; l++) {
            let c = a[l];
            if (!r(n[c], o[c])) return false;
          }
          return true;
        }
      }
    }
    try {
      return r(e28, t);
    } catch {
      return r(wc(e28), wc(t));
    }
  }
  function wf(e28) {
    let t = "abcdefg1234567890", r = "";
    for (; r.length < e28; ) r += t[Math.floor(Math.random() * t.length)];
    return r;
  }
  var LB = wf(16);
  var MB = wf(16);
  var zB = wf(16);
  var BB = wf(16);
  var VB = wf(16);
  var GB = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((e28) => this.get(e28));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      return this.countsDict = {}, this.valuesDict = {}, this;
    }
    count(e28) {
      for (let t of e28) it(t) ? this.count(t) : this.increment(t);
      return this;
    }
    delete(e28) {
      let t = this.getStandardizedKey(e28);
      return delete this.countsDict[t], delete this.valuesDict[t], this;
    }
    get(e28) {
      return this.countsDict[this.getStandardizedKey(e28)] || 0;
    }
    getStandardizedKey(e28) {
      return typeof e28 == "object" && e28 === null ? LB : It(e28) ? MB : ur(e28) ? e28.toString() : typeof e28 == "symbol" ? e28.toString() + " - " + VB : e28 === 1 / 0 ? zB : e28 === -1 / 0 ? BB : typeof e28 == "bigint" ? e28.toString() : Tt(e28) ? e28.toJSONString() : At(e28) ? JSON.stringify(e28.toObject()) : JSON.stringify(e28);
    }
    has(e28) {
      return !It(this.countsDict[this.getStandardizedKey(e28)]);
    }
    increment(e28) {
      return this.set(e28, this.get(e28) + 1);
    }
    set(e28, t) {
      let r = this.getStandardizedKey(e28);
      return this.countsDict[r] = t, this.valuesDict[r] = e28, this;
    }
    toArray() {
      return this.values.map((e28) => ({ value: e28, count: this.get(e28) }));
    }
    toObject() {
      let e28 = {};
      return this.values.forEach((t) => {
        e28[t] = this.get(t);
      }), e28;
    }
  };
  function An(e28) {
    if (Tt(e28) || At(e28)) return An(e28.values);
    B(it(e28), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function t(r) {
      let n = [];
      return r.forEach((o) => {
        it(o) ? n = n.concat(t(o)) : n.push(o);
      }), n;
    }
    return t(e28);
  }
  function qn(e28, t) {
    t = t || {};
    let r = new GB(), n = {}, o = An(e28), s10 = [], i = -1 / 0, a = 1 / 0, u = false, l = 0;
    for (let p of o) {
      if (typeof p == "bigint" && (u = true), !t.shouldDropNaNs || dt(p)) try {
        p > i && (i = p), p < a && (a = p), l += Number(p), s10.push(p);
      } catch {
        i = NaN, a = NaN, l = NaN;
      }
      r.increment(p);
    }
    let c = l / s10.length;
    if (n.counts = r, n.max = i, n.mean = c, n.min = a, n.n = o.length, n.sum = l, isNaN(n.mean) && (n.max = NaN, n.min = NaN), t.shouldDropNaNs && (n.nWithoutNaNs = s10.length), t.mode) {
      let p = Array.from(r.values.map((h) => [h, r.get(h)])).toSorted((h, d) => d[1] - h[1]), m = p[0][1], f = [];
      for (let h of p) if (h[1] == m) f.push(h[0]);
      else break;
      n.mode = f.toSorted();
    }
    if (t.median) if (isNaN(c)) n.median = NaN;
    else {
      let p = s10.toSorted((f, h) => Number(f) - Number(h)), m = Math.floor(p.length / 2);
      if (p.length % 2 === 0) {
        let f = p[m - 1], h = p[m];
        if (n.median = (Number(f) + Number(h)) / 2, u && typeof f == "bigint" && typeof h == "bigint") try {
          n.median = BigInt(n.median);
        } catch {
        }
      } else n.median = p[m];
    }
    if (t.stdev || t.variance) {
      let p = 0;
      for (let f of s10) p += Math.pow(Number(f) - c, 2);
      p /= s10.length;
      let m = Math.sqrt(p);
      n.stdev = m, n.variance = p;
    }
    if (u) {
      try {
        n.sum = BigInt(n.sum);
      } catch {
      }
      try {
        n.mean = BigInt(n.mean);
      } catch {
      }
      t.mode && (n.mode = n.mode.map((p) => {
        try {
          return BigInt(p);
        } catch {
          return p;
        }
      }));
    }
    return n;
  }
  function ty(e28, t) {
    let { counts: r } = qn(e28);
    return It(t) || (ur(t) ? r.values.forEach((n) => {
      t(n) || r.delete(n);
    }) : r.values.forEach((n) => {
      on(n, t) || r.delete(n);
    })), r;
  }
  function dv(e28) {
    if (Tt(e28) || At(e28)) return dv(e28.values);
    if (it(e28)) {
      let t = false, r = false, n = null;
      for (let o of e28) {
        if (dv(o)) return true;
        if (it(o)) {
          if (n === null) n = o.length;
          else if (o.length !== n) return true;
          t = true;
        } else r = true;
        if (t && r) return true;
      }
    }
    return false;
  }
  function vf(e28) {
    return dv(wc(e28));
  }
  function oy(e28) {
    if (Tt(e28) || At(e28)) return oy(e28.values);
    B(it(e28), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let t = 0; t < e28.length; t++) if (it(e28[t])) return true;
    return false;
  }
  var gc = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function Lo(e28) {
    B(!It(e28), gc), it(e28) || (e28 = [e28]), B(!oy(e28), gc), B(e28.length > 0, gc);
    let t = e28[0];
    if (typeof t == "bigint" && (t = Number(t)), B(dt(t), gc), B(t >= 0, gc), B(Math.floor(t) === t, gc), B(t !== 1 / 0, "We can't create an array containing an infinite number of values!"), e28.length === 1) {
      let r = [];
      for (let n = 0; n < t; n++) r.push(void 0);
      return r;
    } else {
      let r = [];
      for (let n = 0; n < t; n++) r.push(Lo(e28.slice(1)));
      return r;
    }
  }
  function cs(e28) {
    if (Tt(e28) || At(e28)) {
      let r = e28.copy();
      return r.values = cs(r.values), r.index = cs(r.index), r;
    }
    B(it(e28), "The `reverse` function only works on arrays, Series, and DataFrames!");
    let t = [];
    for (let r = e28.length - 1; r >= 0; r--) t.push(e28[r]);
    return t;
  }
  function hr(e28, t, r = 1) {
    B(!It(e28) && !It(t) && !It(r), "You must pass two numbers and optionally a step value to the `range` function!"), B(dt(e28) && dt(t) && dt(r), "You must pass two numbers and optionally a step value to the `range` function!"), B(r > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let n = false, o = typeof e28 == "bigint" || typeof t == "bigint" || typeof r == "bigint";
    if (e28 = Number(e28), t = Number(t), r = Number(r), e28 > t) {
      n = true;
      let i = e28;
      e28 = t + r, t = i + r;
    }
    let s10 = [];
    for (let i = e28; i < t; i += r) if (o) try {
      s10.push(BigInt(i));
    } catch {
      s10.push(i);
    }
    else s10.push(i);
    return n && (s10 = cs(s10)), s10;
  }
  function Nf(e28) {
    let t = "abcdefg1234567890", r = "";
    for (; r.length < e28; ) r += t[Math.floor(Math.random() * t.length)];
    return r;
  }
  var WB = Nf(256);
  var UB = Nf(256);
  var jB = Nf(256);
  var HB = Nf(256);
  var KB = Nf(256);
  function co(e28) {
    if (Tt(e28) || At(e28)) return co(e28.values);
    B(it(e28), "The `set` function only works on arrays, Series, and DataFrames!");
    let t = [], r = {};
    return An(e28).forEach((n) => {
      let o = typeof n == "object" && n === null ? WB : It(n) ? UB : ur(n) ? n.toString() : typeof n == "symbol" ? n.toString() + " - " + KB : n === 1 / 0 ? jB : n === -1 / 0 ? HB : typeof n == "bigint" ? n.toString() : Tt(n) ? n.toJSONString() : At(n) ? JSON.stringify(n.toObject()) : JSON.stringify(n);
      r[o] || t.push(n), r[o] = true;
    }), t;
  }
  function DI(e28) {
    if (it(e28)) {
      let t = DI(e28[0]);
      return [e28.length].concat(t || []);
    } else return;
  }
  function Et(e28) {
    return Tt(e28) || At(e28) ? Et(e28.values) : (B(it(e28), "The `shape` function only works on arrays, Series, and DataFrames!"), DI(e28));
  }
  function $I(e28, t, r) {
    if (It(r) && (r = 0), B(r === 0 || r === 1 || r === "vertical" || r === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'), it(t)) {
      B(!vf(t), "The array of data you're trying to append to this DataFrame is jagged!");
      let n = Et(t);
      if (n.length === 1) if (r === 0) {
        let o = e28.copy();
        o._values.push(t);
        let s10 = Math.max(e28.shape[1], n[0]);
        for (o._values.forEach((i) => {
          for (; i.length < s10; ) i.push(void 0);
        }); o._index.length < o._values.length; ) o._index.push("row" + o._index.length);
        for (; o._columns.length < s10; ) o._columns.push("col" + o._columns.length);
        return o;
      } else {
        let o = Math.max(e28.shape[0], n[0]), s10 = e28.copy();
        for (hr(0, o).forEach((i) => {
          i >= s10._values.length && s10._values.push(Lo(e28.shape[1])), s10._values[i].push(t[i]);
        }); s10._index.length < s10._values.length; ) s10._index.push("row" + s10._index.length);
        for (; s10._columns.length < s10._values[0].length; ) s10._columns.push("col" + s10._columns.length);
        return s10;
      }
      else if (n.length === 2) if (r === 0) {
        let o = Math.max(...t.map((i) => i.length).concat([e28.shape[1]])), s10 = e28.copy();
        for (s10._values = s10._values.concat(t).map((i) => {
          for (; i.length < o; ) i.push(void 0);
          return i;
        }); s10._index.length < s10._values.length; ) s10._index.push("row" + s10._index.length);
        for (; s10._columns.length < o; ) s10._columns.push("col" + s10._columns.length);
        return s10;
      } else {
        let o = Math.max(...t.map((a) => a.length)) + e28.shape[1], s10 = Math.max(e28.shape[0], n[0]), i = e28.copy();
        for (hr(0, s10).forEach((a) => {
          for (a >= i._values.length && i._values.push(Lo(e28.shape[1])), i._values[a] = i._values[a].concat(t[a]); i._values[a].length < o; ) i._values[a].push(void 0);
        }); i._index.length < i._values.length; ) i._index.push("row" + i._index.length);
        for (; i._columns.length < o; ) i._columns.push("col" + i._columns.length);
        return i;
      }
      else throw new Ca("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
    } else if (At(t)) {
      let n = $I(e28, t.values, r);
      return r === 0 ? n.index[n.index.length - 1] = n.index.indexOf(t.name) > -1 ? t.name + " (2)" : t.name : n.columns[n.columns.length - 1] = n.columns.indexOf(t.name) > -1 ? t.name + " (2)" : t.name, n;
    } else if (Tt(t)) if (r === 0) {
      let n = e28.copy(), o = co(n._columns.concat(t._columns)).length;
      for (n._values.forEach((s10) => {
        for (; s10.length < o; ) s10.push(void 0);
      }), t.apply((s10) => {
        let i = s10.copy(), a = [];
        n._columns.forEach((u) => {
          let l = i._index.indexOf(u);
          l > -1 ? (a.push(i._values[l]), i._values.splice(l, 1), i._index.splice(l, 1)) : a.push(void 0);
        }), n._values.push(a.concat(i._values));
      }, 1), n._columns = n._columns.concat(t._columns.filter((s10) => n._columns.indexOf(s10) < 0)); n._index.length < n._values.length; ) {
        let s10 = "row" + n._index.length;
        n._index.push(s10 + (e28._index.indexOf(s10) > -1 ? " (2)" : ""));
      }
      return n;
    } else {
      let n = e28.copy();
      return n._index.forEach((o, s10) => {
        let i = t._index.indexOf(o);
        i > -1 ? n._values[s10] = n._values[s10].concat(t._values[i]) : n._values[s10] = n._values[s10].concat(Lo(t.shape[1]));
      }), t._index.forEach((o, s10) => {
        n._index.indexOf(o) < 0 && (n._index.push(o), n._values.push(Lo(n._columns.length).concat(t._values[s10])));
      }), n._columns = n._columns.concat(t._columns.map((o) => o + (n._columns.indexOf(o) > -1 ? " (2)" : ""))), n;
    }
    else throw new Ca("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
  }
  function qB(e28, t, r, n, o) {
    if (o = o || 0, B(ur(n), "The first parameter to the `apply` method must be a function."), B(o === 0 || o === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1."), o === 0) {
      let s10 = {}, i;
      if (r.columns.forEach((a, u) => {
        let l = new t(r.values.map((p) => p[u]));
        l.name = a, l.index = r.index;
        let c = n(l, u, r);
        c instanceof t ? s10[a] = c.values : s10[a] = c, It(i) && (i = c instanceof t || it(c));
      }), i) {
        let a = new e28(s10);
        return a.index = r.index, a;
      } else {
        let a = new t(r.columns.map((u) => s10[u]));
        return a.index = r.columns, a;
      }
    } else if (o === 1) {
      let s10, i = r.values.map((a, u) => {
        let l = new t(a);
        l.name = r.index[u], l.index = r.columns;
        let c = n(l, u, r);
        return It(s10) && (s10 = c instanceof t || it(c)), c instanceof t ? c.values : c;
      });
      if (s10) {
        let a = new e28(i);
        return a.index = r.index, a.columns = r.columns, a;
      } else {
        let a = new t(i);
        return a.index = r.index, a;
      }
    }
  }
  function Ge(e28) {
    return typeof e28 == "string";
  }
  function XB(e28, t, r, n, o) {
    let s10 = (a) => a instanceof e28, i = (a) => a instanceof t;
    if (It(o)) {
      if (s10(n)) return r.append(n, 1);
      if (i(n)) return r.append(n, 1);
      if (ps(n)) {
        let a = Math.max(...Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map((u) => n[u].length));
        return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach((u) => {
          for (; n[u].length < a; ) n[u].push(void 0);
        }), r.append(new e28(n), 1);
      } else throw new Ca("You must pass a DataFrame, Series, or object into the `assign` method!");
    } else {
      B(Ge(n), "If passing two arguments into the `assign` method, then the first argument must be a string name!"), B(it(o) && !vf(o) && Et(o).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      let a = r.append(o, 1);
      return a.columns[a.columns.length - 1] = n, a;
    }
  }
  function YB(e28, t) {
    if (t.isEmpty) return new e28();
    let r = new e28(Xr(t.values));
    return r.columns = t.columns.slice(), r.index = t.index.slice(), r;
  }
  function JB(e28, t, r, n, o) {
    It(n) && (n = []), It(o) && (o = []), (Ge(n) || dt(n)) && (n = [n]), (Ge(o) || dt(o)) && (o = [o]), B(it(n), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), B(it(o), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), B(Et(n).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), B(Et(o).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let s10, i;
    r.index.forEach((u, l) => {
      n.indexOf(u) < 0 && n.indexOf(l) < 0 && (s10 || (s10 = []), s10.push(u));
    }), r.columns.forEach((u, l) => {
      o.indexOf(u) < 0 && o.indexOf(l) < 0 && (i || (i = []), i.push(u));
    });
    let a = r.get(s10, i);
    if (a instanceof t) {
      let u = new e28();
      u = u.assign(a), r.index.indexOf(a.name) > -1 && (u = u.transpose()), a = u;
    }
    return a;
  }
  function FI(e28) {
    return dt(e28) && (e28 >= 0 ? Math.floor(e28) === e28 : Math.ceil(e28) === e28);
  }
  function vc(e28) {
    return FI(e28) && e28 >= 0;
  }
  function ZB(e28, t, r, n, o, s10) {
    n = n || 0, B(n === 0 || n === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."), s10 = s10 || 0, B(vc(s10), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."), o = s10 > 0 ? "none" : o || "any", B(o === "any" || o === "all" || o === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function i(l) {
      if (s10 > 0) {
        let c = 0;
        for (let p = 0; p < l.length; p++) {
          let m = l[p];
          if (It(m) && c++, c >= s10) return [];
        }
      } else if (o === "any") for (let c = 0; c < l.length; c++) {
        let p = l[c];
        if (It(p)) return [];
      }
      else if (o === "all") {
        for (let c = 0; c < l.length; c++) {
          let p = l[c];
          if (!It(p)) return l;
        }
        return [];
      }
      return l;
    }
    let a = r.copy(), u = Math.random().toString();
    if (n === 0) {
      a = a.assign(u, a.index);
      let l = a.values.map(i).filter((p) => p.length > 0);
      if (Et(l).length < 2) return new e28();
      a.values = l;
      let c = a.get(null, u);
      if (It(c)) return new e28();
      Ge(c) && (c = [c]), c instanceof t && (c = c.values), a.index = c, a = a.drop(null, u);
    } else if (n === 1) {
      let l = {};
      if (a.columns.forEach((p, m) => {
        let f = a.values.map((d) => d[m]), h = i(f);
        h.length > 0 && (l[p] = h);
      }), Object.keys(l).length + Object.getOwnPropertySymbols(l).length === 0) return new e28();
      let c = new e28(l);
      return c.index = a.index, c;
    }
    return a;
  }
  function Sv(e28) {
    if (Tt(e28) || At(e28)) return e28.dropNaN(...Object.values(arguments).slice(1));
    B(it(e28), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    let t = [];
    return e28.forEach((r) => {
      try {
        return t.push(Sv(r));
      } catch {
        if (dt(r)) return t.push(r);
      }
    }), t;
  }
  function QB(e28, t, r, n, o) {
    r = r || 0, B(r === 0 || r === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."), o = o || 0, B(vc(o), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."), n = o > 0 ? "none" : n || "any", B(n === "any" || n === "all" || n === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function s10(a) {
      let u = Sv(a);
      return o > 0 ? a.length - u.length < o : n === "any" ? u.length === a.length : n === "all" ? u.length > 0 : true;
    }
    let i = t.copy();
    if (r === 0) {
      let a = i.index.filter((u) => {
        let l = i.get(u, null).values;
        return s10(l);
      });
      return a.length > 0 ? i.get(a, null) : new e28();
    } else if (r === 1) {
      let a = i.columns.filter((u) => {
        let l = i.get(null, u).values;
        return s10(l);
      });
      return a.length > 0 ? i.get(null, a) : new e28();
    }
    return i;
  }
  function wI(e28) {
    let t = {};
    return An(e28).forEach((r, n) => {
      t[r] = n;
    }), t;
  }
  function yc(e28) {
    return Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).sort((t, r) => e28[t] - e28[r]);
  }
  function tV(e28, t, r, n, o) {
    B(ur(n), "The `filter` method takes a single parameter: a function that is used to filter the values."), It(o) && (o = 0), B(o === 0 || o === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let s10 = r.copy();
    if (s10.isEmpty) return s10;
    let i = wI(s10.index), a = wI(s10.columns);
    if (o === 0) {
      let u = 0, l = s10.values.filter((c, p) => {
        let m = new t(c);
        m.name = r.index[p], m.index = r.columns;
        let f = n(m, p, r);
        return f ? u++ : delete i[s10.index[p]], f;
      });
      if (u === 0) return new e28();
      if (u === 1) {
        let c = new t(l[0]);
        return c.name = yc(i)[0], c.index = yc(a), c;
      }
      s10.values = l, s10.index = yc(i);
    } else if (o === 1) {
      s10 = s10.transpose();
      let u = 0, l = s10.values.filter((c, p) => {
        let m = new t(c);
        m.name = r.columns[p], m.index = r.index;
        let f = n(m, p, r);
        return f ? u++ : delete a[s10.index[p]], f;
      });
      if (u === 0) return new e28();
      if (u === 1) {
        let c = new t(l[0]);
        return c.name = yc(a)[0], c.index = yc(i), c;
      }
      s10.values = l, s10.index = yc(a), s10 = s10.transpose();
    }
    return s10;
  }
  function eV(e28, t, r) {
    (Ge(t) || dt(t)) && (t = [t]), (Ge(r) || dt(r)) && (r = [r]);
    for (let o in t) typeof t[o] == "bigint" && (t[o] = Number(t[o]));
    for (let o in r) typeof r[o] == "bigint" && (r[o] = Number(r[o]));
    let n = co((t || []).concat(r || []).map((o) => typeof o));
    return B(n.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!"), n.length === 1 && B(n[0] === "string" || n[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!"), n.length === 2 && (B(n.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!"), B(n.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!")), It(t) || (t = t.map((o) => {
      if (Ge(o)) return B(e28.index.indexOf(o) > -1, `Row "${o}" does not exist!`), o;
      if (dt(o)) return B(o >= 0, `Index ${o} is out of bounds!`), B(Math.floor(o) === o, "Row numbers must be integers!"), B(o < e28.index.length, `Index ${o} is out of bounds!`), e28.index[o];
    })), It(r) || (r = r.map((o) => {
      if (Ge(o)) return B(e28.columns.indexOf(o) > -1, `Column "${o}" does not exist!`), o;
      if (dt(o)) return B(o >= 0, `Column ${o} is out of bounds!`), B(Math.floor(o) === o, "Column numbers must be integers!"), B(o < e28.columns.length, `Column ${o} is out of bounds!`), e28.columns[o];
    })), e28.getSubsetByNames(t, r);
  }
  function rV(e28, t) {
    try {
      return e28 < t ? -1 : e28 > t ? 1 : 0;
    } catch {
      return e28 = typeof e28 == "object" && e28 !== null ? JSON.stringify(e28) : e28.toString(), t = typeof t == "object" && t !== null ? JSON.stringify(t) : t.toString(), e28 < t ? -1 : e28 > t ? 1 : 0;
    }
  }
  function Zu(e28, t) {
    if (It(t) && (t = rV), Tt(e28) || At(e28)) return e28.sort(...Object.values(arguments).slice(1));
    B(it(e28), "The `sort` function only works on arrays, Series, and DataFrames!"), B(ur(t), "The second parameter of the `sort` function must be a comparison function!");
    let r = e28.slice();
    return r.sort(t), r;
  }
  function nV(e28) {
    let t = e28.toLowerCase(), r = "";
    for (let o = 0; o < t.length; o++) {
      let s10 = t[o];
      s10.match(/[a-z0-9]/g) ? r += s10 : r += " ";
    }
    let n = r.split(" ").filter((o) => o.length > 0);
    return n[0] + n.slice(1).map((o) => o[0].toUpperCase() + o.substring(1)).join("");
  }
  function vI(e28, t, r) {
    It(r) ? r = t.columns : Ge(r) && (r = [r]);
    let n = {};
    r.forEach((s10) => {
      B(Ge(s10), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      let i = t.columns.indexOf(s10);
      B(i > -1, `The given DataFrame does not have a column called "${s10}"!`);
      let a = t.values.map((l) => l[i]), u = Zu(co(a));
      a.forEach((l) => {
        u.forEach((c) => {
          let p = s10 + "_" + nV(c.toString());
          n[p] || (n[p] = []), l === c ? n[p].push(1) : n[p].push(0);
        });
      });
    });
    let o = new e28(n);
    return o.index = t.index, o;
  }
  function oV(e28, t, r) {
    let n = e28.shape;
    It(t) && (t = hr(0, n[0])), It(r) && (r = hr(0, n[1])), dt(t) && (t = [t]), dt(r) && (r = [r]), B(it(t) && it(r), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), B(Et(t).length === 1 && Et(r).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), B(t.length > 0, "The `rowIndices` array must contain at least one index."), B(r.length > 0, "The `colIndices` array must contain at least one index."), t.forEach((i) => {
      B(vc(i), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), B(i < e28.index.length, `The row index ${i} is out of bounds.`);
    }), r.forEach((i) => {
      B(vc(i), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), B(i < e28.columns.length, `The column index ${i} is out of bounds.`);
    });
    let o = t.map((i) => e28.index[i]), s10 = r.map((i) => e28.columns[i]);
    return e28.getSubsetByNames(o, s10);
  }
  function sV(e28, t, r, n, o) {
    It(n) && (n = r.index), It(o) && (o = r.columns), Ge(n) && (n = [n]), Ge(o) && (o = [o]), B(it(n) && it(o), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), B(Et(n).length === 1 && Et(o).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), B(n.length > 0, "The `rows` array must contain at least one row name."), B(o.length > 0, "The `cols` array must contain at least one column name."), n.forEach((a) => {
      B(Ge(a), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), B(r.index.indexOf(a) > -1, `The row name "${a}" does not exist in the list of rows.`);
    }), o.forEach((a) => {
      B(Ge(a), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), B(r.columns.indexOf(a) > -1, `The column name "${a}" does not exist in the list of columns.`);
    });
    let s10 = n.map((a) => o.map((u) => r.values[r.index.indexOf(a)][r.columns.indexOf(u)]));
    if (n.length === 1 && o.length === 1) return s10[0][0];
    if (n.length === 1) {
      let a = new t(s10[0]);
      return a.name = n[0], a.index = o, a;
    }
    if (o.length === 1) {
      let a = new t(s10.map((u) => u[0]));
      return a.name = o[0], a.index = n, a;
    }
    let i = new e28(s10);
    return i.columns = o, i.index = n, i;
  }
  function iV(e28, t, r) {
    function n(m, f) {
      return Ge(m) && m.length > f ? m.substring(0, f - 3) + "..." : m;
    }
    if (r.isEmpty) return console.table({}), console.log("Shape:", [0, 0], `
`), r;
    let o = typeof window > "u" ? 20 : 10, s10 = Math.floor(o / 2), i = typeof process > "u" ? 10 : Math.floor(process.stdout.columns / 24) - 1, a = Math.floor(i / 2), u = o > r.index.length ? null : hr(0, s10).concat(hr(r.index.length - s10, r.index.length)), l = i > r.columns.length ? null : hr(0, a).concat(hr(r.columns.length - a, r.columns.length)), c = r.get(u, l);
    c instanceof t && (r.shape[0] === 1 ? (c = new e28([c.values]), c.index = r.index, c.columns = new t(r.columns).get(l).values) : r.shape[1] === 1 && (c = new e28([c.values]).transpose(), c.index = new t(r.index).get(u).values, c.columns = r.columns)), o <= r.index.length && (c._index.splice(s10, 0, "..."), c._values.splice(s10, 0, hr(0, c.columns.length).map(() => "..."))), i <= r.columns.length && (c._columns.splice(a, 0, "..."), c._values = c._values.map((m) => (m.splice(a, 0, "..."), m)));
    let p = 28;
    return c instanceof t ? (c.values = c.values.map((m) => n(m, p)), c.name = n(c.name, p), c.index = c.index.map((m) => n(m, p))) : (c.values = c.values.map((m) => m.map((f) => n(f, p))), c.columns = c.columns.map((m) => n(m, p)), c.index = c.index.map((m) => n(m, p))), console.table(c.toDetailedObject()), console.log("Shape:", r.shape, `
`), r;
  }
  function xc(e28, t) {
    B(dt(e28), "The `leftPad` function only works on numbers!");
    let r = e28.toString();
    for (; r.length < t; ) r = "0" + r;
    return r;
  }
  function aV(e28, t) {
    let r = t ? e28 : e28.copy();
    return r.index = hr(0, e28.shape[0]).map((n) => "row" + xc(n, (r.index.length - 1).toString().length)), r;
  }
  function Cf(e28, t) {
    if (Tt(e28) || At(e28)) return Cf(e28.values, t);
    B(it(e28), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (e28.length === 0) return NaN;
      let r = An(e28), n = false, o = 1;
      for (let s10 of r) {
        if (!dt(s10)) if (t) s10 = 1;
        else return NaN;
        typeof s10 == "bigint" && (n = true, s10 = Number(s10)), o *= s10;
      }
      if (n) try {
        return BigInt(o);
      } catch {
      }
      return o;
    } catch {
      return NaN;
    }
  }
  function uV(e28) {
    return FI(e28) && e28 > 0;
  }
  function yf(e28, t) {
    if (Tt(e28) || At(e28)) return yf(e28.values, t);
    if (B(it(e28), "The first argument passed into the `reshape` function must be an array!"), dt(t) && (t = [t]), B(it(t), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), B(Et(t).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), t = t.map((s10) => (typeof s10 == "bigint" && (s10 = Number(s10)), B(uV(s10), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), Number(s10))), t.length === 0) return An(e28);
    let r = An(e28);
    if (t.length === 1 && t[0] === r.length) return r;
    B(Cf(t) === r.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    let n = [], o = Math.floor(r.length / t[0]);
    for (let s10 = 0; s10 < t[0]; s10++) {
      let i = r.slice(s10 * o, (s10 + 1) * o);
      n.push(yf(i, t.slice(1)));
    }
    return n;
  }
  var _I = Math.pow(2, 64);
  var qe = [];
  OI(Math.floor(Math.random() * _I));
  function lV(e28, t) {
    e28 = nn(e28);
    function r() {
      e28 += nn("0x9e3779b97f4a7c15");
      let o = Xr(e28);
      return o = (o ^ o >> BigInt(30)) * nn("0xbf58476d1ce4e5b9"), o = (o ^ o >> BigInt(27)) * nn("0x94d049bb133111eb"), o ^ o >> BigInt(31);
    }
    let n = [];
    for (let o = 0; o < t; o++) n.push(r());
    return n;
  }
  function nn(e28) {
    return BigInt.asUintN(64, BigInt(e28));
  }
  function NI(e28, t) {
    return e28 = nn(e28), t = BigInt(t), nn(nn(e28 << t) | nn(e28 >> nn(BigInt(64) - t)));
  }
  function OI(e28) {
    if (typeof e28 == "bigint" && (e28 = Number(e28)), It(e28)) return Xr(qe);
    {
      B(dt(e28), "If passing a value into the `seed` function, then that value must be an integer!");
      let t = lV(Math.floor(e28), 4);
      qe[0] = t[0], qe[1] = t[1], qe[2] = t[2], qe[3] = t[3];
    }
  }
  function CI() {
    let e28 = nn(NI(qe[0] + qe[3], 23) + qe[0]), t = nn(qe[1] << BigInt(17));
    return qe[2] = nn(qe[2] ^ qe[0]), qe[3] = nn(qe[3] ^ qe[1]), qe[1] = nn(qe[1] ^ qe[2]), qe[0] = nn(qe[0] ^ qe[3]), qe[2] = nn(qe[2] ^ t), qe[3] = NI(qe[3], 45), Math.floor(Number(e28)) / _I;
  }
  function po(e28) {
    return It(e28) ? CI() : (it(e28) || (e28 = [e28]), yf(Lo(Cf(e28)).map(CI), e28));
  }
  function ey(e28) {
    if (Tt(e28) || At(e28)) return e28.shuffle(...Object.values(arguments).slice(1));
    B(it(e28), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    let t = [], r = e28.slice();
    for (let n = 0; n < e28.length; n++) {
      let o = Math.floor(po() * r.length);
      t.push(r.splice(o, 1)[0]);
    }
    return t;
  }
  function cV(e28, t) {
    return It(t) && (t = 0), B(t === 0 || t === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined."), e28.get(t === 0 ? ey(e28.index) : null, t === 1 ? ey(e28.columns) : null);
  }
  function Ju(e28) {
    return typeof e28 == "boolean";
  }
  function pV(e28, t, r) {
    return ur(t) ? mV(e28, t, r) : fV(e28, t, r);
  }
  function mV(e28, t, r) {
    if (r = It(r) ? 0 : r, B(ur(t), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"), B(dt(r), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."), r === 0) {
      let n = Zu(e28.index, (o, s10) => t(e28.get(o, null), e28.get(s10, null)));
      return e28.get(n, null);
    } else {
      let n = Zu(e28.columns, (o, s10) => t(e28.get(null, o), e28.get(null, s10)));
      return e28.get(null, n);
    }
  }
  function fV(e28, t, r) {
    let n = e28.copy(), o = po().toString();
    n = n.assign(o, n.index), It(t) && (t = [o], r = [true]), (dt(t) || Ge(t)) && (t = [t], (Ju(r) || Ge(r)) && (r = [r])), B(it(t), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."), B(Et(t).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."), It(r) && (r = hr(0, t.length).map(() => true)), B(it(r), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."), B(Et(r).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."), B(t.length === r.length, "The arrays passed into the `sort` method must be equal in length."), t = t.map((i) => {
      if (B(Ge(i) || dt(i), "Column references can either be column names (as strings) or column indices (as whole numbers)."), Ge(i)) {
        let a = n.columns.indexOf(i);
        return B(a > -1, `The column "${i}" does not exist!`), a;
      }
      if (dt(i)) return B(vc(i), "Column indices must be whole numbers!"), B(i < n.columns.length, `The index ${i} is out of bounds!`), i;
    }), r = r.map((i) => {
      if (B(Ge(i) || Ju(i), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."), Ge(i)) {
        let a = i.trim().toLowerCase();
        return B(a === "ascending" || a === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."), a === "ascending";
      }
      if (Ju(i)) return i;
    }), n.values = Zu(n.values, (i, a) => {
      let u = 0;
      for (; i[t[u]] === a[t[u]] && u < t.length; ) u++;
      let l = r[u];
      if (i[t[u]] === a[t[u]]) return 0;
      if (i[t[u]] < a[t[u]]) return l ? -1 : 1;
      if (i[t[u]] > a[t[u]]) return l ? 1 : -1;
    });
    let s10 = n.columns.indexOf(o);
    return n.index = n.values.map((i) => i[s10]), n = n.dropColumns(o), n;
  }
  function hV(e28, t) {
    It(t) ? t = 0 : B(t === 0 || t === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    let r = {};
    return t === 0 ? e28.index.forEach((n, o) => {
      let s10 = {};
      e28.columns.forEach((i, a) => {
        s10[i] = e28.values[o][a];
      }), r[n] = s10;
    }) : e28.columns.forEach((n, o) => {
      let s10 = {};
      e28.index.forEach((i, a) => {
        s10[i] = e28.values[a][o];
      }), r[n] = s10;
    }), r;
  }
  function RI(e28, t) {
    return JSON.stringify(e28.toObject(t));
  }
  async function dV(e28, t, r) {
    let n = RI(e28, r), o = false, s10 = false, i, a;
    try {
      let u = t;
      if (t.includes("/")) {
        let c = t.split("/");
        u = c[c.length - 1];
      }
      let l = document.createElement("a");
      l.href = `data:application/json;charset=utf-8,${encodeURIComponent(n)}`, l.download = u, l.dispatchEvent(new MouseEvent("click")), o = true;
    } catch (u) {
      i = u;
    }
    try {
      let u = await import("node:fs"), l = await import("node:path");
      u.writeFileSync(l.resolve(t), n, "utf8"), s10 = true;
    } catch (u) {
      a = u;
    }
    if (!o && !s10) throw typeof window < "u" ? new Ca(i) : typeof module < "u" ? new Ca(a) : new Ca("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
    return e28;
  }
  function gV(e28) {
    let t = {};
    return e28.columns.forEach((r) => {
      t[r] = e28.get(r).values;
    }), t;
  }
  function Ks(e28) {
    if (Tt(e28) || At(e28)) return e28.transpose();
    B(it(e28), "The `transpose` function only works on arrays, Series, and DataFrames!");
    let t = Et(e28);
    if (B(t.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"), t.length === 1) return cs(e28);
    if (t.length === 2) {
      let r = Lo(cs(t));
      for (let n = 0; n < t[0]; n++) for (let o = 0; o < t[1]; o++) r[o][n] = e28[n][o];
      return r;
    }
  }
  function PI(e28, t, r) {
    if (At(r)) return new e28(t.values.concat(r.values));
    if (it(r)) {
      let n = Et(r);
      B(n.length === 1 && !oy(n), "Only vectors can be appended to Series!");
      let o = t.copy();
      return r.forEach((s10, i) => {
        o._values.push(s10), o._index.push("item" + (t.values.length + i));
      }), o;
    }
    return PI(t, [r]);
  }
  function yV(e28, t) {
    B(ur(t), "The parameter to the `apply` method must be a function.");
    let r = e28.copy();
    return r._values = r._values.map((n, o) => t(n, o)), r;
  }
  function xV(e28) {
    let t = e28.copy(), r = [];
    return t._values = t.values.filter((n, o) => It(n) ? false : (r.push(t.index[o]), true)), t._index = r, t;
  }
  function bV(e28, t) {
    let r = [], n = [];
    t.values.forEach((s10, i) => {
      dt(s10) && (n.push(s10), r.push(t.index[i]));
    });
    let o = new e28(n);
    return o.name = t.name, o.index = r, o;
  }
  function wV(e28, t, r) {
    let n = t.copy(), o = Xr(n.index), s10 = [], i = n.values.filter((a, u) => {
      let l = r(a, u, n.values);
      return l || s10.push(n.index[u]), l;
    });
    return s10.forEach((a) => {
      o.splice(o.indexOf(a), 1);
    }), i.length === 0 ? (n = new e28(), n.name = t.name, n) : (n.values = i, n.index = o, n);
  }
  function vV(e28, t) {
    (Ge(t) || dt(t)) && (t = [t]);
    for (let n in t) typeof t[n] == "bigint" && (t[n] = Number(t[n]));
    let r = co((t || []).map((n) => typeof n));
    return B(r.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!"), r.length === 1 && B(r[0] === "string" || r[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!"), r.length === 2 && (B(r.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!"), B(r.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!")), It(t) || (t = t.map((n) => {
      if (typeof n == "string") return B(e28.index.indexOf(n) > -1, `Index "${n}" does not exist!`), n;
      if (typeof n == "number") return B(n >= 0, `Index ${n} is out of bounds!`), B(Math.floor(n) === n, "Indices must be integers!"), B(n < e28.index.length, `Index ${n} is out of bounds!`), e28.index[n];
    })), e28.getSubsetByNames(t);
  }
  function NV(e28, t) {
    let r = e28.shape;
    It(t) && (t = hr(0, r[0])), B(it(t), "The `indices` array must be 1-dimensional array of whole numbers."), B(Et(t).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers."), B(t.length > 0, "The `indices` array must contain at least one index."), t.forEach((o) => {
      B(vc(o), "The `indices` array must be a 1-dimensional array of whole numbers."), B(o < e28.index.length, `The row index ${o} is out of bounds.`);
    });
    let n = t.map((o) => e28.index[o]);
    return e28.getSubsetByNames(n);
  }
  function CV(e28, t, r) {
    It(r) && (r = t.index), B(it(r), "The `indices` array must be a 1-dimensional array of strings."), B(Et(r).length === 1, "The `indices` array must be a 1-dimensional array of strings."), B(r.length > 0, "The `indices` array must contain at least one index name."), r.forEach((s10) => {
      B(Ge(s10), "The `indices` array must contain only strings."), B(t.index.indexOf(s10) > -1, `The name "${s10}" does not exist in the index.`);
    });
    let n = r.map((s10) => t.values[t.index.indexOf(s10)]);
    if (n.length === 1) return n[0];
    let o = new e28(n);
    return o.index = r, o.name = t.name, o;
  }
  function SV(e28) {
    let t = e28.copy(), r = typeof window > "u" ? 20 : 10;
    if (t.index.length > r) {
      t = t.get(hr(0, r / 2).concat(hr(t.index.length - r / 2, t.index.length)));
      let o = Xr(t.index);
      o.splice(Math.floor(o.length / 2), 0, "..."), t.values.push("..."), t.index.push("..."), t = t.get(o);
    }
    let n = {};
    return t.values.forEach((o, s10) => {
      let i = {};
      i[t.name] = o, n[t.index[s10]] = i;
    }), console.table(n), console.log("Shape:", e28.shape, `
`), e28;
  }
  function IV(e28) {
    let t = e28.copy();
    return t.get(ey(t.index));
  }
  function TV(e28, t, r) {
    r = r || ((u, l) => u < l ? -1 : 1), B(It(r) || ur(r), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    let n = Ks([t.values, t.index]), o = Zu(n, (u, l) => r(u[0], l[0])), s10 = [], i = [];
    o.forEach((u) => {
      s10.push(u[0]), i.push(u[1]);
    });
    let a = new e28();
    return a._values = s10, a._index = i, a.name = t.name, a;
  }
  function kV(e28, t) {
    let r = Ks([t.values, t.index]);
    r = Ks(Zu(r, (o, s10) => {
      if (o[1] === s10[1]) return 0;
      if (o[1] < s10[1]) return -1;
      if (o[1] > s10[1]) return 1;
    }));
    let n = new e28(r[0]);
    return n.index = r[1], n.name = t.name, n;
  }
  function EV(e28) {
    let t = {};
    return t[e28.name] = {}, e28.index.forEach((r, n) => {
      t[e28.name][r] = e28.values[n];
    }), t;
  }
  var SI = Symbol.for("@jrc03c/js-math-tools/series");
  function AV(e28) {
    class t {
      static [Symbol.hasInstance](n) {
        try {
          return !!n._symbol && n._symbol === SI;
        } catch {
          return false;
        }
      }
      constructor(n) {
        if (this.name = "data", Object.defineProperty(this, "_symbol", { configurable: false, enumerable: false, writable: false, value: SI }), Object.defineProperty(this, "_values", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "values", { configurable: true, enumerable: true, get() {
          return this._values;
        }, set(o) {
          B(it(o), "The new values must be a 1-dimensional array!");
          let s10 = Et(o);
          B(s10.length === 1, "The new array of values must be 1-dimensional!"), s10[0] < this._index.length ? this._index = this._index.slice(0, s10[0]) : s10[0] > this._index.length && (this._index = this._index.concat(hr(this._index.length, s10[0]).map((i) => "item" + xc(i, (o.length - 1).toString().length)))), this._values = o;
        } }), Object.defineProperty(this, "_index", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "index", { configurable: true, enumerable: true, get() {
          return this._index;
        }, set(o) {
          B(it(o), "The new index must be a 1-dimensional array of strings!"), B(o.length === this.shape[0], "The new index must be the same length as the old index!"), B(Et(o).length === 1, "The new index must be a 1-dimensional array of strings!"), o.forEach((s10) => {
            B(Ge(s10), "All of the row names must be strings!");
          }), this._index = o;
        } }), n) {
          if (n instanceof t) this.name = n.name, this.values = Xr(n.values), this.index = Xr(n.index);
          else if (it(n)) {
            let o = Et(n);
            B(o.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!"), this.values = n;
          } else if (n instanceof Object) {
            let o = Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map((a) => a.toString());
            B(o.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            let s10 = o[0], i = n[s10];
            B(Et(i).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"), this.name = s10, this.values = i.slice();
          }
        }
      }
      get shape() {
        return Et(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((n) => !It(n)).length === 0;
      }
      clear() {
        let n = this.copy();
        return n.values.forEach((o, s10) => {
          n.values[s10] = void 0;
        }), n;
      }
      get(n) {
        return vV(this, n);
      }
      getSubsetByNames(n) {
        return CV(t, this, n);
      }
      getSubsetByIndices(n) {
        return NV(this, n);
      }
      loc(n) {
        return this.getSubsetByNames(n);
      }
      iloc(n) {
        return this.getSubsetByIndices(n);
      }
      reverse() {
        let n = new t(cs(this.values));
        return n.index = cs(this.index), n.name = this.name, n;
      }
      resetIndex() {
        let n = this.copy();
        return n.index = hr(0, this.shape[0]).map((o) => "item" + xc(o, (n.index.length - 1).toString().length)), n;
      }
      copy() {
        let n = new t();
        return n._values = Xr(this.values), n._index = Xr(this.index), n.name = this.name, n;
      }
      append(n) {
        return PI(t, this, n);
      }
      apply(n) {
        return yV(this, n);
      }
      concat(n) {
        return this.append(n);
      }
      dropMissing(n, o) {
        return xV(this, n, o);
      }
      dropNaN() {
        return bV(t, this);
      }
      toObject() {
        return EV(this);
      }
      print() {
        return SV(this);
      }
      shuffle() {
        return IV(this);
      }
      sort(n) {
        return TV(t, this, n);
      }
      sortByIndex() {
        return kV(t, this);
      }
      filter(n) {
        return wV(t, this, n);
      }
      toDataFrame() {
        let n = new e28(Ks([this.values]));
        return n.columns = [this.name], n.index = this.index, n;
      }
      transpose() {
        let n = this.copy();
        return n.values = cs(n.values), n.index = cs(n.index), n;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return t;
  }
  var II = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function qg(e28) {
    let t = "abcdefghijklmnopqrstuvwxyz1234567890", r = "";
    for (let n = 0; n < e28; n++) r += t[Math.floor(po() * t.length)];
    return r;
  }
  var ar = class {
    static [Symbol.hasInstance](e28) {
      try {
        return !!e28._symbol && e28._symbol === II;
      } catch {
        return false;
      }
    }
    constructor(e28) {
      if (Object.defineProperty(this, "_symbol", { configurable: false, enumerable: false, writable: false, value: II }), Object.defineProperty(this, "_values", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "values", { configurable: true, enumerable: true, get() {
        return this._values.length === 0 || !It(this._values[0]) && this._values[0].length === 0 ? [[]] : this._values;
      }, set(t) {
        B(it(t), "The new values must be a 2-dimensional array!");
        let r = Et(t);
        B(r.length === 2, "The new array of values must be 2-dimensional!"), r[0] < this._index.length ? this._index = this._index.slice(0, r[0]) : r[0] > this._index.length && (this._index = this._index.concat(hr(this._index.length, r[0]).map((n) => "row" + xc(n, (r[0] - 1).toString().length)))), r[1] < this._columns.length ? this._columns = this._columns.slice(0, r[1]) : r[1] > this._columns.length && (this._columns = this._columns.concat(hr(this._columns.length, r[1]).map((n) => "col" + xc(n, (r[1] - 1).toString().length)))), this._values = t;
      } }), Object.defineProperty(this, "_columns", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "columns", { configurable: true, enumerable: true, get() {
        return this._columns;
      }, set(t) {
        B(it(t), "The new columns list must be a 1-dimensional array of strings!"), B(this.isEmpty || t.length === this.shape[1], "The new columns list must be the same length as the old columns list!"), B(Et(t).length === 1, "The new columns list must be a 1-dimensional array of strings!"), t = t.map((n) => (typeof n != "string" && (n = JSON.stringify(n) || n.toString()), n.trim().length === 0 ? "untitled_" + qg(8) : n.trim()));
        let r = (() => {
          let n = ty(t), o = {};
          return n.values.forEach((s10) => {
            o[s10] = n.get(s10);
          }), o;
        })();
        t = t.map((n) => r[n] > 1 ? n + "_" + qg(8) : n), this._columns = t;
      } }), Object.defineProperty(this, "_index", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "index", { configurable: true, enumerable: true, get() {
        return this._index;
      }, set(t) {
        B(it(t), "The new index must be a 1-dimensional array of strings!"), B(this.isEmpty || t.length === this.shape[0], "The new index must be the same length as the old index!"), B(Et(t).length === 1, "The new index must be a 1-dimensional array of strings!"), t = t.map((n) => (typeof n != "string" && (n = JSON.stringify(n) || n.toString()), n.trim().length === 0 ? "untitled_" + qg(8) : n.trim()));
        let r = (() => {
          let n = ty(t), o = {};
          return n.values.forEach((s10) => {
            o[s10] = n.get(s10);
          }), o;
        })();
        t = t.map((n) => r[n] > 1 ? n + "_" + qg(8) : n), this._index = t;
      } }), B(It(e28) || ps(e28) || it(e28), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."), e28) if (e28 instanceof ar) this.values = Xr(e28.values), this.columns = Xr(e28.columns), this.index = Xr(e28.index);
      else if (it(e28)) {
        let t = Et(e28);
        B(t.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"), B(!vf(e28), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"), this.values = e28;
      } else {
        this._columns = Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).map((s10) => s10.toString());
        let t = [], r = null, n = null;
        this._columns.forEach((s10) => {
          It(n) && (r = s10, n = e28[s10].length), B(e28[s10].length === n, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${r}" points to an array containing ${n} items, and the key "${s10}" points to an array containing ${e28[s10].length} items.`), n = e28[s10].length;
          let i = e28[s10];
          t.push(i);
        }), this._values = Ks(t);
        let o = Et(this.values);
        this._index = hr(0, o[0]).map((s10) => "row" + xc(s10, (o[0] - 1).toString().length));
      }
    }
    get shape() {
      return Et(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(e28) {
      this.index = e28;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((e28) => e28.length === 0);
    }
    clear() {
      let e28 = new ar(Lo(this.shape));
      return e28.columns = this.columns.slice(), e28.index = this.index.slice(), e28;
    }
    get(e28, t) {
      if (arguments.length === 0) return this;
      if (arguments.length === 1) try {
        return this.get(null, e28);
      } catch {
        return this.get(e28, null);
      }
      return eV(this, e28, t);
    }
    getSubsetByNames(e28, t) {
      return sV(ar, xn, this, e28, t);
    }
    getSubsetByIndices(e28, t) {
      return oV(this, e28, t);
    }
    getDummies(e28) {
      return vI(ar, this, e28);
    }
    oneHotEncode(e28) {
      return vI(ar, this, e28);
    }
    transpose() {
      let e28 = new ar(Ks(this.values));
      return e28.columns = this.index.slice(), e28.index = this.columns.slice(), e28;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(e28) {
      return aV(this, e28);
    }
    copy() {
      return YB(ar, this);
    }
    assign(e28, t) {
      return XB(ar, xn, this, e28, t);
    }
    apply(e28, t) {
      return qB(ar, xn, this, e28, t);
    }
    dropMissing(e28, t, r) {
      return ZB(ar, xn, this, e28, t, r);
    }
    dropNaN(e28, t, r) {
      return QB(ar, this, e28, t, r);
    }
    drop(e28, t) {
      return JB(ar, xn, this, e28, t);
    }
    dropColumns(e28) {
      return this.drop(null, e28);
    }
    dropRows(e28) {
      return this.drop(e28, null);
    }
    toDetailedObject(e28) {
      return hV(this, e28);
    }
    toObject() {
      return gV(this);
    }
    toJSONString(e28) {
      return RI(this, e28);
    }
    saveAsJSON(e28, t) {
      return dV(this, e28, t);
    }
    print() {
      return iV(ar, xn, this);
    }
    sort(e28, t) {
      return pV(this, e28, t);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(e28, t) {
      return tV(ar, xn, this, e28, t);
    }
    shuffle(e28) {
      return cV(this, e28);
    }
    append(e28, t) {
      return $I(this, e28, t);
    }
    concat(e28, t) {
      return this.append(e28, t);
    }
    join(e28, t) {
      return this.append(e28, t);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var xn = AV(ar);
  function sy(e28, t) {
    return qn(e28, { shouldDropNaNs: t }).max;
  }
  function Fe(e28) {
    return B(ur(e28), "You must pass a function into the `vectorize` function!"), function t() {
      let r, n, o = [], s10 = [], i = Object.keys(arguments).filter((a) => {
        let u = arguments[a];
        return it(u) ? true : At(u) ? (r = true, o.push(u), true) : Tt(u) ? (n = true, s10.push(u), true) : false;
      }).map((a) => arguments[a]);
      if (i.slice(0, -1).forEach((a, u) => {
        B(on(it(a) ? Et(a) : a.shape, it(i[u + 1]) ? Et(i[u + 1]) : i[u + 1].shape), `When passing multiple arrays into the \`${e28.name}\` function, all of the arrays must have the same shape!`);
      }), i.length > 0) {
        let a = sy(i.map((l) => l.length ? l.length : l.values.length)), u = hr(0, a).map((l) => {
          let c = Object.keys(arguments).map((p) => it(arguments[p]) ? arguments[p][l] : At(arguments[p]) || Tt(arguments[p]) ? arguments[p].values[l] : arguments[p]);
          return t(...c);
        });
        if (n) try {
          if (s10.length === 1 && on(Et(s10[0]), Et(u))) {
            let l = new ar(u);
            return l.index = s10[0].index.slice(), l.columns = s10[0].columns.slice(), l;
          } else return new ar(u);
        } catch {
          return u;
        }
        if (r) try {
          if (o.length === 1 && o[0].length === u.length) {
            let l = new xn(u);
            return l.name = o[0].name, l.index = o[0].index.slice(), l;
          } else return new xn(u);
        } catch {
          return u;
        }
        return u;
      } else return e28(...arguments);
    };
  }
  function DV(e28) {
    try {
      return dt(e28) ? typeof e28 == "bigint" ? e28 < 0 ? -e28 : e28 : Math.abs(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var Iv = Fe(DV);
  function $V() {
    try {
      let e28 = 0, t = false, r = Object.values(arguments);
      for (let n of r) {
        if (!dt(n)) return NaN;
        typeof n == "bigint" && (t = true, n = Number(n)), e28 += n;
      }
      if (t) try {
        return BigInt(e28);
      } catch {
      }
      return e28;
    } catch {
      return NaN;
    }
  }
  var Nc = Fe($V);
  function FV(e28, t) {
    try {
      return t(e28);
    } catch {
      return NaN;
    }
  }
  var Cc = Fe(FV);
  function _V(e28) {
    try {
      return dt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.acos(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var OV = Fe(_V);
  function RV(e28) {
    try {
      return dt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.asin(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var PV = Fe(RV);
  function LV(e28) {
    try {
      return dt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.atan(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var MV = Fe(LV);
  function gv(e28, t) {
    if (Tt(e28)) {
      let r = gv(e28.values, t);
      return [e28.index[r[0]], e28.columns[r[1]]];
    }
    if (At(e28)) {
      let r = gv(e28.values, t);
      return e28.index[r];
    }
    B(it(e28), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      let r = bc(e28, sy(e28, t));
      return r ? r.length === 0 ? void 0 : r.length === 1 ? r[0] : r : void 0;
    } catch {
      return;
    }
  }
  function LI(e28, t) {
    return qn(e28, { shouldDropNaNs: t }).min;
  }
  function xf(e28, t) {
    if (Tt(e28)) {
      let r = xf(e28.values, t);
      return [e28.index[r[0]], e28.columns[r[1]]];
    }
    if (At(e28)) {
      let r = xf(e28.values, t);
      return e28.index[r];
    }
    B(it(e28), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      let r = bc(e28, LI(e28, t));
      return r ? r.length === 0 ? void 0 : r.length === 1 ? r[0] : r : void 0;
    } catch {
      return;
    }
  }
  function Kn(e28, t) {
    if (Tt(e28) || At(e28)) return e28.apply((r) => Kn(r, t));
    if (it(e28)) return e28.map((r) => Kn(r, t));
    if (t === "null") return null;
    if (t === "number") {
      if (It(e28)) return NaN;
      let r = Kn(e28, "boolean");
      if (Ju(r)) return r ? 1 : 0;
      try {
        JSON.parse(e28);
      } catch {
        let s10 = Kn(e28, "date");
        if (Hs(s10)) return s10.getTime();
      }
      let n = parseFloat(e28);
      return isNaN(n) ? NaN : n;
    }
    if (t === "int") {
      let r = Kn(e28, "number");
      return r >= 0 ? Math.floor(r) : Math.ceil(r);
    }
    if (t === "float") return Kn(e28, "number");
    if (t === "bigint") return typeof e28 == "bigint" ? e28 : BigInt(Kn(e28, "int"));
    if (t === "boolean") {
      if (Ju(e28)) return e28;
      if (dt(e28)) return e28 === 0 ? false : e28 === 1 ? true : null;
      try {
        let r = (typeof e28 == "object" ? e28.toString() === "null" ? "false" : JSON.stringify(e28) : e28.toString()).trim().toLowerCase();
        return r === "true" || r === "yes" || r === "y" ? true : r === "false" || r === "no" || r === "n" ? false : null;
      } catch {
        return null;
      }
    }
    if (t === "date") {
      if (Hs(e28)) return e28;
      if (It(e28)) return null;
      let r = parseFloat(e28);
      if (!isNaN(r)) {
        let o = new Date(e28);
        return Hs(o) ? o : null;
      }
      let n = Date.parse(e28);
      return isNaN(n) ? null : new Date(n);
    }
    if (t === "object") {
      if (ps(e28)) return e28;
      let r = Kn(e28, "boolean");
      if (Ju(r)) return null;
      try {
        let o = Kn(e28, "number");
        if (dt(o)) return JSON.parse(e28), null;
      } catch {
      }
      let n = Kn(e28, "date");
      if (n) return n;
      try {
        let o = JSON.parse(e28);
        return it(o) ? o.map((s10) => Kn(s10, t)) : o;
      } catch {
        return null;
      }
    }
    if (t === "string") return It(e28) ? on(e28, void 0) ? "undefined" : "null" : e28 instanceof Date ? e28.toJSON() : typeof e28 == "object" ? e28 === null ? "null" : JSON.stringify(e28) : e28.toString();
  }
  function zV(e28) {
    try {
      return dt(e28) ? typeof e28 == "bigint" ? e28 : Math.ceil(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var BV = Fe(zV);
  function VV(e28, t) {
    try {
      if (!dt(e28)) return NaN;
      if (typeof e28 == "bigint") return e28;
      if (It(t)) t = 1e-10;
      else if (!dt(t)) return NaN;
      return Iv(e28) < t ? 0 : e28;
    } catch {
      return NaN;
    }
  }
  var GV = Fe(VV);
  function yv(e28) {
    if (Tt(e28) || At(e28)) {
      let t = e28.copy();
      return t.values = yv(t.values), t;
    }
    if (it(e28)) return e28.map((t) => yv(t));
    try {
      let t = JSON.parse(e28);
      return dt(t) ? typeof t == "bigint" ? Number(t) : t >= 0 ? Math.floor(t) : Math.ceil(t) : NaN;
    } catch {
      return NaN;
    }
  }
  var Xn = Fe(yv);
  function MI(e28, t, r) {
    try {
      return dt(e28) ? dt(t) ? dt(r) ? typeof e28 == "bigint" ? BigInt(MI(Xn(e28), t, r)) : e28 < t ? t : e28 > r ? r : e28 : NaN : NaN : NaN;
    } catch {
      return NaN;
    }
  }
  var WV = Fe(MI);
  function ry(e28, t) {
    function* r(n, o) {
      if (o > n.length) yield n;
      else if (o <= 0) yield [];
      else if (n.length < 2) yield n;
      else for (let s10 = 0; s10 < n.length; s10++) {
        let i = n[s10], a = n.slice(s10 + 1);
        if (!(a.length < o - 1) && o - 1 >= 0) for (let u of ry(a, o - 1)) yield [i].concat(u);
      }
    }
    return Tt(e28) || At(e28) ? ry(e28.values, t) : (B(it(e28), "The `combinations` function only works on arrays, Series, and DataFrames!"), B(dt(t) && Xn(t) === t && t >= 0, "`r` must be a non-negative integer!"), r(An(e28), t));
  }
  function zI(e28, t) {
    let r = [];
    for (let n of ry(e28, t)) r.push(n.slice());
    return r;
  }
  function BI() {
    let e28 = Object.values(arguments).map((r) => Tt(r) || At(r) ? co(r.values) : (B(it(r), "The `intersect` function only works on arrays, Series, and DataFrames!"), co(r)));
    return co(e28).filter((r) => e28.every((n) => n.findIndex((o) => on(o, r)) > -1));
  }
  var hf = class {
    constructor(e28) {
      B(It(e28) || e28 === hf.DROP_NAN_MODE || e28 === hf.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"), this.mode = It(e28) ? hf.DROP_NAN_MODE : e28, this.index = null;
    }
    fit() {
      let e28 = [];
      return Object.values(arguments).forEach((t) => {
        if (it(t)) {
          let r = Et(t);
          if (r.length === 1) t = new xn(t);
          else if (r.length === 2) t = new ar(t);
          else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        }
        B(Tt(t) || At(t), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"), this.mode === hf.DROP_MISSING_MODE ? e28.push(t.dropMissing().index) : e28.push(t.dropNaN().index);
      }), this.index = BI(...e28), this;
    }
    transform() {
      B(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      let e28 = Object.values(arguments).map((t) => {
        if (it(t)) {
          let r = Et(t);
          if (r.length === 1) return new xn(t).get(this.index).values;
          if (r.length === 2) return new ar(t).get(this.index, null).values;
          throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        }
        return B(Tt(t) || At(t), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"), t.get(this.index, null);
      });
      return e28.length === 1 ? e28[0] : e28;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var iy = hf;
  EI(iy, "DROP_NAN_MODE", "DROP_NAN_MODE");
  EI(iy, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function gf(e28, t, r, n) {
    if (At(e28)) return gf(e28.values, t, r, n);
    if (At(t)) return gf(e28, t.values, r, n);
    if (B(it(e28) && it(t) && Et(e28).length === 1 && Et(t).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!"), B(e28.length === t.length, "The two arrays or Series passed into the `covariance` function must have the same length!"), r) return gf(...new iy().fitAndTransform(e28, t), false, n);
    try {
      let o = qn(e28, { stdev: n }), s10 = qn(t, { stdev: n }), i = Number(o.mean), a = Number(s10.mean);
      if (!dt(i) || !dt(a)) return NaN;
      let u = Math.max(e28.length, t.length), l = 0;
      for (let c = 0; c < u; c++) {
        let p = e28[c], m = t[c];
        if (!dt(p)) return NaN;
        if (!dt(m)) return NaN;
        typeof p == "bigint" && (p = Number(p)), typeof m == "bigint" && (m = Number(m)), l += (p - i) * (m - a);
      }
      return n ? [l / e28.length, o, s10] : l / e28.length;
    } catch {
      return NaN;
    }
  }
  function xv(e28, t, r) {
    if (At(e28)) return xv(e28.values, t, r);
    if (At(t)) return xv(e28, t.values, r);
    B(it(e28) && it(t) && Et(e28).length === 1 && Et(t).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!"), B(e28.length === t.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      let [o, s10, i] = gf(e28, t, r, true), a = s10.stdev * i.stdev;
      return o / a;
    } catch {
      return NaN;
    }
  }
  function UV(e28) {
    try {
      return dt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.cos(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var jV = Fe(UV);
  var HV = Object.freeze({ boolean: "boolean", date: "date", null: "null", number: "number", object: "object", string: "string" });
  function bv(e28, t) {
    if (Tt(e28) || At(e28)) return bv(e28.values, t);
    if (Tt(t) || At(t)) return bv(e28, t.values);
    B(it(e28) && it(t), "The `diff` function only works on arrays, Series, and DataFrames!");
    let r = co(e28), n = co(t), o = [];
    return r.forEach((s10) => {
      n.findIndex((i) => on(i, s10)) < 0 && o.push(s10);
    }), o;
  }
  function VI(e28, t) {
    try {
      if (!dt(e28)) return NaN;
      if (!dt(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = VI(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return Math.pow(e28, t);
    } catch {
      return NaN;
    }
  }
  var Tv = Fe(VI);
  function GI(e28) {
    try {
      if (!dt(e28)) return NaN;
      if (typeof e28 == "bigint") {
        let t = GI(Number(e28));
        try {
          return BigInt(t);
        } catch {
          return t;
        }
      }
      return Math.sqrt(e28);
    } catch {
      return NaN;
    }
  }
  var WI = Fe(GI);
  function KV() {
    try {
      let e28 = Object.values(arguments);
      if (e28.length === 0) return NaN;
      let t = false, r = 1;
      for (let n of e28) {
        if (!dt(n)) return NaN;
        typeof n == "bigint" && (t = true, n = Number(n)), r *= n;
      }
      if (t) try {
        return BigInt(r);
      } catch {
      }
      return r;
    } catch {
      return NaN;
    }
  }
  var UI = Fe(KV);
  function Sa() {
    return UI(...arguments);
  }
  function jI(e28, t) {
    return Nc(e28, Sa(t, -1));
  }
  function kv(e28, t) {
    return qn(e28, { shouldDropNaNs: t }).sum;
  }
  function bf(e28, t) {
    if (dt(e28) && dt(t)) return Iv(e28 - t);
    if (Tt(e28) || At(e28)) return bf(e28.values, t);
    if (Tt(t) || At(t)) return bf(e28, t.values);
    it(e28) && it(t) && B(on(Et(e28), Et(t)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    try {
      return WI(kv(Tv(jI(e28, t), 2)));
    } catch {
      return NaN;
    }
  }
  function qV(e28, t) {
    return Sa(e28, Tv(t, -1));
  }
  function js(e28, t) {
    if (Tt(e28)) {
      let o = js(e28.values, t);
      if (Et(o).length === 1) {
        let s10 = new xn(o);
        return s10.name = At(t) ? t.name : s10.name, s10.index = e28.index.slice(), s10;
      } else {
        let s10 = new ar(o);
        return s10.index = e28.index.slice(), Tt(t) && (s10.columns = t.columns.slice()), s10;
      }
    }
    if (Tt(t)) {
      let o = js(e28, t.values);
      if (Et(o).length === 1) {
        let s10 = new xn(o);
        return s10.name = At(e28) ? e28.name : s10.name, s10.index = t.columns.slice(), s10;
      } else {
        let s10 = new ar(o);
        return s10.columns = t.columns.slice(), s10;
      }
    }
    if (At(e28)) return js(e28.values, t);
    if (At(t)) return js(e28, t.values);
    B(it(e28) && it(t), "The `dot` function only works on arrays, Series, and DataFrames!");
    let r = Et(e28), n = Et(t);
    if (B(r.length <= 2 && n.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"), B(r[r.length - 1] === n[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${r[r.length - 1]} !== ${n[0]})`), r.length === 1 && n.length === 1) return kv(Sa(e28, t));
    if (r.length === 1 && n.length === 2) return Ks(t).map((o) => js(e28, o));
    if (r.length === 2 && n.length === 1) return e28.map((o) => js(o, t));
    if (r.length === 2 && n.length === 2) {
      let o = Ks(t), s10 = [];
      for (let i = 0; i < e28.length; i++) {
        let a = [];
        for (let u = 0; u < o.length; u++) a.push(js(e28[i], o[u]));
        s10.push(a);
      }
      return s10;
    }
  }
  function Ev(e28) {
    if (Tt(e28) || At(e28)) return e28.dropMissing(...Object.values(arguments).slice(1));
    B(it(e28), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    let t = [];
    return e28.forEach((r) => {
      try {
        return t.push(Ev(r));
      } catch {
        It(r) || t.push(r);
      }
    }), t;
  }
  function Yg(e28, t) {
    if (Tt(e28) || At(e28)) return Yg(e28.values, t);
    if (Tt(t) || At(t)) return Yg(e28, t.values);
    B(it(e28) && it(t), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"), B(on(Et(e28), Et(t)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    let r = [], n = [];
    for (let o = 0; o < e28.length; o++) try {
      let [s10, i] = Yg(e28[o], t[o]);
      r.push(s10), n.push(i);
    } catch {
      !It(e28[o]) && !It(t[o]) && (r.push(e28[o]), n.push(t[o]));
    }
    return [r, n];
  }
  function Jg(e28, t) {
    if (Tt(e28) || At(e28)) return Jg(e28.values, t);
    if (Tt(t) || At(t)) return Jg(e28, t.values);
    B(it(e28) && it(t), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"), B(on(Et(e28), Et(t)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    let r = [], n = [];
    for (let o = 0; o < e28.length; o++) try {
      let [s10, i] = Jg(e28[o], t[o]);
      r.push(s10), n.push(i);
    } catch {
      dt(e28[o]) && dt(t[o]) && (r.push(e28[o]), n.push(t[o]));
    }
    return [r, n];
  }
  function XV(e28) {
    return Ev(e28);
  }
  function ny(e28, t) {
    if (Tt(e28) || At(e28)) return ny(e28.values, t);
    B(it(e28), "The first argument passed into the `every` function must be an array, Series, or DataFrame!"), B(ur(t), "The second argument passed into the `every` function must be a function!");
    for (let r of e28) if (it(r)) {
      if (!ny(r, t)) return false;
    } else if (!t(r)) return false;
    return true;
  }
  function YV(e28) {
    try {
      if (!dt(e28)) return NaN;
      if (typeof e28 == "bigint") {
        if (e28 === 0n) return 1n;
        e28 = Number(e28);
      }
      return Math.exp(e28);
    } catch {
      return NaN;
    }
  }
  var JV = Fe(YV);
  function wv(e28) {
    try {
      return typeof e28 == "bigint" ? BigInt(wv(Xn(e28))) : e28 !== Xn(e28) ? NaN : e28 <= 1 ? 1 : e28 * wv(e28 - 1);
    } catch {
      return NaN;
    }
  }
  var ZV = Fe(wv);
  function vv(e28, t) {
    if (Tt(e28) || At(e28)) return vv(e28.values, t);
    if (B(ps(e28) || it(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"), !ur(t)) {
      let o = t;
      t = (s10) => s10 === o;
    }
    function r(o, s10, i) {
      if (i = i || [], i.indexOf(o) > -1) return null;
      if (ps(o)) {
        i.push(o);
        let a = Object.keys(o).concat(Object.getOwnPropertySymbols(o));
        for (let u = 0; u < a.length; u++) {
          let l = a[u], c = o[l];
          if (s10(c)) return c;
          let p = r(c, s10, i);
          if (p) return p;
        }
      } else if (it(o)) {
        i.push(o);
        for (let a = 0; a < o.length; a++) {
          let u = o[a];
          if (s10(u)) return u;
          let l = r(u, s10, i);
          if (l) return l;
        }
      } else if (s10(o)) return o;
      return null;
    }
    function n(o) {
      try {
        return t(o);
      } catch {
        return false;
      }
    }
    return r(e28, n);
  }
  function Nv(e28, t) {
    if (Tt(e28) || At(e28)) return Nv(e28.values, t);
    if (B(ps(e28) || it(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"), !ur(t)) {
      let s10 = t;
      t = (i) => i === s10;
    }
    function r(s10, i, a) {
      if (a = a || [], a.indexOf(s10) > -1) return null;
      if (ps(s10)) {
        a.push(s10);
        let u = Object.keys(s10).concat(Object.getOwnPropertySymbols(s10)), l = [];
        for (let c = 0; c < u.length; c++) {
          let p = u[c], m = s10[p], f = false;
          i(m) && (l.push(m), f = true);
          let h = r(m, i, a);
          h && h.length > 0 && h.slice(f ? 1 : 0).forEach((d) => l.push(d));
        }
        return l;
      } else if (it(s10)) {
        a.push(s10);
        let u = [];
        for (let l = 0; l < s10.length; l++) {
          let c = s10[l], p = false;
          i(c) && (u.push(c), p = true);
          let m = r(c, i, a);
          m && m.length > 0 && m.slice(p ? 1 : 0).forEach((f) => u.push(f));
        }
        return u;
      } else if (i(s10)) return [s10];
      return null;
    }
    function n(s10) {
      try {
        return t(s10);
      } catch {
        return false;
      }
    }
    let o = r(e28, n);
    return o && o.length > 0 ? o : null;
  }
  function QV(e28) {
    try {
      if (e28 === "Infinity") return 1 / 0;
      if (e28 === "-Infinity") return -1 / 0;
      let t = JSON.parse(e28);
      return dt(t) ? t : NaN;
    } catch {
      return NaN;
    }
  }
  var ms = Fe(QV);
  function tG(e28) {
    try {
      return dt(e28) ? typeof e28 == "bigint" ? e28 : Math.floor(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var eG = Fe(tG);
  function Av(e28) {
    dt(e28) && (e28 = [e28]);
    let t = [], r = Cf(e28);
    for (let n = 0; n < r; n++) t.push(0);
    return yf(t, e28);
  }
  function rG(e28) {
    typeof e28 == "bigint" && (e28 = Xn(e28)), B(!It(e28), "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), B(dt(e28), "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), B(Xn(e28) === e28, "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), B(e28 > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    let t = Av([e28, e28]);
    for (let r = 0; r < e28; r++) t[r][r] = 1;
    return t;
  }
  var nG = ["true", "false", "yes", "no"];
  var oG = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function Xg(e28) {
    return e28.type === "number" && (typeof e28.value < "u" ? e28.isInteger = Xn(e28.value) === e28.value : e28.isInteger = ny(e28.values, (t) => dt(t) ? Xn(t) === t : true)), e28;
  }
  function Zg(e28) {
    if (Tt(e28)) {
      let s10 = e28.copy(), i = Zg(e28.values);
      return s10.values = i.values, Xg({ type: i.type, values: s10 });
    }
    if (At(e28)) {
      let s10 = e28.copy(), i = Zg(e28.values);
      return s10.values = i.values, Xg({ type: i.type, values: s10 });
    }
    if (!it(e28)) {
      let s10 = Zg([e28]);
      return s10.value = s10.values[0], delete s10.values, Xg(s10);
    }
    B(it(e28), "The `inferType` function only works on arrays, Series, and DataFrames!");
    let t = An(e28).map((s10) => {
      if (s10 === void 0) return "null";
      try {
        if (typeof s10 == "object") {
          let u = new Date(s10.getTime());
          if (Hs(u)) return "date";
        }
      } catch {
      }
      Ge(s10) || (typeof s10 == "bigint" ? s10 = s10.toString() + "n" : s10 = JSON.stringify(s10));
      let a = s10.toLowerCase().trim();
      if (oG.indexOf(a) > -1) return "null";
      if (nG.indexOf(a) > -1) return "boolean";
      try {
        if (s10.match(/^-?\d+n$/g)) return "bigint";
        let u = JSON.parse(s10);
        return dt(u) ? "number" : typeof u == "object" ? it(u) ? "string" : "object" : "string";
      } catch {
        let l = new Date(s10);
        return Hs(l) ? "date" : "string";
      }
    }), r = ty(t), o = r.values.toSorted((s10, i) => r.get(i) - r.get(s10))[0];
    return Xg({ type: o, values: Cc(e28, (s10) => Kn(s10, o)) });
  }
  function Qg(e28) {
    if (Tt(e28)) {
      let r = e28.copy();
      return r.values = Qg(r.values), r;
    }
    B(it(e28), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    let t = Et(e28);
    if (B(t.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!"), B(t[0] === t[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!"), B(t[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!"), t[0] === 0) return e28;
    if (t[0] === 1) {
      B(e28[0][0] !== 0, "This matrix cannot be inverted!");
      let r = e28[0][0];
      return typeof r == "bigint" && (r = Number(r)), 1 / r;
    } else if (t[0] === 2) {
      let r = e28[0][0], n = e28[0][1], o = e28[1][0], s10 = e28[1][1];
      typeof r == "bigint" && (r = Number(r)), typeof n == "bigint" && (n = Number(n)), typeof o == "bigint" && (o = Number(o)), typeof s10 == "bigint" && (s10 = Number(s10));
      let i = r * s10 - n * o;
      B(i !== 0, "This matrix cannot be inverted!");
      let a = [[s10, -n], [-o, r]];
      return Sa(a, 1 / i);
    } else if (t[0] > 1) {
      let r = (n, o) => dt(n) || dt(o) ? Sa(n, o) : js(n, o);
      for (let n = 1; n < t[0] - 1; n++) try {
        let o = e28.slice(0, n).map((d) => d.slice(0, n)), s10 = e28.slice(0, n).map((d) => d.slice(n, t[0])), i = e28.slice(n, t[0]).map((d) => d.slice(0, n)), a = e28.slice(n, t[0]).map((d) => d.slice(n, t[0])), u = Qg(o), l = Qg(Nc(a, r(-1, r(r(i, u), s10)))), c = Nc(u, r(r(r(r(u, s10), l), i), u)), p = r(-1, r(r(u, s10), l)), m = r(-1, r(r(l, i), u)), f = l;
        return c.map((d, g) => d.concat(p[g])).concat(m.map((d, g) => d.concat(f[g])));
      } catch {
      }
      B(false, "This matrix cannot be inverted!");
    }
  }
  var sG = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function HI(e28, t, r) {
    try {
      if (!dt(e28)) return NaN;
      if (!dt(t)) return NaN;
      if (!dt(r)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let n = HI(Number(e28), Number(t), r);
        try {
          return BigInt(n);
        } catch {
          return n;
        }
      }
      return r * (t - e28) + e28;
    } catch {
      return NaN;
    }
  }
  var iG = Fe(HI);
  function KI(e28, t) {
    try {
      if (t = It(t) ? Math.E : t, !dt(e28)) return NaN;
      if (!dt(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = KI(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return Math.log(e28) / Math.log(t);
    } catch {
      return NaN;
    }
  }
  var aG = Fe(KI);
  function uG(e28, t) {
    return qn(e28, { shouldDropNaNs: t }).mean;
  }
  function lG(e28, t) {
    return qn(e28, { shouldDropNaNs: t, median: true }).median;
  }
  function qI(e28, t) {
    try {
      if (!dt(e28)) return NaN;
      if (!dt(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = qI(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return e28 % t;
    } catch {
      return NaN;
    }
  }
  var cG = Fe(qI);
  function pG(e28, t) {
    return qn(e28, { shouldDropNaNs: t, mode: true }).mode;
  }
  function TI() {
    let e28 = po(), t = po();
    return Math.sqrt(-2 * Math.log(e28)) * Math.cos(2 * Math.PI * t);
  }
  function Dv(e28) {
    return It(e28) ? TI() : Cc(Lo(e28), TI);
  }
  function mG(e28) {
    return Cc(Lo(e28), () => 1);
  }
  function $v(e28, t) {
    function* r(n, o) {
      if (o = o || n.length, n.length === 1) {
        yield [n];
        return;
      }
      for (let s10 of zI(n, o)) {
        if (!s10.slice) continue;
        let i = Av(s10.length);
        yield s10;
        let a = 1;
        for (; a < s10.length; ) if (i[a] < a) {
          if (a % 2 === 0) {
            let u = s10[0];
            s10[0] = s10[a], s10[a] = u;
          } else {
            let u = s10[i[a]];
            s10[i[a]] = s10[a], s10[a] = u;
          }
          yield s10, i[a] += 1, a = 1;
        } else i[a] = 0, a += 1;
      }
    }
    return Tt(e28) || At(e28) ? $v(e28.values, t) : (B(it(e28), "The `permutations` function only works on arrays, Series, and DataFrames!"), It(t) && (t = e28.length), B(dt(t) && Xn(t) === t && t >= 0, "`r` must be a non-negative integer!"), r(An(e28), t));
  }
  function fG(e28, t) {
    let r = [];
    for (let n of $v(e28, t)) r.push(n.slice());
    return r;
  }
  function hG() {
    Object.keys(arguments).forEach((e28) => {
      let t = arguments[e28];
      if (it(t)) if (vf(t)) console.log(t);
      else {
        let r = Et(t);
        r.length === 1 ? new xn(t).print() : r.length == 2 ? new ar(t).print() : console.log(t);
      }
      else Tt(t) || At(t) ? t.print() : console.log(t);
    });
  }
  var dG = Fe((e28, t, r, n, o) => {
    try {
      let s10 = false;
      for (let l of [e28, t, r, n, o]) {
        if (!dt(l)) return NaN;
        typeof l == "bigint" && (s10 = true);
      }
      s10 && (e28 = Number(e28), t = Number(t), r = Number(r), n = Number(n), o = Number(o));
      let i = (o - n) * (e28 - t), a = r - t;
      if (a === 0) return NaN;
      let u = i / a + n;
      if (s10) try {
        return BigInt(u);
      } catch {
      }
      return u;
    } catch {
      return NaN;
    }
  });
  function gG(e28, t, r, n, o) {
    if (it(e28) && It(n) && It(o)) {
      n = t, o = r;
      let s10 = qn(e28);
      t = s10.min, r = s10.max;
    }
    return dG(e28, t, r, n, o);
  }
  function yG(e28) {
    try {
      return dt(e28) ? typeof e28 == "bigint" ? e28 : Math.round(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var xG = Fe(yG);
  function XI(e28) {
    try {
      return dt(e28) ? typeof e28 == "bigint" ? BigInt(XI(Number(e28))) : e28 < 0 ? -1 : e28 > 0 ? 1 : 0 : NaN;
    } catch {
      return NaN;
    }
  }
  var bG = Fe(XI);
  function wG(e28) {
    try {
      return dt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.sin(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var vG = Fe(wG);
  function Cv(e28, t) {
    if (Tt(e28) || At(e28)) return Cv(e28.values, t);
    B(it(e28), "The first argument passed into the `some` function must be an array, Series, or DataFrame!"), B(ur(t), "The second argument passed into the `some` function must be a function!");
    for (let r of e28) if (it(r)) {
      if (Cv(r, t)) return true;
    } else if (t(r)) return true;
    return false;
  }
  function YI(e28, t) {
    return qn(e28, { shouldDropNaNs: t, stdev: true }).stdev;
  }
  function NG(e28) {
    return YI(e28);
  }
  function CG(e28) {
    try {
      return dt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.tan(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var SG = Fe(CG);
  function kI(e28, t) {
    B(ur(e28), "`fn` must be a function!");
    let r = /* @__PURE__ */ new Date();
    return t ? e28(...t) : e28(), /* @__PURE__ */ new Date() - r;
  }
  async function IG(e28, t) {
    B(ur(e28), "`fn` must be a function!");
    let r = /* @__PURE__ */ new Date();
    return t ? await e28(...t) : await e28(), /* @__PURE__ */ new Date() - r;
  }
  function TG() {
    return co([...arguments].map((e28) => it(e28) ? e28 : Tt(e28) || At(e28) ? e28.values : [e28]));
  }
  function kG(e28, t) {
    return qn(e28, { shouldDropNaNs: t, variance: true }).variance;
  }
  function EG() {
    let e28 = [], t = Object.values(arguments).map((r) => ((Tt(r) || At(r)) && (r = r.values), B(it(r), "The `zip` function only works on arrays, Series, and DataFrames!"), r));
    return hr(0, sy(t.map((r) => r.length))).forEach((r) => {
      let n = [];
      t.forEach((o) => {
        let s10 = o[r];
        n.push(It(s10) ? void 0 : s10);
      }), e28.push(n);
    }), e28;
  }
  var df = { abs: Iv, add: Nc, apply: Cc, arccos: OV, arcsin: PV, arctan: MV, argmax: gv, argmin: xf, assert: B, cast: Kn, ceil: BV, chop: GV, clamp: WV, combinations: zI, combinationsIterator: ry, copy: Xr, correl: xv, cos: jV, count: ty, covariance: gf, DataFrame: ar, dataTypes: HV, decycle: wc, diff: bv, distance: bf, divide: qV, dot: js, dropMissing: Ev, dropMissingPairwise: Yg, dropNaN: Sv, dropNaNPairwise: Jg, dropUndefined: XV, every: ny, exp: JV, factorial: ZV, find: vv, findAll: Nv, flatten: An, float: ms, floor: eG, identity: rG, IndexMatcher: iy, indexOf: bc, inferType: Zg, int: Xn, intersect: BI, inverse: Qg, isArray: it, isBoolean: Ju, isBrowser: sG, isDataFrame: Tt, isDate: Hs, isEqual: on, isFunction: ur, isJagged: vf, isNested: oy, isNumber: dt, isObject: ps, isSeries: At, isString: Ge, isUndefined: It, lerp: iG, log: aG, MathError: Ca, max: sy, mean: uG, median: lG, min: LI, mod: cG, mode: pG, multiply: UI, ndarray: Lo, normal: Dv, ones: mG, permutations: fG, permutationsIterator: $v, pow: Tv, print: hG, product: Cf, random: po, range: hr, remap: gG, reshape: yf, reverse: cs, round: xG, scale: Sa, seed: OI, Series: xn, set: co, shape: Et, shuffle: ey, sign: bG, sin: vG, some: Cv, sort: Zu, sqrt: WI, stats: qn, std: YI, stdev: NG, subtract: jI, sum: kv, tan: SG, timeAsync: IG, timeSync: kI, time: kI, transpose: Ks, union: TG, variance: kG, vectorize: Fe, zeros: Av, zip: EG, dump() {
    let e28 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : void 0;
    if (!e28) throw new df.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
    Object.keys(df).forEach((t) => {
      try {
        Object.defineProperty(e28, t, { configurable: false, enumerable: true, writable: false, value: df[t] });
      } catch {
        e28[t] = df[t];
      }
    });
  } };
  typeof window < "u" && (window.JSMathTools = df);
  var Qu = class {
    constructor(t, r) {
      this.backend = t, this.dataMover = r, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
    }
    get(t) {
      return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);
    }
    set(t, r) {
      this.dataIdsCount++, this.data.set(t, r);
    }
    has(t) {
      return this.data.has(t);
    }
    delete(t) {
      return this.dataIdsCount--, this.data.delete(t);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  };
  var qs = class {
    refCount(t) {
      return Dn("refCount");
    }
    incRef(t) {
      return Dn("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(t) {
      return Dn("time");
    }
    read(t) {
      return Dn("read");
    }
    readSync(t) {
      return Dn("readSync");
    }
    readToGPU(t, r) {
      return Dn("readToGPU");
    }
    numDataIds() {
      return Dn("numDataIds");
    }
    disposeData(t, r) {
      return Dn("disposeData");
    }
    write(t, r, n) {
      return Dn("write");
    }
    move(t, r, n, o, s10) {
      return Dn("move");
    }
    createTensorFromGPUData(t, r, n) {
      return Dn("createTensorFromGPUData");
    }
    memory() {
      return Dn("memory");
    }
    floatPrecision() {
      return Dn("floatPrecision");
    }
    epsilon() {
      return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
    }
    dispose() {
      return Dn("dispose");
    }
  };
  function Dn(e28) {
    throw new Error(`'${e28}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }
  function JI(e28) {
    let t = e28.length, r = 0;
    for (; t > 0; ) r = Math.random() * t | 0, t--, ay(e28, t, r);
  }
  function AG(e28, t) {
    if (e28.length !== t.length) throw new Error(`Array sizes must match to be shuffled together First array length was ${e28.length}Second array length was ${t.length}`);
    let r = e28.length, n = 0;
    for (; r > 0; ) n = Math.random() * r | 0, r--, ay(e28, r, n), ay(t, r, n);
  }
  function Sc(e28, t, r) {
    return Math.max(e28, Math.min(t, r));
  }
  function DG(e28) {
    return e28 % 2 === 0 ? e28 : e28 + 1;
  }
  function ay(e28, t, r) {
    let n = e28[t];
    e28[t] = e28[r], e28[r] = n;
  }
  function $G(e28) {
    let t = 0;
    for (let r = 0; r < e28.length; r++) t += e28[r];
    return t;
  }
  function FG(e28, t) {
    let r = Math.random();
    return t * r + (1 - r) * e28;
  }
  function _G(e28, t) {
    let r = 0;
    for (let n = 0; n < e28.length; n++) {
      let o = Number(e28[n]) - Number(t[n]);
      r += o * o;
    }
    return r;
  }
  function I(e28, t) {
    if (!e28) throw new Error(typeof t == "string" ? t : t());
  }
  function uy(e28, t, r = "") {
    I(Ia(e28, t), () => r + ` Shapes ${e28} and ${t} must match`);
  }
  function Sf(e28) {
    I(e28 != null, () => "The input to the tensor constructor must be a non-null value.");
  }
  function ie(e28) {
    if (e28.length === 0) return 1;
    let t = e28[0];
    for (let r = 1; r < e28.length; r++) t *= e28[r];
    return t;
  }
  function OG(e28) {
    return e28.length === 0;
  }
  function RG(e28, t) {
    if (e28 === t) return true;
    if (e28 == null || t == null || e28.length !== t.length) return false;
    for (let r = 0; r < e28.length; r++) if (e28[r] !== null && t[r] !== null && e28[r] !== t[r]) return false;
    return true;
  }
  function Ia(e28, t) {
    if (e28 === t) return true;
    if (e28 == null || t == null || e28.length !== t.length) return false;
    for (let r = 0; r < e28.length; r++) if (e28[r] !== t[r]) return false;
    return true;
  }
  function Xs(e28) {
    return e28 % 1 === 0;
  }
  function PG(e28) {
    if (Math.tanh != null) return Math.tanh(e28);
    if (e28 === 1 / 0) return 1;
    if (e28 === -1 / 0) return -1;
    {
      let t = Math.exp(2 * e28);
      return (t - 1) / (t + 1);
    }
  }
  function LG(e28) {
    let t = Math.ceil(Math.sqrt(e28));
    return [t, Math.ceil(e28 / t)];
  }
  function MG(e28) {
    let t = new Uint32Array(e28);
    for (let r = 0; r < e28; ++r) t[r] = r;
    return JI(t), t;
  }
  function el(e28, t) {
    return t <= e28.length ? e28 : e28 + " ".repeat(t - e28.length);
  }
  function zG(e28, t = (o) => 0, r, n) {
    return new Promise((o, s10) => {
      let i = 0, a = () => {
        if (e28()) {
          o();
          return;
        }
        i++;
        let u = t(i);
        if (r != null && i >= r) {
          s10();
          return;
        }
        n != null ? n(a, u) : setTimeout(a, u);
      };
      a();
    });
  }
  function BG(e28, t) {
    let r = 1, n = -1;
    for (let s10 = 0; s10 < e28.length; ++s10) if (e28[s10] >= 0) r *= e28[s10];
    else if (e28[s10] === -1) {
      if (n !== -1) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s10}`);
      n = s10;
    } else if (e28[s10] < 0) throw Error(`Shapes can not be < 0. Found ${e28[s10]} at dim ${s10}`);
    if (n === -1) {
      if (t > 0 && t !== r) throw Error(`Size(${t}) must match the product of shape ${e28}`);
      return e28;
    }
    if (r === 0) throw Error(`Cannot infer the missing size in [${e28}] when there are 0 elements`);
    if (t % r !== 0) throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${r}`);
    let o = e28.slice();
    return o[n] = t / r, o;
  }
  function dr(e28, t) {
    let r = t.length;
    return e28 = e28 == null ? t.map((n, o) => o) : [].concat(e28), I(e28.every((n) => n >= -r && n < r), () => `All values in axis param must be in range [-${r}, ${r}) but got axis ${e28}`), I(e28.every((n) => Xs(n)), () => `All values in axis param must be integers but got axis ${e28}`), e28.map((n) => n < 0 ? r + n : n);
  }
  function Fv(e28, t) {
    let r = [], n = [], o = t != null && Array.isArray(t) && t.length === 0, s10 = t == null || o ? null : dr(t, e28).sort(), i = 0;
    for (let a = 0; a < e28.length; ++a) {
      if (s10 != null) {
        if (s10[i] === a && e28[a] !== 1) throw new Error(`Can't squeeze axis ${a} since its dim '${e28[a]}' is not 1`);
        (s10[i] == null || s10[i] > a) && e28[a] === 1 && (r.push(e28[a]), n.push(a)), s10[i] <= a && i++;
      }
      e28[a] !== 1 && (r.push(e28[a]), n.push(a));
    }
    return { newShape: r, keptDims: n };
  }
  function VG(e28, t) {
    return ly(e28, t);
  }
  function ly(e28, t) {
    let r = null;
    if (e28 == null || e28 === "float32") r = new Float32Array(t);
    else if (e28 === "int32") r = new Int32Array(t);
    else if (e28 === "bool") r = new Uint8Array(t);
    else if (e28 === "string") r = new Array(t);
    else throw new Error(`Unknown data type ${e28}`);
    return r;
  }
  function _v(e28, t) {
    for (let r = 0; r < e28.length; r++) {
      let n = e28[r];
      if (isNaN(n) || !isFinite(n)) throw Error(`A tensor of type ${t} being uploaded contains ${n}.`);
    }
  }
  function Ov(e28) {
    return e28 === "bool" || e28 === "complex64" || e28 === "float32" || e28 === "int32" || e28 === "string";
  }
  function GG(e28, t) {
    return !(t === "complex64" || t === "float32" && e28 !== "complex64" || t === "int32" && e28 !== "float32" && e28 !== "complex64" || t === "bool" && e28 === "bool");
  }
  function Ic(e28) {
    if (e28 === "float32" || e28 === "int32") return 4;
    if (e28 === "complex64") return 8;
    if (e28 === "bool") return 1;
    throw new Error(`Unknown dtype ${e28}`);
  }
  function Rv(e28) {
    if (e28 == null) return 0;
    let t = 0;
    return e28.forEach((r) => t += r.length), t;
  }
  function Tc(e28) {
    return typeof e28 == "string" || e28 instanceof String;
  }
  function ZI(e28) {
    return typeof e28 == "boolean";
  }
  function QI(e28) {
    return typeof e28 == "number";
  }
  function Ta(e28) {
    return Array.isArray(e28) ? Ta(e28[0]) : e28 instanceof Float32Array ? "float32" : e28 instanceof Int32Array || e28 instanceof Uint8Array || e28 instanceof Uint8ClampedArray ? "int32" : QI(e28) ? "float32" : Tc(e28) ? "string" : ZI(e28) ? "bool" : "float32";
  }
  function kc(e28) {
    return !!(e28 && e28.constructor && e28.call && e28.apply);
  }
  function Ec(e28, t) {
    for (let r = t; r < e28; ++r) if (e28 % r === 0) return r;
    return e28;
  }
  function fs(e28) {
    let t = e28.length;
    if (t < 2) return [];
    let r = new Array(t - 1);
    r[t - 2] = e28[t - 1];
    for (let n = t - 3; n >= 0; --n) r[n] = r[n + 1] * e28[n + 1];
    return r;
  }
  function tT(e28, t, r, n = false) {
    let o = new Array();
    if (t.length === 1) {
      let s10 = t[0] * (n ? 2 : 1);
      for (let i = 0; i < s10; i++) o[i] = r[e28 + i];
    } else {
      let s10 = t[0], i = t.slice(1), a = i.reduce((u, l) => u * l) * (n ? 2 : 1);
      for (let u = 0; u < s10; u++) o[u] = tT(e28 + u * a, i, r, n);
    }
    return o;
  }
  function tl(e28, t, r = false) {
    if (e28.length === 0) return t[0];
    let n = e28.reduce((o, s10) => o * s10) * (r ? 2 : 1);
    if (n === 0) return [];
    if (n !== t.length) throw new Error(`[${e28}] does not match the input size ${t.length}${r ? " for a complex tensor" : ""}.`);
    return tT(0, e28, t, r);
  }
  function WG(e28, t) {
    if (Array.isArray(e28)) return e28;
    if (t === "float32") return e28 instanceof Float32Array ? e28 : new Float32Array(e28);
    if (t === "int32") return e28 instanceof Int32Array ? e28 : new Int32Array(e28);
    if (t === "bool" || t === "string") return Uint8Array.from(new Int32Array(e28));
    throw new Error(`Unknown dtype ${t}`);
  }
  function If(e28, t) {
    let r = Ac(e28, t);
    for (let n = 0; n < r.length; n++) r[n] = 1;
    return r;
  }
  function Ac(e28, t) {
    if (t == null || t === "float32" || t === "complex64") return new Float32Array(e28);
    if (t === "int32") return new Int32Array(e28);
    if (t === "bool") return new Uint8Array(e28);
    throw new Error(`Unknown data type ${t}`);
  }
  function UG(e28, t) {
    let r = e28.reduce((n, o) => n * o, 1);
    if (t == null || t === "float32") return tl(e28, new Float32Array(r));
    if (t === "int32") return tl(e28, new Int32Array(r));
    if (t === "bool") return tl(e28, new Uint8Array(r));
    throw new Error(`Unknown data type ${t}`);
  }
  function Ar(e28) {
    e28.forEach((t) => {
      I(Number.isInteger(t) && t >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${e28}].`);
    });
  }
  function jG(e28, t, r) {
    if (t === 0) return 0;
    if (t === 1) return e28[0];
    let n = e28[e28.length - 1];
    for (let o = 0; o < e28.length - 1; ++o) n += r[o] * e28[o];
    return n;
  }
  function HG(e28, t, r) {
    if (t === 0) return [];
    if (t === 1) return [e28];
    let n = new Array(t);
    for (let o = 0; o < n.length - 1; ++o) n[o] = Math.floor(e28 / r[o]), e28 -= n[o] * r[o];
    return n[n.length - 1] = e28, n;
  }
  function rl(e28) {
    return e28 && e28.then && typeof e28.then == "function";
  }
  var eT = "tfjsflags";
  var Tf = class {
    constructor(t) {
      this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = qG, this.populateURLFlags();
    }
    setPlatform(t, r) {
      this.platform != null && (z().getBool("IS_TEST") || z().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)), this.platformName = t, this.platform = r;
    }
    registerFlag(t, r, n) {
      if (this.flagRegistry[t] = { evaluationFn: r, setHook: n }, this.urlFlags[t] != null) {
        let o = this.urlFlags[t];
        z().getBool("IS_TEST") || z().getBool("PROD") || console.warn(`Setting feature override from URL ${t}: ${o}.`), this.set(t, o);
      }
    }
    async getAsync(t) {
      return t in this.flags ? this.flags[t] : (this.flags[t] = await this.evaluateFlag(t), this.flags[t]);
    }
    get(t) {
      if (t in this.flags) return this.flags[t];
      let r = this.evaluateFlag(t);
      if (rl(r)) throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);
      return this.flags[t] = r, this.flags[t];
    }
    getNumber(t) {
      return this.get(t);
    }
    getBool(t) {
      return this.get(t);
    }
    getString(t) {
      return this.get(t);
    }
    getFlags() {
      return this.flags;
    }
    get features() {
      return this.flags;
    }
    set(t, r) {
      if (this.flagRegistry[t] == null) throw new Error(`Cannot set flag ${t} as it has not been registered.`);
      this.flags[t] = r, this.flagRegistry[t].setHook != null && this.flagRegistry[t].setHook(r);
    }
    evaluateFlag(t) {
      if (this.flagRegistry[t] == null) throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);
      return this.flagRegistry[t].evaluationFn();
    }
    setFlags(t) {
      this.flags = Object.assign({}, t);
    }
    reset() {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u") return;
      let t = this.getQueryParams(this.global.location.search);
      eT in t && t[eT].split(",").forEach((n) => {
        let [o, s10] = n.split(":");
        this.urlFlags[o] = YG(o, s10);
      });
    }
  };
  function qG(e28) {
    let t = {};
    return e28.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (r, ...n) => (XG(t, n[0], n[1]), n.join("="))), t;
  }
  function XG(e28, t, r) {
    e28[decodeURIComponent(t)] = decodeURIComponent(r || "");
  }
  function YG(e28, t) {
    let r = t.toLowerCase();
    return r === "true" || r === "false" ? r === "true" : `${+r}` === r ? +r : t;
  }
  function z() {
    return Pv;
  }
  var Pv = null;
  function rT(e28) {
    Pv = e28;
  }
  var Lv;
  function Mv() {
    if (Lv == null) {
      let e28;
      if (typeof window < "u") e28 = window;
      else if (typeof global < "u") e28 = global;
      else if (typeof process < "u") e28 = process;
      else if (typeof self < "u") e28 = self;
      else throw new Error("Could not find a global object");
      Lv = e28;
    }
    return Lv;
  }
  function JG() {
    let e28 = Mv();
    return e28._tfGlobals == null && (e28._tfGlobals = /* @__PURE__ */ new Map()), e28._tfGlobals;
  }
  function kf(e28, t) {
    let r = JG();
    if (r.has(e28)) return r.get(e28);
    {
      let n = t();
      return r.set(e28, n), r.get(e28);
    }
  }
  var ka = "Abs";
  var Ys = "Acos";
  var Js = "Acosh";
  var Mo = "Add";
  var Dc = "AddN";
  var $c = "All";
  var Fc = "Any";
  var Ea = "ArgMax";
  var Aa = "ArgMin";
  var Zs = "Asin";
  var Qs = "Asinh";
  var ti = "Atan";
  var ei = "Atanh";
  var ri = "Atan2";
  var Da = "AvgPool";
  var _c = "AvgPoolGrad";
  var $a = "AvgPool3D";
  var Oc = "AvgPool3DGrad";
  var Fa = "BatchMatMul";
  var _a = "BatchToSpaceND";
  var Rc = "Bincount";
  var Ef = "BitwiseAnd";
  var nT = "BroadcastTo";
  var cy = "BroadcastArgs";
  var hs = "Cast";
  var ni = "Ceil";
  var oi = "ClipByValue";
  var Pc = "Complex";
  var Oa = "ComplexAbs";
  var Ra = "Concat";
  var Pa = "Conv2D";
  var Lc = "Conv2DBackpropFilter";
  var La = "Conv2DBackpropInput";
  var Ma = "Conv3D";
  var Mc = "Conv3DBackpropFilterV2";
  var zc = "Conv3DBackpropInputV2";
  var si = "Cos";
  var ii = "Cosh";
  var Bc = "Cumprod";
  var za = "Cumsum";
  var Vc = "CropAndResize";
  var Gc = "DenseBincount";
  var Wc = "DepthToSpace";
  var Ba = "DepthwiseConv2dNative";
  var Uc = "DepthwiseConv2dNativeBackpropFilter";
  var jc = "DepthwiseConv2dNativeBackpropInput";
  var py = "Diag";
  var Va = "Dilation2D";
  var Af = "Dilation2DBackpropInput";
  var Df = "Dilation2DBackpropFilter";
  var oT = "Draw";
  var ai = "RealDiv";
  var Hc = "Einsum";
  var ui = "Elu";
  var Kc = "EluGrad";
  var li = "Erf";
  var nl = "Equal";
  var ci = "Exp";
  var Ga = "ExpandDims";
  var pi = "Expm1";
  var qc = "FFT";
  var Xc = "Fill";
  var Yc = "FlipLeftRight";
  var mi = "Floor";
  var fi = "FloorDiv";
  var Wa = "FusedBatchNorm";
  var Ua = "GatherV2";
  var my = "GatherNd";
  var ol = "Greater";
  var hi = "GreaterEqual";
  var ds = "Identity";
  var Jc = "IFFT";
  var Zc = "Imag";
  var di = "IsFinite";
  var gi = "IsInf";
  var yi = "IsNan";
  var ja = "LeakyRelu";
  var sl = "Less";
  var il = "LessEqual";
  var fy = "LinSpace";
  var xi = "Log";
  var bi = "Log1p";
  var al = "LogicalAnd";
  var ul = "LogicalNot";
  var ll = "LogicalOr";
  var sT = "LogSoftmax";
  var Ha = "LRN";
  var Qc = "LRNGrad";
  var Ka = "Max";
  var wi = "Maximum";
  var qa = "MaxPool";
  var tp = "MaxPoolGrad";
  var Xa = "MaxPool3D";
  var ep = "MaxPool3DGrad";
  var hy = "MaxPoolWithArgmax";
  var Ya = "Mean";
  var Ja = "Min";
  var vi = "Minimum";
  var Za = "MirrorPad";
  var Ni = "Mod";
  var dy = "Multinomial";
  var Ci = "Multiply";
  var Qa = "Neg";
  var cl = "NotEqual";
  var rp = "NonMaxSuppressionV3";
  var np = "NonMaxSuppressionV4";
  var op = "NonMaxSuppressionV5";
  var tu = "OnesLike";
  var eu = "OneHot";
  var ru = "Pack";
  var nu = "PadV2";
  var Si = "Pow";
  var ou = "Prelu";
  var su = "Prod";
  var gy = "RaggedGather";
  var yy = "RaggedRange";
  var xy = "RaggedTensorToTensor";
  var sp = "Range";
  var ip = "Real";
  var Ii = "Reciprocal";
  var Ti = "Relu";
  var iu = "Reshape";
  var au = "ResizeNearestNeighbor";
  var ap = "ResizeNearestNeighborGrad";
  var uu = "ResizeBilinear";
  var up = "ResizeBilinearGrad";
  var ki = "Relu6";
  var lu = "Reverse";
  var Ei = "Round";
  var Ai = "Rsqrt";
  var by = "ScatterNd";
  var wy = "TensorScatterUpdate";
  var vy = "SearchSorted";
  var cu = "Select";
  var Di = "Selu";
  var pu = "Slice";
  var $i = "Sin";
  var Fi = "Sinh";
  var _i = "Sign";
  var Oi = "Sigmoid";
  var Ri = "Softplus";
  var Pi = "Sqrt";
  var mu = "Sum";
  var fu = "SpaceToBatchND";
  var hu = "SplitV";
  var du = "Softmax";
  var Ny = "SparseFillEmptyRows";
  var Cy = "SparseReshape";
  var Sy = "SparseSegmentMean";
  var Iy = "SparseSegmentSum";
  var Ty = "SparseToDense";
  var Li = "SquaredDifference";
  var lp = "Square";
  var $f = "StaticRegexReplace";
  var cp = "StridedSlice";
  var ky = "StringNGrams";
  var Ey = "StringSplit";
  var Ay = "StringToHashBucketFast";
  var Mi = "Sub";
  var zi = "Tan";
  var Bi = "Tanh";
  var gs = "Tile";
  var pp = "TopK";
  var mp = "Transform";
  var ys = "Transpose";
  var fp = "Unique";
  var gu = "Unpack";
  var yu = "UnsortedSegmentSum";
  var xu = "ZerosLike";
  var Vi = "Step";
  var iT = "FromPixels";
  var hp = "RotateWithOffset";
  var pl = "_FusedMatMul";
  var ml = "FusedConv2D";
  var fl = "FusedDepthwiseConv2D";
  function xs(...e28) {
    z().getBool("IS_TEST") || z().getBool("PROD") || console.warn(...e28);
  }
  function ZG(...e28) {
    z().getBool("IS_TEST") || z().getBool("PROD") || console.log(...e28);
  }
  var Dy = kf("kernelRegistry", () => /* @__PURE__ */ new Map());
  var zv = kf("gradRegistry", () => /* @__PURE__ */ new Map());
  function Bv(e28, t) {
    let r = lT(e28, t);
    return Dy.get(r);
  }
  function Vv(e28) {
    return zv.get(e28);
  }
  function Gv(e28) {
    let t = Dy.entries(), r = [];
    for (; ; ) {
      let { done: n, value: o } = t.next();
      if (n) break;
      let [s10, i] = o, [a] = s10.split("_");
      a === e28 && r.push(i);
    }
    return r;
  }
  function $y(e28) {
    let { kernelName: t, backendName: r } = e28, n = lT(t, r);
    Dy.has(n) && xs(`The kernel '${t}' for backend '${r}' is already registered`), Dy.set(n, e28);
  }
  function uT(e28) {
    let { kernelName: t } = e28;
    zv.has(t) && z().getBool("DEBUG") && xs(`Overriding the gradient for '${t}'`), zv.set(t, e28);
  }
  function lT(e28, t) {
    return `${t}_${e28}`;
  }
  var x = {};
  lo(x, { arraysEqual: () => Ia, arraysEqualWithNull: () => RG, assert: () => I, assertNonNegativeIntegerDimensions: () => Ar, assertNonNull: () => Sf, assertShapesMatch: () => uy, bytesFromStringArray: () => Rv, bytesPerElement: () => Ic, checkConversionForErrors: () => _v, clamp: () => Sc, computeStrides: () => fs, convertBackendValuesAndArrayBuffer: () => WG, createScalarValue: () => s4, createShuffledIndices: () => MG, decodeString: () => bp, distSquared: () => _G, encodeString: () => xp, fetch: () => a4, fingerPrint64: () => o4, flatten: () => wu, getArrayFromDType: () => ly, getTypedArrayFromDType: () => VG, hasEncodingLoss: () => GG, hexToLong: () => Ff, indexToLoc: () => HG, inferDtype: () => Ta, inferFromImplicitShape: () => BG, isBoolean: () => ZI, isFunction: () => kc, isInt: () => Xs, isNumber: () => QI, isPromise: () => rl, isScalarShape: () => OG, isString: () => Tc, isTypedArray: () => Yr, isValidDtype: () => Ov, locToIndex: () => jG, makeOnesTypedArray: () => If, makeZerosNestedTypedArray: () => UG, makeZerosTypedArray: () => Ac, nearestDivisor: () => Ec, nearestLargerEven: () => DG, now: () => xl, parseAxisParam: () => dr, randUniform: () => FG, repeatedTry: () => zG, rightPad: () => el, shuffle: () => JI, shuffleCombo: () => AG, sizeFromShape: () => ie, sizeToSquarishShape: () => LG, squeezeShape: () => Fv, sum: () => $G, swap: () => ay, tanh: () => PG, toNestedArray: () => tl, toTypedArray: () => yp });
  function Fy(e28) {
    return e28 instanceof Float32Array || e28 instanceof Int32Array || e28 instanceof Uint8Array || e28 instanceof Uint8ClampedArray;
  }
  var Hv = ff(wT());
  var yl = Hv.default || Hv;
  function Ff(e28) {
    return yl.fromString(e28, true, 16);
  }
  var NT = Ff("c3a5c85c97cb3127");
  var gl = Ff("b492b66fbe98f273");
  var sn = Ff("9ae16a3b2f90404f");
  function jv(e28) {
    return e28.xor(e28.shru(47));
  }
  function CT(e28, t, r) {
    let n = e28.slice(t, t + r);
    return yl.fromBytes(Array.from(n), true, true);
  }
  function _e(e28, t) {
    return CT(e28, t, 8);
  }
  function vT(e28, t) {
    return CT(e28, t, 4);
  }
  function Dr(e28, t) {
    return t === 0 ? e28 : e28.shru(t).or(e28.shl(64 - t));
  }
  function bu(e28, t, r = Ff("9ddfea08eb382d69")) {
    let n = e28.xor(t).mul(r);
    n = n.xor(n.shru(47));
    let o = t.xor(n).mul(r);
    return o = o.xor(o.shru(47)), o = o.mul(r), o;
  }
  function t4(e28, t, r, n, o, s10) {
    o = o.add(e28), s10 = Dr(s10.add(o).add(n), 21);
    let i = o;
    return o = o.add(t), o = o.add(r), s10 = s10.add(Dr(o, 44)), [o.add(n), s10.add(i)];
  }
  function Oy(e28, t, r, n) {
    return t4(_e(e28, t), _e(e28, t + 8), _e(e28, t + 16), _e(e28, t + 24), r, n);
  }
  function e4(e28, t = e28.length) {
    if (t >= 8) {
      let r = sn.add(t * 2), n = _e(e28, 0).add(sn), o = _e(e28, t - 8), s10 = Dr(o, 37).mul(r).add(n), i = Dr(n, 25).add(o).mul(r);
      return bu(s10, i, r);
    }
    if (t >= 4) {
      let r = sn.add(t * 2), n = vT(e28, 0);
      return bu(n.shl(3).add(t), vT(e28, t - 4), r);
    }
    if (t > 0) {
      let r = e28[0], n = e28[t >> 1], o = e28[t - 1], s10 = r + (n << 8), i = t + (o << 2);
      return jv(sn.mul(s10).xor(NT.mul(i))).mul(sn);
    }
    return sn;
  }
  function r4(e28, t = e28.length) {
    let r = sn.add(t * 2), n = _e(e28, 0).mul(gl), o = _e(e28, 8), s10 = _e(e28, t - 8).mul(r), i = _e(e28, t - 16).mul(sn);
    return bu(Dr(n.add(o), 43).add(Dr(s10, 30)).add(i), n.add(Dr(o.add(sn), 18)).add(s10), r);
  }
  function n4(e28, t = e28.length) {
    let r = sn.add(t * 2), n = _e(e28, 0).mul(sn), o = _e(e28, 8), s10 = _e(e28, t - 8).mul(r), i = _e(e28, t - 16).mul(sn), a = Dr(n.add(o), 43).add(Dr(s10, 30)).add(i), u = bu(a, n.add(Dr(o.add(sn), 18)).add(s10), r), l = _e(e28, 16).mul(r), c = _e(e28, 24), p = a.add(_e(e28, t - 32)).mul(r), m = u.add(_e(e28, t - 24)).mul(r);
    return bu(Dr(l.add(c), 43).add(Dr(p, 30)).add(m), l.add(Dr(c.add(n), 18)).add(p), r);
  }
  function o4(e28, t = e28.length) {
    let r = yl.fromNumber(81, true);
    if (t <= 32) return t <= 16 ? e4(e28, t) : r4(e28, t);
    if (t <= 64) return n4(e28, t);
    let n = r, o = r.mul(gl).add(113), s10 = jv(o.mul(sn).add(113)).mul(sn), i = [yl.UZERO, yl.UZERO], a = [yl.UZERO, yl.UZERO];
    n = n.mul(sn).add(_e(e28, 0));
    let u = 0, l = (t - 1 >> 6) * 64, c = l + (t - 1 & 63) - 63;
    do
      n = Dr(n.add(o).add(i[0]).add(_e(e28, u + 8)), 37).mul(gl), o = Dr(o.add(i[1]).add(_e(e28, u + 48)), 42).mul(gl), n = n.xor(a[1]), o = o.add(i[0]).add(_e(e28, u + 40)), s10 = Dr(s10.add(a[0]), 33).mul(gl), i = Oy(e28, u, i[1].mul(gl), n.add(a[0])), a = Oy(e28, u + 32, s10.add(a[1]), o.add(_e(e28, u + 16))), [s10, n] = [n, s10], u += 64;
    while (u !== l);
    let p = gl.add(s10.and(255).shl(1));
    return u = c, a[0] = a[0].add(t - 1 & 63), i[0] = i[0].add(a[0]), a[0] = a[0].add(i[0]), n = Dr(n.add(o).add(i[0]).add(_e(e28, u + 8)), 37).mul(p), o = Dr(o.add(i[1]).add(_e(e28, u + 48)), 42).mul(p), n = n.xor(a[1].mul(9)), o = o.add(i[0].mul(9).add(_e(e28, u + 40))), s10 = Dr(s10.add(a[0]), 33).mul(p), i = Oy(e28, u, i[1].mul(p), n.add(a[0])), a = Oy(e28, u + 32, s10.add(a[1]), o.add(_e(e28, u + 16))), [s10, n] = [n, s10], bu(bu(i[0], a[0], p).add(jv(o).mul(NT)).add(s10), bu(i[1], a[1], p).add(n), p);
  }
  function s4(e28, t) {
    return t === "string" ? xp(e28) : yp([e28], t);
  }
  function i4(e28, t) {
    return e28 instanceof Float32Array && t === "float32" || e28 instanceof Int32Array && t === "int32" || e28 instanceof Uint8Array && t === "bool";
  }
  function yp(e28, t) {
    if (t === "string") throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(e28) && (e28 = wu(e28)), z().getBool("DEBUG") && _v(e28, t), i4(e28, t)) return e28;
    if (t == null || t === "float32" || t === "complex64") return new Float32Array(e28);
    if (t === "int32") return new Int32Array(e28);
    if (t === "bool") {
      let r = new Uint8Array(e28.length);
      for (let n = 0; n < r.length; ++n) Math.round(e28[n]) !== 0 && (r[n] = 1);
      return r;
    } else throw new Error(`Unknown data type ${t}`);
  }
  function xl() {
    return z().platform.now();
  }
  function a4(e28, t) {
    return z().platform.fetch(e28, t);
  }
  function xp(e28, t = "utf-8") {
    return t = t || "utf-8", z().platform.encode(e28, t);
  }
  function bp(e28, t = "utf-8") {
    return t = t || "utf-8", z().platform.decode(e28, t);
  }
  function Yr(e28) {
    return z().platform.isTypedArray != null ? z().platform.isTypedArray(e28) : Fy(e28);
  }
  function wu(e28, t = [], r = false) {
    if (t == null && (t = []), typeof e28 == "boolean" || typeof e28 == "number" || typeof e28 == "string" || rl(e28) || e28 == null || Yr(e28) && r) t.push(e28);
    else if (Array.isArray(e28) || Yr(e28)) for (let n = 0; n < e28.length; ++n) wu(e28[n], t, r);
    else {
      let n = -1;
      for (let o of Object.keys(e28)) /^([1-9]+[0-9]*|0)$/.test(o) && (n = Math.max(n, Number(o)));
      for (let o = 0; o <= n; o++) wu(e28[o], t, r);
    }
    return t;
  }
  var Ry = class {
    constructor(t, r) {
      this.backendTimer = t, this.logger = r, r == null && (this.logger = new Kv());
    }
    profileKernel(t, r, n) {
      let o, s10 = () => {
        o = n();
      }, i, a = xl();
      if (this.backendTimer.timerAvailable()) i = this.backendTimer.time(s10);
      else {
        s10();
        for (let l of o) l.dataSync();
        i = Promise.resolve({ kernelMs: xl() - a });
      }
      if (z().getBool("CHECK_COMPUTATION_FOR_ERRORS")) for (let l = 0; l < o.length; l++) {
        let c = o[l];
        c.data().then((p) => {
          u4(p, c.dtype, t);
        });
      }
      return { kernelName: t, outputs: o, inputs: r, timeMs: i.then((l) => l.kernelMs), extraInfo: i.then((l) => l.getExtraProfileInfo != null ? l.getExtraProfileInfo() : "") };
    }
    logKernelProfile(t) {
      let { kernelName: r, outputs: n, timeMs: o, inputs: s10, extraInfo: i } = t;
      n.forEach((a) => {
        Promise.all([a.data(), o, i]).then((u) => {
          this.logger.logKernelProfile(r, a, u[0], u[1], s10, u[2]);
        });
      });
    }
  };
  function u4(e28, t, r) {
    if (t !== "float32") return false;
    for (let n = 0; n < e28.length; n++) {
      let o = e28[n];
      if (isNaN(o) || !isFinite(o)) return console.warn(`Found ${o} in the result of '${r}'`), true;
    }
    return false;
  }
  var Kv = class {
    logKernelProfile(t, r, n, o, s10, i) {
      let a = typeof o == "number" ? el(`${o}ms`, 9) : o.error, u = el(t, 25), l = r.rank, c = r.size, p = el(r.shape.toString(), 14), m = "";
      for (let f in s10) {
        let h = s10[f];
        if (h != null) {
          let d = h.shape || r.shape, g = d.length;
          m += `${f}: ${g}D ${g > 0 ? d : ""} `;
        }
      }
      console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${m}	%c${i}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  };
  function ST(e28, t, r) {
    let n = {}, o = {};
    for (let u = 0; u < t.length; u++) n[t[u].id] = true;
    for (let u = 0; u < e28.length; u++) {
      let l = e28[u], c = l.inputs;
      for (let p in c) {
        let m = c[p], f = false;
        for (let h = 0; h < t.length; h++) if (n[m.id]) {
          l.outputs.forEach((d) => n[d.id] = true), f = true, o[l.id] = true;
          break;
        }
        if (f) break;
      }
    }
    let s10 = {};
    s10[r.id] = true;
    let i = {};
    for (let u = e28.length - 1; u >= 0; u--) {
      let l = e28[u], c = l.inputs;
      for (let p = 0; p < l.outputs.length; p++) if (s10[l.outputs[p].id]) {
        for (let m in c) s10[c[m].id] = true, i[l.id] = true;
        break;
      }
    }
    let a = [];
    for (let u = 0; u < e28.length; u++) {
      let l = e28[u];
      if (o[l.id] && i[l.id]) {
        let c = {};
        for (let m in l.inputs) {
          let f = l.inputs[m];
          n[f.id] && (c[m] = f);
        }
        let p = Object.assign({}, l);
        p.inputs = c, p.outputs = l.outputs, a.push(p);
      }
    }
    return a;
  }
  function IT(e28, t, r, n) {
    for (let o = t.length - 1; o >= 0; o--) {
      let s10 = t[o], i = [];
      if (s10.outputs.forEach((u) => {
        let l = e28[u.id];
        l != null ? i.push(l) : i.push(null);
      }), s10.gradient == null) throw new Error(`Cannot compute gradient: gradient function not found for ${s10.kernelName}.`);
      let a = s10.gradient(i);
      for (let u in s10.inputs) {
        if (!(u in a)) throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);
        let l = r(() => a[u]());
        if (l.dtype !== "float32") throw new Error(`Error in gradient for op ${s10.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);
        let c = s10.inputs[u];
        if (!Ia(l.shape, c.shape)) throw new Error(`Error in gradient for op ${s10.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);
        if (e28[c.id] == null) e28[c.id] = l;
        else {
          let p = e28[c.id];
          e28[c.id] = n(p, l), p.dispose();
        }
      }
    }
  }
  var TT = 20;
  var _f = 3;
  var qv = 7;
  function kT(e28, t, r, n) {
    let o = fs(t), s10 = l4(e28, t, r, o), i = t.length, a = Py(e28, t, r, o, s10), u = ["Tensor"];
    return n && (u.push(`  dtype: ${r}`), u.push(`  rank: ${i}`), u.push(`  shape: [${t}]`), u.push("  values:")), u.push(a.map((l) => "    " + l).join(`
`)), u.join(`
`);
  }
  function l4(e28, t, r, n) {
    let o = ie(t), s10 = n[n.length - 1], i = new Array(s10).fill(0), a = t.length, u = r === "complex64" ? Rf(e28) : e28;
    if (a > 1) for (let l = 0; l < o / s10; l++) {
      let c = l * s10;
      for (let p = 0; p < s10; p++) i[p] = Math.max(i[p], Of(u[c + p], 0, r).length);
    }
    return i;
  }
  function Of(e28, t, r) {
    let n;
    return Array.isArray(e28) ? n = `${parseFloat(e28[0].toFixed(qv))} + ${parseFloat(e28[1].toFixed(qv))}j` : Tc(e28) ? n = `'${e28}'` : r === "bool" ? n = ET(e28) : n = parseFloat(e28.toFixed(qv)).toString(), el(n, t);
  }
  function ET(e28) {
    return e28 === 0 ? "false" : "true";
  }
  function Py(e28, t, r, n, o, s10 = true) {
    let i = r === "complex64" ? 2 : 1, a = t[0], u = t.length;
    if (u === 0) {
      if (r === "complex64") {
        let d = Rf(e28);
        return [Of(d[0], 0, r)];
      }
      return r === "bool" ? [ET(e28[0])] : [e28[0].toString()];
    }
    if (u === 1) {
      if (a > TT) {
        let g = _f * i, y = Array.from(e28.slice(0, g)), b = Array.from(e28.slice((a - _f) * i, a * i));
        return r === "complex64" && (y = Rf(y), b = Rf(b)), ["[" + y.map((v, w) => Of(v, o[w], r)).join(", ") + ", ..., " + b.map((v, w) => Of(v, o[a - _f + w], r)).join(", ") + "]"];
      }
      return ["[" + (r === "complex64" ? Rf(e28) : Array.from(e28)).map((g, y) => Of(g, o[y], r)).join(", ") + "]"];
    }
    let l = t.slice(1), c = n.slice(1), p = n[0] * i, m = [];
    if (a > TT) {
      for (let d = 0; d < _f; d++) {
        let g = d * p, y = g + p;
        m.push(...Py(e28.slice(g, y), l, r, c, o, false));
      }
      m.push("...");
      for (let d = a - _f; d < a; d++) {
        let g = d * p, y = g + p;
        m.push(...Py(e28.slice(g, y), l, r, c, o, d === a - 1));
      }
    } else for (let d = 0; d < a; d++) {
      let g = d * p, y = g + p;
      m.push(...Py(e28.slice(g, y), l, r, c, o, d === a - 1));
    }
    let f = u === 2 ? "," : "";
    m[0] = "[" + (a > 0 ? m[0] + f : "");
    for (let d = 1; d < m.length - 1; d++) m[d] = " " + m[d] + f;
    let h = `,
`;
    for (let d = 2; d < u; d++) h += `
`;
    return m[m.length - 1] = " " + m[m.length - 1] + "]" + (s10 ? "" : h), m;
  }
  function Rf(e28) {
    let t = [];
    for (let r = 0; r < e28.length; r += 2) t.push([e28[r], e28[r + 1]]);
    return t;
  }
  var pe = class {
    constructor(t, r, n) {
      if (this.dtype = r, this.shape = t.slice(), this.size = ie(t), n != null) {
        let o = n.length;
        I(o === this.size, () => `Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (r === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
      this.values = n || ly(r, this.size), this.strides = fs(t);
    }
    set(t, ...r) {
      r.length === 0 && (r = [0]), I(r.length === this.rank, () => `The number of provided coordinates (${r.length}) must match the rank (${this.rank})`);
      let n = this.locToIndex(r);
      this.values[n] = t;
    }
    get(...t) {
      t.length === 0 && (t = [0]);
      let r = 0;
      for (let o of t) {
        if (o < 0 || o >= this.shape[r]) {
          let s10 = `Requested out of range element at ${t}.   Buffer shape=${this.shape}`;
          throw new Error(s10);
        }
        r++;
      }
      let n = t[t.length - 1];
      for (let o = 0; o < t.length - 1; ++o) n += this.strides[o] * t[o];
      return this.values[n];
    }
    locToIndex(t) {
      if (this.rank === 0) return 0;
      if (this.rank === 1) return t[0];
      let r = t[t.length - 1];
      for (let n = 0; n < t.length - 1; ++n) r += this.strides[n] * t[n];
      return r;
    }
    indexToLoc(t) {
      if (this.rank === 0) return [];
      if (this.rank === 1) return [t];
      let r = new Array(this.shape.length);
      for (let n = 0; n < r.length - 1; ++n) r[n] = Math.floor(t / this.strides[n]), t -= r[n] * this.strides[n];
      return r[r.length - 1] = t, r;
    }
    get rank() {
      return this.shape.length;
    }
    toTensor() {
      return Bo().makeTensor(this.values, this.shape, this.dtype);
    }
  };
  var Bo = null;
  var wp = null;
  var c4 = null;
  function AT(e28) {
    Bo = e28;
  }
  function DT(e28) {
    wp = e28;
  }
  function $T(e28) {
    c4 = e28;
  }
  var ee = class {
    constructor(t, r, n, o) {
      this.kept = false, this.isDisposedInternal = false, this.shape = t.slice(), this.dtype = r || "float32", this.size = ie(t), this.strides = fs(t), this.dataId = n, this.id = o, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    async buffer() {
      let t = await this.data();
      return wp.buffer(this.shape, this.dtype, t);
    }
    bufferSync() {
      return wp.buffer(this.shape, this.dtype, this.dataSync());
    }
    async array() {
      let t = await this.data();
      return tl(this.shape, t, this.dtype === "complex64");
    }
    arraySync() {
      return tl(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    async data() {
      this.throwIfDisposed();
      let t = Bo().read(this.dataId);
      if (this.dtype === "string") {
        let r = await t;
        try {
          return r.map((n) => bp(n));
        } catch {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return t;
    }
    dataToGPU(t) {
      return this.throwIfDisposed(), Bo().readToGPU(this.dataId, t);
    }
    dataSync() {
      this.throwIfDisposed();
      let t = Bo().readSync(this.dataId);
      if (this.dtype === "string") try {
        return t.map((r) => bp(r));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
      return t;
    }
    async bytes() {
      this.throwIfDisposed();
      let t = await Bo().read(this.dataId);
      return this.dtype === "string" ? t : new Uint8Array(t.buffer);
    }
    dispose() {
      this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), Bo().disposeTensor(this), this.isDisposedInternal = true);
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed) throw new Error("Tensor is disposed.");
    }
    print(t = false) {
      return wp.print(this, t);
    }
    clone() {
      return this.throwIfDisposed(), wp.clone(this);
    }
    toString(t = false) {
      let r = this.dataSync();
      return kT(r, this.shape, this.dtype, t);
    }
    cast(t) {
      return this.throwIfDisposed(), wp.cast(this, t);
    }
    variable(t = true, r, n) {
      return this.throwIfDisposed(), Bo().makeVariable(this, t, r, n);
    }
  };
  Object.defineProperty(ee, Symbol.hasInstance, { value: (e28) => !!e28 && e28.data != null && e28.dataSync != null && e28.throwIfDisposed != null });
  function $() {
    return kf("Tensor", () => ee);
  }
  $();
  var Gi = class extends ee {
    constructor(t, r, n, o) {
      super(t.shape, t.dtype, t.dataId, o), this.trainable = r, this.name = n;
    }
    assign(t) {
      if (t.dtype !== this.dtype) throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);
      if (!Ia(t.shape, this.shape)) throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);
      Bo().disposeTensor(this), this.dataId = t.dataId, Bo().incRef(this, null);
    }
    dispose() {
      Bo().disposeVariable(this), this.isDisposedInternal = true;
    }
  };
  Object.defineProperty(Gi, Symbol.hasInstance, { value: (e28) => e28 instanceof ee && e28.assign != null && e28.assign instanceof Function });
  var go = {};
  lo(go, { assertTypesMatch: () => m4, getTensorsInContainer: () => Pf, isTensorInList: () => f4, makeTypesMatch: () => Yt });
  var Xv;
  (function(e28) {
    e28.R0 = "R0", e28.R1 = "R1", e28.R2 = "R2", e28.R3 = "R3", e28.R4 = "R4", e28.R5 = "R5", e28.R6 = "R6";
  })(Xv || (Xv = {}));
  var Yv;
  (function(e28) {
    e28.float32 = "float32", e28.int32 = "int32", e28.bool = "int32", e28.complex64 = "complex64";
  })(Yv || (Yv = {}));
  var Jv;
  (function(e28) {
    e28.float32 = "float32", e28.int32 = "int32", e28.bool = "bool", e28.complex64 = "complex64";
  })(Jv || (Jv = {}));
  var Zv;
  (function(e28) {
    e28.float32 = "float32", e28.int32 = "float32", e28.bool = "float32", e28.complex64 = "complex64";
  })(Zv || (Zv = {}));
  var Qv;
  (function(e28) {
    e28.float32 = "complex64", e28.int32 = "complex64", e28.bool = "complex64", e28.complex64 = "complex64";
  })(Qv || (Qv = {}));
  var p4 = { float32: Zv, int32: Yv, bool: Jv, complex64: Qv };
  function lr(e28, t) {
    if (e28 === "string" || t === "string") {
      if (e28 === "string" && t === "string") return "string";
      throw new Error(`Can not upcast ${e28} with ${t}`);
    }
    return p4[e28][t];
  }
  function bl(e28) {
    return lr(e28, "int32");
  }
  function Ly(e28) {
    return e28 != null && typeof e28 == "object" && "texture" in e28 && e28.texture instanceof WebGLTexture;
  }
  function My(e28) {
    return typeof GPUBuffer < "u" && e28 != null && typeof e28 == "object" && "buffer" in e28 && e28.buffer instanceof GPUBuffer;
  }
  function Yt(e28, t) {
    if (e28.dtype === t.dtype) return [e28, t];
    let r = lr(e28.dtype, t.dtype);
    return [e28.cast(r), t.cast(r)];
  }
  function m4(e28, t) {
    I(e28.dtype === t.dtype, () => `The dtypes of the first(${e28.dtype}) and second(${t.dtype}) input must match`);
  }
  function f4(e28, t) {
    return t.some((r) => r.id === e28.id);
  }
  function Pf(e28) {
    let t = [];
    return FT(e28, t, /* @__PURE__ */ new Set()), t;
  }
  function FT(e28, t, r) {
    if (e28 == null) return;
    if (e28 instanceof ee) {
      t.push(e28);
      return;
    }
    if (!h4(e28)) return;
    let n = e28;
    for (let o in n) {
      let s10 = n[o];
      r.has(s10) || (r.add(s10), FT(s10, t, r));
    }
  }
  function h4(e28) {
    return Array.isArray(e28) || typeof e28 == "object";
  }
  function tN(e28) {
    return e28.kernelName != null;
  }
  var zy = class {
    constructor() {
      this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null, get kernelNames() {
        return Array.from(new Set(this.kernels.map((t) => t.name)));
      } };
    }
    dispose() {
      for (let t in this.registeredVariables) this.registeredVariables[t].dispose();
    }
  };
  var Lf = class e {
    constructor(t) {
      this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new zy();
    }
    async ready() {
      if (this.pendingBackendInit != null) return this.pendingBackendInit.then(() => {
      });
      if (this.backendInstance != null) return;
      let t = this.getSortedBackends();
      for (let r = 0; r < t.length; r++) {
        let n = t[r];
        if (await this.initializeBackend(n).success) {
          await this.setBackend(n);
          return;
        }
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    get backend() {
      if (this.pendingBackendInit != null) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      if (this.backendInstance == null) {
        let { name: t, asyncInit: r } = this.initializeBackendsAndReturnBest();
        if (r) throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        this.setBackend(t);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(t) {
      if (!(t in this.registry)) if (t in this.registryFactory) {
        let { asyncInit: r } = this.initializeBackend(t);
        if (r) return null;
      } else return null;
      return this.registry[t];
    }
    findBackendFactory(t) {
      return t in this.registryFactory ? this.registryFactory[t].factory : null;
    }
    registerBackend(t, r, n = 1) {
      return t in this.registryFactory ? (xs(`${t} backend was already registered. Reusing existing backend factory.`), false) : (this.registryFactory[t] = { factory: r, priority: n }, true);
    }
    async setBackend(t) {
      if (this.registryFactory[t] == null) throw new Error(`Backend name '${t}' not found in registry`);
      if (this.backendName = t, this.registry[t] == null) {
        this.backendInstance = null;
        let { success: r, asyncInit: n } = this.initializeBackend(t);
        if (!(n ? await r : r)) return false;
      }
      return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new Ry(this.backendInstance), true;
    }
    setupRegisteredKernels() {
      Gv(this.backendName).forEach((r) => {
        r.setupFunc != null && r.setupFunc(this.backendInstance);
      });
    }
    disposeRegisteredKernels(t) {
      Gv(t).forEach((n) => {
        n.disposeFunc != null && n.disposeFunc(this.registry[t]);
      });
    }
    initializeBackend(t) {
      let r = this.registryFactory[t];
      if (r == null) throw new Error(`Cannot initialize backend ${t}, no registration found.`);
      try {
        let n = r.factory();
        if (n && !(n instanceof qs) && typeof n.then == "function") {
          let o = ++this.pendingBackendInitId, s10 = n.then((i) => o < this.pendingBackendInitId ? false : (this.registry[t] = i, this.pendingBackendInit = null, true)).catch((i) => (o < this.pendingBackendInitId || (this.pendingBackendInit = null, xs(`Initialization of backend ${t} failed`), xs(i.stack || i.message)), false));
          return this.pendingBackendInit = s10, { success: s10, asyncInit: true };
        } else return this.registry[t] = n, { success: true, asyncInit: false };
      } catch (n) {
        return xs(`Initialization of backend ${t} failed`), xs(n.stack || n.message), { success: false, asyncInit: false };
      }
    }
    removeBackend(t) {
      if (!(t in this.registryFactory)) throw new Error(`${t} backend not found in registry`);
      this.backendName === t && this.pendingBackendInit != null && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0) throw new Error("No backend found in registry.");
      return Object.keys(this.registryFactory).sort((t, r) => this.registryFactory[r].priority - this.registryFactory[t].priority);
    }
    initializeBackendsAndReturnBest() {
      let t = this.getSortedBackends();
      for (let r = 0; r < t.length; r++) {
        let n = t[r], { success: o, asyncInit: s10 } = this.initializeBackend(n);
        if (s10 || o) return { name: n, asyncInit: s10 };
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    moveData(t, r) {
      let n = this.state.tensorInfo.get(r), o = n.backend, s10 = this.readSync(r), i = o.refCount(r);
      o.disposeData(r, true), n.backend = t, t.move(r, s10, n.shape, n.dtype, i), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
    tidy(t, r) {
      let n = null;
      if (r == null) {
        if (typeof t != "function") throw new Error("Please provide a function to tidy()");
        r = t;
      } else {
        if (typeof t != "string" && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        if (typeof r != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        n = t;
      }
      let o;
      return this.scopedRun(() => this.startScope(n), () => this.endScope(o), () => (o = r(), o instanceof Promise && console.error("Cannot return a Promise inside of tidy."), o));
    }
    scopedRun(t, r, n) {
      t();
      try {
        let o = n();
        return r(), o;
      } catch (o) {
        throw r(), o;
      }
    }
    nextTensorId() {
      return e.nextTensorId++;
    }
    nextVariableId() {
      return e.nextVariableId++;
    }
    clone(t) {
      let r = T.runKernel(ds, { x: t }), n = { x: t }, o = (i) => ({ x: () => {
        let a = "float32", u = { x: i }, l = { dtype: a };
        return T.runKernel(hs, u, l);
      } }), s10 = [];
      return this.addTapeNode(this.state.activeScope.name, n, [r], o, s10, {}), r;
    }
    runKernel(t, r, n) {
      if (this.backendName == null && this.backend, !(Bv(t, this.backendName) != null)) throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);
      return this.runKernelFunc({ kernelName: t, inputs: r, attrs: n });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(t, r, n) {
      let o = this.backend.numDataIds(), s10 = 0;
      n.forEach((u) => {
        s10 += u.dtype === "complex64" ? 3 : 1;
      });
      let i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], a = o - r - s10 - i;
      if (a > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`);
    }
    runKernelFunc(t) {
      let r, n = [], o = this.isTapeOn(), s10 = this.state.numBytes, i = this.state.numTensors;
      this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
      let a;
      this.backendName == null && this.backend;
      let u, l = tN(t) ? t.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (tN(t)) {
        let { kernelName: h, inputs: d, attrs: g } = t;
        this.backendName == null && this.backend;
        let y = Bv(h, this.backendName);
        I(y != null, () => `Cannot find registered kernel '${h}' for backend '${this.backendName}'`), a = () => {
          let b = this.backend.numDataIds();
          u = y.kernelFunc({ inputs: d, attrs: g, backend: this.backend });
          let v = Array.isArray(u) ? u : [u];
          this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(h, b, v);
          let w = v.map((N) => N.rank != null ? N : this.makeTensorFromTensorInfo(N));
          if (o) {
            let N = this.getTensorsForGradient(h, d, w);
            n = this.saveTensorsForBackwardMode(N);
          }
          return w;
        };
      } else {
        let { forwardFunc: h } = t, d = (g) => {
          o && (n = g.map((y) => this.keep(this.clone(y))));
        };
        a = () => {
          let g = this.backend.numDataIds();
          u = this.tidy(() => h(this.backend, d));
          let y = Array.isArray(u) ? u : [u];
          return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(l, g, y), y;
        };
      }
      let { inputs: c, attrs: p } = t, m = tN(t) ? null : t.backwardsFunc, f;
      return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? r = a() : (f = this.profiler.profileKernel(l, c, () => a()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(f), r = f.outputs);
      }), o && this.addTapeNode(l, c, r, m, n, p), this.state.profiling && this.state.activeProfile.kernels.push({ name: l, bytesAdded: this.state.numBytes - s10, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - i, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(c).map((h) => c[h] != null ? c[h].shape : null), outputShapes: r.map((h) => h.shape), kernelTimeMs: f.timeMs, extraInfo: f.extraInfo }), Array.isArray(u) ? r : r[0];
    }
    saveTensorsForBackwardMode(t) {
      return t.map((n) => this.keep(this.clone(n)));
    }
    getTensorsForGradient(t, r, n) {
      let o = Vv(t);
      if (o != null) {
        let s10 = o.inputsToSave || [], i = o.outputsToSave || [], a;
        o.saveAllInputs ? (I(Array.isArray(r), () => "saveAllInputs is true, expected inputs to be an array."), a = Object.keys(r).map((l) => r[l])) : a = s10.map((l) => r[l]);
        let u = n.filter((l, c) => i[c]);
        return a.concat(u);
      }
      return [];
    }
    makeTensor(t, r, n, o) {
      if (t == null) throw new Error("Values passed to engine.makeTensor() are null");
      n = n || "float32", o = o || this.backend;
      let s10 = t;
      n === "string" && Tc(t[0]) && (s10 = t.map((u) => xp(u)));
      let i = o.write(s10, r, n), a = new ee(r, n, i, this.nextTensorId());
      if (this.trackTensor(a, o), n === "string") {
        let u = this.state.tensorInfo.get(i), l = Rv(s10);
        this.state.numBytes += l - u.bytes, u.bytes = l;
      }
      return a;
    }
    makeTensorFromDataId(t, r, n, o) {
      n = n || "float32";
      let s10 = { dataId: t, shape: r, dtype: n };
      return this.makeTensorFromTensorInfo(s10, o);
    }
    makeTensorFromTensorInfo(t, r) {
      let { dataId: n, shape: o, dtype: s10 } = t, i = new ee(o, s10, n, this.nextTensorId());
      return this.trackTensor(i, r), i;
    }
    makeVariable(t, r = true, n, o) {
      n = n || this.nextVariableId().toString(), o != null && o !== t.dtype && (t = t.cast(o));
      let s10 = new Gi(t, r, n, this.nextTensorId());
      if (this.state.registeredVariables[s10.name] != null) throw new Error(`Variable with name ${s10.name} was already registered`);
      return this.state.registeredVariables[s10.name] = s10, this.incRef(s10, this.backend), s10;
    }
    trackTensor(t, r) {
      this.state.numTensors++, t.dtype === "string" && this.state.numStringTensors++;
      let n = 0;
      t.dtype !== "complex64" && t.dtype !== "string" && (n = t.size * Ic(t.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(t.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(t.dataId, { backend: r || this.backend, dtype: t.dtype, shape: t.shape, bytes: n })), t instanceof Gi || this.track(t);
    }
    incRef(t, r) {
      this.trackTensor(t, r), this.backend.incRef(t.dataId);
    }
    removeDataId(t, r) {
      this.state.tensorInfo.has(t) && this.state.tensorInfo.get(t).backend === r && (this.state.tensorInfo.delete(t), this.state.numDataBuffers--);
    }
    disposeTensor(t) {
      if (!this.state.tensorInfo.has(t.dataId)) return;
      let r = this.state.tensorInfo.get(t.dataId);
      if (this.state.numTensors--, t.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= r.bytes), t.dtype !== "complex64" && t.dtype !== "string") {
        let n = t.size * Ic(t.dtype);
        this.state.numBytes -= n;
      }
      r.backend.disposeData(t.dataId) && this.removeDataId(t.dataId, r.backend);
    }
    disposeVariables() {
      for (let t in this.state.registeredVariables) {
        let r = this.state.registeredVariables[t];
        this.disposeVariable(r);
      }
    }
    disposeVariable(t) {
      this.disposeTensor(t), this.state.registeredVariables[t.name] != null && delete this.state.registeredVariables[t.name];
    }
    memory() {
      let t = this.backend.memory();
      return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = true, t.reasons == null && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t;
    }
    async profile(t) {
      this.state.profiling = true;
      let r = this.state.numBytes, n = this.state.numTensors;
      this.state.activeProfile.kernels = [], this.state.activeProfile.result = await t(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((o) => o.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - r, this.state.activeProfile.newTensors = this.state.numTensors - n;
      for (let o of this.state.activeProfile.kernels) o.kernelTimeMs = await o.kernelTimeMs, o.extraInfo = await o.extraInfo;
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(t, r, n, o, s10, i) {
      let a = { id: this.state.nextTapeNodeId++, kernelName: t, inputs: r, outputs: n, saved: s10 }, u = Vv(t);
      u != null && (o = u.gradFunc), o != null && (a.gradient = (l) => (l = l.map((c, p) => {
        if (c == null) {
          let m = n[p], f = Ac(m.size, m.dtype);
          return this.makeTensor(f, m.shape, m.dtype);
        }
        return c;
      }), o(l.length > 1 ? l : l[0], s10, i))), this.state.activeTape.push(a);
    }
    keep(t) {
      return t.kept = true, t;
    }
    startTape() {
      this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    startScope(t) {
      let r = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
      t && (r.name = t), this.state.scopeStack.push(r), this.state.activeScope = r;
    }
    endScope(t) {
      let r = Pf(t), n = new Set(r.map((s10) => s10.id));
      for (let s10 = 0; s10 < this.state.activeScope.track.length; s10++) {
        let i = this.state.activeScope.track[s10];
        !i.kept && !n.has(i.id) && i.dispose();
      }
      let o = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], r.forEach((s10) => {
        !s10.kept && s10.scopeId === o.id && this.track(s10);
      });
    }
    gradients(t, r, n, o = false) {
      if (I(r.length > 0, () => "gradients() received an empty list of xs."), n != null && n.dtype !== "float32") throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);
      let s10 = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", t));
      I(s10 instanceof ee, () => "The result y returned by f() must be a tensor.");
      let i = ST(this.state.activeTape, r, s10);
      if (!o && i.length === 0 && r.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      return this.tidy("backward", () => {
        let a = {};
        a[s10.id] = n ?? d4(s10.shape), IT(a, i, (l) => this.tidy(l), g4);
        let u = r.map((l) => a[l.id]);
        return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((l) => {
          for (let c of l.saved) c.dispose();
        }), this.state.activeTape = null), { value: s10, grads: u };
      });
    }
    customGrad(t) {
      return I(kc(t), () => "The f passed in customGrad(f) must be a function."), (...r) => {
        I(r.every((a) => a instanceof ee), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let n, o = {};
        r.forEach((a, u) => {
          o[u] = a;
        });
        let s10 = (a, u) => (n = t(...r, u), I(n.value instanceof ee, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), I(kc(n.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), n.value), i = (a, u) => {
          let l = n.gradFunc(a, u), c = Array.isArray(l) ? l : [l];
          I(c.length === r.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), I(c.every((m) => m instanceof ee), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          let p = {};
          return c.forEach((m, f) => {
            p[f] = () => m;
          }), p;
        };
        return this.runKernelFunc({ forwardFunc: s10, backwardsFunc: i, inputs: o });
      };
    }
    readSync(t) {
      return this.state.tensorInfo.get(t).backend.readSync(t);
    }
    read(t) {
      return this.state.tensorInfo.get(t).backend.read(t);
    }
    readToGPU(t, r) {
      return this.state.tensorInfo.get(t).backend.readToGPU(t, r);
    }
    async time(t) {
      let r = xl(), n = await this.backend.time(t);
      return n.wallMs = xl() - r, n;
    }
    track(t) {
      return this.state.activeScope != null && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    reset() {
      this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new zy();
      for (let t in this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];
      this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }
  };
  Lf.nextTensorId = 0;
  Lf.nextVariableId = 0;
  function d4(e28) {
    let t = If(ie(e28), "float32");
    return T.makeTensor(t, e28, "float32");
  }
  function eN() {
    let e28 = Mv();
    if (e28._tfengine == null) {
      let t = new Tf(e28);
      e28._tfengine = new Lf(t);
    }
    return rT(e28._tfengine.ENV), AT(() => e28._tfengine), e28._tfengine;
  }
  var T = eN();
  function g4(e28, t) {
    let r = { a: e28, b: t };
    return T.runKernel(Mo, r);
  }
  var vu = {};
  lo(vu, { isBrowser: () => nN, isMobile: () => b4, mockIsMobile: () => x4 });
  function y4() {
    return typeof navigator < "u" && navigator != null;
  }
  var rN;
  function x4(e28) {
    rN = e28;
  }
  function b4(e28) {
    if (rN !== void 0) return rN;
    if (e28 || y4()) {
      if (e28 || (e28 = navigator), e28.product === "ReactNative") return true;
      let t = e28.userAgent || e28.vendor || (typeof window < "u" ? window.opera : "");
      if (!t) {
        let r = e28;
        return r.userAgentData && r.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
    }
    return false;
  }
  function nN() {
    return typeof window < "u" && window.document != null || typeof WorkerGlobalScope < "u";
  }
  var bn = z();
  bn.registerFlag("DEBUG", () => false, (e28) => {
    e28 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  });
  bn.registerFlag("IS_BROWSER", () => nN());
  bn.registerFlag("IS_NODE", () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u");
  bn.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  bn.registerFlag("IS_SAFARI", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
  bn.registerFlag("PROD", () => false);
  bn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => bn.getBool("DEBUG"));
  bn.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  bn.registerFlag("IS_TEST", () => false);
  bn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => bn.getBool("DEBUG"));
  bn.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  bn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  bn.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
  function wl(e28, t) {
    let r = e28;
    if (Yr(e28)) return t === "string" ? [] : [e28.length];
    if (Ly(e28)) {
      let o = e28.channels || "RGBA";
      return [e28.height, e28.width * o.length];
    } else if (My(e28)) return [e28.buffer.size / (t == null ? 4 : Ic(t))];
    if (!Array.isArray(e28)) return [];
    let n = [];
    for (; Array.isArray(r) || Yr(r) && t !== "string"; ) n.push(r.length), r = r[0];
    return Array.isArray(e28) && z().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && OT(e28, n, []), n;
  }
  function OT(e28, t, r) {
    if (r = r || [], !Array.isArray(e28) && !Yr(e28)) {
      I(t.length === 0, () => `Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);
      return;
    }
    I(t.length > 0, () => `Element arr[${r.join("][")}] should be a primitive, but is an array of ${e28.length} elements`), I(e28.length === t[0], () => `Element arr[${r.join("][")}] should have ${t[0]} elements, but has ${e28.length} elements`);
    let n = t.slice(1);
    for (let o = 0; o < e28.length; ++o) OT(e28[o], n, r.concat(o));
  }
  function _T(e28, t, r, n) {
    if (e28 !== "string_or_numeric") {
      if (e28 == null) throw new Error("Expected dtype cannot be null.");
      if (e28 !== "numeric" && e28 !== t || e28 === "numeric" && t === "string") throw new Error(`Argument '${r}' passed to '${n}' must be ${e28} tensor, but got ${t} tensor`);
    }
  }
  function S(e28, t, r, n = "numeric") {
    if (e28 instanceof $()) return _T(n, e28.dtype, t, r), e28;
    let o = Ta(e28);
    if (o !== "string" && ["bool", "int32", "float32"].indexOf(n) >= 0 && (o = n), _T(n, o, t, r), e28 == null || !Yr(e28) && !Array.isArray(e28) && typeof e28 != "number" && typeof e28 != "boolean" && typeof e28 != "string") {
      let u = e28 == null ? "null" : e28.constructor.name;
      throw new Error(`Argument '${t}' passed to '${r}' must be a Tensor or TensorLike, but got '${u}'`);
    }
    let s10 = wl(e28, o);
    !Yr(e28) && !Array.isArray(e28) && (e28 = [e28]);
    let a = o !== "string" ? yp(e28, o) : wu(e28, [], true);
    return T.makeTensor(a, s10, o);
  }
  function By(e28, t, r, n = "numeric") {
    if (!Array.isArray(e28)) throw new Error(`Argument ${t} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);
    return e28.map((s10, i) => S(s10, `${t}[${i}]`, r, n));
  }
  var w4 = "__op";
  function k(e28) {
    let t = Object.keys(e28);
    if (t.length !== 1) throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
    let r = t[0], n = e28[r];
    r.endsWith("_") && (r = r.substring(0, r.length - 1)), r = r + w4;
    let o = (...s10) => {
      T.startScope(r);
      try {
        let i = n(...s10);
        return rl(i) && console.error("Cannot return a Promise inside of tidy."), T.endScope(i), i;
      } catch (i) {
        throw T.endScope(null), i;
      }
    };
    return Object.defineProperty(o, "name", { value: r, configurable: true }), o;
  }
  function v4(e28, t) {
    let r = S(e28, "real", "complex"), n = S(t, "imag", "complex");
    uy(r.shape, n.shape, `real and imag shapes, ${r.shape} and ${n.shape}, must match in call to tf.complex().`);
    let o = { real: r, imag: n };
    return T.runKernel(Pc, o);
  }
  var Yn = k({ complex_: v4 });
  function Nu(e28, t, r, n) {
    if (n == null) n = Ta(e28);
    else if (n === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (My(e28) || Ly(e28)) {
      if (n !== "float32" && n !== "int32") throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);
      return T.backend.createTensorFromGPUData(e28, t || r, n);
    }
    if (!Yr(e28) && !Array.isArray(e28) && typeof e28 != "number" && typeof e28 != "boolean" && typeof e28 != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (t != null) {
      Ar(t);
      let o = ie(t), s10 = ie(r);
      I(o === s10, () => `Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s10}`);
      for (let i = 0; i < r.length; ++i) {
        let a = r[i], u = i === r.length - 1 ? a !== ie(t.slice(i)) : true;
        I(r[i] === t[i] || !u, () => `Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${t}). `);
      }
    }
    return !Yr(e28) && !Array.isArray(e28) && (e28 = [e28]), t = t || r, e28 = n !== "string" ? yp(e28, n) : wu(e28, [], true), T.makeTensor(e28, t, n);
  }
  function me(e28, t, r) {
    let n = wl(e28, r);
    return Nu(e28, t, n, r);
  }
  var Wi = { float32: 4, float16: 2, int32: 4, uint16: 2, uint8: 1, bool: 1, complex64: 8 };
  var Gr = class e2 {
    static join(t) {
      return new e2(t).slice();
    }
    constructor(t) {
      if (this.shards = [], this.previousShardIndex = 0, t == null || (t instanceof Array || (t = [t]), t = t.map((n) => Yr(n) ? n.buffer : n), t.length === 0)) return;
      this.bufferUniformSize = t[0].byteLength;
      let r = 0;
      for (let n = 0; n < t.length; n++) {
        let o = t[n];
        n !== t.length - 1 && o.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
        let s10 = r + o.byteLength;
        this.shards.push({ buffer: o, start: r, end: s10 }), r = s10;
      }
      this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(t = 0, r = this.byteLength) {
      if (this.shards.length === 0) return new ArrayBuffer(0);
      if (t = isNaN(Number(t)) ? 0 : t, r = isNaN(Number(r)) ? 0 : r, t = Math.max(0, t), r = Math.min(this.byteLength, r), r <= t) return new ArrayBuffer(0);
      let n = this.findShardForByte(t);
      if (n === -1) throw new Error(`Could not find start shard for byte ${t}`);
      let o = r - t, s10 = new ArrayBuffer(o), i = new Uint8Array(s10), a = 0;
      for (let u = n; u < this.shards.length; u++) {
        let l = this.shards[u], p = t + a - l.start, m = a, h = Math.min(r, l.end) - l.start, d = new Uint8Array(l.buffer, p, h - p);
        if (i.set(d, m), a += d.length, r < l.end) break;
      }
      return s10;
    }
    findShardForByte(t) {
      if (this.shards.length === 0 || t < 0 || t >= this.byteLength) return -1;
      if (this.bufferUniformSize != null) return this.previousShardIndex = Math.floor(t / this.bufferUniformSize), this.previousShardIndex;
      function r(o) {
        return t < o.start ? -1 : t >= o.end ? 1 : 0;
      }
      if (r(this.shards[this.previousShardIndex]) === 0) return this.previousShardIndex;
      let n = N4(this.shards, r);
      return n === -1 ? -1 : (this.previousShardIndex = n, this.previousShardIndex);
    }
  };
  function N4(e28, t) {
    let r = 0, n = e28.length;
    for (; r <= n; ) {
      let o = Math.floor((n - r) / 2) + r, s10 = t(e28[o]);
      if (s10 === 0) return o;
      s10 < 0 ? n = o : r = o + 1;
    }
    return -1;
  }
  function C4(e28) {
    z().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e28 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
  }
  $T(C4);
  function yo() {
    return T;
  }
  function Mf() {
    return T.memory();
  }
  function M(e28, t) {
    return T.tidy(e28, t);
  }
  function Mt(e28) {
    Pf(e28).forEach((r) => r.dispose());
  }
  function wr(e28) {
    return T.keep(e28);
  }
  function RT() {
    return T.backendName;
  }
  function Vy(e28, t, r = 1) {
    return T.registerBackend(e28, t, r);
  }
  function Gy() {
    return T.backend;
  }
  var Cu = 4;
  async function MT(e28, t) {
    let r = [], n = [], o = Array.isArray(e28) ? e28.map((i) => i.name) : Object.keys(e28);
    for (let i = 0; i < o.length; ++i) {
      let a = o[i], u = Array.isArray(e28) ? e28[i].tensor : e28[a];
      if (u.dtype !== "float32" && u.dtype !== "int32" && u.dtype !== "bool" && u.dtype !== "string" && u.dtype !== "complex64") throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);
      let l = { name: a, shape: u.shape, dtype: u.dtype };
      if (u.dtype === "string") {
        let c = new Promise(async (p) => {
          let m = await u.bytes(), f = m.reduce((g, y) => g + y.length, 0) + Cu * m.length, h = new Uint8Array(f), d = 0;
          for (let g = 0; g < m.length; g++) {
            let y = m[g], b = new Uint8Array(new Uint32Array([y.length]).buffer);
            h.set(b, d), d += Cu, h.set(y, d), d += y.length;
          }
          p(h);
        });
        n.push(c);
      } else n.push(u.data());
      t != null && (l.group = t), r.push(l);
    }
    let s10 = await Promise.all(n);
    return { data: T4(s10), specs: r };
  }
  function Wy(e28, t) {
    let r = new Gr(e28), n = {}, o = 0;
    for (let s10 of t) {
      let i = S4(s10, (a, u) => r.slice(o + a, o + u));
      n[s10.name] = zT(s10, r.slice(o, o + i)), o += i;
    }
    return n;
  }
  function S4(e28, t) {
    let r = ie(e28.shape), n;
    if ("quantization" in e28) {
      let o = e28.quantization;
      n = Wi[o.dtype];
    } else if (e28.dtype === "string") {
      let o = 0;
      for (let s10 = 0; s10 < r; s10++) o += Cu + new Uint32Array(t(o, o + Cu))[0];
      return o;
    } else n = Wi[e28.dtype];
    return r * n;
  }
  async function I4(e28, t) {
    let r = ie(e28.shape), n;
    if ("quantization" in e28) {
      let o = e28.quantization;
      n = Wi[o.dtype];
    } else if (e28.dtype === "string") {
      let o = 0;
      for (let s10 = 0; s10 < r; s10++) o += Cu + new Uint32Array(await t(o, o + Cu))[0];
      return o;
    } else n = Wi[e28.dtype];
    return r * n;
  }
  function zT(e28, t) {
    let r = e28.name, n = e28.dtype, o = e28.shape, s10 = ie(o), i, a = 0;
    if ("quantization" in e28) {
      let u = e28.quantization;
      if (u.dtype === "uint8" || u.dtype === "uint16") {
        if (!("min" in u && "scale" in u)) throw new Error(`Weight ${e28.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`);
      } else if (u.dtype === "float16") {
        if (n !== "float32") throw new Error(`Weight ${e28.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${n}.`);
      } else throw new Error(`Weight ${e28.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      let l = Wi[u.dtype], c = u.dtype === "uint8" ? new Uint8Array(t) : new Uint16Array(t);
      if (n === "float32") if (u.dtype === "uint8" || u.dtype === "uint16") {
        i = new Float32Array(c.length);
        for (let p = 0; p < c.length; p++) {
          let m = c[p];
          i[p] = m * u.scale + u.min;
        }
      } else if (u.dtype === "float16") i = D4()(c);
      else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);
      else if (n === "int32") {
        if (u.dtype !== "uint8" && u.dtype !== "uint16") throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);
        i = new Int32Array(c.length);
        for (let p = 0; p < c.length; p++) {
          let m = c[p];
          i[p] = Math.round(m * u.scale + u.min);
        }
      } else throw new Error(`Unsupported dtype in weight '${r}': ${n}`);
      a += s10 * l;
    } else if (n === "string") {
      let u = ie(e28.shape);
      i = [];
      for (let l = 0; l < u; l++) {
        let c = new Uint32Array(t.slice(a, a + Cu))[0];
        a += Cu;
        let p = new Uint8Array(t.slice(a, a + c));
        i.push(p), a += c;
      }
    } else {
      let u = Wi[n];
      if (n === "float32") i = new Float32Array(t);
      else if (n === "int32") i = new Int32Array(t);
      else if (n === "bool") i = new Uint8Array(t);
      else if (n === "complex64") {
        i = new Float32Array(t);
        let l = new Float32Array(i.length / 2), c = new Float32Array(i.length / 2);
        for (let h = 0; h < l.length; h++) l[h] = i[h * 2], c[h] = i[h * 2 + 1];
        let p = me(l, o, "float32"), m = me(c, o, "float32"), f = Yn(p, m);
        return p.dispose(), m.dispose(), f;
      } else throw new Error(`Unsupported dtype in weight '${r}': ${n}`);
      a += s10 * u;
    }
    return me(i, o, n);
  }
  async function PT(e28, t, r) {
    let n = new Uint8Array(t);
    for (; n.byteLength < r; ) {
      let { done: o, value: s10 } = await e28.read();
      if (o && s10 == null) {
        let a = r - n.byteLength;
        throw new Error(`Reader is done but ${a} bytes are still expected`);
      }
      let i = new Uint8Array(n.length + s10.byteLength);
      i.set(n, 0), i.set(new Uint8Array(s10), n.length), n = i;
    }
    return n.buffer;
  }
  async function oN(e28, t) {
    let r = {}, n = e28.getReader(), o = new ArrayBuffer(0);
    for (let s10 of t) {
      let i = await I4(s10, async (l, c) => (o = await PT(n, o, c), o.slice(l, c)));
      o = await PT(n, o, i);
      let a = o.slice(0, i);
      o = o.slice(i);
      let u = zT(s10, a);
      if (r[s10.name] = u, RT() === "webgpu") {
        let l = Gy();
        "uploadToGPU" in l && ie(u.shape) >= z().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && l.uploadToGPU(u.dataId);
      }
    }
    return r;
  }
  function T4(e28) {
    if (e28 === null) throw new Error(`Invalid input value: ${JSON.stringify(e28)}`);
    let t = 0, r = [];
    e28.forEach((s10) => {
      if (t += s10.byteLength, r.push(s10.byteLength === s10.buffer.byteLength ? s10 : new s10.constructor(s10)), !(s10 instanceof Float32Array || s10 instanceof Int32Array || s10 instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${s10.constructor.name}`);
    });
    let n = new Uint8Array(t), o = 0;
    return r.forEach((s10) => {
      n.set(new Uint8Array(s10.buffer), o), o += s10.byteLength;
    }), n.buffer;
  }
  var sN = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
  function LT(e28) {
    return sN ? Buffer.byteLength(e28, "utf8") : new Blob([e28]).size;
  }
  function BT(e28) {
    if (sN) return Buffer.from(e28).toString("base64");
    let t = new Uint8Array(e28), r = "";
    for (let n = 0, o = t.length; n < o; n++) r += String.fromCharCode(t[n]);
    return btoa(r);
  }
  function VT(e28) {
    if (sN) {
      let n = Buffer.from(e28, "base64");
      return n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
    }
    let t = atob(e28), r = new Uint8Array(t.length);
    for (let n = 0; n < t.length; ++n) r.set([t.charCodeAt(n)], n);
    return r.buffer;
  }
  function GT(e28) {
    return Gr.join(e28);
  }
  function iN(e28) {
    let t = "/";
    for (e28 = e28.trim(); e28.endsWith(t); ) e28 = e28.slice(0, e28.length - 1);
    let r = e28.split(t);
    return r[r.length - 1];
  }
  function Uy(e28, t) {
    let r = { modelTopology: e28.modelTopology, format: e28.format, generatedBy: e28.generatedBy, convertedBy: e28.convertedBy, weightsManifest: t };
    return e28.signature != null && (r.signature = e28.signature), e28.userDefinedMetadata != null && (r.userDefinedMetadata = e28.userDefinedMetadata), e28.modelInitializer != null && (r.modelInitializer = e28.modelInitializer), e28.initializerSignature != null && (r.initializerSignature = e28.initializerSignature), e28.trainingConfig != null && (r.trainingConfig = e28.trainingConfig), r;
  }
  function aN(e28, t, r) {
    let n = { modelTopology: e28.modelTopology, format: e28.format, generatedBy: e28.generatedBy, convertedBy: e28.convertedBy };
    if (e28.trainingConfig != null && (n.trainingConfig = e28.trainingConfig), e28.weightsManifest != null) {
      if (!t) throw new Error("modelJSON has weightsManifest but weightSpecs is null");
      if (!r) throw new Error("modelJSON has weightsManifest but weightData is null");
      n.weightSpecs = t, n.weightData = r;
    }
    return e28.signature != null && (n.signature = e28.signature), e28.userDefinedMetadata != null && (n.userDefinedMetadata = e28.userDefinedMetadata), e28.modelInitializer != null && (n.modelInitializer = e28.modelInitializer), e28.initializerSignature != null && (n.initializerSignature = e28.initializerSignature), n;
  }
  async function vp(e28, t) {
    let r, n;
    return e28.weightsManifest != null && ([r, n] = await t(e28.weightsManifest)), aN(e28, r, n);
  }
  function bs(e28) {
    if (e28.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: e28.modelTopology == null ? 0 : LT(JSON.stringify(e28.modelTopology)), weightSpecsBytes: e28.weightSpecs == null ? 0 : LT(JSON.stringify(e28.weightSpecs)), weightDataBytes: e28.weightData == null ? 0 : new Gr(e28.weightData).byteLength };
  }
  function zf(e28) {
    let t = [];
    for (let r of e28) t.push(...r.weights);
    return t;
  }
  function k4() {
    let e28 = (r) => {
      let n = r << 13, o = 0;
      for (; !(n & 8388608); ) o -= 8388608, n <<= 1;
      return n &= -8388609, o += 947912704, n | o;
    }, t = new Uint32Array(2048);
    t[0] = 0;
    for (let r = 1; r < 1024; r++) t[r] = e28(r);
    for (let r = 1024; r < 2048; r++) t[r] = 939524096 + (r - 1024 << 13);
    return t;
  }
  function E4() {
    let e28 = new Uint32Array(64);
    e28[0] = 0, e28[31] = 1199570944, e28[32] = 2147483648, e28[63] = 3347054592;
    for (let t = 1; t < 31; t++) e28[t] = t << 23;
    for (let t = 33; t < 63; t++) e28[t] = 2147483648 + (t - 32 << 23);
    return e28;
  }
  function A4() {
    let e28 = new Uint32Array(64);
    for (let t = 0; t < 64; t++) e28[t] = 1024;
    return e28[0] = e28[32] = 0, e28;
  }
  function D4() {
    let e28 = k4(), t = E4(), r = A4();
    return (n) => {
      let o = new ArrayBuffer(4 * n.length), s10 = new Uint32Array(o);
      for (let i = 0; i < n.length; i++) {
        let a = n[i], u = e28[r[a >> 10] + (a & 1023)] + t[a >> 10];
        s10[i] = u;
      }
      return new Float32Array(o);
    };
  }
  var vr = class e3 {
    constructor() {
      this.saveRouters = [], this.loadRouters = [];
    }
    static getInstance() {
      return e3.instance == null && (e3.instance = new e3()), e3.instance;
    }
    static registerSaveRouter(t) {
      e3.getInstance().saveRouters.push(t);
    }
    static registerLoadRouter(t) {
      e3.getInstance().loadRouters.push(t);
    }
    static getSaveHandlers(t) {
      return e3.getHandlers(t, "save");
    }
    static getLoadHandlers(t, r) {
      return e3.getHandlers(t, "load", r);
    }
    static getHandlers(t, r, n) {
      let o = [];
      return (r === "load" ? e3.getInstance().loadRouters : e3.getInstance().saveRouters).forEach((i) => {
        let a = i(t, n);
        a !== null && o.push(a);
      }), o;
    }
  };
  var WT = (e28) => vr.registerSaveRouter(e28);
  var UT = (e28) => vr.registerLoadRouter(e28);
  var jT = (e28) => vr.getSaveHandlers(e28);
  var HT = (e28, t) => vr.getLoadHandlers(e28, t);
  var uN = "tensorflowjs";
  var lN = 1;
  var vl = "models_store";
  var Su = "model_info_store";
  function KT() {
    if (!z().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    let e28 = typeof window > "u" ? self : window, t = e28.indexedDB || e28.mozIndexedDB || e28.webkitIndexedDB || e28.msIndexedDB || e28.shimIndexedDB;
    if (t == null) throw new Error("The current browser does not appear to support IndexedDB.");
    return t;
  }
  function cN(e28) {
    let t = e28.result;
    t.createObjectStore(vl, { keyPath: "modelPath" }), t.createObjectStore(Su, { keyPath: "modelPath" });
  }
  var ws = class {
    constructor(t) {
      if (this.indexedDB = KT(), t == null || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      this.modelPath = t;
    }
    async save(t) {
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return this.databaseAction(this.modelPath, t);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    databaseAction(t, r) {
      return new Promise((n, o) => {
        let s10 = this.indexedDB.open(uN, lN);
        s10.onupgradeneeded = () => cN(s10), s10.onsuccess = () => {
          let i = s10.result;
          if (r == null) {
            let a = i.transaction(vl, "readonly"), l = a.objectStore(vl).get(this.modelPath);
            l.onsuccess = () => {
              if (l.result == null) return i.close(), o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              n(l.result.modelArtifacts);
            }, l.onerror = (c) => (i.close(), o(l.error)), a.oncomplete = () => i.close();
          } else {
            r.weightData = Gr.join(r.weightData);
            let a = bs(r), u = i.transaction(Su, "readwrite"), l = u.objectStore(Su), c;
            try {
              c = l.put({ modelPath: this.modelPath, modelArtifactsInfo: a });
            } catch (m) {
              return o(m);
            }
            let p;
            c.onsuccess = () => {
              p = i.transaction(vl, "readwrite");
              let m = p.objectStore(vl), f;
              try {
                f = m.put({ modelPath: this.modelPath, modelArtifacts: r, modelArtifactsInfo: a });
              } catch (h) {
                return o(h);
              }
              f.onsuccess = () => n({ modelArtifactsInfo: a }), f.onerror = (h) => {
                l = u.objectStore(Su);
                let d = l.delete(this.modelPath);
                d.onsuccess = () => (i.close(), o(f.error)), d.onerror = (g) => (i.close(), o(f.error));
              };
            }, c.onerror = (m) => (i.close(), o(c.error)), u.oncomplete = () => {
              p == null ? i.close() : p.oncomplete = () => i.close();
            };
          }
        }, s10.onerror = (i) => o(s10.error);
      });
    }
  };
  ws.URL_SCHEME = "indexeddb://";
  var qT = (e28) => z().getBool("IS_BROWSER") && !Array.isArray(e28) && e28.startsWith(ws.URL_SCHEME) ? $4(e28.slice(ws.URL_SCHEME.length)) : null;
  vr.registerSaveRouter(qT);
  vr.registerLoadRouter(qT);
  function $4(e28) {
    return new ws(e28);
  }
  function F4(e28) {
    return e28.startsWith(ws.URL_SCHEME) ? e28.slice(ws.URL_SCHEME.length) : e28;
  }
  var jy = class {
    constructor() {
      this.indexedDB = KT();
    }
    async listModels() {
      return new Promise((t, r) => {
        let n = this.indexedDB.open(uN, lN);
        n.onupgradeneeded = () => cN(n), n.onsuccess = () => {
          let o = n.result, s10 = o.transaction(Su, "readonly"), a = s10.objectStore(Su).getAll();
          a.onsuccess = () => {
            let u = {};
            for (let l of a.result) u[l.modelPath] = l.modelArtifactsInfo;
            t(u);
          }, a.onerror = (u) => (o.close(), r(a.error)), s10.oncomplete = () => o.close();
        }, n.onerror = (o) => r(n.error);
      });
    }
    async removeModel(t) {
      return t = F4(t), new Promise((r, n) => {
        let o = this.indexedDB.open(uN, lN);
        o.onupgradeneeded = () => cN(o), o.onsuccess = () => {
          let s10 = o.result, i = s10.transaction(Su, "readwrite"), a = i.objectStore(Su), u = a.get(t), l;
          u.onsuccess = () => {
            if (u.result == null) return s10.close(), n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));
            {
              let c = a.delete(t), p = () => {
                l = s10.transaction(vl, "readwrite");
                let f = l.objectStore(vl).delete(t);
                f.onsuccess = () => r(u.result.modelArtifactsInfo), f.onerror = (h) => n(u.error);
              };
              c.onsuccess = p, c.onerror = (m) => (p(), s10.close(), n(u.error));
            }
          }, u.onerror = (c) => (s10.close(), n(u.error)), i.oncomplete = () => {
            l == null ? s10.close() : l.oncomplete = () => s10.close();
          };
        }, o.onerror = (s10) => n(o.error);
      });
    }
  };
  var Ui = "/";
  var Np = "tensorflowjs_models";
  var XT = "info";
  var _4 = "model_topology";
  var O4 = "weight_specs";
  var R4 = "weight_data";
  var P4 = "model_metadata";
  function YT(e28) {
    return { info: [Np, e28, XT].join(Ui), topology: [Np, e28, _4].join(Ui), weightSpecs: [Np, e28, O4].join(Ui), weightData: [Np, e28, R4].join(Ui), modelMetadata: [Np, e28, P4].join(Ui) };
  }
  function JT(e28) {
    for (let t of Object.values(e28)) window.localStorage.removeItem(t);
  }
  function L4(e28) {
    let t = e28.split(Ui);
    if (t.length < 3) throw new Error(`Invalid key format: ${e28}`);
    return t.slice(1, t.length - 1).join(Ui);
  }
  function M4(e28) {
    return e28.startsWith(vs.URL_SCHEME) ? e28.slice(vs.URL_SCHEME.length) : e28;
  }
  var vs = class {
    constructor(t) {
      if (!z().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u") throw new Error("The current environment does not support local storage.");
      if (this.LS = window.localStorage, t == null || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      this.modelPath = t, this.keys = YT(this.modelPath);
    }
    async save(t) {
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        let r = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), o = bs(t), s10 = Gr.join(t.weightData);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, r), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, BT(s10));
          let i = { format: t.format, generatedBy: t.generatedBy, convertedBy: t.convertedBy, signature: t.signature != null ? t.signature : void 0, userDefinedMetadata: t.userDefinedMetadata != null ? t.userDefinedMetadata : void 0, modelInitializer: t.modelInitializer != null ? t.modelInitializer : void 0, initializerSignature: t.initializerSignature != null ? t.initializerSignature : void 0, trainingConfig: t.trainingConfig != null ? t.trainingConfig : void 0 };
          return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(i)), { modelArtifactsInfo: o };
        } catch {
          throw JT(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`);
        }
      }
    }
    async load() {
      let t = JSON.parse(this.LS.getItem(this.keys.info));
      if (t == null) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      if (t.modelTopologyType !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      let r = {}, n = JSON.parse(this.LS.getItem(this.keys.topology));
      if (n == null) throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      r.modelTopology = n;
      let o = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (o == null) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      r.weightSpecs = o;
      let s10 = this.LS.getItem(this.keys.modelMetadata);
      if (s10 != null) {
        let a = JSON.parse(s10);
        r.format = a.format, r.generatedBy = a.generatedBy, r.convertedBy = a.convertedBy, a.signature != null && (r.signature = a.signature), a.userDefinedMetadata != null && (r.userDefinedMetadata = a.userDefinedMetadata), a.modelInitializer != null && (r.modelInitializer = a.modelInitializer), a.initializerSignature != null && (r.initializerSignature = a.initializerSignature), a.trainingConfig != null && (r.trainingConfig = a.trainingConfig);
      }
      let i = this.LS.getItem(this.keys.weightData);
      if (i == null) throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      return r.weightData = VT(i), r;
    }
  };
  vs.URL_SCHEME = "localstorage://";
  var ZT = (e28) => z().getBool("IS_BROWSER") && !Array.isArray(e28) && e28.startsWith(vs.URL_SCHEME) ? z4(e28.slice(vs.URL_SCHEME.length)) : null;
  vr.registerSaveRouter(ZT);
  vr.registerLoadRouter(ZT);
  function z4(e28) {
    return new vs(e28);
  }
  var Hy = class {
    constructor() {
      I(z().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), I(typeof window > "u" || typeof window.localStorage < "u", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
    }
    async listModels() {
      let t = {}, r = Np + Ui, n = Ui + XT;
      for (let o = 0; o < this.LS.length; ++o) {
        let s10 = this.LS.key(o);
        if (s10.startsWith(r) && s10.endsWith(n)) {
          let i = L4(s10);
          t[i] = JSON.parse(this.LS.getItem(s10));
        }
      }
      return t;
    }
    async removeModel(t) {
      t = M4(t);
      let r = YT(t);
      if (this.LS.getItem(r.info) == null) throw new Error(`Cannot find model at path '${t}'`);
      let n = JSON.parse(this.LS.getItem(r.info));
      return JT(r), n;
    }
  };
  var Cp = "://";
  var Vo = class e5 {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      return e5.instance == null && (e5.instance = new e5()), e5.instance;
    }
    static registerManager(t, r) {
      I(t != null, () => "scheme must not be undefined or null."), t.endsWith(Cp) && (t = t.slice(0, t.indexOf(Cp))), I(t.length > 0, () => "scheme must not be an empty string.");
      let n = e5.getInstance();
      I(n.managers[t] == null, () => `A model store manager is already registered for scheme '${t}'.`), n.managers[t] = r;
    }
    static getManager(t) {
      let r = e5.getInstance().managers[t];
      if (r == null) throw new Error(`Cannot find model manager for scheme '${t}'`);
      return r;
    }
    static getSchemes() {
      return Object.keys(e5.getInstance().managers);
    }
  };
  function Ky(e28) {
    if (e28.indexOf(Cp) === -1) throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Vo.getSchemes().join(",")}`);
    return { scheme: e28.split(Cp)[0], path: e28.split(Cp)[1] };
  }
  async function QT(e28, t, r = false) {
    I(e28 !== t, () => `Old path and new path are the same: '${e28}'`);
    let n = vr.getLoadHandlers(e28);
    I(n.length > 0, () => `Copying failed because no load handler is found for source URL ${e28}.`), I(n.length < 2, () => `Copying failed because more than one (${n.length}) load handlers for source URL ${e28}.`);
    let o = n[0], s10 = vr.getSaveHandlers(t);
    I(s10.length > 0, () => `Copying failed because no save handler is found for destination URL ${t}.`), I(s10.length < 2, () => `Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);
    let i = s10[0], a = Ky(e28).scheme, u = Ky(e28).path, l = a === Ky(e28).scheme, c = await o.load();
    r && l && await Vo.getManager(a).removeModel(u);
    let p = await i.save(c);
    return r && !l && await Vo.getManager(a).removeModel(u), p.modelArtifactsInfo;
  }
  async function tk() {
    let e28 = Vo.getSchemes(), t = {};
    for (let r of e28) {
      let n = await Vo.getManager(r).listModels();
      for (let o in n) {
        let s10 = r + Cp + o;
        t[s10] = n[o];
      }
    }
    return t;
  }
  async function ek(e28) {
    let t = Ky(e28);
    return Vo.getManager(t.scheme).removeModel(t.path);
  }
  async function rk(e28, t) {
    return QT(e28, t, false);
  }
  async function nk(e28, t) {
    return QT(e28, t, true);
  }
  var pN = class {
    constructor() {
      this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
    }
    fetch(t, r) {
      return fetch(t, r);
    }
    now() {
      return performance.now();
    }
    encode(t, r) {
      if (r !== "utf-8" && r !== "utf8") throw new Error(`Browser's encoder only supports utf-8, but got ${r}`);
      return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);
    }
    decode(t, r) {
      return new TextDecoder(r).decode(t);
    }
    setTimeoutCustom(t, r) {
      if (typeof window > "u" || !z().getBool("USE_SETTIMEOUTCUSTOM")) {
        setTimeout(t, r);
        return;
      }
      this.functionRefs.push(t), setTimeout(() => {
        window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
      }, r), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", (n) => {
        if (n.source === window && n.data.name === this.messageName) {
          n.stopPropagation();
          let o = this.functionRefs[n.data.index];
          o(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
        }
      }, true));
    }
    isTypedArray(t) {
      return Fy(t);
    }
  };
  if (z().get("IS_BROWSER")) {
    z().setPlatform("browser", new pN());
    try {
      Vo.registerManager(vs.URL_SCHEME, new Hy());
    } catch {
    }
    try {
      Vo.registerManager(ws.URL_SCHEME, new jy());
    } catch {
    }
  }
  var B4 = { importFetch: () => ok() };
  var mN;
  var fN = class {
    constructor() {
      this.util = sk(), this.textEncoder = new this.util.TextEncoder();
    }
    fetch(t, r) {
      return z().global.fetch != null ? z().global.fetch(t, r) : (mN == null && (mN = B4.importFetch()), mN(t, r));
    }
    now() {
      let t = process.hrtime();
      return t[0] * 1e3 + t[1] / 1e6;
    }
    encode(t, r) {
      if (r !== "utf-8" && r !== "utf8") throw new Error(`Node built-in encoder only supports utf-8, but got ${r}`);
      return this.textEncoder.encode(t);
    }
    decode(t, r) {
      return t.length === 0 ? "" : new this.util.TextDecoder(r).decode(t);
    }
    isTypedArray(t) {
      return this.util.types.isFloat32Array(t) || this.util.types.isInt32Array(t) || this.util.types.isUint8Array(t) || this.util.types.isUint8ClampedArray(t);
    }
  };
  z().get("IS_NODE") && !z().get("IS_BROWSER") && z().setPlatform("node", new fN());
  function kt(e28, t = "float32", r) {
    return t = t || "float32", Ar(e28), new pe(e28, t, r);
  }
  function V4(e28, t) {
    let r = S(e28, "x", "cast");
    if (!Ov(t)) throw new Error(`Failed to cast to unknown dtype ${t}`);
    if (t === "string" && r.dtype !== "string" || t !== "string" && r.dtype === "string") throw new Error("Only strings can be casted to strings");
    let n = { x: r }, o = { dtype: t };
    return T.runKernel(hs, n, o);
  }
  var Z = k({ cast_: V4 });
  function G4(e28) {
    let r = { x: S(e28, "x", "clone", "string_or_numeric") };
    return T.runKernel(ds, r);
  }
  var _n = k({ clone_: G4 });
  function ik(e28, t = false) {
    console.log(e28.toString(t));
  }
  eN();
  var W4 = { buffer: kt, cast: Z, clone: _n, print: ik };
  DT(W4);
  function U4(e28, t) {
    let r = S(e28, "a", "add"), n = S(t, "b", "add");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(Mo, o);
  }
  var Y = k({ add_: U4 });
  function j4(e28, t) {
    let r = S(e28, "a", "floorDiv"), n = S(t, "b", "floorDiv");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(fi, o);
  }
  var qy = k({ floorDiv_: j4 });
  function H4(e28, t) {
    let r = S(e28, "a", "div"), n = S(t, "b", "div");
    if ([r, n] = Yt(r, n), r.dtype === "int32" && n.dtype === "int32") return qy(r, n);
    let o = { a: r, b: n }, s10 = {};
    return T.runKernel(ai, o, s10);
  }
  var ut = k({ div_: H4 });
  function K4(e28, t) {
    let r = S(e28, "a", "mul"), n = S(t, "b", "mul");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(Ci, o);
  }
  var F = k({ mul_: K4 });
  function q4(e28) {
    let t = S(e28, "x", "abs");
    if (t.dtype === "complex64") {
      let r = { x: t };
      return T.runKernel(Oa, r);
    } else {
      let r = { x: t };
      return T.runKernel(ka, r);
    }
  }
  var cr = k({ abs_: q4 });
  function X4(e28) {
    let r = { x: S(e28, "x", "acos") };
    return T.runKernel(Ys, r);
  }
  var hN = k({ acos_: X4 });
  function Y4(e28) {
    let r = { x: S(e28, "x", "acosh") };
    return T.runKernel(Js, r);
  }
  var dN = k({ acosh_: Y4 });
  function J4(e28, t = null, r = false) {
    let o = { x: S(e28, "x", "all", "bool") }, s10 = { axis: t, keepDims: r };
    return T.runKernel($c, o, s10);
  }
  var Bf = k({ all_: J4 });
  function Z4(e28, t = null, r = false) {
    let o = { x: S(e28, "x", "any", "bool") }, s10 = { axis: t, keepDims: r };
    return T.runKernel(Fc, o, s10);
  }
  var Sp = k({ any_: Z4 });
  function Q4(e28, t = 0) {
    let n = { x: S(e28, "x", "argMax") }, o = { axis: t };
    return T.runKernel(Ea, n, o);
  }
  var ji = k({ argMax_: Q4 });
  function tW(e28, t = 0) {
    let n = { x: S(e28, "x", "argMin") }, o = { axis: t };
    return T.runKernel(Aa, n, o);
  }
  var ak = k({ argMin_: tW });
  function eW(e28) {
    let r = { x: S(e28, "x", "asin") };
    return T.runKernel(Zs, r);
  }
  var gN = k({ asin_: eW });
  function rW(e28) {
    let r = { x: S(e28, "x", "asinh") };
    return T.runKernel(Qs, r);
  }
  var yN = k({ asinh_: rW });
  function nW(e28) {
    let r = { x: S(e28, "x", "atan") };
    return T.runKernel(ti, r);
  }
  var xN = k({ atan_: nW });
  function oW(e28, t) {
    let r = S(e28, "a", "atan2"), n = S(t, "b", "atan2");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(ri, o);
  }
  var uk = k({ atan2_: oW });
  function sW(e28) {
    let r = { x: S(e28, "x", "atanh") };
    return T.runKernel(ei, r);
  }
  var bN = k({ atanh_: sW });
  function iW(e28, t, r, n, o = "NHWC", s10) {
    let i = e28[3], a = [...t, i], u = ck(o);
    return Nl(e28, a, r, s10, n, null, null, u);
  }
  function vN(e28, t, r, n, o, s10, i = "channelsLast") {
    let [a, u] = Vf(t), l;
    if (i === "channelsLast") l = [a, u, e28[3], e28[3]];
    else if (i === "channelsFirst") l = [a, u, e28[1], e28[1]];
    else throw new Error(`Unknown dataFormat ${i}`);
    return Nl(e28, l, r, n, o, s10, false, i);
  }
  function aW(e28, t, r, n, o, s10, i = "NDHWC") {
    let [a, u, l] = wN(t), c, p;
    if (i === "NDHWC") p = "channelsLast", c = [a, u, l, e28[4], e28[4]];
    else if (i === "NCDHW") p = "channelsFirst", c = [a, u, l, e28[1], e28[1]];
    else throw new Error(`Unknown dataFormat ${i}`);
    return lk(e28, c, r, n, o, false, p, s10);
  }
  function Nl(e28, t, r, n, o, s10, i = false, a = "channelsLast") {
    let [u, l, c, p] = [-1, -1, -1, -1];
    if (a === "channelsLast") [u, l, c, p] = e28;
    else if (a === "channelsFirst") [u, p, l, c] = e28;
    else throw new Error(`Unknown dataFormat ${a}`);
    let [m, f, , h] = t, [d, g] = Vf(r), [y, b] = Vf(n), v = Ip(m, y), w = Ip(f, b), { padInfo: N, outHeight: E, outWidth: A } = cW(o, l, c, d, g, v, w, s10, a), D = i ? h * p : h, R;
    return a === "channelsFirst" ? R = [u, D, E, A] : a === "channelsLast" && (R = [u, E, A, D]), { batchSize: u, dataFormat: a, inHeight: l, inWidth: c, inChannels: p, outHeight: E, outWidth: A, outChannels: D, padInfo: N, strideHeight: d, strideWidth: g, filterHeight: m, filterWidth: f, effectiveFilterHeight: v, effectiveFilterWidth: w, dilationHeight: y, dilationWidth: b, inShape: e28, outShape: R, filterShape: t };
  }
  function lk(e28, t, r, n, o, s10 = false, i = "channelsLast", a) {
    let [u, l, c, p, m] = [-1, -1, -1, -1, -1];
    if (i === "channelsLast") [u, l, c, p, m] = e28;
    else if (i === "channelsFirst") [u, m, l, c, p] = e28;
    else throw new Error(`Unknown dataFormat ${i}`);
    let [f, h, d, , g] = t, [y, b, v] = wN(r), [w, N, E] = wN(n), A = Ip(f, w), D = Ip(h, N), R = Ip(d, E), { padInfo: L, outDepth: G, outHeight: W, outWidth: U } = pW(o, l, c, p, y, b, v, A, D, R, a), H = s10 ? g * m : g, j;
    return i === "channelsFirst" ? j = [u, H, G, W, U] : i === "channelsLast" && (j = [u, G, W, U, H]), { batchSize: u, dataFormat: i, inDepth: l, inHeight: c, inWidth: p, inChannels: m, outDepth: G, outHeight: W, outWidth: U, outChannels: H, padInfo: L, strideDepth: y, strideHeight: b, strideWidth: v, filterDepth: f, filterHeight: h, filterWidth: d, effectiveFilterDepth: A, effectiveFilterHeight: D, effectiveFilterWidth: R, dilationDepth: w, dilationHeight: N, dilationWidth: E, inShape: e28, outShape: j, filterShape: t };
  }
  function uW(e28, t, r, n, o) {
    n == null && (n = NN(e28, t, r));
    let s10 = e28[0], i = e28[1], a = Gf((s10 - t + 2 * n) / r + 1, o), u = Gf((i - t + 2 * n) / r + 1, o);
    return [a, u];
  }
  function lW(e28, t, r, n, o, s10) {
    o == null && (o = NN(e28, t[0], n[0]));
    let i = [0, 0, 0, r];
    for (let a = 0; a < 3; a++) e28[a] + 2 * o >= t[a] && (i[a] = Gf((e28[a] - t[a] + 2 * o) / n[a] + 1, s10));
    return i;
  }
  function NN(e28, t, r, n = 1) {
    let o = Ip(t, n);
    return Math.floor((e28[0] * (r - 1) - r + o) / 2);
  }
  function Vf(e28) {
    return typeof e28 == "number" ? [e28, e28, e28] : e28.length === 2 ? [e28[0], e28[1], 1] : e28;
  }
  function wN(e28) {
    return typeof e28 == "number" ? [e28, e28, e28] : e28;
  }
  function Ip(e28, t) {
    return t <= 1 ? e28 : e28 + (e28 - 1) * (t - 1);
  }
  function cW(e28, t, r, n, o, s10, i, a, u) {
    let l, c, p;
    if (typeof e28 == "number") {
      l = { top: e28, bottom: e28, left: e28, right: e28, type: e28 === 0 ? "VALID" : "NUMBER" };
      let f = uW([t, r], s10, n, e28, a);
      c = f[0], p = f[1];
    } else if (e28 === "same") {
      c = Math.ceil(t / n), p = Math.ceil(r / o);
      let m = Math.max(0, (c - 1) * n + s10 - t), f = Math.max(0, (p - 1) * o + i - r), h = Math.floor(m / 2), d = m - h, g = Math.floor(f / 2), y = f - g;
      l = { top: h, bottom: d, left: g, right: y, type: "SAME" };
    } else if (e28 === "valid") l = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, c = Math.ceil((t - s10 + 1) / n), p = Math.ceil((r - i + 1) / o);
    else if (typeof e28 == "object") {
      let m = u === "channelsLast" ? e28[1][0] : e28[2][0], f = u === "channelsLast" ? e28[1][1] : e28[2][1], h = u === "channelsLast" ? e28[2][0] : e28[3][0], d = u === "channelsLast" ? e28[2][1] : e28[3][1];
      l = { top: m, bottom: f, left: h, right: d, type: m === 0 && f === 0 && h === 0 && d === 0 ? "VALID" : "EXPLICIT" }, c = Gf((t - s10 + m + f) / n + 1, a), p = Gf((r - i + h + d) / o + 1, a);
    } else throw Error(`Unknown padding parameter: ${e28}`);
    return { padInfo: l, outHeight: c, outWidth: p };
  }
  function pW(e28, t, r, n, o, s10, i, a, u, l, c) {
    let p, m, f, h;
    if (e28 === "valid" && (e28 = 0), typeof e28 == "number") {
      p = { top: e28, bottom: e28, left: e28, right: e28, front: e28, back: e28, type: e28 === 0 ? "VALID" : "NUMBER" };
      let g = lW([t, r, n, 1], [a, u, l], 1, [o, s10, i], e28, c);
      m = g[0], f = g[1], h = g[2];
    } else if (e28 === "same") {
      m = Math.ceil(t / o), f = Math.ceil(r / s10), h = Math.ceil(n / i);
      let d = (m - 1) * o + a - t, g = (f - 1) * s10 + u - r, y = (h - 1) * i + l - n, b = Math.floor(d / 2), v = d - b, w = Math.floor(g / 2), N = g - w, E = Math.floor(y / 2), A = y - E;
      p = { top: w, bottom: N, left: E, right: A, front: b, back: v, type: "SAME" };
    } else throw Error(`Unknown padding parameter: ${e28}`);
    return { padInfo: p, outDepth: m, outHeight: f, outWidth: h };
  }
  function Gf(e28, t) {
    if (!t) return Math.trunc(e28);
    switch (t) {
      case "round":
        return Math.round(e28);
      case "ceil":
        return Math.ceil(e28);
      case "floor":
        return Math.floor(e28);
      default:
        throw new Error(`Unknown roundingMode ${t}`);
    }
  }
  function Jn(e28) {
    let [t, r, n] = Vf(e28);
    return t === 1 && r === 1 && n === 1;
  }
  function $r(e28, t) {
    return Jn(e28) || Jn(t);
  }
  function Ns(e28) {
    return Vf(e28).every((t) => t > 0);
  }
  function ck(e28) {
    if (e28 === "NHWC") return "channelsLast";
    if (e28 === "NCHW") return "channelsFirst";
    throw new Error(`Unknown dataFormat ${e28}`);
  }
  function be(e28, t, r) {
    if (r != null) {
      if (typeof t == "string") throw Error(`Error in ${e28}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);
      if (typeof t == "number") I(Xs(t), () => `Error in ${e28}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);
      else if (typeof t == "object") t.forEach((n) => {
        n.forEach((o) => {
          I(Xs(o), () => `Error in ${e28}: pad must be an integer when using dimRoundingMode ${r} but got pad ${o}.`);
        });
      });
      else throw Error(`Error in ${e28}: Unknown padding parameter: ${t}`);
    }
  }
  function mW(e28, t) {
    let n = { x: S(e28, "x", "reshape", "string_or_numeric") }, o = { shape: t };
    return T.runKernel(iu, n, o);
  }
  var _ = k({ reshape_: mW });
  function fW(e28, t, r, n, o) {
    let s10 = S(e28, "x", "avgPool", "float32"), i = 1;
    I($r(r, i), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);
    let a = s10, u = false;
    s10.rank === 3 && (u = true, a = _(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), I(a.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${a.rank}.`), be("avgPool", n, o);
    let l = { x: a }, c = { filterSize: t, strides: r, pad: n, dimRoundingMode: o }, p = T.runKernel(Da, l, c);
    return p = Z(p, s10.dtype), u ? _(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
  var Cl = k({ avgPool_: fW });
  function hW(e28, t, r, n, o, s10 = "NDHWC") {
    let i = S(e28, "x", "avgPool3d", "float32"), a = i, u = false;
    i.rank === 4 && (u = true, a = _(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), I(a.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`), I(s10 === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s10}`), I(typeof r == "number" && r > 0 || Array.isArray(r) && r[0] > 0 && r[1] > 0 && r[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${r}'`), be("avgPool3d", n, o);
    let l = { x: a }, c = { filterSize: t, strides: r, pad: n, dimRoundingMode: o, dataFormat: s10 }, p = T.runKernel($a, l, c);
    return p = Z(p, a.dtype), u ? _(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p;
  }
  var CN = k({ avgPool3d_: hW });
  function dW(e28, t = 0) {
    I(e28.length >= 1, () => "Pass at least one tensor to concat");
    let r = By(e28, "tensors", "concat", "string_or_numeric");
    if (r[0].dtype === "complex64" && r.forEach((s10) => {
      if (s10.dtype !== "complex64") throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s10.dtype}. `);
    }), r.length === 1) return _n(r[0]);
    let n = r, o = { axis: t };
    return T.runKernel(Ra, n, o);
  }
  var Ne = k({ concat_: dW });
  function gW(e28, t, r = false, n = false) {
    let o = S(e28, "a", "matMul"), s10 = S(t, "b", "matMul");
    [o, s10] = Yt(o, s10);
    let i = { a: o, b: s10 }, a = { transposeA: r, transposeB: n };
    return T.runKernel(Fa, i, a);
  }
  var ae = k({ matMul_: gW });
  function yW(e28) {
    let r = { x: S(e28, "x", "sigmoid", "float32") };
    return T.runKernel(Oi, r);
  }
  var xo = k({ sigmoid_: yW });
  function xW(e28, t, r) {
    let n = S(e28, "x", "slice", "string_or_numeric");
    if (n.rank === 0) throw new Error("Slicing scalar is not possible");
    let o = { x: n }, s10 = { begin: t, size: r };
    return T.runKernel(pu, o, s10);
  }
  var Qt = k({ slice_: xW });
  function bW(e28) {
    let r = { x: S(e28, "x", "tanh", "float32") };
    return T.runKernel(Bi, r);
  }
  var Sl = k({ tanh_: bW });
  function wW(e28, t, r) {
    let n = S(e28, "x", "batchToSpaceND"), o = t.reduce((a, u) => a * u);
    I(n.rank >= 1 + t.length, () => `input rank is ${n.rank} but should be > than blockShape.length ${t.length}`), I(r.length === t.length, () => `crops.length is ${r.length} but should be equal to blockShape.length  ${t.length}`), I(n.shape[0] % o === 0, () => `input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);
    let s10 = { x: n }, i = { blockShape: t, crops: r };
    return T.runKernel(_a, s10, i);
  }
  var Tp = k({ batchToSpaceND_: wW });
  function pk(e28) {
    let t;
    return e28.rank === 0 || e28.rank === 1 ? t = _(e28, [1, 1, 1, e28.size]) : e28.rank === 2 ? t = _(e28, [1, 1, e28.shape[0], e28.shape[1]]) : e28.rank === 3 ? t = _(e28, [1, e28.shape[0], e28.shape[1], e28.shape[2]]) : t = e28, t;
  }
  function vW(e28, t, r, n, o, s10) {
    s10 == null && (s10 = 1e-3);
    let i = S(e28, "x", "batchNorm"), a = S(t, "mean", "batchNorm"), u = S(r, "variance", "batchNorm"), l;
    o != null && (l = S(o, "scale", "batchNorm"));
    let c;
    n != null && (c = S(n, "offset", "batchNorm")), I(a.rank === u.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), I(c == null || a.rank === c.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), I(l == null || a.rank === l.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let m = { x: pk(i), scale: l, offset: c, mean: a, variance: u }, f = { varianceEpsilon: s10 }, h = T.runKernel(Wa, m, f);
    return _(h, i.shape);
  }
  var Iu = k({ batchNorm_: vW });
  function NW(e28, t, r, n, o, s10) {
    let i = S(e28, "x", "batchNorm"), a = S(t, "mean", "batchNorm"), u = S(r, "variance", "batchNorm"), l;
    o != null && (l = S(o, "scale", "batchNorm"));
    let c;
    return n != null && (c = S(n, "offset", "batchNorm")), I(i.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`), I(a.rank === 2 || a.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`), I(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`), l != null && I(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`), c != null && I(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`), Iu(i, a, u, c, l, s10);
  }
  var SN = k({ batchNorm2d_: NW });
  function CW(e28, t, r, n, o, s10) {
    let i = S(e28, "x", "batchNorm"), a = S(t, "mean", "batchNorm"), u = S(r, "variance", "batchNorm"), l;
    o != null && (l = S(o, "scale", "batchNorm"));
    let c;
    return n != null && (c = S(n, "offset", "batchNorm")), I(i.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`), I(a.rank === 3 || a.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`), I(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`), l != null && I(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`), c != null && I(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`), Iu(i, a, u, c, l, s10);
  }
  var IN = k({ batchNorm3d_: CW });
  function SW(e28, t, r, n, o, s10) {
    let i = S(e28, "x", "batchNorm"), a = S(t, "mean", "batchNorm"), u = S(r, "variance", "batchNorm"), l;
    o != null && (l = S(o, "scale", "batchNorm"));
    let c;
    return n != null && (c = S(n, "offset", "batchNorm")), I(i.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`), I(a.rank === 4 || a.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`), I(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`), l != null && I(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`), c != null && I(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`), Iu(i, a, u, c, l, s10);
  }
  var TN = k({ batchNorm4d_: SW });
  function IW(e28, t, r) {
    let n = S(e28, "x", "bincount"), o = S(t, "weights", "bincount");
    I(n.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${n.dtype}`), I(r >= 0, () => `size must be non-negative, but got ${r}.`), I(o.size === n.size || o.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);
    let s10 = { x: n, weights: o }, i = { size: r };
    return T.runKernel(Rc, s10, i);
  }
  var mk = k({ bincount_: IW });
  function TW(e28, t) {
    let r = S(e28, "broadcastTo", "x"), n = r.shape;
    if (Ar(t), t.length < r.rank) throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${r.rank}.`);
    if (t.length > r.rank) {
      let l = r.shape.slice();
      for (; l.length < t.length; ) l.unshift(1);
      r = _(r, l);
    }
    let o = r.shape, s10 = Array.from(t);
    for (let l = t.length - 1; l >= 0; l--) if (o[l] === t[l]) s10[l] = 1;
    else if (r.shape[l] !== 1) throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);
    if (s10.map((l, c) => l > 1 ? c : -1).filter((l) => l >= 0).length === 0) return _n(r);
    let a = { x: r }, u = { reps: s10 };
    return T.runKernel(gs, a, u);
  }
  var Hi = k({ broadcastTo_: TW });
  function kW(e28) {
    let r = { x: S(e28, "x", "ceil", "float32") };
    return T.runKernel(ni, r);
  }
  var kN = k({ ceil_: kW });
  function Ki(e28, t, r) {
    Ar(e28), r = r || Ta(t);
    let n = { shape: e28, value: t, dtype: r };
    return T.runKernel(Xc, {}, n);
  }
  function EW(e28, t, r) {
    let n = S(e28, "x", "clipByValue");
    if (I(t <= r, () => `Error in clip: min (${t}) must be less than or equal to max (${r}).`), t === r) return Ki(n.shape, t, n.dtype);
    let o = { x: n }, s10 = { clipValueMin: t, clipValueMax: r };
    return T.runKernel(oi, o, s10);
  }
  var Fr = k({ clipByValue_: EW });
  function AW(e28) {
    return Ne(e28, 0);
  }
  var EN = k({ concat1d_: AW });
  function DW(e28, t) {
    return Ne(e28, t);
  }
  var AN = k({ concat2d_: DW });
  function $W(e28, t) {
    return Ne(e28, t);
  }
  var DN = k({ concat3d_: $W });
  function FW(e28, t) {
    return Ne(e28, t);
  }
  var $N = k({ concat4d_: FW });
  function _W(e28, t, r, n, o = "NHWC", s10 = [1, 1], i) {
    let a = S(e28, "x", "conv2d", "float32"), u = S(t, "filter", "conv2d", "float32"), l = a, c = false;
    a.rank === 3 && (c = true, l = _(a, [1, a.shape[0], a.shape[1], a.shape[2]])), I(l.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${l.rank}.`), I(u.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`), be("conv2d", n, i);
    let p = o === "NHWC" ? l.shape[3] : l.shape[1];
    I(p === u.shape[2], () => `Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`), I($r(r, s10), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s10}'`), I(Ns(s10), () => "Error in conv2D: Dilated rates should be larger than 0."), I(Ns(r), () => "Error in conv2D: Strides should be larger than 0.");
    let m = { x: l, filter: u }, f = { strides: r, pad: n, dataFormat: o, dilations: s10, dimRoundingMode: i }, h = T.runKernel(Pa, m, f);
    return c ? _(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
  var On = k({ conv2d_: _W });
  function OW(e28, t, r, n, o = "NWC", s10 = 1, i) {
    let a = S(e28, "x", "conv1d"), u = S(t, "filter", "conv1d"), l = a, c = false;
    a.rank === 2 && (c = true, l = _(a, [1, a.shape[0], a.shape[1]])), I(l.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${l.rank}.`), I(u.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`), be("conv1d", n, i), I(l.shape[2] === u.shape[1], () => `Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`), I($r(r, s10), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${r} and dilation '${s10}'`), I(Ns(s10), () => "Error in conv1D: Dilated rates should be larger than 0."), I(Ns(r), () => "Error in conv1D: Stride should be larger than 0."), I(o === "NWC", () => `Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);
    let p = _(u, [1, u.shape[0], u.shape[1], u.shape[2]]), m = _(l, [l.shape[0], 1, l.shape[1], l.shape[2]]), g = On(m, p, [1, r], n, "NHWC", [1, s10], i);
    return c ? _(g, [g.shape[2], g.shape[3]]) : _(g, [g.shape[0], g.shape[2], g.shape[3]]);
  }
  var Wf = k({ conv1d_: OW });
  function RW(e28, t, r, n, o, s10 = "NHWC", i) {
    I(e28.length === t.rank, () => `Length of inShape (${e28.length}) and rank of dy (${t.rank}) must match`);
    let a = e28, u = t, l = false;
    t.rank === 3 && (l = true, u = _(t, [1, t.shape[0], t.shape[1], t.shape[2]]), a = [1, e28[0], e28[1], e28[2]]), I(a.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`), I(u.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`), I(r.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${r.rank}`);
    let c = s10 === "NHWC" ? a[3] : a[1], p = s10 === "NHWC" ? u.shape[3] : u.shape[1];
    I(c === r.shape[2], () => `Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${r.shape[2]}.`), I(p === r.shape[3], () => `Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${r.shape[3]}.`), be("conv2dDerInput", o, i);
    let m = { dy: u, filter: r }, f = { strides: n, pad: o, dataFormat: s10, dimRoundingMode: i, inputShape: a }, h = T.runKernel(La, m, f);
    return l ? _(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
  var kp = k({ conv2DBackpropInput_: RW });
  function PW(e28, t, r, n, o, s10) {
    let i = S(e28, "x", "conv2dTranspose"), a = S(t, "filter", "conv2dTranspose");
    return kp(r, i, a, n, o, "NHWC", s10);
  }
  var Uf = k({ conv2dTranspose_: PW });
  function LW(e28, t, r, n, o = "NDHWC", s10 = [1, 1, 1]) {
    let i = S(e28, "x", "conv3d"), a = S(t, "filter", "conv3d"), u = i, l = false;
    i.rank === 4 && (l = true, u = _(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), I(u.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${u.rank}.`), I(a.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`), I(u.shape[4] === a.shape[3], () => `Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`), I($r(r, s10), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s10}'`), I(o === "NDHWC", () => `Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`), I(Ns(s10), () => "Error in conv3D: Dilated rates should be larger than 0."), I(Ns(r), () => "Error in conv3D: Strides should be larger than 0.");
    let c = { x: u, filter: a }, p = { strides: r, pad: n, dataFormat: o, dilations: s10 }, m = T.runKernel(Ma, c, p);
    return l ? _(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
  var FN = k({ conv3d_: LW });
  function MW(e28, t, r, n, o) {
    I(e28.length === t.rank, () => `Length of inShape (${e28.length}) and rank of dy (${t.rank}) must match`);
    let s10 = e28, i = t, a = false;
    t.rank === 4 && (a = true, i = _(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), s10 = [1, e28[0], e28[1], e28[2], e28[3]]);
    let u = s10[4], l = i.shape[4];
    I(s10.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${s10.length}.`), I(i.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`), I(r.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${r.rank}`), I(u === r.shape[3], () => `Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${r.shape[3]}.`), I(l === r.shape[4], () => `Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${r.shape[4]}.`);
    let c = { dy: i, filter: r }, p = { pad: o, strides: n, inputShape: s10 }, m = T.runKernel(zc, c, p);
    return a ? _(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
  var Xy = k({ conv3DBackpropInput_: MW });
  function zW(e28, t, r, n, o) {
    let s10 = S(e28, "x", "conv3dTranspose"), i = S(t, "filter", "conv3dTranspose");
    return Xy(r, s10, i, n, o);
  }
  var _N = k({ conv3dTranspose_: zW });
  function BW(e28) {
    let r = { x: S(e28, "x", "cos", "float32") };
    return T.runKernel(si, r);
  }
  var Il = k({ cos_: BW });
  function VW(e28) {
    let r = { x: S(e28, "x", "cosh", "float32") };
    return T.runKernel(ii, r);
  }
  var jf = k({ cosh_: VW });
  function GW(e28, t = 0, r = false, n = false) {
    let s10 = { x: S(e28, "x", "cumprod") }, i = { axis: t, exclusive: r, reverse: n };
    return T.runKernel(Bc, s10, i);
  }
  var Hf = k({ cumprod_: GW });
  function WW(e28, t = 0, r = false, n = false) {
    let s10 = { x: S(e28, "x", "cumsum") }, i = { axis: t, exclusive: r, reverse: n };
    return T.runKernel(za, s10, i);
  }
  var Yy = k({ cumsum_: WW });
  function UW(e28, t, r, n = false) {
    let o = S(e28, "x", "denseBincount"), s10 = S(t, "weights", "denseBincount");
    I(o.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${o.dtype}`), I(o.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`), I(r >= 0, () => `size must be non-negative, but got ${r}.`), I(s10.size === o.size || s10.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s10.shape}.`);
    let i = { x: o, weights: s10 }, a = { size: r, binaryOutput: n };
    return T.runKernel(Gc, i, a);
  }
  var Jy = k({ denseBincount_: UW });
  function jW(e28, t, r = "NHWC") {
    let n = S(e28, "x", "depthToSpace", "float32"), o = r === "NHWC" ? n.shape[1] : n.shape[2], s10 = r === "NHWC" ? n.shape[2] : n.shape[3], i = r === "NHWC" ? n.shape[3] : n.shape[1];
    I(t > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${t}`), I(o * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`), I(s10 * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${s10} and ${t} for depthToSpace with input shape
        ${n.shape}`), I(i % (t * t) === 0, () => `Dimension size must be evenly divisible by ${t * t} but is ${i} for depthToSpace with input shape ${n.shape}`);
    let a = { x: n }, u = { blockSize: t, dataFormat: r };
    return T.runKernel(Wc, a, u);
  }
  var fk = k({ depthToSpace_: jW });
  function HW(e28, t, r, n, o = "NHWC", s10 = [1, 1], i) {
    let a = S(e28, "x", "depthwiseConv2d", "float32"), u = S(t, "filter", "depthwiseConv2d", "float32"), l = a, c = false;
    a.rank === 3 && (c = true, l = _(a, [1, a.shape[0], a.shape[1], a.shape[2]])), I(l.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`), I(u.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);
    let p = o === "NHWC" ? l.shape[3] : l.shape[1];
    I(p === u.shape[2], () => `Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`), be("depthwiseConv2d", n, i);
    let m = { x: l, filter: u }, f = { strides: r, pad: n, dataFormat: o, dilations: s10, dimRoundingMode: i }, h = T.runKernel(Ba, m, f);
    return c ? _(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
  var qi = k({ depthwiseConv2d_: HW });
  function KW(e28, t, r, n, o = [1, 1], s10 = "NHWC") {
    let i = S(e28, "x", "dilation2d"), a = S(t, "filter", "dilation2d");
    I(i.rank === 3 || i.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`), I(a.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`), I(s10 === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s10}`);
    let u = i, l = false;
    i.rank === 3 && (u = _(i, [1, i.shape[0], i.shape[1], i.shape[2]]), l = true), I(u.shape[3] === a.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);
    let c = { x: u, filter: a }, p = { strides: r, pad: n, dilations: o }, m = T.runKernel(Va, c, p);
    return l ? _(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
  }
  var hk = k({ dilation2d_: KW });
  var Rn = {};
  lo(Rn, { assertAndGetBroadcastShape: () => Gt, getBroadcastDims: () => dk, getReductionAxes: () => de });
  function dk(e28, t) {
    let r = e28.length, n = [];
    for (let o = 0; o < r; o++) {
      let s10 = r - 1 - o, i = e28[s10] || 1;
      (t[t.length - 1 - o] || 1) > 1 && i === 1 && n.unshift(s10);
    }
    return n;
  }
  function de(e28, t) {
    let r = [];
    for (let n = 0; n < t.length; n++) {
      let o = e28[e28.length - n - 1], s10 = t.length - n - 1, i = t[s10];
      (o == null || o === 1 && i > 1) && r.unshift(s10);
    }
    return r;
  }
  function Gt(e28, t) {
    let r = Math.max(e28.length, t.length), n = new Array(r);
    for (let o = 0; o < r; o++) {
      let s10 = e28[e28.length - o - 1];
      s10 == null && (s10 = 1);
      let i = t[t.length - o - 1];
      if (i == null && (i = 1), s10 === 1) n[r - o - 1] = i;
      else if (i === 1) n[r - o - 1] = s10;
      else if (s10 !== i) {
        let a = `Operands could not be broadcast together with shapes ${e28} and ${t}.`;
        throw Error(a);
      } else n[r - o - 1] = s10;
    }
    return n;
  }
  function qW(e28, t) {
    let r = S(e28, "a", "equal", "string_or_numeric"), n = S(t, "b", "equal", "string_or_numeric");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(nl, o);
  }
  var an = k({ equal_: qW });
  function XW(e28, t, r) {
    let n = S(t, "a", "where"), o = S(r, "b", "where"), s10 = S(e28, "condition", "where", "bool"), i = Gt(Gt(s10.shape, n.shape), o.shape), a = Hi(s10, i), u = Hi(n, i), l = Hi(o, i), c = { condition: a, t: u, e: l };
    return T.runKernel(cu, c);
  }
  var Ce = k({ where_: XW });
  function YW(e28) {
    let r = { x: S(e28, "x", "zerosLike") };
    return T.runKernel(xu, r);
  }
  var Dt = k({ zerosLike_: YW });
  function JW(e28, t) {
    let r = S(e28, "a", "div"), n = S(t, "b", "div");
    [r, n] = Yt(r, n);
    let o = ut(r, n), s10 = Dt(o), i = an(n, s10);
    return Ce(i, s10, o);
  }
  var gk = k({ divNoNan_: JW });
  function ZW(e28, t) {
    let r = S(e28, "t1", "dot"), n = S(t, "t2", "dot");
    I((r.rank === 1 || r.rank === 2) && (n.rank === 1 || n.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${r.rank} and ${n.rank}.`);
    let o = r.rank === 1 ? r.size : r.shape[1], s10 = n.rank === 1 ? n.size : n.shape[0];
    if (I(o === s10, () => `Error in dot: inner dimensions of inputs must match, but got ${o} and ${s10}.`), r.rank === 1 && n.rank === 1) {
      let i = _(r, [1, -1]), a = _(n, [-1, 1]), u = ae(i, a);
      return _(u, []);
    } else if (r.rank === 1 && n.rank === 2) {
      let i = _(r, [1, -1]), a = _(n, [n.shape[0], n.shape[1]]), u = ae(i, a);
      return _(u, [u.size]);
    } else if (r.rank === 2 && n.rank === 1) {
      let i = _(n, [-1, 1]), a = ae(r, i);
      return _(a, [a.size]);
    } else {
      let i = _(n, [n.shape[0], n.shape[1]]);
      return ae(r, i);
    }
  }
  var yk = k({ dot_: ZW });
  function QW(e28, ...t) {
    let r = t.map((o, s10) => S(o, `tensors${s10}`, "einsum")), n = { equation: e28 };
    return T.runKernel(Hc, r, n);
  }
  var Ep = k({ einsum_: QW });
  function tU(e28) {
    let r = { x: S(e28, "x", "elu", "float32") };
    return T.runKernel(ui, r);
  }
  var Xi = k({ elu_: tU });
  function eU(e28) {
    let t = S(e28, "x", "erf");
    I(t.dtype === "int32" || t.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), t.dtype === "int32" && (t = Z(t, "float32"));
    let r = { x: t };
    return T.runKernel(li, r);
  }
  var Kf = k({ erf_: eU });
  function ON(e28, t) {
    for (let r = 0; r < e28.length; ++r) if (e28[e28.length - r - 1] !== t - 1 - r) return false;
    return true;
  }
  function xk(e28, t, r) {
    let n = e28.length + t.length, o = [], s10 = 0, i = 0;
    for (let a = 0; a < n; a++) r.indexOf(a) === -1 ? o.push(e28[s10++]) : o.push(t[i++]);
    return o;
  }
  function RN(e28, t) {
    let r = [], n = e28.length;
    for (let s10 = 0; s10 < n; s10++) t.indexOf(s10) === -1 && r.push(e28[s10]);
    let o = t.map((s10) => e28[s10]);
    return [r, o];
  }
  function Cs(e28, t) {
    let r = t.map((n) => 1);
    return xk(e28, r, t);
  }
  function rU(e28, t, r) {
    I(ON(t, r), () => `${e28} supports only inner-most axes for now. Got axes ${t} and rank-${r} input.`);
  }
  function PN(e28, t) {
    if (ON(e28, t)) return null;
    let r = [];
    for (let n = 0; n < t; ++n) e28.indexOf(n) === -1 && r.push(n);
    return e28.forEach((n) => r.push(n)), r;
  }
  function qf(e28) {
    return e28.map((t, r) => [r, t]).sort((t, r) => t[1] - r[1]).map((t) => t[0]);
  }
  function nU(e28, t) {
    let r = [];
    for (let n = t - e28; n < t; ++n) r.push(n);
    return r;
  }
  function oU(e28, t = null, r = false) {
    let o = { x: S(e28, "x", "max") }, s10 = { reductionIndices: t, keepDims: r };
    return T.runKernel(Ka, o, s10);
  }
  var _r = k({ max_: oU });
  function sU(e28, t = null, r = false) {
    let o = { x: S(e28, "x", "min") }, s10 = { axis: t, keepDims: r };
    return T.runKernel(Ja, o, s10);
  }
  var Tu = k({ min_: sU });
  function iU(e28, t) {
    let r = S(e28, "base", "pow"), n = S(t, "exp", "pow");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(Si, o);
  }
  var wn = k({ pow_: iU });
  function $t(e28, t) {
    if ((Yr(e28) && t !== "string" || Array.isArray(e28)) && t !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if (t === "string" && Yr(e28) && !(e28 instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return Nu(e28, [], [], t);
  }
  function aU(e28) {
    let r = { x: S(e28, "x", "sqrt", "float32") };
    return T.runKernel(Pi, r);
  }
  var ge = k({ sqrt_: aU });
  function uU(e28) {
    let t = S(e28, "x", "square"), r = {};
    return T.runKernel("Square", { x: t }, r);
  }
  var Xt = k({ square_: uU });
  function lU(e28, t = null, r = false) {
    let n = S(e28, "x", "sum");
    n.dtype === "bool" && (n = Z(n, "int32"));
    let o = { x: n }, s10 = { axis: t, keepDims: r };
    return T.runKernel(mu, o, s10);
  }
  var ht = k({ sum_: lU });
  function cU(e28, t = "euclidean", r = null, n = false) {
    e28 = S(e28, "x", "norm");
    let o = bk(e28, t, r), s10 = o.shape;
    if (n) {
      let i = dr(r, e28.shape);
      s10 = Cs(o.shape, i);
    }
    return _(o, s10);
  }
  function bk(e28, t, r = null) {
    if (e28.rank === 0) return cr(e28);
    if (e28.rank !== 1 && r === null) return bk(_(e28, [-1]), t, r);
    if (e28.rank === 1 || typeof r == "number" || Array.isArray(r) && r.length === 1) {
      if (t === 1) return ht(cr(e28), r);
      if (t === 1 / 0) return _r(cr(e28), r);
      if (t === -1 / 0) return Tu(cr(e28), r);
      if (t === "euclidean" || t === 2) return ge(ht(wn(cr(e28), $t(2, "int32")), r));
      throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    if (Array.isArray(r) && r.length === 2) {
      if (t === 1) return _r(ht(cr(e28), r[0]), r[1] - 1);
      if (t === 1 / 0) return _r(ht(cr(e28), r[1]), r[0]);
      if (t === -1 / 0) return Tu(ht(cr(e28), r[1]), r[0]);
      if (t === "fro" || t === "euclidean") return ge(ht(Xt(e28), r));
      throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    throw new Error(`Error in norm: invalid axis: ${r}`);
  }
  var ku = k({ norm_: cU });
  function pU(e28, t = null, r = false) {
    return ku(e28, "euclidean", t, r);
  }
  var wk = k({ euclideanNorm_: pU });
  function mU(e28) {
    let r = { x: S(e28, "x", "exp") };
    return T.runKernel(ci, r);
  }
  var Nr = k({ exp_: mU });
  function fU(e28, t = 0) {
    let r = S(e28, "x", "expandDims", "string_or_numeric");
    I(t <= r.rank, () => "Axis must be <= rank of the tensor");
    let n = { input: r }, o = { dim: t };
    return T.runKernel(Ga, n, o);
  }
  var or = k({ expandDims_: fU });
  function hU(e28) {
    let r = { x: S(e28, "x", "expm1") };
    return T.runKernel(pi, r);
  }
  var MN = k({ expm1_: hU });
  function dU(e28, t) {
    let r = S(e28, "x", "tile", "string_or_numeric");
    I(r.rank === t.length, () => `Error in transpose: rank of input ${r.rank} must match length of reps ${t}.`);
    let n = { x: r }, o = { reps: t };
    return T.runKernel(gs, n, o);
  }
  var Wr = k({ tile_: dU });
  function gU(e28, t, r, n = "float32") {
    t == null && (t = e28);
    let o = kt([e28, t], n), s10 = e28 <= t ? e28 : t;
    for (let a = 0; a < s10; ++a) o.set(1, a, a);
    let i = _(o.toTensor(), [e28, t]);
    if (r == null) return i;
    if (r.length === 1) return Wr(or(i, 0), [r[0], 1, 1]);
    if (r.length === 2) return Wr(or(or(i, 0), 0), [r[0], r[1], 1, 1]);
    if (r.length === 3) return Wr(or(or(or(i, 0), 0), 0), [r[0], r[1], r[2], 1, 1]);
    throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${r.length}D.`);
  }
  var Ap = k({ eye_: gU });
  function yU(e28) {
    let r = { x: S(e28, "x", "floor", "float32") };
    return T.runKernel(mi, r);
  }
  var Yi = k({ floor_: yU });
  function xU(e28, t, r = 0, n = 0) {
    let o = S(e28, "x", "gather"), s10 = S(t, "indices", "gather", "int32"), i = { x: o, indices: s10 }, a = { axis: r, batchDims: n };
    return T.runKernel(Ua, i, a);
  }
  var Tl = k({ gather_: xU });
  function bU(e28, t) {
    let r = S(e28, "a", "greater", "string_or_numeric"), n = S(t, "b", "greater", "string_or_numeric");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(ol, o);
  }
  var je = k({ greater_: bU });
  function wU(e28, t) {
    let r = S(e28, "a", "greaterEqual", "string_or_numeric"), n = S(t, "b", "greaterEqual", "string_or_numeric");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(hi, o);
  }
  var vn = k({ greaterEqual_: wU });
  function vU(e28) {
    let r = { input: S(e28, "input", "imag") };
    return T.runKernel(Zc, r);
  }
  var Dp = k({ imag_: vU });
  function NU(e28) {
    let r = { x: S(e28, "x", "isFinite") };
    return T.runKernel(di, r);
  }
  var zN = k({ isFinite_: NU });
  function CU(e28) {
    let r = { x: S(e28, "x", "isInf") };
    return T.runKernel(gi, r);
  }
  var BN = k({ isInf_: CU });
  function SU(e28) {
    let r = { x: S(e28, "x", "isNaN") };
    return T.runKernel(yi, r);
  }
  var VN = k({ isNaN_: SU });
  function IU(e28, t = 0.2) {
    let n = { x: S(e28, "x", "leakyRelu") }, o = { alpha: t };
    return T.runKernel(ja, n, o);
  }
  var kl = k({ leakyRelu_: IU });
  function TU(e28, t) {
    let r = S(e28, "a", "less", "string_or_numeric"), n = S(t, "b", "less", "string_or_numeric");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(sl, o);
  }
  var El = k({ less_: TU });
  function kU(e28, t) {
    let r = S(e28, "a", "lessEqual", "string_or_numeric"), n = S(t, "b", "lessEqual", "string_or_numeric");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(il, o);
  }
  var bo = k({ lessEqual_: kU });
  function EU(e28, t = 5, r = 1, n = 1, o = 0.5) {
    let s10 = S(e28, "x", "localResponseNormalization");
    I(s10.rank === 4 || s10.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s10.rank}.`), I(Xs(t), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);
    let i = s10, a = false;
    s10.rank === 3 && (a = true, i = _(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]]));
    let u = { x: i }, l = { depthRadius: t, bias: r, alpha: n, beta: o }, c = T.runKernel(Ha, u, l);
    return a ? _(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
  }
  var vk = k({ localResponseNormalization_: EU });
  function AU(e28) {
    let r = { x: S(e28, "x", "log", "float32") };
    return T.runKernel(xi, r);
  }
  var un = k({ log_: AU });
  function DU(e28) {
    let r = { x: S(e28, "x", "log1p") };
    return T.runKernel(bi, r);
  }
  var Xf = k({ log1p_: DU });
  function GN(e28, t) {
    I(kc(e28), () => "The f passed in variableGrads(f) must be a function"), I(t == null || Array.isArray(t) && t.every((l) => l instanceof Gi), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    let r = t != null;
    if (!r) {
      t = [];
      for (let l in T.registeredVariables) t.push(T.registeredVariables[l]);
    }
    let n = r ? t.filter((l) => !l.trainable) : null, o = t.length;
    t = t.filter((l) => l.trainable), I(t.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);
    let s10 = true, { value: i, grads: a } = T.gradients(e28, t, null, s10);
    I(a.some((l) => l != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), I(i.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);
    let u = {};
    return t.forEach((l, c) => {
      a[c] != null && (u[l.name] = a[c]);
    }), n?.forEach((l) => u[l.name] = null), { value: i, grads: u };
  }
  function Qn(e28) {
    return T.customGrad(e28);
  }
  function $U(e28) {
    let r = { x: S(e28, "x", "neg") };
    return T.runKernel(Qa, r);
  }
  var ne = k({ neg_: $U });
  function FU(e28) {
    let r = { x: S(e28, "x", "softplus") };
    return T.runKernel(Ri, r);
  }
  var Ss = k({ softplus_: FU });
  function _U(e28) {
    let t = S(e28, "x", "logSigmoid");
    return Qn((n) => ({ value: ne(Ss(ne(n))), gradFunc: (i) => F(i, xo(ne(n))) }))(t);
  }
  var WN = k({ logSigmoid_: _U });
  function OU(e28, t) {
    let r = S(e28, "a", "sub"), n = S(t, "b", "sub");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(Mi, o);
  }
  var xt = k({ sub_: OU });
  function RU(e28, t = -1) {
    let r = S(e28, "logits", "logSoftmax");
    if (t === -1 && (t = r.rank - 1), t !== r.rank - 1) throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and axis was ${t}`);
    return Qn((o, s10) => {
      let a = _r(o, t, true), u = xt(o, a), l = xt(Z(u, "float32"), un(ht(Nr(u), t, true)));
      return s10([l]), { value: l, gradFunc: (p, m) => {
        let [f] = m, h = true, d = Nr(f);
        return xt(p, F(ht(p, t, h), d));
      } };
    })(r);
  }
  var Yf = k({ logSoftmax_: RU });
  function PU(e28, t = null, r = false) {
    let n = S(e28, "x", "logSumExp"), o = dr(t, n.shape), s10 = _r(n, o, true), i = xt(n, s10), a = Nr(i), u = ht(a, o), l = un(u), c = Y(_(s10, l.shape), l);
    if (r) {
      let p = Cs(c.shape, o);
      return _(c, p);
    }
    return c;
  }
  var Jf = k({ logSumExp_: PU });
  function LU(e28, t) {
    let r = S(e28, "a", "logicalAnd", "bool"), n = S(t, "b", "logicalAnd", "bool");
    Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(al, o);
  }
  var Jr = k({ logicalAnd_: LU });
  function MU(e28) {
    let r = { x: S(e28, "x", "logicalNot", "bool") };
    return T.runKernel(ul, r);
  }
  var $p = k({ logicalNot_: MU });
  function zU(e28, t) {
    let r = S(e28, "a", "logicalOr", "bool"), n = S(t, "b", "logicalOr", "bool");
    Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(ll, o);
  }
  var Zy = k({ logicalOr_: zU });
  function BU(e28, t) {
    let r = S(e28, "a", "logicalXor", "bool"), n = S(t, "b", "logicalXor", "bool");
    return Gt(r.shape, n.shape), Jr(Zy(e28, t), $p(Jr(e28, t)));
  }
  var Nk = k({ logicalXor_: BU });
  function VU(e28, t, r, n, o) {
    let s10 = S(e28, "x", "maxPool"), i = 1, a = s10, u = false;
    s10.rank === 3 && (u = true, a = _(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), I(a.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${a.rank}.`), I($r(r, i), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`), be("maxPool", n, o);
    let l = { x: a }, c = { filterSize: t, strides: r, pad: n, dimRoundingMode: o }, p = T.runKernel(qa, l, c);
    return u ? _(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
  var Al = k({ maxPool_: VU });
  function GU(e28, t = [1, 1, 1], r, n, o, s10 = "NDHWC") {
    let i = S(e28, "x", "maxPool3d"), a = i, u = false;
    i.rank === 4 && (u = true, a = _(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), I(a.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`), I(s10 === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s10}`), be("maxPool3d", n, o);
    let l = { x: a }, c = { filterSize: t, strides: r, pad: n, dimRoundingMode: o, dataFormat: s10 }, p = T.runKernel(Xa, l, c);
    return u ? _(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p;
  }
  var UN = k({ maxPool3d_: GU });
  function WU(e28, t) {
    let r = S(e28, "a", "maximum"), n = S(t, "b", "maximum");
    [r, n] = Yt(r, n), r.dtype === "bool" && (r = Z(r, "int32"), n = Z(n, "int32")), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(wi, o);
  }
  var Pn = k({ maximum_: WU });
  function UU(e28, t = null, r = false) {
    let o = { x: S(e28, "x", "mean") }, s10 = { axis: t, keepDims: r };
    return T.runKernel(Ya, o, s10);
  }
  var ke = k({ mean_: UU });
  function Se(e28, t = "float32") {
    if (Ar(e28), t === "complex64") {
      let n = Se(e28, "float32"), o = Se(e28, "float32");
      return Yn(n, o);
    }
    let r = Ac(ie(e28), t);
    return T.makeTensor(r, e28, t);
  }
  function ln(e28, t = "float32") {
    if (Ar(e28), t === "complex64") {
      let n = ln(e28, "float32"), o = Se(e28, "float32");
      return Yn(n, o);
    }
    let r = If(ie(e28), t);
    return T.makeTensor(r, e28, t);
  }
  function jU(e28, t) {
    let r = S(e28, "a", "minimum"), n = S(t, "b", "minimum");
    [r, n] = Yt(r, n), r.dtype === "bool" && (r = Z(r, "int32"), n = Z(n, "int32")), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(vi, o);
  }
  var Is = k({ minimum_: jU });
  function HU(e28, t, r) {
    I(r === "reflect" || r === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${r}.`);
    let n = S(e28, "x", "mirrorPad");
    if (n.rank === 0) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    I(t.length === n.rank, () => `Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);
    let o = r === "reflect" ? 1 : 0;
    for (let a = 0; a < n.rank; a++) I(t[a].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), I(t[a][0] >= 0 && t[a][0] <= n.shape[a] - o && t[a][1] >= 0 && t[a][1] <= n.shape[a] - o, () => `Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a] - o} or less than 0 for input of shape ${n.shape}`);
    let s10 = { paddings: t, mode: r }, i = { x: n };
    return T.runKernel(Za, i, s10);
  }
  var Ck = k({ mirrorPad_: HU });
  function KU(e28, t) {
    let r = S(e28, "a", "mod"), n = S(t, "b", "mod");
    [r, n] = Yt(r, n);
    let o = { a: r, b: n };
    return T.runKernel(Ni, o);
  }
  var Sk = k({ mod_: KU });
  function qU(e28, t = null, r = false) {
    e28 = S(e28, "x", "moments");
    let n = dr(t, e28.shape), o = ke(e28, n, r), s10 = o.shape;
    r || (s10 = Cs(o.shape, n));
    let i = Xt(xt(Z(e28, "float32"), _(o, s10))), a = ke(i, n, r);
    return { mean: o, variance: a };
  }
  var Fp = k({ moments_: qU });
  function XU(e28, t) {
    let r = S(e28, "a", "notEqual", "string_or_numeric"), n = S(t, "b", "notEqual", "string_or_numeric");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n };
    return T.runKernel(cl, o);
  }
  var Eu = k({ notEqual_: XU });
  function YU(e28, t, r = 1, n = 0, o = "int32") {
    if (t < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
    let i = { indices: S(e28, "indices", "oneHot", "int32") }, a = { dtype: o, depth: t, onValue: r, offValue: n };
    return T.runKernel(eu, i, a);
  }
  var _p = k({ oneHot_: YU });
  function JU(e28) {
    let r = { x: S(e28, "x", "onesLike") };
    return T.runKernel(tu, r);
  }
  var Cr = k({ onesLike_: JU });
  function ZU(e28, t, r = 0) {
    let n = S(e28, "x", "pad");
    if (n.rank === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    let o = { paddings: t, constantValue: r }, s10 = { x: n };
    return T.runKernel(nu, s10, o);
  }
  var Dl = k({ pad_: ZU });
  function QU(e28, t, r) {
    let n = S(e28, "x", "spaceToBatchND");
    I(n.rank >= 1 + t.length, () => `input rank ${n.rank} should be > than [blockShape] ${t.length}`), I(r.length === t.length, () => `paddings.shape[0] ${r.length} must be equal to [blockShape] ${t.length}`), I(n.shape.reduce((i, a, u) => u > 0 && u <= t.length ? i && (a + r[u - 1][0] + r[u - 1][1]) % t[u - 1] === 0 : i, true), () => `input spatial dimensions ${n.shape.slice(1)} with paddings ${r.toString()} must be divisible by blockShapes ${t.toString()}`);
    let o = { x: n }, s10 = { blockShape: t, paddings: r };
    return T.runKernel(fu, o, s10);
  }
  var Op = k({ spaceToBatchND_: QU });
  function tj(e28, t, r, n, o, s10, i) {
    o == null && (o = [1, 1]), s10 == null && (s10 = 1), n === 0 && (n = "valid");
    let a = S(e28, "x", "maxPool"), u = a, l = false;
    a.rank === 3 && (l = true, u = _(a, [1, a.shape[0], a.shape[1], a.shape[2]])), I($r(s10, o), () => `Error in pool: Either strides or dilations must be 1. Got strides ${s10} and dilations '${o}'`);
    let c = vN(u.shape, t, s10, o, n), p = [c.dilationHeight, c.dilationWidth], m;
    n === "same" ? m = rj([c.filterHeight, c.filterWidth], p) : m = [[0, 0], [0, 0]];
    let f = p[0] === 1 && p[1] === 1, [h, d] = ej([c.inHeight, c.inWidth], p, m), g = f ? n : "valid", y = f ? u : Op(u, p, h), v = (r === "avg" ? () => Cl(y, t, s10, g, i) : () => Al(y, t, s10, g, i))(), w = f ? v : Tp(v, p, d);
    return l ? _(w, [w.shape[1], w.shape[2], w.shape[3]]) : w;
  }
  function ej(e28, t, r) {
    let n = r.map((c) => c[0]), o = r.map((c) => c[1]), s10 = e28.concat(n, o), i = t.map((c, p) => (c - s10[p] % c) % c), a = o.map((c, p) => c + i[p]), u = t.map((c, p) => [n[p], a[p]]), l = t.map((c, p) => [0, i[p]]);
    return [u, l];
  }
  function rj(e28, t) {
    let n = e28.map((i, a) => i + (i - 1) * (t[a] - 1)).map((i) => i - 1), o = n.map((i) => Math.floor(i / 2)), s10 = n.map((i, a) => i - o[a]);
    return n.map((i, a) => [o[a], s10[a]]);
  }
  var Ik = k({ pool_: tj });
  function nj(e28, t) {
    let r = S(e28, "x", "prelu"), n = S(t, "alpha", "prelu"), o = { x: r, alpha: n };
    return T.runKernel(ou, o);
  }
  var $l = k({ prelu_: nj });
  function oj(e28, t = null, r = false) {
    let n = S(e28, "x", "prod");
    n.dtype === "bool" && (n = Z(n, "int32"));
    let o = { x: n }, s10 = { axis: t, keepDims: r };
    return T.runKernel(su, o, s10);
  }
  var Tk = k({ prod_: oj });
  var JN = ff(Zf());
  var Rp = class {
    constructor(t, r, n, o, s10) {
      this.mean = t, this.stdDev = r, this.dtype = n, this.nextVal = NaN, this.truncated = o, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
      let i = s10 || Math.random();
      this.random = JN.alea(i.toString());
    }
    nextValue() {
      if (!isNaN(this.nextVal)) {
        let o = this.nextVal;
        return this.nextVal = NaN, o;
      }
      let t, r, n = false;
      for (; !n; ) {
        let o, s10, i;
        do
          o = 2 * this.random() - 1, s10 = 2 * this.random() - 1, i = o * o + s10 * s10;
        while (i >= 1 || i === 0);
        let a = Math.sqrt(-2 * Math.log(i) / i);
        t = this.mean + this.stdDev * o * a, r = this.mean + this.stdDev * s10 * a, (!this.truncated || this.isValidTruncated(t)) && (n = true);
      }
      return (!this.truncated || this.isValidTruncated(r)) && (this.nextVal = this.convertValue(r)), this.convertValue(t);
    }
    convertValue(t) {
      return this.dtype == null || this.dtype === "float32" ? t : Math.round(t);
    }
    isValidTruncated(t) {
      return t <= this.upper && t >= this.lower;
    }
  };
  var tx = class {
    constructor(t = 0, r = 1, n, o) {
      if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = t, this.range = r - t, this.dtype = n, o == null && (o = Math.random()), typeof o == "number" && (o = o.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(`The difference between ${t} - ${r} <= 1 and dtype is not float`);
      this.random = JN.alea(o);
    }
    convertValue(t) {
      return this.canReturnFloat() ? t : Math.round(t);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  };
  function pj(e28, t = 0, r = 1, n, o) {
    if (Ar(e28), n != null && n === "bool") throw new Error(`Unsupported data type ${n}`);
    let s10 = new Rp(t, r, n, false, o), i = kt(e28, n);
    for (let a = 0; a < i.values.length; a++) i.values[a] = s10.nextValue();
    return i.toTensor();
  }
  var ex = k({ randomNormal_: pj });
  function mj(e28, t = 0, r = 1, n = "float32", o) {
    Ar(e28);
    let s10 = kt(e28, n), i = new tx(t, r, null, o);
    for (let a = 0; a < s10.values.length; a++) s10.values[a] = i.nextValue();
    return s10.toTensor();
  }
  var Go = k({ randomUniform_: mj });
  function Ji(e28, t, r = 1, n = "float32") {
    if (r === 0) throw new Error("Cannot have a step of zero");
    let o = { start: e28, stop: t, step: r, dtype: n };
    return T.runKernel(sp, {}, o);
  }
  function fj(e28) {
    let r = { input: S(e28, "input", "real") };
    return T.runKernel(ip, r);
  }
  var _l = k({ real_: fj });
  function hj(e28) {
    let r = { x: S(e28, "x", "reciprocal") };
    return T.runKernel(Ii, r);
  }
  var ZN = k({ reciprocal_: hj });
  function dj(e28) {
    let r = { x: S(e28, "x", "relu") };
    return T.runKernel(Ti, r);
  }
  var Ln = k({ relu_: dj });
  function gj(e28) {
    let r = { x: S(e28, "x", "relu6") };
    return T.runKernel(ki, r);
  }
  var rx = k({ relu6_: gj });
  function yj(e28, t) {
    let n = { x: S(e28, "x", "reverse") }, o = { dims: t };
    return T.runKernel(lu, n, o);
  }
  var to = k({ reverse_: yj });
  function xj(e28) {
    let r = { x: S(e28, "x", "round") };
    return T.runKernel(Ei, r);
  }
  var Qf = k({ round_: xj });
  function bj(e28) {
    let r = { x: S(e28, "x", "rsqrt", "float32") };
    return T.runKernel(Ai, r);
  }
  var th = k({ rsqrt_: bj });
  function wj(e28) {
    let r = { x: S(e28, "x", "selu") };
    return T.runKernel(Di, r);
  }
  var eh = k({ selu_: wj });
  function vj(e28, t, r, n, o, s10 = [1, 1], i = "NHWC") {
    let a = S(e28, "x", "separableConv2d"), u = S(t, "depthwiseFilter", "separableConv2d"), l = S(r, "pointwiseFilter", "separableConv2d"), c = a, p = false;
    if (a.rank === 3 && (p = true, c = _(a, [1, a.shape[0], a.shape[1], a.shape[2]])), i === "NCHW") throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    I(c.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`), I(u.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`), I(l.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`), I(l.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`), I(l.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);
    let m = u.shape[2], f = u.shape[3];
    I(l.shape[2] === m * f, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${m * f}, but got ${l.shape[2]}.`);
    let h = qi(c, u, n, o, i, s10), g = On(h, l, 1, "valid", i);
    return p ? _(g, [g.shape[1], g.shape[2], g.shape[3]]) : g;
  }
  var rh = k({ separableConv2d_: vj });
  function Nj(e28) {
    let r = { x: S(e28, "x", "sign") };
    return T.runKernel(_i, r);
  }
  var QN = k({ sign_: Nj });
  function Cj(e28) {
    let r = { x: S(e28, "x", "sin", "float32") };
    return T.runKernel($i, r);
  }
  var nh = k({ sin_: Cj });
  function Sj(e28) {
    let r = { x: S(e28, "x", "sinh") };
    return T.runKernel(Fi, r);
  }
  var oh = k({ sinh_: Sj });
  function Ij(e28, t, r) {
    let n = S(e28, "x", "slice1d");
    return I(n.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`), Qt(n, [t], [r]);
  }
  var sh = k({ slice1d_: Ij });
  function Tj(e28, t, r) {
    let n = S(e28, "x", "slice2d");
    return I(n.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`), Qt(n, t, r);
  }
  var nx = k({ slice2d_: Tj });
  function kj(e28, t, r) {
    let n = S(e28, "x", "slice3d");
    return I(n.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`), Qt(n, t, r);
  }
  var ih = k({ slice3d_: kj });
  function Ej(e28, t, r) {
    let n = S(e28, "x", "slice4d");
    return I(n.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`), Qt(n, t, r);
  }
  var Pp = k({ slice4d_: Ej });
  function Aj(e28, t = -1) {
    let r = S(e28, "logits", "softmax", "float32");
    if (t === -1 && (t = r.rank - 1), t !== r.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and dim was ${t}`);
    let n = { logits: r }, o = { dim: t };
    return T.runKernel(du, n, o);
  }
  var Ol = k({ softmax_: Aj });
  function Dj(e28) {
    I(e28.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${e28.dtype}.`);
    let t = { input: e28 };
    return T.runKernel(qc, t);
  }
  var ah = k({ fft_: Dj });
  function $j(e28) {
    I(e28.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${e28.dtype}.`);
    let t = { input: e28 };
    return T.runKernel(Jc, t);
  }
  var Lp = k({ ifft_: $j });
  function Fj(e28) {
    let t = e28.shape[e28.shape.length - 1], r = e28.size / t, n;
    if (t <= 2) {
      let o = _(e28, [r, t]);
      n = Lp(o);
    } else {
      let o = [r, 2 * (t - 1)], s10 = _(_l(e28), [r, t]), i = _(Dp(e28), [r, t]), a = to(Qt(s10, [0, 1], [r, t - 2]), 1), u = F(to(Qt(i, [0, 1], [r, t - 2]), 1), $t(-1)), l = Ne([s10, a], 1), c = Ne([i, u], 1), p = _(Yn(l, c), [o[0], o[1]]);
      n = Lp(p);
    }
    if (n = _l(n), e28.rank === 3 && e28.shape[0] !== 0) {
      let o = n, s10 = e28.shape[0];
      n = _(n, [s10, n.shape[0] / s10, n.shape[1]]), o.dispose();
    }
    return n;
  }
  var t1 = k({ irfft_: Fj });
  function _j(e28, t, r = 0) {
    let o = { x: S(e28, "x", "split") }, s10 = { numOrSizeSplits: t, axis: r };
    return T.runKernel(hu, o, s10);
  }
  var xr = k({ split_: _j });
  function Oj(e28, t) {
    I(e28.dtype === "float32", () => `The dtype for rfft() must be real value but got ${e28.dtype}`);
    let r = e28.shape[e28.shape.length - 1], n = e28.size / r, o;
    if (t != null && t < r) {
      let h = e28.shape.map((g) => 0), d = e28.shape.map((g) => g);
      d[e28.shape.length - 1] = t, o = Qt(e28, h, d), r = t;
    } else if (t != null && t > r) {
      let h = e28.shape.map((d) => d);
      h[e28.shape.length - 1] = t - r, o = Ne([e28, Se(h)], e28.shape.length - 1), r = t;
    } else o = e28;
    let s10 = Dt(o), i = _(Yn(o, s10), [n, r]), a = ah(i), u = Math.floor(r / 2) + 1, l = _l(a), c = Dp(a), p = xr(l, [u, r - u], l.shape.length - 1), m = xr(c, [u, r - u], c.shape.length - 1), f = o.shape.slice();
    return f[o.shape.length - 1] = u, _(Yn(p[0], m[0]), f);
  }
  var e1 = k({ rfft_: Oj });
  function Rj(e28, t) {
    let r = S(e28, "a", "squaredDifference"), n = S(t, "b", "squaredDifference");
    [r, n] = Yt(r, n), Gt(r.shape, n.shape);
    let o = { a: r, b: n }, s10 = {};
    return T.runKernel(Li, o, s10);
  }
  var Wk = k({ squaredDifference_: Rj });
  function Pj(e28, t) {
    let r = S(e28, "x", "squeeze", "string_or_numeric");
    return _(r, Fv(r.shape, t).newShape);
  }
  var Wo = k({ squeeze_: Pj });
  function Lj(e28, t = 0) {
    let r = By(e28, "tensors", "stack", "string_or_numeric");
    I(r.length >= 1, () => "Pass at least one tensor to tf.stack"), r.length > 0 && I(t <= r[0].rank, () => "Axis must be <= rank of the tensor");
    let n = r, o = { axis: t };
    return T.runKernel(ru, n, o);
  }
  var Xe = k({ stack_: Lj });
  function Mj(e28, t = 0) {
    let n = { x: S(e28, "x", "step") }, o = { alpha: t };
    return T.runKernel(Vi, n, o);
  }
  var Uo = k({ step_: Mj });
  function zj(e28, t, r, n, o = 0, s10 = 0, i = 0, a = 0, u = 0) {
    let c = { x: S(e28, "x", "stridedSlice", "string_or_numeric") }, p = { begin: t, end: r, strides: n, beginMask: o, endMask: s10, ellipsisMask: i, newAxisMask: a, shrinkAxisMask: u };
    return T.runKernel(cp, c, p);
  }
  var r1 = k({ stridedSlice_: zj });
  function Bj(e28) {
    let r = { x: S(e28, "x", "tan", "float32") };
    return T.runKernel(zi, r);
  }
  var n1 = k({ tan_: Bj });
  function sr(e28, t) {
    Sf(e28);
    let r = wl(e28, t);
    if (r.length !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return Nu(e28, null, r, t);
  }
  function uh(e28, t, r) {
    if (Sf(e28), t != null && t.length !== 2) throw new Error("tensor2d() requires shape to have two numbers");
    let n = wl(e28, r);
    if (n.length !== 2 && n.length !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (n.length === 1 && t == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return Nu(e28, t, n, r);
  }
  function Uk(e28, t, r) {
    let n = t.rank > 1 ? t.shape[t.rank - 1] : 1, o = t.rank > 1 ? t.rank - 1 : 1, s10 = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${r.shape}, indices.shape: ${t.shape}, shape: ${e28}, sliceDim: ${n}, and batchDim: ${o}.`;
    if (r.rank < o) throw new Error(s10 + ` update.rank < ${o}. `);
    if (e28.length < n + (r.rank - o)) throw new Error(s10 + ` Output shape length < ${n + (r.rank - o)}`);
    if (r.rank !== o + e28.length - n) throw new Error(s10 + ` update.rank != ${o + e28.length - n}`);
    for (let i = 0; i < o; ++i) if (r.shape[i] !== t.shape[i]) throw new Error(s10 + ` updates.shape[${i}] (${r.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);
    for (let i = 0; i < r.rank - o; ++i) if (r.shape[i + o] !== e28[i + n]) throw new Error(s10 + ` updates.shape[${i + o}] (${r.shape[i + o]}) != shape[${i + o}] (${e28[i + o]})`);
  }
  function Vj(e28, t, r) {
    if (t.rank < 1) throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
    if (e28.rank < 1) throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e28.rank}.`);
    if (t.dtype !== "int32") throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
    if (r.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${r}`);
    if (r.length === 0) {
      if (t.size === 0) throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
      if (e28.size === 0) throw new Error(`Updates specified for empty output. updates shape: ${e28.shape}`);
    }
    Uk(r, t, e28);
  }
  function Gj(e28, t, r) {
    let n = t.shape.length, o = n > 1 ? t.shape[n - 1] : 1, s10 = r.length, i = 1;
    for (let p = o; p < s10; ++p) i *= r[p];
    let a = o < 1 ? 1 : o, u = ie(t.shape) / a, l = [...fs(r.slice(0, o)), 1], c = ie(r);
    return { sliceRank: o, numUpdates: u, sliceSize: i, strides: l, outputSize: c };
  }
  function Wj(e28, t = 1, r = true) {
    let n = S(e28, "x", "topk");
    if (n.rank === 0) throw new Error("topk() expects the input to be of rank 1 or higher");
    let o = n.shape[n.shape.length - 1];
    if (t < 0) throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
    if (t > o) throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);
    let s10 = { x: n }, i = { k: t, sorted: r }, [a, u] = T.runKernel(pp, s10, i);
    return { values: a, indices: u };
  }
  var jk = k({ topk_: Wj });
  function Uj(e28, t = 0, r = 1, n, o) {
    if (Ar(e28), n != null && n === "bool") throw new Error("Unsupported data type $ { dtype }");
    let s10 = new Rp(t, r, n, true, o), i = kt(e28, n);
    for (let a = 0; a < i.values.length; a++) i.values[a] = s10.nextValue();
    return i.toTensor();
  }
  var lh = k({ truncatedNormal_: Uj });
  function jj(e28, t = 0) {
    let r = S(e28, "x", "unique", "string_or_numeric");
    I(r.rank > 0, () => "The input tensor must be at least 1D");
    let n = { x: r }, o = { axis: t }, [s10, i] = T.runKernel(fp, n, o);
    return { values: s10, indices: i };
  }
  var Hk = k({ unique_: jj });
  function Hj(e28, t, r) {
    let n = S(e28, "x", "unsortedSegmentSum"), o = S(t, "segmentIds", "unsortedSegmentSum", "int32");
    I(Xs(r), () => "numSegments must be of dtype int");
    let s10 = { x: n, segmentIds: o }, i = { numSegments: r };
    return T.runKernel(yu, s10, i);
  }
  var ox = k({ unsortedSegmentSum_: Hj });
  function Kj(e28, t = 0) {
    let r = S(e28, "x", "unstack", "string_or_numeric");
    I(t >= -r.shape.length && t < r.shape.length, () => `Axis = ${t} is not in [-${r.shape.length}, ${r.shape.length})`);
    let n = { value: r }, o = { axis: t };
    return T.runKernel(gu, n, o);
  }
  var Zr = k({ unstack_: Kj });
  function o1(e28, t = true, r, n) {
    return T.makeVariable(e28, t, r, n);
  }
  function Kk(e28, t) {
    let r = [];
    for (let s10 = 0; s10 < t.length; s10++) t[s10] && r.push(s10);
    let n = kt(e28, "int32"), o = kt([r.length, e28.length], "int32");
    for (let s10 = 0; s10 < r.length; s10++) {
      let i = n.indexToLoc(r[s10]), a = s10 * e28.length;
      o.values.set(i, a);
    }
    return o.toTensor();
  }
  function qj(e28, t, r) {
    let n = S(e28, "x", "transpose");
    if (t == null && (t = n.shape.map((i, a) => a).reverse()), I(n.rank === t.length, () => `Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`), t.forEach((i) => {
      I(i >= 0 && i < n.rank, () => `All entries in 'perm' must be between 0 and ${n.rank - 1} but got ${t}`);
    }), n.rank <= 1) return n.clone();
    let o = { x: n }, s10 = { perm: t };
    return n.dtype === "complex64" ? M(() => {
      let i = _l(n), a = Dp(n);
      return i = T.runKernel(ys, { x: i }, s10), a = T.runKernel(ys, { x: a }, s10), r && (a = ne(a)), Yn(i, a);
    }) : T.runKernel(ys, o, s10);
  }
  var qt = k({ transpose_: qj });
  function qk(e28, t) {
    if (t == null) return e28.shape.slice();
    if (Ia(e28.shape, t)) return t;
    if (e28.shape.length === t.length) {
      let r = [];
      for (let n = 0; n < e28.shape.length; n++) t[n] == null && e28.shape[n] != null ? r.push(e28.shape[n]) : r.push(t[n]);
      return r;
    }
    return t;
  }
  function Xj(e28, t, r, n) {
    let o = S(e28, "x", "dropout");
    if (I(o.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`), I(t >= 0 && t < 1, () => `rate must be a float in the range [0, 1), but got ${t}.`), t === 0) return e28 instanceof ee ? o.clone() : o;
    let s10 = qk(o, r), i = 1 - t, a = ut(Yi(Y(Go(s10, 0, 1, "float32", n), i)), i);
    return F(o, a);
  }
  var Xk = k({ dropout_: Xj });
  var zl = {};
  lo(zl, { conv2d: () => Yk, depthwiseConv2d: () => Jk, matMul: () => Zk });
  function Yj(e28, t, r, n, o, s10 = "NHWC", i) {
    let a = e28;
    e28.rank === 3 && (a = _(e28, [1, e28.shape[0], e28.shape[1], e28.shape[2]]));
    let u = t;
    u.rank === 3 && (u = _(t, [1, t.shape[0], t.shape[1], t.shape[2]])), I(a.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`), I(u.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`), I(r.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${r}.`);
    let l = s10 === "NHWC" ? a.shape[3] : a.shape[1], c = s10 === "NHWC" ? u.shape[3] : u.shape[1];
    I(l === r[2], () => `Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${r[2]}.`), I(c === r[3], () => `Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${r[3]}).`), be("conv2dDerFilter", o, i);
    let p = { x: a, dy: u }, m = { strides: n, pad: o, dataFormat: s10, dimRoundingMode: i, filterShape: r };
    return T.runKernel(Lc, p, m);
  }
  var Mp = k({ conv2DBackpropFilter_: Yj });
  function Rl(e28, t, r) {
    if (r == null || r === "linear") return e28;
    if (r === "relu") return F(e28, Uo(t));
    throw new Error(`Cannot compute gradient for fused activation ${r}.`);
  }
  function Pl(e28, t) {
    let r = t, n = de(e28.shape, t.shape);
    return n.length > 0 && (r = ht(r, n)), _(r, e28.shape);
  }
  function Ll(e28, t, r, n) {
    if (t === "linear") return e28;
    if (t === "relu") return Ln(e28);
    if (t === "elu") return Xi(e28);
    if (t === "relu6") return rx(e28);
    if (t === "prelu") return $l(e28, r);
    if (t === "leakyrelu") return kl(e28, n);
    if (t === "sigmoid") return xo(e28);
    throw new Error(`Unknown fused activation ${t}.`);
  }
  var Ml = (e28, t) => !(e28 > 0) || t === "linear";
  function Jj({ x: e28, filter: t, strides: r, pad: n, dataFormat: o = "NHWC", dilations: s10 = [1, 1], dimRoundingMode: i, bias: a, activation: u = "linear", preluActivationWeights: l, leakyreluAlpha: c }) {
    if (u = u || "linear", Ml(T.state.gradientDepth, u) === false) {
      I(o === "NHWC", () => `Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
      let E = On(e28, t, r, n, o, s10, i);
      return a != null && (E = Y(E, a)), Ll(E, u, l, c);
    }
    let p = S(e28, "x", "conv2d", "float32"), m = S(t, "filter", "conv2d", "float32"), f = p, h = false;
    p.rank === 3 && (h = true, f = _(p, [1, p.shape[0], p.shape[1], p.shape[2]])), I(f.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`), I(m.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`), be("fused conv2d", n, i);
    let d = o === "NHWC" ? f.shape[3] : f.shape[1];
    I(m.shape[2] === d, () => `Error in conv2d: depth of input (${d}) must match input depth for filter ${m.shape[2]}.`), I($r(r, s10), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s10}'`);
    let g = Nl(f.shape, m.shape, r, s10, n, i), y;
    a != null && (y = S(a, "bias", "fused conv2d"), [y] = Yt(y, p), o === "NHWC" ? Gt(g.outShape, y.shape) : (I(y.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`), I(y.shape.length === 0 || y.shape[0] === g.outChannels || y.shape[0] === 1, () => `Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));
    let b;
    if (l != null) {
      let E = l.shape;
      if (I(E.length <= 1 || E.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`), E.length === 1) I(E[0] === 1 || E[0] === g.outChannels, () => `Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${g.outChannels}).`);
      else if (E.length === 3) try {
        Gt(E, g.outShape);
      } catch {
        let D = `Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${g.outShape}).`;
        throw Error(D);
      }
      b = S(l, "prelu weights", "fused conv2d");
    }
    let v = (E, A) => {
      I(o === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);
      let [D, R, L, G] = A, W = Rl(E, L, u);
      I(Jn(s10), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s10}'`);
      let U = kp(R.shape, W, D, r, n), H = Mp(R, W, D.shape, r, n), j = [U, H];
      if (G != null) {
        let X = Pl(G, W);
        j.push(X);
      }
      return j;
    }, w = { x: f, filter: m, bias: y, preluActivationWeights: b }, N = { strides: r, pad: n, dataFormat: o, dilations: s10, dimRoundingMode: i, activation: u, leakyreluAlpha: c };
    return a == null ? Qn((A, D, R) => {
      let L = T.runKernel(ml, w, N);
      return R([D, A, L]), h && (L = _(L, [L.shape[1], L.shape[2], L.shape[3]])), { value: L, gradFunc: v };
    })(f, m) : Qn((A, D, R, L) => {
      let G = T.runKernel(ml, w, N);
      return L([D, A, G, R]), h && (G = _(G, [G.shape[1], G.shape[2], G.shape[3]])), { value: G, gradFunc: v };
    })(f, m, y);
  }
  var Yk = k({ fusedConv2d_: Jj });
  function Zj(e28, t, r, n, o, s10 = [1, 1], i) {
    let a = e28;
    e28.rank === 3 && (a = _(e28, [1, e28.shape[0], e28.shape[1], e28.shape[2]]));
    let u = t;
    u.rank === 3 && (u = _(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
    let l = { x: a, dy: u }, c = { strides: n, pad: o, dimRoundingMode: i, dilations: s10, filterShape: r };
    return T.runKernel(Uc, l, c);
  }
  var sx = k({ depthwiseConv2dNativeBackpropFilter_: Zj });
  function Qj(e28, t, r, n, o, s10 = [1, 1], i) {
    let a = t, u = false;
    t.rank === 3 && (u = true, a = _(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
    let l = { dy: a, filter: r }, c = { strides: n, pad: o, dimRoundingMode: i, dilations: s10, inputShape: e28 }, p = T.runKernel(jc, l, c);
    return u ? _(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
  var ix = k({ depthwiseConv2dNativeBackpropInput_: Qj });
  function tH({ x: e28, filter: t, strides: r, pad: n, dataFormat: o = "NHWC", dilations: s10 = [1, 1], dimRoundingMode: i, bias: a, activation: u = "linear", preluActivationWeights: l, leakyreluAlpha: c }) {
    if (Ml(T.state.gradientDepth, u) === false) {
      let N = qi(e28, t, r, n, o, s10, i);
      return a != null && (N = Y(N, a)), Ll(N, u, l, c);
    }
    let p = S(e28, "x", "depthwiseConv2d", "float32"), m = S(t, "filter", "depthwiseConv2d", "float32"), f = p, h = false;
    p.rank === 3 && (h = true, f = _(p, [1, p.shape[0], p.shape[1], p.shape[2]])), I(f.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`), I(m.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`), I(f.shape[3] === m.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`), s10 == null && (s10 = [1, 1]), I($r(r, s10), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${s10}'`), be("fused depthwiseConv2d", n, i);
    let d = Nl(f.shape, m.shape, r, s10, n, i, true), g;
    a != null && (g = S(a, "bias", "fused conv2d"), [g] = Yt(g, p), Gt(d.outShape, g.shape));
    let y;
    l != null && (y = S(l, "prelu weights", "fused depthwiseConv2d"));
    let b = (N, E) => {
      I(Jn(s10), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s10}'`);
      let [A, D, R, L] = E, G = Rl(N, R, u), W = ix(D.shape, G, A, r, n, s10, i), U = sx(D, G, A.shape, r, n, s10, i);
      if (L != null) {
        let H = Pl(g, G);
        return [W, U, H];
      }
      return [W, U];
    }, v = { x: f, filter: m, bias: g, preluActivationWeights: y }, w = { strides: r, pad: n, dataFormat: o, dilations: s10, dimRoundingMode: i, activation: u, leakyreluAlpha: c };
    return a == null ? Qn((E, A, D) => {
      let R = T.runKernel(fl, v, w);
      return D([A, E, R]), h && (R = _(R, [R.shape[1], R.shape[2], R.shape[3]])), { value: R, gradFunc: b };
    })(f, m) : Qn((E, A, D, R) => {
      let L = T.runKernel(fl, v, w);
      return R([A, E, L, D]), h && (L = _(L, [L.shape[1], L.shape[2], L.shape[3]])), { value: L, gradFunc: b };
    })(f, m, g);
  }
  var Jk = k({ fusedDepthwiseConv2d_: tH });
  function eH({ a: e28, b: t, transposeA: r = false, transposeB: n = false, bias: o, activation: s10 = "linear", preluActivationWeights: i, leakyreluAlpha: a = 0.2 }) {
    if (Ml(T.state.gradientDepth, s10) === false) {
      let G = ae(e28, t, r, n);
      return o != null && (G = Y(G, o)), Ll(G, s10, i, a);
    }
    let u = S(e28, "a", "fused matMul"), l = S(t, "b", "fused matMul");
    [u, l] = Yt(u, l);
    let c = r ? u.shape[u.rank - 2] : u.shape[u.rank - 1], p = n ? l.shape[l.rank - 1] : l.shape[l.rank - 2], m = r ? u.shape[u.rank - 1] : u.shape[u.rank - 2], f = n ? l.shape[l.rank - 2] : l.shape[l.rank - 1], h = u.shape.slice(0, -2), d = l.shape.slice(0, -2), g = ie(h), y = ie(d);
    I(c === p, () => `Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${r} and transposeB=${n} must match.`);
    let v = Gt(u.shape.slice(0, -2), l.shape.slice(0, -2)).concat([m, f]), w = r ? _(u, [g, c, m]) : _(u, [g, m, c]), N = n ? _(l, [y, f, p]) : _(l, [y, p, f]), E;
    o != null && (E = S(o, "bias", "fused matMul"), [E] = Yt(E, u), Gt(v, E.shape));
    let A;
    i != null && (A = S(i, "prelu weights", "fused matMul"));
    let D = (G, W) => {
      let [U, H, j, X] = W, Q = Rl(_(G, j.shape), j, s10), q, et;
      if (!r && !n ? (q = ae(Q, H, false, true), et = ae(U, Q, true, false)) : !r && n ? (q = ae(Q, H, false, false), et = ae(Q, U, true, false)) : r && !n ? (q = ae(H, Q, false, true), et = ae(U, Q, false, false)) : (q = ae(H, Q, true, true), et = ae(Q, U, true, true)), o != null) {
        let ot = Pl(X, Q);
        return [q, et, ot];
      } else return [q, et];
    }, R = { a: w, b: N, bias: E, preluActivationWeights: A }, L = { transposeA: r, transposeB: n, activation: s10, leakyreluAlpha: a };
    return o == null ? Qn((W, U, H) => {
      let j = T.runKernel(pl, R, L);
      return H([W, U, j]), { value: _(j, v), gradFunc: D };
    })(w, N) : Qn((W, U, H, j) => {
      let X = T.runKernel(pl, R, L);
      return j([W, U, X, H]), { value: _(X, v), gradFunc: D };
    })(w, N, E);
  }
  var Zk = k({ fusedMatMul_: eH });
  function rH(e28, t, r, n, o = "bilinear", s10 = 0) {
    let i = S(e28, "image", "cropAndResize"), a = S(t, "boxes", "cropAndResize", "float32"), u = S(r, "boxInd", "cropAndResize", "int32"), l = a.shape[0];
    I(i.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`), I(a.rank === 2 && a.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`), I(u.rank === 1 && u.shape[0] === l, () => `Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`), I(n.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`), I(n[0] >= 1 && n[1] >= 1, () => `cropSize must be atleast [1,1], but was ${n}`), I(o === "bilinear" || o === "nearest", () => `method must be bilinear or nearest, but was ${o}`);
    let c = { image: i, boxes: a, boxInd: u }, p = { method: o, extrapolationValue: s10, cropSize: n };
    return T.runKernel(Vc, c, p);
  }
  var Qk = k({ cropAndResize_: rH });
  function nH(e28) {
    let t = S(e28, "image", "flipLeftRight", "float32");
    I(t.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);
    let r = { image: t };
    return T.runKernel(Yc, r, {});
  }
  var tE = k({ flipLeftRight_: nH });
  function oH(e28) {
    let t = S(e28, "image", "grayscaleToRGB"), r = t.rank - 1, n = t.shape[r];
    I(t.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`), I(n === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);
    let o = new Array(t.rank);
    return o.fill(1, 0, r), o[r] = 3, Wr(t, o);
  }
  var eE = k({ grayscaleToRGB_: oH });
  function sH(e28) {
    let t = S(e28, "image", "RGBToGrayscale"), r = t.rank - 1, n = t.shape[r];
    I(t.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`), I(n === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);
    let o = t.dtype, s10 = Z(t, "float32"), i = sr([0.2989, 0.587, 0.114]), a;
    switch (t.rank) {
      case 2:
        a = Ep("ij,j->i", s10, i);
        break;
      case 3:
        a = Ep("ijk,k->ij", s10, i);
        break;
      case 4:
        a = Ep("ijkl,l->ijk", s10, i);
        break;
      case 5:
        a = Ep("ijklm,m->ijkl", s10, i);
        break;
      case 6:
        a = Ep("ijklmn,n->ijklm", s10, i);
        break;
      default:
        throw new Error("Not a valid tensor rank.");
    }
    return a = or(a, -1), Z(a, o);
  }
  var rE = k({ rgbToGrayscale_: sH });
  function iH(e28, t, r = 0, n = 0.5) {
    let o = S(e28, "image", "rotateWithOffset", "float32");
    I(o.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);
    let s10 = { image: o }, i = { radians: t, fillValue: r, center: n };
    return T.runKernel(hp, s10, i);
  }
  var nE = k({ rotateWithOffset_: iH });
  function wo(e28, t, r, n, o, s10) {
    n == null && (n = 0.5), o == null && (o = Number.NEGATIVE_INFINITY), s10 == null && (s10 = 0);
    let i = e28.shape[0];
    return r = Math.min(r, i), I(0 <= n && n <= 1, () => `iouThreshold must be in [0, 1], but was '${n}'`), I(e28.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${e28.rank}'`), I(e28.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${e28.shape[1]}`), I(t.rank === 1, () => "scores must be a 1D tensor"), I(t.shape[0] === i, () => `scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`), I(0 <= s10 && s10 <= 1, () => `softNmsSigma must be in [0, 1], but was '${s10}'`), { maxOutputSize: r, iouThreshold: n, scoreThreshold: o, softNmsSigma: s10 };
  }
  function aH(e28, t, r, n = 0.5, o = Number.NEGATIVE_INFINITY) {
    let s10 = S(e28, "boxes", "nonMaxSuppression", "float32"), i = S(t, "scores", "nonMaxSuppression", "float32"), a = wo(s10, i, r, n, o);
    r = a.maxOutputSize, n = a.iouThreshold, o = a.scoreThreshold;
    let u = { maxOutputSize: r, iouThreshold: n, scoreThreshold: o };
    return T.runKernel(rp, { boxes: s10, scores: i }, u);
  }
  var oE = k({ nonMaxSuppression_: aH });
  function sE(e28, t, r) {
    let n = uH(e28, t, r), o = n < 0 ? -(n + 1) : n;
    e28.splice(o, 0, t);
  }
  function uH(e28, t, r) {
    return cH(e28, t, r || lH);
  }
  function lH(e28, t) {
    return e28 > t ? 1 : e28 < t ? -1 : 0;
  }
  function cH(e28, t, r) {
    let n = 0, o = e28.length, s10 = 0, i = false;
    for (; n < o; ) {
      s10 = n + (o - n >>> 1);
      let a = r(t, e28[s10]);
      a > 0 ? n = s10 + 1 : (o = s10, i = !a);
    }
    return i ? n : -n - 1;
  }
  function ax(e28, t, r, n, o) {
    return s1(e28, t, r, n, o, 0);
  }
  function ux(e28, t, r, n, o, s10) {
    return s1(e28, t, r, n, o, 0, false, s10, true);
  }
  function lx(e28, t, r, n, o, s10) {
    return s1(e28, t, r, n, o, s10, true);
  }
  function s1(e28, t, r, n, o, s10, i = false, a = false, u = false) {
    let l = [];
    for (let g = 0; g < t.length; g++) t[g] > o && l.push({ score: t[g], boxIndex: g, suppressBeginIndex: 0 });
    l.sort(iE);
    let c = s10 > 0 ? -0.5 / s10 : 0, p = [], m = [];
    for (; p.length < r && l.length > 0; ) {
      let g = l.pop(), { score: y, boxIndex: b, suppressBeginIndex: v } = g;
      if (y < o) break;
      let w = false;
      for (let N = p.length - 1; N >= v; --N) {
        let E = pH(e28, b, p[N]);
        if (E >= n) {
          w = true;
          break;
        }
        if (g.score = g.score * mH(n, c, E), g.score <= o) break;
      }
      g.suppressBeginIndex = p.length, w || (g.score === y ? (p.push(b), m.push(g.score)) : g.score > o && sE(l, g, iE));
    }
    let f = p.length, h = r - f;
    a && h > 0 && (p.push(...new Array(h).fill(0)), m.push(...new Array(h).fill(0)));
    let d = { selectedIndices: p };
    return i && (d.selectedScores = m), u && (d.validOutputs = f), d;
  }
  function pH(e28, t, r) {
    let n = e28.subarray(t * 4, t * 4 + 4), o = e28.subarray(r * 4, r * 4 + 4), s10 = Math.min(n[0], n[2]), i = Math.min(n[1], n[3]), a = Math.max(n[0], n[2]), u = Math.max(n[1], n[3]), l = Math.min(o[0], o[2]), c = Math.min(o[1], o[3]), p = Math.max(o[0], o[2]), m = Math.max(o[1], o[3]), f = (a - s10) * (u - i), h = (p - l) * (m - c);
    if (f <= 0 || h <= 0) return 0;
    let d = Math.max(s10, l), g = Math.max(i, c), y = Math.min(a, p), b = Math.min(u, m), v = Math.max(y - d, 0) * Math.max(b - g, 0);
    return v / (f + h - v);
  }
  function mH(e28, t, r) {
    let n = Math.exp(t * r * r);
    return r <= e28 ? n : 0;
  }
  function iE(e28, t) {
    return e28.score - t.score || e28.score === t.score && t.boxIndex - e28.boxIndex;
  }
  async function fH(e28, t, r, n = 0.5, o = Number.NEGATIVE_INFINITY) {
    let s10 = S(e28, "boxes", "nonMaxSuppressionAsync"), i = S(t, "scores", "nonMaxSuppressionAsync"), a = wo(s10, i, r, n, o);
    r = a.maxOutputSize, n = a.iouThreshold, o = a.scoreThreshold;
    let u = await Promise.all([s10.data(), i.data()]), l = u[0], c = u[1], { selectedIndices: p } = ax(l, c, r, n, o);
    return s10 !== e28 && s10.dispose(), i !== t && i.dispose(), sr(p, "int32");
  }
  var aE = fH;
  function hH(e28, t, r, n = 0.5, o = Number.NEGATIVE_INFINITY, s10 = 0) {
    let i = S(e28, "boxes", "nonMaxSuppression"), a = S(t, "scores", "nonMaxSuppression"), u = wo(i, a, r, n, o, s10);
    r = u.maxOutputSize, n = u.iouThreshold, o = u.scoreThreshold, s10 = u.softNmsSigma;
    let l = { boxes: i, scores: a }, c = { maxOutputSize: r, iouThreshold: n, scoreThreshold: o, softNmsSigma: s10 }, p = T.runKernel(op, l, c);
    return { selectedIndices: p[0], selectedScores: p[1] };
  }
  var uE = k({ nonMaxSuppressionWithScore_: hH });
  async function dH(e28, t, r, n = 0.5, o = Number.NEGATIVE_INFINITY, s10 = 0) {
    let i = S(e28, "boxes", "nonMaxSuppressionAsync"), a = S(t, "scores", "nonMaxSuppressionAsync"), u = wo(i, a, r, n, o, s10);
    r = u.maxOutputSize, n = u.iouThreshold, o = u.scoreThreshold, s10 = u.softNmsSigma;
    let l = await Promise.all([i.data(), a.data()]), c = l[0], p = l[1], { selectedIndices: m, selectedScores: f } = lx(c, p, r, n, o, s10);
    return i !== e28 && i.dispose(), a !== t && a.dispose(), { selectedIndices: sr(m, "int32"), selectedScores: sr(f) };
  }
  var lE = dH;
  function gH(e28, t, r, n = 0.5, o = Number.NEGATIVE_INFINITY, s10 = false) {
    let i = S(e28, "boxes", "nonMaxSuppression"), a = S(t, "scores", "nonMaxSuppression"), u = wo(i, a, r, n, o, null), l = u.maxOutputSize, c = u.iouThreshold, p = u.scoreThreshold, m = { boxes: i, scores: a }, f = { maxOutputSize: l, iouThreshold: c, scoreThreshold: p, padToMaxOutputSize: s10 }, h = T.runKernel(np, m, f);
    return { selectedIndices: h[0], validOutputs: h[1] };
  }
  var cE = k({ nonMaxSuppressionPadded_: gH });
  async function yH(e28, t, r, n = 0.5, o = Number.NEGATIVE_INFINITY, s10 = false) {
    let i = S(e28, "boxes", "nonMaxSuppressionAsync"), a = S(t, "scores", "nonMaxSuppressionAsync"), u = wo(i, a, r, n, o, null), l = u.maxOutputSize, c = u.iouThreshold, p = u.scoreThreshold, [m, f] = await Promise.all([i.data(), a.data()]), { selectedIndices: h, validOutputs: d } = ux(m, f, l, c, p, s10);
    return i !== e28 && i.dispose(), a !== t && a.dispose(), { selectedIndices: sr(h, "int32"), validOutputs: $t(d, "int32") };
  }
  var pE = yH;
  function xH(e28, t, r = false, n = false) {
    let o = S(e28, "images", "resizeBilinear");
    I(o.rank === 3 || o.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`), I(t.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`), I(n === false || r === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
    let s10 = o, i = false;
    o.rank === 3 && (i = true, s10 = _(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
    let [] = t, a = { images: s10 }, u = { alignCorners: r, halfPixelCenters: n, size: t }, l = T.runKernel(uu, a, u);
    return i ? _(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
  }
  var cx = k({ resizeBilinear_: xH });
  function bH(e28, t, r = false, n = false) {
    let o = S(e28, "images", "resizeNearestNeighbor");
    I(o.rank === 3 || o.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`), I(t.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`), I(o.dtype === "float32" || o.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), I(n === false || r === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
    let s10 = o, i = false;
    o.rank === 3 && (i = true, s10 = _(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
    let [] = t, a = { images: s10 }, u = { alignCorners: r, halfPixelCenters: n, size: t }, l = T.runKernel(au, a, u);
    return i ? _(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
  }
  var px = k({ resizeNearestNeighbor_: bH });
  function wH(e28, t = "binary", r = false, n = 0.5) {
    let o = S(e28, "image", "threshold"), s10 = 0.2989, i = 0.587, a = 0.114, u = o.shape[0] * o.shape[1], l = F(sr([n]), 255), c, p, m, f;
    if (I(o.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${o.rank}.`), I(o.shape[2] === 3 || o.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`), I(o.dtype === "int32" || o.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`), I(t === "otsu" || t === "binary", () => `Method must be binary or otsu, but was ${t}`), o.shape[2] === 3) {
      [c, p, m] = xr(o, [1, 1, 1], -1);
      let g = F(c, s10), y = F(p, i), b = F(m, a);
      f = Y(Y(g, y), b);
    } else f = e28;
    if (t === "otsu") {
      let g = mk(Z(Qf(f), "int32"), me([]), 256);
      l = vH(g, u);
    }
    let h = r ? bo(f, l) : je(f, l);
    return Z(F(h, 255), "int32");
  }
  function vH(e28, t) {
    let r = sr([-1]), n = sr([0]), o = sr([0]), s10, i, a, u, l, c;
    for (let p = 0; p < e28.size - 1; p++) {
      s10 = Qt(e28, 0, p + 1), i = Qt(e28, p + 1), l = ut(ht(s10), t), c = ut(ht(i), t);
      let m = ht(F(s10, Ji(0, s10.size)));
      a = ut(m, ht(s10));
      let f = Ki(i.shape, s10.size), h = Y(Ji(0, i.size), f), d = F(i, h);
      u = ut(ht(d), ht(i));
      let g = xt(a, u), y = xt(a, u), b = F(l, c);
      o = F(F(b, g), y);
      let v = je(o, n);
      n = Ce(v, o, n), r = Ce(v, sr([p]), r);
    }
    return r;
  }
  var mE = k({ threshold_: wH });
  function NH(e28, t, r = "nearest", n = "constant", o = 0, s10) {
    let i = S(e28, "image", "transform", "float32"), a = S(t, "transforms", "transform", "float32");
    I(i.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${i.rank}.`), I(a.rank === 2 && (a.shape[0] === i.shape[0] || a.shape[0] === 1) && a.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), I(s10 == null || s10.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${s10}.`);
    let u = { image: i, transforms: a }, l = { interpolation: r, fillMode: n, fillValue: o, outputShape: s10 };
    return T.runKernel(mp, u, l);
  }
  var fE = k({ transform_: NH });
  function CH(e28, t, r) {
    let n = S(e28, "a", "bandPart");
    I(n.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${n.rank}.`);
    let o = n.shape, [s10, i] = n.shape.slice(-2), a, u;
    typeof t == "number" ? (I(t % 1 === 0, () => `bandPart(): numLower must be an integer, got ${t}.`), I(t <= s10, () => `bandPart(): numLower (${t}) must not be greater than the number of rows (${s10}).`), a = S(t < 0 ? s10 : t, "numLower", "bandPart")) : (I(t.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), a = Ce(El(t, 0), s10, Is(t, s10))), typeof r == "number" ? (I(r % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${r}.`), I(r <= i, () => `bandPart(): numUpper (${r}) must not be greater than the number of columns (${i}).`), u = S(r < 0 ? i : r, "numUpper", "bandPart")) : (I(r.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), u = Ce(El(r, 0), i, Is(r, i)));
    let l = _(Ji(0, s10, 1, "int32"), [-1, 1]), c = Ji(0, i, 1, "int32"), p = xt(l, c), m = Jr(bo(p, a), vn(p, ne(u))), f = Se([s10, i], n.dtype);
    return _(Xe(Zr(_(n, [-1, s10, i])).map((h) => Ce(m, h, f))), o);
  }
  var hE = k({ bandPart_: CH });
  function SH(e28) {
    let t;
    if (Array.isArray(e28)) {
      t = false, I(e28 != null && e28.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      let o = e28[0].shape[0];
      for (let s10 = 1; s10 < e28.length; ++s10) I(e28[s10].shape[0] === o, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${e28[s10].shape[0]} vs. ${o})`);
    } else t = true, e28 = xr(e28, e28.shape[0], 0).map((o) => Wo(o, [0]));
    I(e28.length <= e28[0].shape[0], () => `Gram-Schmidt: Number of vectors (${e28.length}) exceeds number of dimensions (${e28[0].shape[0]}).`);
    let r = [], n = e28;
    for (let o = 0; o < e28.length; ++o) r.push(T.tidy(() => {
      let s10 = n[o];
      if (o > 0) for (let i = 0; i < o; ++i) {
        let a = F(ht(F(r[i], s10)), r[i]);
        s10 = xt(s10, a);
      }
      return ut(s10, ku(s10, "euclidean"));
    }));
    return t ? Xe(r, 0) : r;
  }
  var dE = k({ gramSchmidt_: SH });
  function IH(e28, t = false) {
    if (I(e28.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${e28.rank}`), e28.rank === 2) return gE(e28, t);
    {
      let r = e28.shape.slice(0, e28.shape.length - 2).reduce((u, l) => u * l), n = Zr(_(e28, [r, e28.shape[e28.shape.length - 2], e28.shape[e28.shape.length - 1]]), 0), o = [], s10 = [];
      n.forEach((u) => {
        let [l, c] = gE(u, t);
        o.push(l), s10.push(c);
      });
      let i = _(Xe(o, 0), e28.shape), a = _(Xe(s10, 0), e28.shape);
      return [i, a];
    }
  }
  function gE(e28, t = false) {
    return T.tidy(() => {
      I(e28.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${e28.shape.length}D Tensor.`);
      let r = e28.shape[0], n = e28.shape[1], o = Ap(r), s10 = _n(e28), i = uh([[1]], [1, 1]), a = _n(i), u = r >= n ? n : r;
      for (let l = 0; l < u; ++l) {
        let c = s10, p = a, m = o;
        [a, s10, o] = T.tidy(() => {
          let f = Qt(s10, [l, l], [r - l, 1]), h = ku(f), d = Qt(s10, [l, l], [1, 1]), g = Ce(je(d, 0), uh([[-1]]), uh([[1]])), y = xt(d, F(g, h)), b = ut(f, y);
          b.shape[0] === 1 ? a = _n(i) : a = Ne([i, Qt(b, [1, 0], [b.shape[0] - 1, b.shape[1]])], 0);
          let v = ne(ut(ae(g, y), h)), w = Qt(s10, [l, 0], [r - l, n]), N = F(v, a), E = qt(a);
          if (l === 0) s10 = xt(w, ae(N, ae(E, w)));
          else {
            let R = xt(w, ae(N, ae(E, w)));
            s10 = Ne([Qt(s10, [0, 0], [l, n]), R], 0);
          }
          let A = qt(N), D = Qt(o, [0, l], [r, o.shape[1] - l]);
          if (l === 0) o = xt(D, ae(ae(D, a), A));
          else {
            let R = xt(D, ae(ae(D, a), A));
            o = Ne([Qt(o, [0, 0], [r, l]), R], 1);
          }
          return [a, s10, o];
        }), Mt([c, p, m]);
      }
      return !t && r > n && (o = Qt(o, [0, 0], [r, n]), s10 = Qt(s10, [0, 0], [n, n])), [o, s10];
    });
  }
  var yE = k({ qr_: IH });
  var Mn = { flipLeftRight: tE, grayscaleToRGB: eE, resizeNearestNeighbor: px, resizeBilinear: cx, rgbToGrayscale: rE, rotateWithOffset: nE, cropAndResize: Qk, nonMaxSuppression: oE, nonMaxSuppressionAsync: aE, nonMaxSuppressionWithScore: uE, nonMaxSuppressionWithScoreAsync: lE, nonMaxSuppressionPadded: cE, nonMaxSuppressionPaddedAsync: pE, threshold: mE, transform: fE };
  var xE = { bandPart: hE, gramSchmidt: dE, qr: yE };
  var K = {};
  lo(K, { Serializable: () => ch, SerializationMap: () => mx, getRegisteredName: () => kH, registerClass: () => a1 });
  var TH = /* @__PURE__ */ new Map();
  var i1 = /* @__PURE__ */ new Map();
  var ch = class {
    getClassName() {
      return this.constructor.className;
    }
    static fromConfig(t, r) {
      return new t(r);
    }
  };
  var mx = class e6 {
    constructor() {
      this.classNameMap = {};
    }
    static getMap() {
      return e6.instance == null && (e6.instance = new e6()), e6.instance;
    }
    static register(t) {
      e6.getMap().classNameMap[t.className] = [t, t.fromConfig];
    }
  };
  function a1(e28, t, r) {
    I(e28.className != null, () => "Class being registered does not have the static className property defined."), I(typeof e28.className == "string", () => "className is required to be a string, but got type " + typeof e28.className), I(e28.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), typeof t > "u" && (t = "Custom"), typeof r > "u" && (r = e28.className);
    let n = r, o = t + ">" + n;
    return mx.register(e28), TH.set(o, e28), i1.set(e28, o), e28;
  }
  function kH(e28) {
    return i1.has(e28) ? i1.get(e28) : e28.className;
  }
  var Ur = class extends ch {
    minimize(t, r = false, n) {
      let { value: o, grads: s10 } = this.computeGradients(t, n);
      if (n != null) {
        let i = n.map((a) => ({ name: a.name, tensor: s10[a.name] }));
        this.applyGradients(i);
      } else this.applyGradients(s10);
      return Mt(s10), r ? o : (o.dispose(), null);
    }
    get iterations() {
      return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    computeGradients(t, r) {
      return GN(t, r);
    }
    dispose() {
      this.iterations_ != null && Mt(this.iterations_);
    }
    async saveIterations() {
      return this.iterations_ == null && (this.iterations_ = 0), { name: "iter", tensor: $t(this.iterations_, "int32") };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(t) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    async extractIterations(t) {
      return this.iterations_ = (await t[0].tensor.data())[0], t.slice(1);
    }
  };
  Object.defineProperty(Ur, Symbol.hasInstance, { value: (e28) => e28.minimize != null && e28.computeGradients != null && e28.applyGradients != null });
  var zp = class extends Ur {
    static get className() {
      return "Adadelta";
    }
    constructor(t, r, n = null) {
      super(), this.learningRate = t, this.rho = r, this.epsilon = n, this.accumulatedGrads = [], this.accumulatedUpdates = [], n == null && (this.epsilon = T.backend.epsilon());
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t)).forEach((n, o) => {
        let s10 = T.registeredVariables[n], i = false;
        this.accumulatedGrads[o] == null && (this.accumulatedGrads[o] = { originalName: `${n}/accum_grad`, variable: M(() => Dt(s10).variable(i)) }), this.accumulatedUpdates[o] == null && (this.accumulatedUpdates[o] = { originalName: `${n}/accum_var`, variable: M(() => Dt(s10).variable(i)) });
        let a = Array.isArray(t) ? t[o].tensor : t[n];
        if (a == null) return;
        let u = this.accumulatedGrads[o].variable, l = this.accumulatedUpdates[o].variable;
        M(() => {
          let c = Y(F(u, this.rho), F(Xt(a), 1 - this.rho)), p = F(ut(ge(Y(l, this.epsilon)), ge(Y(u, this.epsilon))), a), m = Y(F(l, this.rho), F(Xt(p), 1 - this.rho));
          u.assign(c), l.assign(m);
          let f = Y(F(p, -this.learningRate), s10);
          s10.assign(f);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedUpdates != null && (Mt(this.accumulatedGrads.map((t) => t.variable)), Mt(this.accumulatedUpdates.map((t) => t.variable)));
    }
    async getWeights() {
      let t = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [await this.saveIterations()].concat(t.map((r) => ({ name: r.originalName, tensor: r.variable })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      let r = t.length / 2, n = false;
      this.accumulatedGrads = t.slice(0, r).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) })), this.accumulatedUpdates = t.slice(r, r * 2).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate, r.rho, r.epsilon);
    }
  };
  var Bp = class extends Ur {
    static get className() {
      return "Adagrad";
    }
    constructor(t, r = 0.1) {
      super(), this.learningRate = t, this.initialAccumulatorValue = r, this.accumulatedGrads = [];
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t)).forEach((n, o) => {
        let s10 = T.registeredVariables[n];
        this.accumulatedGrads[o] == null && (this.accumulatedGrads[o] = { originalName: `${n}/accumulator`, variable: M(() => Ki(s10.shape, this.initialAccumulatorValue).variable(false)) });
        let i = Array.isArray(t) ? t[o].tensor : t[n];
        if (i == null) return;
        let a = this.accumulatedGrads[o].variable;
        M(() => {
          let u = Y(a, Xt(i));
          a.assign(u);
          let l = Y(F(ut(i, ge(Y(u, T.backend.epsilon()))), -this.learningRate), s10);
          s10.assign(l);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedGrads != null && Mt(this.accumulatedGrads.map((t) => t.variable));
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulatedGrads.map((t) => ({ name: t.originalName, tensor: t.variable })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      let r = false;
      this.accumulatedGrads = t.map((n) => ({ originalName: n.name, variable: n.tensor.variable(r) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate, r.initialAccumulatorValue);
    }
  };
  var Vp = class extends Ur {
    static get className() {
      return "Adam";
    }
    constructor(t, r, n, o = null) {
      super(), this.learningRate = t, this.beta1 = r, this.beta2 = n, this.epsilon = o, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], M(() => {
        this.accBeta1 = $t(r).variable(), this.accBeta2 = $t(n).variable();
      }), o == null && (this.epsilon = T.backend.epsilon());
    }
    applyGradients(t) {
      let r = Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t);
      M(() => {
        let n = xt(1, this.accBeta1), o = xt(1, this.accBeta2);
        r.forEach((s10, i) => {
          let a = T.registeredVariables[s10], u = false;
          this.accumulatedFirstMoment[i] == null && (this.accumulatedFirstMoment[i] = { originalName: `${s10}/m`, variable: M(() => Dt(a).variable(u)) }), this.accumulatedSecondMoment[i] == null && (this.accumulatedSecondMoment[i] = { originalName: `${s10}/v`, variable: M(() => Dt(a).variable(u)) });
          let l = Array.isArray(t) ? t[i].tensor : t[s10];
          if (l == null) return;
          let c = this.accumulatedFirstMoment[i].variable, p = this.accumulatedSecondMoment[i].variable, m = Y(F(c, this.beta1), F(l, 1 - this.beta1)), f = Y(F(p, this.beta2), F(Xt(l), 1 - this.beta2)), h = ut(m, n), d = ut(f, o);
          c.assign(m), p.assign(f);
          let g = Y(F(ut(h, Y(ge(d), this.epsilon)), -this.learningRate), a);
          a.assign(g);
        }), this.accBeta1.assign(F(this.accBeta1, this.beta1)), this.accBeta2.assign(F(this.accBeta2, this.beta2));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && Mt(this.accumulatedFirstMoment.map((t) => t.variable)), this.accumulatedSecondMoment != null && Mt(this.accumulatedSecondMoment.map((t) => t.variable));
    }
    async getWeights() {
      let t = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [await this.saveIterations()].concat(t.map((r) => ({ name: r.originalName, tensor: r.variable })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t), M(() => {
        this.accBeta1.assign(wn(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(wn(this.beta2, this.iterations_ + 1));
      });
      let r = t.length / 2, n = false;
      this.accumulatedFirstMoment = t.slice(0, r).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) })), this.accumulatedSecondMoment = t.slice(r, r * 2).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate, r.beta1, r.beta2, r.epsilon);
    }
  };
  var Gp = class extends Ur {
    static get className() {
      return "Adamax";
    }
    constructor(t, r, n, o = null, s10 = 0) {
      super(), this.learningRate = t, this.beta1 = r, this.beta2 = n, this.epsilon = o, this.decay = s10, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], M(() => {
        this.iteration = $t(0).variable(), this.accBeta1 = $t(r).variable();
      }), o == null && (this.epsilon = T.backend.epsilon());
    }
    applyGradients(t) {
      let r = Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t);
      M(() => {
        let n = xt(1, this.accBeta1), o = ut(-this.learningRate, Y(F(this.iteration, this.decay), 1));
        r.forEach((s10, i) => {
          let a = T.registeredVariables[s10], u = false;
          this.accumulatedFirstMoment[i] == null && (this.accumulatedFirstMoment[i] = { originalName: `${s10}/m`, variable: Dt(a).variable(u) }), this.accumulatedWeightedInfNorm[i] == null && (this.accumulatedWeightedInfNorm[i] = { originalName: `${s10}/v`, variable: Dt(a).variable(u) });
          let l = Array.isArray(t) ? t[i].tensor : t[s10];
          if (l == null) return;
          let c = this.accumulatedFirstMoment[i].variable, p = this.accumulatedWeightedInfNorm[i].variable, m = Y(F(c, this.beta1), F(l, 1 - this.beta1)), f = F(p, this.beta2), h = cr(l), d = Pn(f, h);
          c.assign(m), p.assign(d);
          let g = Y(F(ut(o, n), ut(m, Y(d, this.epsilon))), a);
          a.assign(g);
        }), this.iteration.assign(Y(this.iteration, 1)), this.accBeta1.assign(F(this.accBeta1, this.beta1));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && Mt(this.accumulatedFirstMoment.map((t) => t.variable)), this.accumulatedWeightedInfNorm != null && Mt(this.accumulatedWeightedInfNorm.map((t) => t.variable));
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(t) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate, r.beta1, r.beta2, r.epsilon, r.decay);
    }
  };
  var Au = class extends Ur {
    static get className() {
      return "SGD";
    }
    constructor(t) {
      super(), this.learningRate = t, this.setLearningRate(t);
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t)).forEach((n, o) => {
        let s10 = Array.isArray(t) ? t[o].tensor : t[n];
        if (s10 == null) return;
        let i = T.registeredVariables[n];
        M(() => {
          let a = Y(F(this.c, s10), i);
          i.assign(a);
        });
      }), this.incrementIterations();
    }
    setLearningRate(t) {
      this.learningRate = t, this.c != null && this.c.dispose(), this.c = wr($t(-t));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [await this.saveIterations()];
    }
    async setWeights(t) {
      if (t = await this.extractIterations(t), t.length !== 0) throw new Error("SGD optimizer does not have settable weights.");
    }
    getConfig() {
      return { learningRate: this.learningRate };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate);
    }
  };
  var Wp = class extends Au {
    static get className() {
      return "Momentum";
    }
    constructor(t, r, n = false) {
      super(t), this.learningRate = t, this.momentum = r, this.useNesterov = n, this.accumulations = [], this.m = $t(this.momentum);
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t)).forEach((n, o) => {
        let s10 = T.registeredVariables[n];
        this.accumulations[o] == null && (this.accumulations[o] = { originalName: `${n}/momentum`, variable: M(() => Dt(s10).variable(false)) });
        let i = this.accumulations[o].variable, a = Array.isArray(t) ? t[o].tensor : t[n];
        a != null && M(() => {
          let u, l = Y(F(this.m, i), a);
          this.useNesterov ? u = Y(F(this.c, Y(a, F(l, this.m))), s10) : u = Y(F(this.c, l), s10), i.assign(l), s10.assign(u);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.m.dispose(), this.accumulations != null && Mt(this.accumulations.map((t) => t.variable));
    }
    setMomentum(t) {
      this.momentum = t;
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulations.map((t) => ({ name: t.originalName, tensor: t.variable })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      let r = false;
      this.accumulations = t.map((n) => ({ originalName: n.name, variable: n.tensor.variable(r) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate, r.momentum, r.useNesterov);
    }
  };
  var Up = class extends Ur {
    static get className() {
      return "RMSProp";
    }
    constructor(t, r = 0.9, n = 0, o = null, s10 = false) {
      if (super(), this.learningRate = t, this.decay = r, this.momentum = n, this.epsilon = o, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = s10, o == null && (this.epsilon = T.backend.epsilon()), t == null) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((n) => n.name) : Object.keys(t)).forEach((n, o) => {
        let s10 = T.registeredVariables[n], i = false;
        this.accumulatedMeanSquares[o] == null && (this.accumulatedMeanSquares[o] = { originalName: `${n}/rms`, variable: M(() => Dt(s10).variable(i)) }), this.accumulatedMoments[o] == null && (this.accumulatedMoments[o] = { originalName: `${n}/momentum`, variable: M(() => Dt(s10).variable(i)) }), this.accumulatedMeanGrads[o] == null && this.centered && (this.accumulatedMeanGrads[o] = { originalName: `${n}/mg`, variable: M(() => Dt(s10).variable(i)) });
        let a = Array.isArray(t) ? t[o].tensor : t[n];
        if (a == null) return;
        let u = this.accumulatedMeanSquares[o].variable, l = this.accumulatedMoments[o].variable;
        M(() => {
          let c = Y(F(u, this.decay), F(Xt(a), 1 - this.decay));
          if (this.centered) {
            let p = this.accumulatedMeanGrads[o].variable, m = Y(F(p, this.decay), F(a, 1 - this.decay)), f = ut(F(a, this.learningRate), ge(xt(c, Y(Xt(m), this.epsilon)))), h = Y(F(l, this.momentum), f);
            u.assign(c), p.assign(m), l.assign(h);
            let d = xt(s10, h);
            s10.assign(d);
          } else {
            let p = Y(F(u, this.decay), F(Xt(a), 1 - this.decay)), m = Y(F(l, this.momentum), ut(F(a, this.learningRate), ge(Y(p, this.epsilon))));
            u.assign(p), l.assign(m);
            let f = xt(s10, m);
            s10.assign(f);
          }
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedMeanSquares != null && Mt(this.accumulatedMeanSquares.map((t) => t.variable)), this.accumulatedMeanGrads != null && this.centered && Mt(this.accumulatedMeanGrads.map((t) => t.variable)), this.accumulatedMoments != null && Mt(this.accumulatedMoments.map((t) => t.variable));
    }
    async getWeights() {
      let t = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      return this.centered && t.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(t.map((r) => ({ name: r.originalName, tensor: r.variable })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      let r = this.centered ? t.length / 3 : t.length / 2, n = false;
      this.accumulatedMeanSquares = t.slice(0, r).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) })), this.accumulatedMoments = t.slice(r, r * 2).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) })), this.centered && (this.accumulatedMeanGrads = t.slice(r * 2, r * 3).map((o) => ({ originalName: o.name, variable: o.tensor.variable(n) })));
    }
    getConfig() {
      return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
    }
    static fromConfig(t, r) {
      return new t(r.learningRate, r.decay, r.momentum, r.epsilon, r.centered);
    }
  };
  var EH = [zp, Bp, Vp, Gp, Wp, Up, Au];
  function bE() {
    for (let e28 of EH) a1(e28);
  }
  var Zi = {};
  lo(Zi, { CompositeArrayBuffer: () => Gr, browserFiles: () => vE, browserHTTPRequest: () => IE, concatenateArrayBuffers: () => GT, copyModel: () => rk, decodeWeights: () => Wy, decodeWeightsStream: () => oN, encodeWeights: () => MT, fromMemory: () => TE, fromMemorySync: () => f1, getLoadHandlers: () => HT, getModelArtifactsForJSON: () => vp, getModelArtifactsForJSONSync: () => aN, getModelArtifactsInfoForJSON: () => bs, getSaveHandlers: () => jT, getWeightSpecs: () => zf, http: () => hx, isHTTPScheme: () => fx, listModels: () => tk, loadWeights: () => CE, moveModel: () => nk, registerLoadRouter: () => UT, registerSaveRouter: () => WT, removeModel: () => ek, weightsLoaderFactory: () => p1, withSaveHandler: () => kE, withSaveHandlerSync: () => EE });
  var AH = "model";
  var DH = ".json";
  var $H = ".weights.bin";
  function wE(e28) {
    return new Promise((t) => setTimeout(t)).then(e28);
  }
  var jp = class e7 {
    constructor(t) {
      if (!z().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      t.startsWith(e7.URL_SCHEME) && (t = t.slice(e7.URL_SCHEME.length)), (t == null || t.length === 0) && (t = AH), this.modelJsonFileName = t + DH, this.weightDataFileName = t + $H;
    }
    async save(t) {
      if (typeof document > "u") throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      let r = Gr.join(t.weightData), n = window.URL.createObjectURL(new Blob([r], { type: "application/octet-stream" }));
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      {
        let o = [{ paths: ["./" + this.weightDataFileName], weights: t.weightSpecs }], s10 = Uy(t, o), i = window.URL.createObjectURL(new Blob([JSON.stringify(s10)], { type: "application/json" })), a = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
        if (a.download = this.modelJsonFileName, a.href = i, await wE(() => a.dispatchEvent(new MouseEvent("click"))), t.weightData != null) {
          let u = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
          u.download = this.weightDataFileName, u.href = n, await wE(() => u.dispatchEvent(new MouseEvent("click")));
        }
        return { modelArtifactsInfo: bs(t) };
      }
    }
  };
  jp.URL_SCHEME = "downloads://";
  var u1 = class {
    constructor(t) {
      if (t == null || t.length < 1) throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);
      this.jsonFile = t[0], this.weightsFiles = t.slice(1);
    }
    async load() {
      return new Promise((t, r) => {
        let n = new FileReader();
        n.onload = (o) => {
          let s10 = JSON.parse(o.target.result), i = s10.modelTopology;
          if (i == null) {
            r(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (s10.weightsManifest == null) {
            r(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (this.weightsFiles.length === 0) {
            t({ modelTopology: i });
            return;
          }
          let u = vp(s10, (l) => this.loadWeights(l));
          t(u);
        }, n.onerror = (o) => r(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), n.readAsText(this.jsonFile);
      });
    }
    loadWeights(t) {
      let r = [], n = [];
      for (let i of t) r.push(...i.weights), n.push(...i.paths);
      let o = this.checkManifestAndWeightFiles(t), s10 = n.map((i) => this.loadWeightsFile(i, o[i]));
      return Promise.all(s10).then((i) => [r, i]);
    }
    loadWeightsFile(t, r) {
      return new Promise((n, o) => {
        let s10 = new FileReader();
        s10.onload = (i) => {
          let a = i.target.result;
          n(a);
        }, s10.onerror = (i) => o(`Failed to weights data from file of path '${t}'.`), s10.readAsArrayBuffer(r);
      });
    }
    checkManifestAndWeightFiles(t) {
      let r = [], n = this.weightsFiles.map((s10) => iN(s10.name)), o = {};
      for (let s10 of t) s10.paths.forEach((i) => {
        let a = iN(i);
        if (r.indexOf(a) !== -1) throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);
        if (r.push(a), n.indexOf(a) === -1) throw new Error(`Weight file with basename '${a}' is not provided.`);
        o[i] = this.weightsFiles[n.indexOf(a)];
      });
      if (r.length !== this.weightsFiles.length) throw new Error(`Mismatch in the number of files in weights manifest (${r.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
      return o;
    }
  };
  var FH = (e28) => z().getBool("IS_BROWSER") && !Array.isArray(e28) && e28.startsWith(jp.URL_SCHEME) ? _H(e28.slice(jp.URL_SCHEME.length)) : null;
  vr.registerSaveRouter(FH);
  function _H(e28 = "model") {
    return new jp(e28);
  }
  function vE(e28) {
    return new u1(e28);
  }
  function l1(e28, t, r, n) {
    i(e28), r = r ?? 0, n = n ?? 1, a(r, n);
    let o = 0, s10 = (u) => (u.then((l) => {
      let c = r + ++o / e28.length * (n - r);
      return t(c), l;
    }), u);
    function i(u) {
      I(u != null && Array.isArray(u) && u.length > 0, () => "promises must be a none empty array");
    }
    function a(u, l) {
      I(u >= 0 && u <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${u}`), I(l >= 0 && l <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${l}`), I(l >= u, () => `startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`);
    }
    return Promise.all(e28.map(s10));
  }
  async function c1(e28, t) {
    t == null && (t = {});
    let r = t.fetchFunc == null ? z().platform.fetch : t.fetchFunc, n = e28.map((p) => r(p, t.requestInit, { isBinary: true })), a = (t.onProgress == null ? await Promise.all(n) : await l1(n, t.onProgress, 0, 0.5)).map((p) => p.arrayBuffer());
    return t.onProgress == null ? await Promise.all(a) : await l1(a, t.onProgress, 0.5, 1);
  }
  function NE(e28, t) {
    var r;
    let n = t.fetchFunc == null ? z().platform.fetch : t.fetchFunc, o = 0, s10;
    return (r = t.onProgress) === null || r === void 0 || r.call(t, 0), new ReadableStream({ pull: async (i) => {
      for (var a; o < e28.length; ) {
        s10 || (s10 = (await n(e28[o], t.requestInit, { isBinary: true })).body.getReader());
        let { done: u, value: l } = await s10.read();
        if (u) {
          o++, s10 = void 0, (a = t.onProgress) === null || a === void 0 || a.call(t, o / e28.length);
          continue;
        }
        i.enqueue(l);
        return;
      }
      i.close();
    } });
  }
  async function CE(e28, t = "", r, n) {
    return p1((i) => c1(i, { requestInit: n }))(e28, t, r);
  }
  function p1(e28) {
    return async (t, r = "", n) => {
      let o = t.map(() => false), s10 = {}, i = n != null ? n.map(() => false) : [], a = [];
      if (t.forEach((f, h) => {
        let d = 0;
        f.weights.forEach((g) => {
          let y = "quantization" in g ? g.quantization.dtype : g.dtype, b = Wi[y] * ie(g.shape), v = () => {
            o[h] = true, s10[h] == null && (s10[h] = []), s10[h].push({ manifestEntry: g, groupOffset: d, sizeBytes: b });
          };
          n != null ? n.forEach((w, N) => {
            w === g.name && (v(), i[N] = true);
          }) : v(), a.push(g.name), d += b;
        });
      }), !i.every((f) => f)) {
        let f = n.filter((h, d) => !i[d]);
        throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`);
      }
      let u = o.reduce((f, h, d) => (h && f.push(d), f), []), l = [];
      u.forEach((f) => {
        t[f].paths.forEach((h) => {
          let d = r + (r.endsWith("/") ? "" : "/") + h;
          l.push(d);
        });
      });
      let c = await e28(l), p = {}, m = 0;
      return u.forEach((f) => {
        let h = t[f].paths.length, d = new Gr(c.slice(m, m + h));
        s10[f].forEach((y) => {
          let b = d.slice(y.groupOffset, y.groupOffset + y.sizeBytes), v = Wy(b, [y.manifestEntry]);
          for (let w in v) p[w] = v[w];
        }), m += h;
      }), p;
    };
  }
  var OH = "application/octet-stream";
  var RH = "application/json";
  var ph = class {
    constructor(t, r) {
      if (this.DEFAULT_METHOD = "POST", r == null && (r = {}), this.weightPathPrefix = r.weightPathPrefix, this.weightUrlConverter = r.weightUrlConverter, r.fetchFunc != null ? (I(typeof r.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = r.fetchFunc) : this.fetch = z().platform.fetch, I(t != null && t.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(t) && I(t.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${t.length}).`), this.path = t, r.requestInit != null && r.requestInit.body != null) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      this.requestInit = r.requestInit || {}, this.loadOptions = r;
    }
    async save(t) {
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      let r = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
      r.body = new FormData();
      let n = [{ paths: ["./model.weights.bin"], weights: t.weightSpecs }], o = Uy(t, n);
      if (r.body.append("model.json", new Blob([JSON.stringify(o)], { type: RH }), "model.json"), t.weightData != null) {
        let i = Gr.join(t.weightData);
        r.body.append("model.weights.bin", new Blob([i], { type: OH }), "model.weights.bin");
      }
      let s10 = await this.fetch(this.path, r);
      if (s10.ok) return { modelArtifactsInfo: bs(t), responses: [s10] };
      throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s10.status}.`);
    }
    async loadModelJSON() {
      let t = await this.fetch(this.path, this.requestInit);
      if (!t.ok) throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);
      let r;
      try {
        r = await t.json();
      } catch {
        let i = `Failed to parse model JSON of response from ${this.path}.`;
        throw this.path.endsWith(".pb") ? i += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : i += " Please make sure the server is serving valid JSON for this request.", new Error(i);
      }
      let n = r.modelTopology, o = r.weightsManifest;
      if (n == null && o == null) throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
      return r;
    }
    async load() {
      if (this.loadOptions.streamWeights) return this.loadStream();
      let t = await this.loadModelJSON();
      return vp(t, (r) => this.loadWeights(r));
    }
    async loadStream() {
      let t = await this.loadModelJSON(), r = await this.getWeightUrls(t.weightsManifest), n = zf(t.weightsManifest), o = () => NE(r, this.loadOptions);
      return Object.assign(Object.assign({}, t), { weightSpecs: n, getWeightStream: o });
    }
    async getWeightUrls(t) {
      let r = Array.isArray(this.path) ? this.path[1] : this.path, [n, o] = PH(r), s10 = this.weightPathPrefix || n, i = [], a = [];
      for (let u of t) for (let l of u.paths) this.weightUrlConverter != null ? a.push(this.weightUrlConverter(l)) : i.push(s10 + l + o);
      return this.weightUrlConverter && i.push(...await Promise.all(a)), i;
    }
    async loadWeights(t) {
      let r = await this.getWeightUrls(t), n = zf(t), o = await c1(r, this.loadOptions);
      return [n, o];
    }
  };
  ph.URL_SCHEME_REGEX = /^https?:\/\//;
  function PH(e28) {
    let t = e28.lastIndexOf("/"), r = e28.lastIndexOf("?"), n = e28.substring(0, t), o = r > t ? e28.substring(r) : "";
    return [n + "/", o];
  }
  function fx(e28) {
    return e28.match(ph.URL_SCHEME_REGEX) != null;
  }
  var SE = (e28, t) => {
    if (typeof fetch > "u" && (t == null || t.fetchFunc == null)) return null;
    {
      let r = true;
      if (Array.isArray(e28) ? r = e28.every((n) => fx(n)) : r = fx(e28), r) return hx(e28, t);
    }
    return null;
  };
  vr.registerSaveRouter(SE);
  vr.registerLoadRouter(SE);
  function hx(e28, t) {
    return new ph(e28, t);
  }
  function IE(e28, t) {
    return hx(e28, t);
  }
  var mh = class {
    constructor(t) {
      this.modelArtifacts = t;
    }
    load() {
      return this.modelArtifacts;
    }
  };
  var dx = class {
    constructor(t) {
      this.saveHandler = t;
    }
    save(t) {
      return this.saveHandler(t);
    }
  };
  var m1 = class {
    constructor(t) {
      t.load && (this.load = () => Promise.resolve(t.load())), t.save && (this.save = (r) => Promise.resolve(t.save(r)));
    }
  };
  function TE(e28, t, r, n) {
    let o = arguments;
    return new m1(f1(...o));
  }
  function f1(e28, t, r, n) {
    return arguments.length === 1 ? e28.modelTopology != null || e28.weightSpecs != null ? new mh(e28) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new mh({ modelTopology: e28 })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new mh({ modelTopology: e28, weightSpecs: t, weightData: r, trainingConfig: n }));
  }
  function kE(e28) {
    return new dx(e28);
  }
  function EE(e28) {
    return new dx(e28);
  }
  function LH(e28, t) {
    let r = e28.shape.length, n = t.shape.length;
    if (r < 1) throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${r}.`);
    if (n < 1) throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);
    if (t.dtype !== "int32") throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
    if (t.shape[n - 1] > r) throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n - 1]} vs. ${r}`);
    if (ie(e28.shape) === 0) throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e28.shape}.`);
    let o = t.shape, s10 = o[o.length - 1], i = 1;
    for (let p = 0; p < o.length - 1; ++p) i *= o[p];
    let a = e28.shape, u = o.slice();
    u.pop();
    let l = 1;
    for (let p = s10; p < r; ++p) l *= a[p], u.push(a[p]);
    let c = [...fs(e28.shape).map((p) => p / l), 1].slice(0, s10);
    return [u, i, l, c];
  }
  var Sr = {};
  lo(Sr, { assertParamsValid: () => zH, computeFlatOffset: () => UH, computeOutShape: () => VH, getNormalizedAxes: () => GH, isSliceContinous: () => WH, maskToAxes: () => BH, parseSliceParams: () => d1, sliceInfo: () => jH, startForAxis: () => PE, startIndicesWithElidedDims: () => _E, stopForAxis: () => LE, stopIndicesWithElidedDims: () => OE, stridesForAxis: () => RE, stridesWithElidedDims: () => DE });
  var h1 = -2;
  var MH = -1;
  function zH(e28, t, r) {
    let n = e28.shape.length;
    I(n === t.length, () => `Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`), I(n === r.length, () => `Error in slice${n}D: Length of size ${r} must match the rank of the array (${n}).`);
    for (let o = 0; o < n; ++o) I(t[o] + r[o] <= e28.shape[o], () => `Error in slice${n}D: begin[${o}] + size[${o}] (${t[o] + r[o]}) would overflow input.shape[${o}] (${e28.shape[o]})`);
  }
  function BH(e28) {
    let t = [], r = 0;
    for (; e28 > 0; ) e28 & 1 && t.push(r), e28 /= 2, r++;
    return t;
  }
  function VH(e28, t, r) {
    let n = [];
    for (let o = 0; o < e28.length; o++) n[o] = Math.ceil((t[o] - e28[o]) / r[o]);
    return n;
  }
  function DE(e28, t, r, n) {
    let o = [...e28];
    for (let s10 = o.length; s10 < n.length; s10++) o.push(1);
    for (let s10 = 0; s10 < r; s10++) s10 === 0 ? o[t] = 1 : (o.splice(t, 0, 1), o.pop());
    return o;
  }
  function $E(e28, t, r) {
    return r <= e28 ? r : r - (t - 1);
  }
  function FE(e28, t) {
    let r = [];
    for (let n = 0; n < e28; n++) r.push(t + n);
    return r;
  }
  function GH(e28, t, r, n, o, s10, i, a, u) {
    let l = e28.length, c = new Array(l), p = new Array(l), m = new Array(l);
    if (t.length && r > 0) {
      let f = t[0], h = r + 1;
      c = _E(i, f, h, n, e28), p = OE(a, f, h, o, e28), m = DE(s10, f, h, e28);
    } else for (let f = 0; f < l; f++) c[f] = PE(i, n, s10, e28, f, u), p[f] = LE(a, o, s10, e28, f, u), m[f] = RE(s10, f, u);
    return { begin: c, end: p, strides: m };
  }
  function _E(e28, t, r, n, o) {
    let s10 = [...o], i = FE(r, t);
    for (let a = 0; a < s10.length; a++) if (i.indexOf(a) > -1) s10[a] = 0;
    else {
      let u = $E(t, r, a), l = n[u];
      e28 & 1 << u && (l = 0), s10[a] = l;
    }
    return s10;
  }
  function OE(e28, t, r, n, o) {
    let s10 = [...o], i = FE(r, t);
    for (let a = 0; a < s10.length; a++) if (i.indexOf(a) > -1) s10[a] = Number.MAX_SAFE_INTEGER;
    else {
      let u = $E(t, r, a), l = n[u];
      e28 & 1 << u && (l = Number.MAX_SAFE_INTEGER), s10[a] = l;
    }
    for (let a = 0; a < s10.length; a++) {
      let u = o[a];
      s10[a] < 0 && (s10[a] += u), s10[a] = Sc(0, s10[a], o[a]);
    }
    return s10;
  }
  function RE(e28, t, r) {
    let n = e28[t];
    return (r & 1 << t || n == null) && (n = 1), n;
  }
  function PE(e28, t, r, n, o, s10) {
    let i = t[o], a = r[o] || 1;
    (e28 & 1 << o || s10 & 1 << o || i == null) && (a > 0 ? i = Number.MIN_SAFE_INTEGER : i = Number.MAX_SAFE_INTEGER);
    let u = n[o];
    return i < 0 && (i += u), i = Sc(0, i, u - 1), i;
  }
  function LE(e28, t, r, n, o, s10) {
    let i = t[o], a = r[o] || 1;
    (e28 & 1 << o || s10 & 1 << o || i == null) && (a > 0 ? i = Number.MAX_SAFE_INTEGER : i = Number.MIN_SAFE_INTEGER);
    let u = n[o];
    return i < 0 && (i += u), a > 0 ? i = Sc(0, i, u) : i = Sc(-1, i, u - 1), i;
  }
  function WH(e28, t, r) {
    let n = r.length;
    for (let o = 0; o < r.length; o++) if (r[o] > 1) {
      n = o;
      break;
    }
    for (let o = n + 1; o < r.length; o++) if (t[o] > 0 || r[o] !== e28[o]) return false;
    return true;
  }
  function UH(e28, t) {
    let r = e28.length > 0 ? e28[e28.length - 1] : 1;
    for (let n = 0; n < e28.length - 1; n++) r += e28[n] * t[n];
    return r;
  }
  function d1(e28, t, r) {
    let n, o = e28.shape.length;
    typeof t == "number" ? n = [t, ...new Array(o - 1).fill(0)] : t.length < o ? n = t.concat(new Array(o - t.length).fill(0)) : n = t.slice(), n.forEach((i) => {
      I(i !== -1, () => "slice() does not support negative begin indexing.");
    });
    let s10;
    return r == null ? s10 = new Array(o).fill(-1) : typeof r == "number" ? s10 = [r, ...new Array(o - 1).fill(-1)] : r.length < o ? s10 = r.concat(new Array(o - r.length).fill(-1)) : s10 = r, s10 = s10.map((i, a) => i >= 0 ? i : (I(i === -1, () => `Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`), e28.shape[a] - n[a])), [n, s10];
  }
  function jH(e28, t, r, n, o, s10, i, a, u) {
    let l;
    if (n == null ? (l = new Array(t.length), l.fill(1)) : l = n, i != null && i & i - 1) throw new Error("Multiple ellipses in slice is not allowed.");
    let c = false, p = { dims: l.length, numAddAxisAfterEllipsis: 0, begin: t.slice(), end: r.slice(), strides: l.slice(), beginMask: o, endMask: s10, ellipsisMask: i, newAxisMask: a, shrinkAxisMask: u };
    for (let v = 0; v < p.dims; v++) c && 1 << v & a && p.numAddAxisAfterEllipsis++, 1 << v & i && (c = true);
    c || (p.ellipsisMask |= 1 << p.dims, p.dims++);
    let m = { dims: e28.length, beginMask: 0, endMask: 0, beginValid: false, endValid: false };
    HH(p, m);
    let f = true, h = true, d = true, g = [], y = [];
    for (let v = 0; v < e28.length; ++v) {
      if (m.strides[v] === 0) throw Error(`strides[${v}] must be non-zero`);
      let w = !!(m.shrinkAxisMask & 1 << v), N = e28[v];
      if (N === -1) {
        g.push(w ? 1 : -1);
        continue;
      }
      let E = [m.beginMask & 1 << v, m.endMask & 1 << v], A = [m.strides[v] > 0 ? 0 : -1, m.strides[v] > 0 ? N : N - 1];
      if (w && m.strides[v] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
      d = d && m.strides[v] === 1;
      let D = !!(m.beginMask & 1 << v && m.endMask & 1 << v);
      if (m.beginValid && m.endValid) {
        if (w) {
          let W = m.begin[v] < 0 ? N + m.begin[v] : m.begin[v];
          if (m.begin[v] = W, m.end[v] = m.begin[v] + 1, W < 0 || W >= N) throw Error(`slice index ${m.begin[v]} of dimension ${v} out of bounds.`);
        } else m.begin[v] = AE(m.begin[v], 0, m.strides[v], N, E, A), m.end[v] = AE(m.end[v], 1, m.strides[v], N, E, A);
        let G = m.strides[v] === 1 && m.begin[v] === 0 && m.end[v] === N;
        f = f && G, h = h && (v === 0 && m.strides[v] === 1 || G);
      } else f = f && m.strides[v] === 1 && D, h = h && (v === 0 && m.strides[v] === 1 || D);
      let R, L = false;
      if (m.beginValid && m.endValid ? (R = m.end[v] - m.begin[v], L = true) : w ? (R = 1, L = true) : D && N >= 0 && (m.strides[v] < 0 ? R = -N : R = N, L = true), L) {
        let G;
        R === 0 || R < 0 != m.strides[v] < 0 ? G = 0 : G = Math.trunc(R / m.strides[v]) + (R % m.strides[v] !== 0 ? 1 : 0), g.push(G);
      } else g.push(-1);
    }
    for (let v = 0; v < m.finalShapeGatherIndices.length; ++v) {
      let w = m.finalShapeGatherIndices[v];
      w >= 0 ? y.push(g[w]) : w === h1 && y.push(1);
    }
    return { finalShapeSparse: y.filter((v, w) => m.finalShapeGatherIndices[w] !== h1), finalShape: y, isIdentity: f, sliceDim0: h, isSimpleSlice: d, begin: m.begin, end: m.end, strides: m.strides };
  }
  function HH(e28, t) {
    t.beginMask = 0, t.endMask = 0, t.shrinkAxisMask = 0;
    let r = 0;
    t.beginValid = e28.begin != null, t.endValid = e28.end != null, t.begin = new Array(t.dims), t.end = new Array(t.dims), t.strides = new Array(t.dims), t.finalShapeGatherIndices = [], t.finalShapeGatherIndicesSparse = [], t.inputShapeGatherIndicesSparse = new Array(t.dims);
    for (let n = 0; n < e28.dims; n++) if (1 << n & e28.ellipsisMask) {
      let o = Math.min(t.dims - (e28.dims - n) + 1 + e28.numAddAxisAfterEllipsis, t.dims);
      for (; r < o; r++) t.begin[r] = 0, t.end[r] = 0, t.strides[r] = 1, t.beginMask |= 1 << r, t.endMask |= 1 << r, t.finalShapeGatherIndices.push(r), t.finalShapeGatherIndicesSparse.push(-1), t.inputShapeGatherIndicesSparse[r] = n;
    } else if (1 << n & e28.newAxisMask) t.finalShapeGatherIndices.push(h1), t.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (r === t.begin.length) throw Error(`Index out of range using input dim ${r}; input has only ${t.dims} dims, ${t.begin.length}.`);
      e28.begin != null && (t.begin[r] = e28.begin[n]), e28.end != null && (t.end[r] = e28.end[n]), t.strides[r] = e28.strides[n], e28.beginMask & 1 << n && (t.beginMask |= 1 << r), e28.endMask & 1 << n && (t.endMask |= 1 << r), e28.shrinkAxisMask & 1 << n ? (t.finalShapeGatherIndices.push(MH), t.finalShapeGatherIndicesSparse.push(-1), t.shrinkAxisMask |= 1 << r) : (t.finalShapeGatherIndices.push(r), t.finalShapeGatherIndicesSparse.push(n)), t.inputShapeGatherIndicesSparse[r] = n, r++;
    }
  }
  function AE(e28, t, r, n, o, s10) {
    if (o[t]) return r > 0 ? s10[t] : s10[t + 1 & 1];
    {
      let i = e28 < 0 ? n + e28 : e28;
      return i < s10[0] ? s10[0] : i > s10[1] ? s10[1] : i;
    }
  }
  var gx = class {
    static sgd(t) {
      return new Au(t);
    }
    static momentum(t, r, n = false) {
      return new Wp(t, r, n);
    }
    static rmsprop(t, r = 0.9, n = 0, o = null, s10 = false) {
      return new Up(t, r, n, o, s10);
    }
    static adam(t = 1e-3, r = 0.9, n = 0.999, o = null) {
      return new Vp(t, r, n, o);
    }
    static adadelta(t = 1e-3, r = 0.95, n = null) {
      return new zp(t, r, n);
    }
    static adamax(t = 2e-3, r = 0.9, n = 0.999, o = null, s10 = 0) {
      return new Gp(t, r, n, o, s10);
    }
    static adagrad(t, r = 0.1) {
      return new Bp(t, r);
    }
  };
  var Bl = gx;
  var KH = typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : (e28) => e28();
  function fh() {
    return new Promise((e28) => KH(() => e28()));
  }
  var C = {};
  lo(C, { ERF_A1: () => uK, ERF_A2: () => lK, ERF_A3: () => cK, ERF_A4: () => pK, ERF_A5: () => mK, ERF_P: () => aK, PARALLELIZE_THRESHOLD: () => yx, RowPartitionType: () => Ts, SELU_SCALE: () => y1, SELU_SCALEALPHA: () => g1, applyActivation: () => Ll, assertAndGetBroadcastShape: () => Gt, assertAxesAreInnerMostDims: () => rU, assertParamsConsistent: () => qH, assignToTypedArray: () => xK, axesAreInnerMostDims: () => ON, calculateShapes: () => Gj, checkEinsumDimSizes: () => SK, checkPadOnDimRoundingMode: () => be, combineLocations: () => xk, combineRaggedTensorToTensorShapes: () => YH, complexWithEvenIndex: () => dK, complexWithOddIndex: () => gK, computeConv2DInfo: () => Nl, computeConv3DInfo: () => lk, computeDefaultPad: () => NN, computeDilation2DInfo: () => iW, computeOptimalWindowSize: () => tK, computeOutAndReduceShapes: () => RN, computeOutShape: () => XH, computePool2DInfo: () => vN, computePool3DInfo: () => aW, convertConv2DDataFormat: () => ck, decodeEinsumEquation: () => NK, eitherStridesOrDilationsAreOne: () => $r, expandShapeToKeepDim: () => Cs, exponent: () => wK, exponents: () => bK, fromStringArrayToUint8: () => jK, fromUint8ToStringArray: () => UK, getAxesPermutation: () => PN, getBroadcastDims: () => dk, getComplexWithIndex: () => yK, getEinsumComputePath: () => IK, getEinsumPermutation: () => CK, getFusedBiasGradient: () => Pl, getFusedDyActivation: () => Rl, getImageCenter: () => eK, getInnerMostAxes: () => nU, getPermuted: () => nK, getRaggedRank: () => ZH, getReductionAxes: () => de, getReshaped: () => rK, getReshapedPermuted: () => oK, getRowPartitionTypesHelper: () => JH, getSliceBeginCoords: () => sK, getSliceSize: () => iK, getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => AK, getSparseFillEmptyRowsNegativeIndexErrorMessage: () => DK, getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => $K, getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => OK, getSparseReshapeInputOutputMismatchErrorMessage: () => PK, getSparseReshapeInputOutputMultipleErrorMessage: () => RK, getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => FK, getSparseReshapeNegativeOutputDimErrorMessage: () => _K, getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => BK, getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => LK, getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => MK, getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => zK, getUndoAxesPermutation: () => qf, isIdentityPermutation: () => TK, log: () => ZG, mergeRealAndImagArrays: () => fK, prepareAndValidate: () => LH, prepareSplitSize: () => EK, segment_util: () => b1, shouldFuse: () => Ml, slice_util: () => Sr, splitRealAndImagArrays: () => hK, stridesOrDilationsArePositive: () => Ns, tupleValuesAreOne: () => Jn, upcastType: () => lr, validateDefaultValueShape: () => QH, validateInput: () => Vj, validateUpdateShape: () => Uk, warn: () => xs });
  function qH(e28, t) {
    let r = e28[0].length;
    e28.forEach((o, s10) => {
      I(o.length === r, () => `Error in concat${r}D: rank of tensors[${s10}] must be the same as the rank of the rest (${r})`);
    }), I(t >= 0 && t < r, () => `Error in concat${r}D: axis must be between 0 and ${r - 1}.`);
    let n = e28[0];
    e28.forEach((o, s10) => {
      for (let i = 0; i < r; i++) I(i === t || o[i] === n[i], () => `Error in concat${r}D: Shape of tensors[${s10}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s10}.`);
    });
  }
  function XH(e28, t) {
    let r = e28[0].slice();
    for (let n = 1; n < e28.length; n++) r[t] += e28[n][t];
    return r;
  }
  var Ts;
  (function(e28) {
    e28[e28.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", e28[e28.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", e28[e28.ROW_LENGTHS = 2] = "ROW_LENGTHS", e28[e28.ROW_SPLITS = 3] = "ROW_SPLITS", e28[e28.ROW_LIMITS = 4] = "ROW_LIMITS", e28[e28.ROW_STARTS = 5] = "ROW_STARTS";
  })(Ts || (Ts = {}));
  function YH(e28, t, r) {
    let n = new Array();
    if (r == null && t == null) return n;
    if (t == null) for (; n.length < e28 + r.length; ) n.push(-1);
    else n = t.slice();
    if (r == null) return n;
    if (e28 + r.length !== n.length) throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e28 + r.length}, but shape.rank = ${n.length}`);
    for (let o = 1; o < r.length; ++o) {
      let s10 = r[o], i = n[n.length - r.length + o], a = n[i];
      if (s10 >= 0) if (a >= 0) {
        if (a !== s10) throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o + e28}] = ${s10} but shape[${o + e28}] = ${a}`);
      } else n[i] = s10;
    }
    return n;
  }
  function JH(e28) {
    let t = { FIRST_DIM_SIZE: Ts.FIRST_DIM_SIZE, VALUE_ROWIDS: Ts.VALUE_ROWIDS, ROW_LENGTHS: Ts.ROW_LENGTHS, ROW_SPLITS: Ts.ROW_SPLITS, ROW_LIMITS: Ts.ROW_LIMITS, ROW_STARTS: Ts.ROW_STARTS }, r = [];
    for (let n of e28) if (n in t) r.push(t[n]);
    else break;
    return r;
  }
  function ZH(e28) {
    return e28.length === 0 ? 0 : e28[0] === Ts.FIRST_DIM_SIZE ? e28.length - 1 : e28.length;
  }
  function QH(e28, t) {
    if (e28 == null || t == null) return;
    let r = e28.length, n = t.length;
    if (r >= n) throw new Error(`defaultValue.shape=${e28} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${r} must be less than ragged tensor input flatValues.rank = ${n})`);
    for (let o = 0; o < Math.min(r, n - 1); ++o) {
      let s10 = e28[o], i = t[o + 1];
      if (s10 >= 0 && i >= 0 && s10 !== 1 && s10 !== i) throw new Error(`defaultValue.shape=${e28}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o - e28.length}] = ${s10} but ragged tensor input.flatValues.shape[${o - e28.length}] = ${i}`);
    }
  }
  var yx = 30;
  function tK(e28) {
    return e28 <= yx ? e28 : Ec(e28, Math.floor(Math.sqrt(e28)));
  }
  function eK(e28, t, r) {
    let n = r * (typeof e28 == "number" ? e28 : e28[0]), o = t * (typeof e28 == "number" ? e28 : e28[1]);
    return [n, o];
  }
  function rK(e28, t, r, n = true) {
    let o = [];
    if (n) o = o.concat(t.slice(0)), o.push(e28[0] / r), o = o.concat(e28.slice(1));
    else {
      o = o.concat(e28[0]);
      let s10 = t.length;
      for (let i = 0; i < s10; ++i) o = o.concat([e28[i + 1] / t[i], t[i]]);
      o = o.concat(e28.slice(s10 + 1));
    }
    return o;
  }
  function nK(e28, t, r = true) {
    let n = [];
    if (r) {
      n.push(t);
      for (let o = t + 1; o < e28; ++o) o <= 2 * t ? (n.push(o), n.push(o - (t + 1))) : n.push(o);
    } else {
      let o = [], s10 = [];
      for (let i = 1; i < e28; ++i) i >= t * 2 + 1 || i % 2 === 1 ? s10.push(i) : o.push(i);
      n.push(...o), n.push(0), n.push(...s10);
    }
    return n;
  }
  function oK(e28, t, r, n = true) {
    let o = [];
    n ? o.push(e28[0] / r) : o.push(e28[0] * r);
    for (let s10 = 1; s10 < e28.length; ++s10) s10 <= t.length ? n ? o.push(t[s10 - 1] * e28[s10]) : o.push(e28[s10] / t[s10 - 1]) : o.push(e28[s10]);
    return o;
  }
  function sK(e28, t) {
    let r = [0];
    for (let n = 0; n < t; ++n) r.push(e28[n][0]);
    return r;
  }
  function iK(e28, t, r) {
    let n = e28.slice(0, 1);
    for (let o = 0; o < r; ++o) n.push(e28[o + 1] - t[o][0] - t[o][1]);
    return n;
  }
  var g1 = 1.7580993408473768;
  var y1 = 1.0507009873554805;
  var aK = 0.3275911;
  var uK = 0.254829592;
  var lK = -0.284496736;
  var cK = 1.421413741;
  var pK = -1.453152027;
  var mK = 1.061405429;
  function fK(e28, t) {
    if (e28.length !== t.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e28.length}, imag: ${t.length}.`);
    let r = new Float32Array(e28.length * 2);
    for (let n = 0; n < r.length; n += 2) r[n] = e28[n / 2], r[n + 1] = t[n / 2];
    return r;
  }
  function hK(e28) {
    let t = new Float32Array(e28.length / 2), r = new Float32Array(e28.length / 2);
    for (let n = 0; n < e28.length; n += 2) t[n / 2] = e28[n], r[n / 2] = e28[n + 1];
    return { real: t, imag: r };
  }
  function dK(e28) {
    let t = Math.ceil(e28.length / 4), r = new Float32Array(t), n = new Float32Array(t);
    for (let o = 0; o < e28.length; o += 4) r[Math.floor(o / 4)] = e28[o], n[Math.floor(o / 4)] = e28[o + 1];
    return { real: r, imag: n };
  }
  function gK(e28) {
    let t = Math.floor(e28.length / 4), r = new Float32Array(t), n = new Float32Array(t);
    for (let o = 2; o < e28.length; o += 4) r[Math.floor(o / 4)] = e28[o], n[Math.floor(o / 4)] = e28[o + 1];
    return { real: r, imag: n };
  }
  function yK(e28, t) {
    let r = e28[t * 2], n = e28[t * 2 + 1];
    return { real: r, imag: n };
  }
  function xK(e28, t, r, n) {
    e28[n * 2] = t, e28[n * 2 + 1] = r;
  }
  function bK(e28, t) {
    let r = new Float32Array(e28 / 2), n = new Float32Array(e28 / 2);
    for (let o = 0; o < Math.ceil(e28 / 2); o++) {
      let s10 = (t ? 2 : -2) * Math.PI * (o / e28);
      r[o] = Math.cos(s10), n[o] = Math.sin(s10);
    }
    return { real: r, imag: n };
  }
  function wK(e28, t, r) {
    let n = (r ? 2 : -2) * Math.PI * (e28 / t), o = Math.cos(n), s10 = Math.sin(n);
    return { real: o, imag: s10 };
  }
  var x1 = "->";
  var vK = /->/g;
  var ME = ",";
  var zE = "...";
  function NK(e28, t) {
    e28 = e28.replace(/\s/g, "");
    let r = (e28.length - e28.replace(vK, "").length) / x1.length;
    if (r < 1) throw new Error("Equations without an arrow are not supported.");
    if (r > 1) throw new Error(`Equation must contain exactly one arrow ("${x1}").`);
    let [n, o] = e28.split(x1);
    I(n.indexOf(zE) === -1, () => `The ellipsis notation ("${zE}") is not supported yet.`);
    let s10 = n.split(ME), i = s10.length;
    if (t !== i) throw new Error(`Expected ${i} input tensors, received ${t}`);
    if (i > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
    let a = [];
    for (let m = 0; m < o.length; ++m) {
      let f = o[m];
      if (!s10.some((h) => h.indexOf(f) !== -1)) throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);
      a.indexOf(f) === -1 && a.push(f);
    }
    for (let m = 0; m < n.length; ++m) {
      let f = n[m];
      a.indexOf(f) === -1 && f !== ME && a.push(f);
    }
    let u = new Array(s10.length);
    for (let m = 0; m < i; ++m) {
      if (new Set(s10[m].split("")).size !== s10[m].length) throw new Error(`Found duplicate axes in input component ${s10[m]}. Support for duplicate axes in input is not implemented yet.`);
      u[m] = [];
      for (let f = 0; f < s10[m].length; ++f) u[m].push(a.indexOf(s10[m][f]));
    }
    let l = a.length, c = o.length, p = [];
    for (let m = c; m < l; ++m) p.push(m);
    return { allDims: a, summedDims: p, idDims: u };
  }
  function CK(e28, t) {
    let r = new Array(e28);
    r.fill(-1);
    for (let o = 0; o < t.length; ++o) r[t[o]] = o;
    let n = [];
    for (let o = 0; o < e28; ++o) r[o] === -1 && n.push(o);
    return r = r.filter((o) => o !== -1), { permutationIndices: r, expandDims: n };
  }
  function SK(e28, t, r) {
    let n = new Array(e28);
    for (let o = 0; o < r.length; ++o) {
      let s10 = r[o].shape;
      for (let i = 0; i < t[o].length; ++i) n[t[o][i]] === void 0 ? n[t[o][i]] = s10[i] : I(n[t[o][i]] === s10[i], () => `Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s10)}, but got dimension ${s10[i]}`);
    }
  }
  function IK(e28, t) {
    let r = e28, n = [], o = 0;
    e28.length === 0 && r.push(-1), o = e28.length + 1;
    for (let i = 0; i < o; ++i) n.push([]);
    let s10 = [];
    for (let i = 0; i < r.length; ++i) {
      let a = r[i], u = kK(t, a);
      for (let l of u) s10.indexOf(l) === -1 && (n[i].push(l), s10.push(l));
    }
    return { path: r, steps: n };
  }
  function TK(e28) {
    return e28.every((t, r) => t === r);
  }
  function kK(e28, t) {
    let r = [];
    for (let n = 0; n < e28.length; ++n) (e28[n].length === 0 || e28[n].indexOf(t) !== -1 || t === -1) && r.push(n);
    return r;
  }
  function EK(e28, t, r = 0) {
    let n = [];
    if (typeof t == "number") I(e28.shape[r] % t === 0, () => "Number of splits must evenly divide the axis."), n = new Array(t).fill(e28.shape[r] / t);
    else {
      let o = t.reduce((i, a) => (a === -1 && (i += 1), i), 0);
      I(o <= 1, () => "There should be only one negative value in split array.");
      let s10 = t.indexOf(-1);
      if (s10 !== -1) {
        let i = t.reduce((a, u) => u > 0 ? a + u : a);
        t[s10] = e28.shape[r] - i;
      }
      I(e28.shape[r] === t.reduce((i, a) => i + a), () => "The sum of sizes must match the size of the axis dimension."), n = t;
    }
    return n;
  }
  function AK(e28) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e28}`;
  }
  function DK(e28, t) {
    return `indices(${e28}, 0) is invalid: ${t} < 0`;
  }
  function $K(e28, t, r) {
    return `indices(${e28}, 0) is invalid: ${t} >= ${r}`;
  }
  function FK(e28, t) {
    return `only one output dimension may be -1, not both ${e28} and ${t}`;
  }
  function _K(e28, t) {
    return `size ${e28} must be non-negative, not ${t}`;
  }
  function OK() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function RK(e28, t) {
    let r = ie(e28), n = ie(t);
    return `Input to reshape is a SparseTensor with ${r}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${e28} outputShape= ${t}`;
  }
  function PK(e28, t) {
    let r = ie(e28), n = ie(t);
    return `Input to reshape is a tensor with ${r} dense values, but the requested shape has ${n}. inputShape=${e28} outputShape=${t}`;
  }
  function LK() {
    return "segment ids must be >= 0";
  }
  function MK() {
    return "segment ids are not increasing";
  }
  function zK(e28, t) {
    return `Segment id ${e28} out of range [0, ${t}), possibly because segmentIds input is not sorted.`;
  }
  function BK(e28, t, r) {
    return `Bad: indices[${e28}] == ${t} out of range [0, ${r})`;
  }
  var b1 = {};
  lo(b1, { collectGatherOpShapeInfo: () => WK, computeOutShape: () => GK, segOpComputeOptimalWindowSize: () => VK });
  function VK(e28, t) {
    let r = false, n;
    for (e28 <= yx ? (n = e28, r = true) : n = Ec(e28, Math.floor(Math.sqrt(e28))); !r; ) n > t || n === e28 ? r = true : n = Ec(e28, n + 1);
    return n;
  }
  function GK(e28, t, r) {
    let n = [], o = e28.length;
    for (let s10 = 0; s10 < o; s10++) s10 !== t ? n.push(e28[s10]) : n.push(r);
    return n;
  }
  function WK(e28, t, r, n) {
    let o = t.shape.length, s10 = e28.shape.length;
    if (n !== 0 && (n < -o || n > o)) throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);
    if (n < 0 && (n += o), n > s10) throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s10}).`);
    if (r < n) throw new Error(`batchDims (${n}) must be less than or equal to axis (${r}).`);
    for (let p = 0; p < n; ++p) if (e28.shape[p] !== t.shape[p]) throw new Error(`x.shape[${p}]: ${e28.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);
    let i = e28.shape[r], a = [], u = 1, l = 1, c = 1;
    for (let p = 0; p < n; ++p) a.push(e28.shape[p]), u *= e28.shape[p];
    for (let p = n; p < r; p++) a.push(e28.shape[p]), l *= e28.shape[p];
    for (let p = n; p < o; p++) a.push(t.shape[p]);
    for (let p = r + 1; p < s10; p++) a.push(e28.shape[p]), c *= e28.shape[p];
    return { batchSize: u, sliceSize: c, outerSize: l, dimSize: i, outputShape: a };
  }
  function UK(e28) {
    try {
      return e28.map((t) => bp(t));
    } catch (t) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`);
    }
  }
  function jK(e28) {
    return e28.map((t) => xp(t));
  }
  var jr = {};
  lo(jr, { nonMaxSuppressionV3Impl: () => ax, nonMaxSuppressionV4Impl: () => ux, nonMaxSuppressionV5Impl: () => lx, whereImpl: () => Kk });
  bE();
  var xx = { kernelName: ka, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, Uo(Z(r, "float32"), -1)) };
  } };
  var BE = { kernelName: Ys, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => {
      let n = Xt(Z(r, "float32")), o = ge(xt($t(1), n));
      return ne(ut(e28, o));
    } };
  } };
  var VE = { kernelName: Js, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => {
      let n = ge(xt(Xt(Z(r, "float32")), 1));
      return ut(e28, n);
    } };
  } };
  var GE = { kernelName: Mo, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = e28, u = de(r.shape, o);
      return u.length > 0 && (a = ht(a, u)), _(a, r.shape);
    }, b: () => {
      let a = e28, u = de(n.shape, o);
      return u.length > 0 && (a = ht(a, u)), _(a, n.shape);
    } };
  } };
  var WE = { kernelName: Dc, saveAllInputs: true, gradFunc: (e28, t) => {
    let r = {};
    return t.forEach((n, o) => {
      r[o] = () => e28.clone();
    }), r;
  } };
  var UE = { kernelName: Ea, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => Dt(r) };
  } };
  var jE = { kernelName: Aa, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => Dt(r) };
  } };
  var HE = { kernelName: Zs, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, ge(xt($t(1), Xt(Z(r, "float32"))))) };
  } };
  var KE = { kernelName: Qs, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => {
      let n = ge(Y($t(1), Xt(Z(r, "float32"))));
      return ut(e28, n);
    } };
  } };
  var qE = { kernelName: ri, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = Y(Xt(r), Xt(n)), u = F(e28, ut(n, a)), l = de(r.shape, o);
      return l.length > 0 && (u = ht(u, l)), _(u, r.shape);
    }, b: () => {
      let a = Y(Xt(r), Xt(n)), u = ne(F(e28, ut(r, a))), l = de(n.shape, o);
      return l.length > 0 && (u = ht(u, l)), _(u, n.shape);
    } };
  } };
  var XE = { kernelName: ti, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, Y(Xt(Z(r, "float32")), 1)) };
  } };
  var YE = { kernelName: ei, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, xt($t(1), Xt(Z(r, "float32")))) };
  } };
  function HK(e28, t, r, n, o, s10) {
    let i = S(e28, "dy", "avgPool3dGrad"), a = S(t, "input", "avgPool3dGrad"), u = i, l = a, c = false;
    a.rank === 4 && (c = true, u = _(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]]), l = _(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]])), I(u.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`), I(l.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`), be("avgPool3dGrad", o, s10);
    let p = { dy: u, input: l }, m = { filterSize: r, strides: n, pad: o, dimRoundingMode: s10 }, f = T.runKernel(Oc, p, m);
    return c ? _(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f;
  }
  var JE = k({ avgPool3dGrad_: HK });
  var ZE = { kernelName: $a, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { filterSize: o, strides: s10, pad: i, dimRoundingMode: a } = r;
    return { x: () => JE(e28, n, o, s10, i, a) };
  } };
  function KK(e28, t, r, n, o) {
    let s10 = S(e28, "dy", "avgPoolGrad"), i = S(t, "input", "avgPoolGrad");
    I(i.rank === s10.rank, () => `Rank of input (${i.rank}) does not match rank of dy (${s10.rank})`);
    let a = i, u = s10, l = false;
    i.rank === 3 && (l = true, a = _(i, [1, i.shape[0], i.shape[1], i.shape[2]]), u = _(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), I(u.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`), I(a.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);
    let c = { dy: u, input: a }, p = { filterSize: r, strides: n, pad: o }, m = T.runKernel(_c, c, p);
    return l ? _(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
  }
  var QE = k({ avgPoolGrad_: KK });
  var t2 = { kernelName: Da, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { filterSize: o, strides: s10, pad: i } = r;
    return { x: () => QE(e28, n, o, s10, i) };
  } };
  var e22 = { kernelName: Fa, inputsToSave: ["a", "b"], gradFunc: (e28, t, r) => {
    let [n, o] = t, { transposeA: s10, transposeB: i } = r;
    return !s10 && !i ? { a: () => ae(e28, o, false, true), b: () => ae(n, e28, true, false) } : !s10 && i ? { a: () => ae(e28, o, false, false), b: () => ae(e28, n, true, false) } : s10 && !i ? { a: () => ae(o, e28, false, true), b: () => ae(n, e28, false, false) } : { a: () => ae(o, e28, true, true), b: () => ae(e28, n, true, true) };
  } };
  var r2 = { kernelName: _a, gradFunc: (e28, t, r) => {
    let { blockShape: n, crops: o } = r;
    return { x: () => Op(e28, n, o) };
  } };
  var n2 = { kernelName: nT, gradFunc: (e28, t, r) => {
    let n = r, o = n.inputShape, s10 = n.shape, i = Array.from(s10);
    for (let u = o.length - 1; u >= 0; u--) if (o[u] === s10[u]) i[u] = 1;
    else if (o[u] !== 1) throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s10}].`);
    let a = [];
    for (let u = 0; u < i.length; u++) i[u] > 1 && a.push(u);
    return { x: () => ht(e28, a, true) };
  } };
  var o2 = { kernelName: hs, gradFunc: (e28) => ({ x: () => e28.clone() }) };
  var s23 = { kernelName: ni, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var i2 = { kernelName: oi, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { clipValueMin: o, clipValueMax: s10 } = r;
    return { x: () => Ce(Jr(vn(n, o), bo(n, s10)), e28, Dt(e28)) };
  } };
  var a2 = { kernelName: Oa, inputsToSave: ["x"], gradFunc: xx.gradFunc };
  var u2 = { kernelName: Ra, saveAllInputs: true, gradFunc: (e28, t, r) => {
    let n = t.map((u) => u.shape), { axis: o } = r, s10 = dr(o, t[0].shape)[0], i = n.map((u) => u[s10]);
    return xr(e28, i, s10).map((u) => () => u);
  } };
  var l2 = { kernelName: Pa, inputsToSave: ["x", "filter"], gradFunc: (e28, t, r) => {
    let [n, o] = t, { dilations: s10, strides: i, pad: a, dataFormat: u } = r;
    return I(Jn(s10), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s10}'`), { x: () => kp(n.shape, e28, o, i, a, u), filter: () => Mp(n, e28, o.shape, i, a, u) };
  } };
  var c2 = { kernelName: La, inputsToSave: ["dy", "filter"], gradFunc: (e28, t, r) => {
    let [n, o] = t, { strides: s10, pad: i, dataFormat: a, dimRoundingMode: u } = r;
    return { dy: () => On(e28, o, s10, i, a, 1, u), filter: () => Mp(e28, n, o.shape, s10, i, a, u) };
  } };
  function qK(e28, t, r, n, o) {
    let s10 = e28;
    e28.rank === 4 && (s10 = _(e28, [1, e28.shape[0], e28.shape[1], e28.shape[2], e28.shape[3]]));
    let i = t;
    i.rank === 4 && (i = _(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), I(s10.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${s10.shape}.`), I(i.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`), I(r.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${r}.`), I(s10.shape[4] === r[3], () => `Error in conv3dDerFilter: depth of input ${s10.shape[4]}) must match input depth in filter (${r[3]}.`), I(i.shape[4] === r[4], () => `Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${r[4]}).`);
    let a = { x: s10, dy: i }, u = { strides: n, pad: o, filterShape: r };
    return T.runKernel(Mc, a, u);
  }
  var p2 = k({ conv3DBackpropFilter_: qK });
  var m2 = { kernelName: Ma, inputsToSave: ["x", "filter"], gradFunc: (e28, t, r) => {
    let { dilations: n, strides: o, pad: s10 } = r;
    I(Jn(n), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);
    let [i, a] = t;
    return { x: () => Xy(i.shape, e28, a, o, s10), filter: () => p2(i, e28, a.shape, o, s10) };
  } };
  var f2 = { kernelName: si, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(ne(nh(Z(r, "float32"))), e28) };
  } };
  var h2 = { kernelName: ii, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(oh(Z(r, "float32")), e28) };
  } };
  var d2 = { kernelName: za, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { axis: o, exclusive: s10, reverse: i } = r;
    return { x: () => {
      let a = PN([o], n.rank), u = Yy(e28, o, s10, !i);
      return a != null && (u = qt(u, a)), u;
    } };
  } };
  var g2 = { kernelName: Ba, inputsToSave: ["x", "filter"], gradFunc: (e28, t, r) => {
    let { dilations: n, strides: o, pad: s10, dimRoundingMode: i } = r, a = n ?? [1, 1];
    I(Jn(a), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);
    let [u, l] = t;
    return I(u.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`), I(l.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`), I(u.shape[3] === l.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`), I($r(o, a), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`), be("depthwiseConv2d", s10, i), { x: () => ix(u.shape, e28, l, o, s10, a, i), filter: () => sx(u, e28, l.shape, o, s10, a, i) };
  } };
  var y2 = { kernelName: Va, inputsToSave: ["x", "filter"], gradFunc: (e28, t, r) => {
    let [n, o] = t, s10 = { x: n, filter: o, dy: e28 }, i = { x: n, filter: o, dy: e28 };
    return { x: () => T.runKernel(Af, s10, r), filter: () => T.runKernel(Df, i, r) };
  } };
  var x2 = { kernelName: ui, outputsToSave: [true], gradFunc: (e28, t) => {
    let [r] = t, n = { dy: e28, y: r };
    return { x: () => T.runKernel(Kc, n) };
  } };
  var b2 = { kernelName: li, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t, n = F(Nr(ne(Xt(r))), 2 / Math.sqrt(Math.PI));
    return { x: () => F(e28, n) };
  } };
  var w2 = { kernelName: ci, outputsToSave: [true], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, r) };
  } };
  var v2 = { kernelName: Ga, inputsToSave: ["input"], gradFunc: (e28, t) => {
    let [r] = t;
    return { input: () => _(e28, r.shape) };
  } };
  var N2 = { kernelName: pi, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, Nr(r)) };
  } };
  var C2 = { kernelName: mi, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var S2 = { kernelName: fi, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = ut(e28, Z(n, "float32")), u = de(r.shape, o);
      return u.length > 0 ? _(ht(a, u), r.shape) : a;
    }, b: () => {
      let a = F(e28, Z(r, "float32")), u = de(n.shape, o);
      u.length > 0 && (a = _(ht(a, u), n.shape));
      let l = Xt(n);
      return ne(ut(a, Z(l, "float32")));
    } };
  } };
  var I2 = { kernelName: Wa, inputsToSave: ["x", "mean", "variance", "scale"], gradFunc: (e28, t, r) => {
    let { varianceEpsilon: n } = r, [o, s10, i, a] = t, u = a ?? $t(1), l = de(s10.shape, o.shape), c = [];
    if (s10.rank === 1) {
      for (let w = 0; w < o.shape.length - 1; ++w) c.push(o.shape[w]);
      c.push(1);
    }
    let p = xt(o, s10), m = F(e28, u), f = th(Y(i, $t(n))), h = F(F(F(f, f), f), $t(-0.5));
    return { x: () => s10.rank === 1 ? _(F(F(e28, Wr(_(f, [1, 1, 1, s10.shape[0]]), c)), u), o.shape) : _(F(F(e28, f), u), o.shape), mean: () => {
      let w = F(F(f, $t(-1)), m);
      return s10.rank === 1 && (w = ht(w, l)), _(w, s10.shape);
    }, variance: () => {
      let w = F(F(h, p), m);
      return s10.rank === 1 && (w = ht(w, l)), _(w, s10.shape);
    }, scale: () => {
      let w = F(p, f), N = F(e28, w);
      return s10.rank === 1 && (N = ht(N, l)), _(N, s10.shape);
    }, offset: () => {
      let w = e28;
      return s10.rank === 1 && (w = ht(w, l)), _(w, s10.shape);
    } };
  } };
  var E2 = { kernelName: Ua, inputsToSave: ["x", "indices"], gradFunc: (e28, t, r) => {
    let [n, o] = t, { axis: s10, batchDims: i } = r, a = dr(s10, n.shape)[0], u = (l, c, p) => () => {
      let m = l.shape, f = c.size, h = m.slice(0, a), d = h.length, g = m.slice(s10, m.length).slice(1), y = g.length, b = T2(0, d), v = T2(d + 1, d + 1 + y), w = k2([h, [f], g]), N = _(p, w), E = _(c, [f]), A = k2([[d], b, v]), D = qt(N, A), R = ox(D, E, l.shape[a]), L = qf(A);
      return R = qt(R, L), R;
    };
    if (i === 1) {
      let l = n.shape[0], c = n.split(l, 0);
      return { x: () => Xe(c.map((f, h) => u(f, o.slice(h, 1), e28.slice(h, 1))())).reshape(n.shape), indices: () => o };
    } else return { x: u(n, o, e28), indices: () => o };
  } };
  function T2(e28, t) {
    let r = [];
    for (let n = e28; n < t; ++n) r.push(n);
    return r;
  }
  function k2(e28) {
    let t = [];
    for (let r = 0; r < e28.length; ++r) for (let n = 0; n < e28[r].length; ++n) t.push(e28[r][n]);
    return t;
  }
  var A2 = { kernelName: hi, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t;
    return { a: () => Dt(r), b: () => Dt(n) };
  } };
  var D2 = { kernelName: ds, gradFunc: (e28) => ({ x: () => Z(e28, "float32") }) };
  var $2 = { kernelName: di, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var F2 = { kernelName: gi, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var _2 = { kernelName: yi, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var O2 = { kernelName: ja, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { alpha: o } = r, s10 = je(n, 0);
    return { x: () => Ce(s10, e28, F(e28, o)) };
  } };
  var R2 = { kernelName: bi, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, Y(r, 1)) };
  } };
  var P2 = { kernelName: xi, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, Z(r, "float32")) };
  } };
  var L2 = { kernelName: sT, inputsToSave: [], outputsToSave: [true], gradFunc: (e28, t, r) => {
    let [n] = t, { axis: o } = r;
    return { logits: () => {
      let i = Nr(n);
      return xt(e28, F(ht(e28, o, true), i));
    } };
  } };
  function XK(e28, t, r, n = 5, o = 1, s10 = 1, i = 0.5) {
    let a = { x: e28, y: t, dy: r }, u = { depthRadius: n, bias: o, alpha: s10, beta: i };
    return T.runKernel(Qc, a, u);
  }
  var M2 = k({ localResponseNormalizationBackprop_: XK });
  var z2 = { kernelName: Ha, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e28, t, r) => {
    let [n, o] = t, { depthRadius: s10, bias: i, alpha: a, beta: u } = r;
    return { x: () => M2(n, o, e28, s10, i, a, u) };
  } };
  function bx(e28, t, r, n) {
    return t.rank < r.rank && (t = _(t, Cs(t.shape, n))), e28.rank < r.rank && (e28 = _(e28, Cs(e28.shape, n))), { x: () => F(e28, Z(an(r, t), e28.dtype)) };
  }
  var w1 = { kernelName: Ka, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e28, t, r) => {
    let n = r, { reductionIndices: o } = n, s10 = t[0], i = t[1], a = dr(o, s10.shape), u = bx(e28, i, s10, a);
    return { x: () => u.x() };
  } };
  var B2 = { kernelName: wi, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t;
    return { a: () => F(e28, Z(vn(r, n), "float32")), b: () => F(e28, Z(El(r, n), "float32")) };
  } };
  function YK(e28, t, r, n, o, s10, i) {
    let a = S(e28, "dy", "maxPool3dGrad"), u = S(t, "input", "maxPool3dGrad"), l = S(r, "output", "maxPool3dGrad"), c = a, p = u, m = l, f = false;
    u.rank === 4 && (f = true, c = _(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]]), p = _(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), m = _(l, [1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]])), I(c.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`), I(p.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`), I(m.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`), be("maxPool3dGrad", s10, i);
    let h = { dy: c, input: p, output: m }, d = { filterSize: n, strides: o, pad: s10, dimRoundingMode: i }, g = T.runKernel(ep, h, d);
    return f ? _(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g;
  }
  var V2 = k({ maxPool3dGrad_: YK });
  var G2 = { kernelName: Xa, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e28, t, r) => {
    let [n, o] = t, { filterSize: s10, strides: i, pad: a, dimRoundingMode: u } = r;
    return { x: () => V2(e28, n, o, s10, i, a, u) };
  } };
  function JK(e28, t, r, n, o, s10, i) {
    let a = S(e28, "dy", "maxPoolGrad"), u = S(t, "input", "maxPoolGrad"), l = S(r, "output", "maxPoolGrad");
    I(u.rank === a.rank, () => `Rank of input (${u.rank}) does not match rank of dy (${a.rank})`), I(a.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`), I(u.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`), be("maxPoolGrad", s10, i);
    let c = { dy: a, input: u, output: l }, p = { filterSize: n, strides: o, pad: s10, dimRoundingMode: i };
    return T.runKernel(tp, c, p);
  }
  var W2 = k({ maxPoolGrad_: JK });
  var U2 = { kernelName: qa, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e28, t, r) => {
    let [n, o] = t, { filterSize: s10, strides: i, pad: a } = r;
    return { x: () => W2(e28, n, o, s10, i, a) };
  } };
  var j2 = { kernelName: Ya, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { axis: o } = r, s10 = dr(o, n.shape), a = RN(n.shape, s10)[1], u = ie(a);
    return { x: () => {
      let c = n.shape.slice();
      s10.forEach((f) => {
        c[f] = 1;
      });
      let p = _(e28, c);
      return ut(F(p, ln(n.shape, "float32")), u);
    } };
  } };
  var H2 = { kernelName: Ja, inputsToSave: ["x"], outputsToSave: [true], gradFunc: (e28, t, r) => {
    let n = r, { axis: o } = n, [s10, i] = t, a = dr(o, s10.shape), u = bx(e28, i, s10, a);
    return { x: () => u.x() };
  } };
  var K2 = { kernelName: vi, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t;
    return { a: () => F(e28, Z(bo(r, n), "float32")), b: () => F(e28, Z(je(r, n), "float32")) };
  } };
  var q2 = { kernelName: Za, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let n = t[0], { paddings: o } = r, s10 = o.map((i) => i[0]);
    return { x: () => Qt(e28, s10, n.shape) };
  } };
  var X2 = { kernelName: Ni, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = de(r.shape, o);
      return a.length > 0 ? _(ht(e28, a), r.shape) : e28;
    }, b: () => {
      let a = F(e28, ne(Yi(ut(r, n)))), u = de(n.shape, o);
      return u.length > 0 ? _(ht(a, u), n.shape) : a;
    } };
  } };
  var Y2 = { kernelName: Ci, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = F(e28, Z(n, "float32")), u = de(r.shape, o);
      return u.length > 0 ? _(ht(a, u), r.shape) : a;
    }, b: () => {
      let a = F(e28, Z(r, "float32")), u = de(n.shape, o);
      return u.length > 0 ? _(ht(a, u), n.shape) : a;
    } };
  } };
  var J2 = { kernelName: Qa, gradFunc: (e28) => ({ x: () => ne(e28) }) };
  var Z2 = { kernelName: eu, inputsToSave: ["indices"], gradFunc: (e28, t) => {
    let r = t[0];
    return { indices: () => Se(r.shape, "float32") };
  } };
  var Q2 = { kernelName: tu, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var tA = { kernelName: ru, saveAllInputs: true, gradFunc: (e28, t, r) => {
    let { axis: n } = r;
    return Zr(e28, n).map((s10) => () => s10);
  } };
  var v1 = { kernelName: nu, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let n = t[0], { paddings: o } = r, s10 = o.map((i) => i[0]);
    return { x: () => Qt(e28, s10, n.shape) };
  } };
  var eA = { kernelName: Si, inputsToSave: ["a", "b"], outputsToSave: [true], gradFunc: (e28, t) => {
    let [r, n, o] = t, s10 = r, i = n, a = Gt(s10.shape, i.shape);
    return { a: () => {
      let c = Z(i, "float32"), p = F(e28, F(c, wn(s10, xt(c, $t(1))))), m = de(s10.shape, a);
      return m.length > 0 && (p = ht(p, m)), _(p, s10.shape);
    }, b: () => {
      let c = je(s10, 0), p = Ce(c, un(s10), Dt(s10)), m = F(e28, F(o, p)), f = de(i.shape, a);
      return f.length > 0 && (m = ht(m, f)), _(m, i.shape);
    } };
  } };
  var rA = { kernelName: ou, inputsToSave: ["x", "alpha"], gradFunc: (e28, t) => {
    let [r, n] = t, o = je(r, 0);
    return { x: () => Ce(o, e28, F(e28, n)), alpha: () => {
      let s10 = Ce(o, Dt(e28), F(e28, r)), i = de(n.shape, e28.shape);
      return i.length > 0 && (s10 = ht(s10, i)), _(s10, n.shape);
    } };
  } };
  function ZK(e28, t, r) {
    let n = e28.shape.slice();
    n[r] = 1;
    let o = _(t, n), s10 = Hf(e28, r, true, false), i = Hf(e28, r, true, true), a = F(s10, i);
    return F(o, a);
  }
  function QK(e28, t, r) {
    let n = e28.shape.length, o = n - r.length, s10 = C.getAxesPermutation(r, n), i = e28;
    s10 != null && (i = qt(e28, s10));
    let a = i.shape.slice(), l = a.splice(n - r.length, r.length).reduce((m, f) => m * f, 1);
    a.push(l);
    let c = i.reshape(a), p = ZK(c, t, o);
    if (p = p.reshape(i.shape), s10 != null) {
      let m = C.getUndoAxesPermutation(s10);
      p = qt(p, m);
    }
    return p;
  }
  var nA = { kernelName: su, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { axis: o } = r, s10 = [];
    return o == null ? s10 = n.shape.map((i, a) => a) : typeof o == "number" ? s10 = [o] : s10 = o, { x: () => QK(n, e28, s10) };
  } };
  var oA = { kernelName: ai, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = ut(e28, Z(n, "float32")), u = de(r.shape, o);
      return u.length > 0 ? _(ht(a, u), r.shape) : a;
    }, b: () => {
      let a = F(e28, Z(r, "float32")), u = de(n.shape, o);
      u.length > 0 && (a = _(ht(a, u), n.shape));
      let l = Xt(n);
      return ne(ut(a, Z(l, "float32")));
    } };
  } };
  var sA = { kernelName: Ii, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, ne(Xt(r))) };
  } };
  var iA = { kernelName: ki, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t, n = F(bo(r, 6), Uo(r));
    return { x: () => F(e28, Z(n, "float32")) };
  } };
  var aA = { kernelName: Ti, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, Z(Uo(r), "float32")) };
  } };
  var uA = { kernelName: iu, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => _(e28, r.shape) };
  } };
  var lA = { kernelName: uu, inputsToSave: ["images"], gradFunc: (e28, t, r) => {
    let [n] = t, o = { dy: e28, images: n };
    return { images: () => T.runKernel(up, o, r) };
  } };
  var cA = { kernelName: au, inputsToSave: ["images"], gradFunc: (e28, t, r) => {
    let [n] = t, o = { dy: e28, images: n };
    return { images: () => T.runKernel(ap, o, r) };
  } };
  var pA = { kernelName: lu, gradFunc: (e28, t, r) => {
    let { dims: n } = r, o = dr(n, e28.shape);
    return { x: () => to(e28, o) };
  } };
  var mA = { kernelName: Ei, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var fA = { kernelName: Ai, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ne(ut(e28, F(wn(r, 1.5), 2))) };
  } };
  var hA = { kernelName: cu, inputsToSave: ["condition"], gradFunc: (e28, t) => {
    let [r] = t;
    return { condition: () => Z(Dt(r), "float32"), t: () => F(e28, Z(r, e28.dtype)), e: () => F(e28, Z($p(r), e28.dtype)) };
  } };
  var dA = { kernelName: Di, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => {
      let n = je(r, $t(0)), o = $t(g1), s10 = $t(y1), i = F(e28, s10), a = F(F(e28, o), Nr(Z(r, "float32")));
      return Ce(n, i, a);
    } };
  } };
  var gA = { kernelName: Oi, outputsToSave: [true], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, F(r, xt($t(1), r))) };
  } };
  var yA = { kernelName: _i, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var xA = { kernelName: $i, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(Il(Z(r, "float32")), e28) };
  } };
  var bA = { kernelName: Fi, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(jf(Z(r, "float32")), e28) };
  } };
  var wA = { kernelName: pu, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { begin: o, size: s10 } = r, i = n.shape, [a, u] = d1(n, o, s10), l = [];
    for (let c = 0; c < e28.rank; c++) l.push([a[c], i[c] - a[c] - u[c]]);
    return { x: () => Dl(e28, l) };
  } };
  var vA = { kernelName: du, outputsToSave: [true], gradFunc: (e28, t, r) => {
    let [n] = t, { dim: o } = r, s10 = true, i = F(e28, n);
    return { logits: () => xt(i, F(ht(i, [o], s10), n)) };
  } };
  var NA = { kernelName: Ri, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, xo(r)) };
  } };
  var N1 = { kernelName: fu, gradFunc: (e28, t, r) => {
    let { blockShape: n, paddings: o } = r;
    return { x: () => Tp(e28, n, o) };
  } };
  var C1 = { kernelName: hu, gradFunc: (e28, t, r) => {
    let { axis: n } = r;
    return { x: () => Ne(e28, n) };
  } };
  var CA = { kernelName: Pi, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, F(ge(Z(r, "float32")), 2)) };
  } };
  var SA = { kernelName: lp, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(e28, F(Z(r, "float32"), 2)) };
  } };
  var IA = { kernelName: Li, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = $t(2);
    return { a: () => F(e28, F(o, xt(r, n))), b: () => F(e28, F(o, xt(n, r))) };
  } };
  var TA = { kernelName: Vi, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var kA = { kernelName: Mi, inputsToSave: ["a", "b"], gradFunc: (e28, t) => {
    let [r, n] = t, o = Gt(r.shape, n.shape);
    return { a: () => {
      let a = e28, u = de(r.shape, o);
      return u.length > 0 && (a = ht(a, u)), _(a, r.shape);
    }, b: () => {
      let a = e28, u = de(n.shape, o);
      return u.length > 0 && (a = ht(a, u)), _(ne(a), n.shape);
    } };
  } };
  var EA = { kernelName: mu, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, o = n.shape.slice(), { axis: s10 } = r;
    dr(s10, n.shape).forEach((l) => {
      o[l] = 1;
    });
    let a = _(e28, o), u = F(a, ln(n.shape, "float32"));
    return { x: () => u };
  } };
  var AA = { kernelName: zi, inputsToSave: ["x"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => ut(e28, Xt(Il(r))) };
  } };
  var DA = { kernelName: Bi, outputsToSave: [true], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => F(xt($t(1), Xt(r)), e28) };
  } };
  var $A = { kernelName: gs, inputsToSave: ["x"], gradFunc: (e28, t, r) => {
    let [n] = t, { reps: o } = r;
    return { x: () => {
      let i = Dt(n);
      if (n.rank === 1) for (let a = 0; a < o[0]; ++a) i = Y(i, Qt(e28, [a * n.shape[0]], [n.shape[0]]));
      else if (n.rank === 2) for (let a = 0; a < o[0]; ++a) for (let u = 0; u < o[1]; ++u) i = Y(i, Qt(e28, [a * n.shape[0], u * n.shape[1]], [n.shape[0], n.shape[1]]));
      else if (n.rank === 3) for (let a = 0; a < o[0]; ++a) for (let u = 0; u < o[1]; ++u) for (let l = 0; l < o[2]; ++l) i = Y(i, Qt(e28, [a * n.shape[0], u * n.shape[1], l * n.shape[2]], [n.shape[0], n.shape[1], n.shape[2]]));
      else if (n.rank === 4) for (let a = 0; a < o[0]; ++a) for (let u = 0; u < o[1]; ++u) for (let l = 0; l < o[2]; ++l) for (let c = 0; c < o[3]; ++c) i = Y(i, Qt(e28, [a * n.shape[0], u * n.shape[1], l * n.shape[2], c * n.shape[3]], [n.shape[0], n.shape[1], n.shape[2], n.shape[3]]));
      else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);
      return i;
    } };
  } };
  var FA = { kernelName: ys, gradFunc: (e28, t, r) => {
    let n = r, { perm: o } = n, s10 = qf(o);
    return { x: () => qt(e28, s10) };
  } };
  var _A = { kernelName: gu, gradFunc: (e28, t, r) => {
    let n = r, { axis: o } = n;
    return { value: () => Xe(e28, o) };
  } };
  var OA = { kernelName: yu, inputsToSave: ["segmentIds"], gradFunc: (e28, t) => {
    let [r] = t;
    return { x: () => t5(e28, r) };
  } };
  function t5(e28, t) {
    let r = Pn(t, Dt(t)), n = Tl(e28, r), o = vn(t, $t(0, "int32")), s10 = n.rank - o.rank;
    for (let a = 0; a < s10; ++a) o = or(o, a + 1);
    o = Jr(o, ln(n.shape, "bool"));
    let i = Dt(n);
    return Ce(o, n, i);
  }
  var RA = { kernelName: xu, gradFunc: (e28) => ({ x: () => Dt(e28) }) };
  var e52 = [xx, BE, VE, GE, WE, UE, jE, HE, KE, qE, XE, YE, ZE, t2, e22, r2, n2, o2, s23, i2, a2, u2, c2, l2, m2, f2, h2, d2, g2, y2, oA, x2, b2, w2, v2, N2, S2, C2, I2, E2, A2, D2, $2, F2, _2, O2, R2, P2, L2, z2, w1, w1, B2, G2, U2, j2, H2, K2, q2, X2, Y2, J2, Z2, Q2, tA, v1, v1, eA, rA, nA, sA, iA, aA, uA, lA, cA, pA, mA, fA, hA, dA, gA, yA, xA, bA, wA, vA, NA, N1, N1, C1, C1, CA, IA, SA, TA, kA, EA, AA, DA, $A, FA, _A, OA, RA];
  for (let e28 of e52) uT(e28);
  $().prototype.abs = function() {
    return this.throwIfDisposed(), cr(this);
  };
  $().prototype.acos = function() {
    return this.throwIfDisposed(), hN(this);
  };
  $().prototype.acosh = function() {
    return this.throwIfDisposed(), dN(this);
  };
  $().prototype.add = function(e28) {
    return this.throwIfDisposed(), Y(this, e28);
  };
  $().prototype.all = function(e28, t) {
    return this.throwIfDisposed(), Bf(this, e28, t);
  };
  $().prototype.any = function(e28, t) {
    return this.throwIfDisposed(), Sp(this, e28, t);
  };
  $().prototype.argMax = function(e28) {
    return this.throwIfDisposed(), ji(this, e28);
  };
  $().prototype.argMin = function(e28) {
    return this.throwIfDisposed(), ak(this, e28);
  };
  $().prototype.asScalar = function() {
    return this.throwIfDisposed(), I(this.size === 1, () => "The array must have only 1 element."), _(this, []);
  };
  $().prototype.asType = function(e28) {
    return this.throwIfDisposed(), Z(this, e28);
  };
  $().prototype.as1D = function() {
    return this.throwIfDisposed(), _(this, [this.size]);
  };
  $().prototype.as2D = function(e28, t) {
    return this.throwIfDisposed(), _(this, [e28, t]);
  };
  $().prototype.as3D = function(e28, t, r) {
    return this.throwIfDisposed(), _(this, [e28, t, r]);
  };
  $().prototype.as4D = function(e28, t, r, n) {
    return this.throwIfDisposed(), _(this, [e28, t, r, n]);
  };
  $().prototype.as5D = function(e28, t, r, n, o) {
    return this.throwIfDisposed(), _(this, [e28, t, r, n, o]);
  };
  $().prototype.asin = function() {
    return this.throwIfDisposed(), gN(this);
  };
  $().prototype.asinh = function() {
    return this.throwIfDisposed(), yN(this);
  };
  $().prototype.atan = function() {
    return this.throwIfDisposed(), xN(this);
  };
  $().prototype.atan2 = function(e28) {
    return this.throwIfDisposed(), uk(this, e28);
  };
  $().prototype.atanh = function() {
    return this.throwIfDisposed(), bN(this);
  };
  $().prototype.avgPool = function(e28, t, r, n) {
    return this.throwIfDisposed(), Cl(this, e28, t, r, n);
  };
  $().prototype.batchToSpaceND = function(e28, t) {
    return this.throwIfDisposed(), Tp(this, e28, t);
  };
  $().prototype.batchNorm = function(e28, t, r, n, o) {
    return this.throwIfDisposed(), Iu(this, e28, t, r, n, o);
  };
  $().prototype.broadcastTo = function(e28) {
    return this.throwIfDisposed(), Hi(this, e28);
  };
  $().prototype.cast = function(e28) {
    return this.throwIfDisposed(), Z(this, e28);
  };
  $().prototype.ceil = function() {
    return this.throwIfDisposed(), kN(this);
  };
  $().prototype.clipByValue = function(e28, t) {
    return this.throwIfDisposed(), Fr(this, e28, t);
  };
  $().prototype.concat = function(e28, t) {
    return this.throwIfDisposed(), e28 instanceof ee && (e28 = [e28]), Ne([this, ...e28], t);
  };
  $().prototype.conv1d = function(e28, t, r, n, o, s10) {
    return this.throwIfDisposed(), Wf(this, e28, t, r, n, o, s10);
  };
  $().prototype.conv2dTranspose = function(e28, t, r, n, o) {
    return this.throwIfDisposed(), Uf(this, e28, t, r, n, o);
  };
  $().prototype.conv2d = function(e28, t, r, n, o, s10) {
    return this.throwIfDisposed(), On(this, e28, t, r, n, o, s10);
  };
  $().prototype.cos = function() {
    return this.throwIfDisposed(), Il(this);
  };
  $().prototype.cosh = function() {
    return this.throwIfDisposed(), jf(this);
  };
  $().prototype.cumprod = function(e28, t, r) {
    return this.throwIfDisposed(), Hf(this, e28, t, r);
  };
  $().prototype.cumsum = function(e28, t, r) {
    return this.throwIfDisposed(), Yy(this, e28, t, r);
  };
  $().prototype.depthToSpace = function(e28, t) {
    return this.throwIfDisposed(), fk(this, e28, t);
  };
  $().prototype.depthwiseConv2d = function(e28, t, r, n, o, s10) {
    return this.throwIfDisposed(), qi(this, e28, t, r, n, o, s10);
  };
  $().prototype.dilation2d = function(e28, t, r, n, o) {
    return this.throwIfDisposed(), hk(this, e28, t, r, n, o);
  };
  $().prototype.divNoNan = function(e28) {
    return this.throwIfDisposed(), gk(this, e28);
  };
  $().prototype.div = function(e28) {
    return this.throwIfDisposed(), ut(this, e28);
  };
  $().prototype.dot = function(e28) {
    return this.throwIfDisposed(), yk(this, e28);
  };
  $().prototype.elu = function() {
    return this.throwIfDisposed(), Xi(this);
  };
  $().prototype.equal = function(e28) {
    return this.throwIfDisposed(), an(this, e28);
  };
  $().prototype.erf = function() {
    return this.throwIfDisposed(), Kf(this);
  };
  $().prototype.euclideanNorm = function(e28, t) {
    return this.throwIfDisposed(), wk(this, e28, t);
  };
  $().prototype.exp = function() {
    return this.throwIfDisposed(), Nr(this);
  };
  $().prototype.expandDims = function(e28) {
    return this.throwIfDisposed(), or(this, e28);
  };
  $().prototype.expm1 = function() {
    return this.throwIfDisposed(), MN(this);
  };
  $().prototype.fft = function() {
    return this.throwIfDisposed(), ah(this);
  };
  $().prototype.flatten = function() {
    return this.throwIfDisposed(), _(this, [this.size]);
  };
  $().prototype.floor = function() {
    return this.throwIfDisposed(), Yi(this);
  };
  $().prototype.floorDiv = function(e28) {
    return this.throwIfDisposed(), qy(this, e28);
  };
  $().prototype.gather = function(e28, t, r) {
    return this.throwIfDisposed(), Tl(this, e28, t, r);
  };
  $().prototype.greaterEqual = function(e28) {
    return this.throwIfDisposed(), vn(this, e28);
  };
  $().prototype.greater = function(e28) {
    return this.throwIfDisposed(), je(this, e28);
  };
  $().prototype.ifft = function() {
    return this.throwIfDisposed(), Lp(this);
  };
  $().prototype.irfft = function() {
    return this.throwIfDisposed(), t1(this);
  };
  $().prototype.isFinite = function() {
    return this.throwIfDisposed(), zN(this);
  };
  $().prototype.isInf = function() {
    return this.throwIfDisposed(), BN(this);
  };
  $().prototype.isNaN = function() {
    return this.throwIfDisposed(), VN(this);
  };
  $().prototype.leakyRelu = function(e28) {
    return this.throwIfDisposed(), kl(this, e28);
  };
  $().prototype.lessEqual = function(e28) {
    return this.throwIfDisposed(), bo(this, e28);
  };
  $().prototype.less = function(e28) {
    return this.throwIfDisposed(), El(this, e28);
  };
  $().prototype.localResponseNormalization = function(e28, t, r, n) {
    return this.throwIfDisposed(), vk(this, e28, t, r, n);
  };
  $().prototype.logSigmoid = function() {
    return this.throwIfDisposed(), WN(this);
  };
  $().prototype.logSoftmax = function(e28) {
    return this.throwIfDisposed(), Yf(this, e28);
  };
  $().prototype.logSumExp = function(e28, t) {
    return this.throwIfDisposed(), Jf(this, e28, t);
  };
  $().prototype.log = function() {
    return this.throwIfDisposed(), un(this);
  };
  $().prototype.log1p = function() {
    return this.throwIfDisposed(), Xf(this);
  };
  $().prototype.logicalAnd = function(e28) {
    return this.throwIfDisposed(), Jr(this, e28);
  };
  $().prototype.logicalNot = function() {
    return this.throwIfDisposed(), $p(this);
  };
  $().prototype.logicalOr = function(e28) {
    return this.throwIfDisposed(), Zy(this, e28);
  };
  $().prototype.logicalXor = function(e28) {
    return this.throwIfDisposed(), Nk(this, e28);
  };
  $().prototype.matMul = function(e28, t, r) {
    return this.throwIfDisposed(), ae(this, e28, t, r);
  };
  $().prototype.maxPool = function(e28, t, r, n) {
    return this.throwIfDisposed(), Al(this, e28, t, r, n);
  };
  $().prototype.max = function(e28, t) {
    return this.throwIfDisposed(), _r(this, e28, t);
  };
  $().prototype.maximum = function(e28) {
    return this.throwIfDisposed(), Pn(this, e28);
  };
  $().prototype.mean = function(e28, t) {
    return this.throwIfDisposed(), ke(this, e28, t);
  };
  $().prototype.min = function(e28, t) {
    return this.throwIfDisposed(), Tu(this, e28, t);
  };
  $().prototype.minimum = function(e28) {
    return this.throwIfDisposed(), Is(this, e28);
  };
  $().prototype.mirrorPad = function(e28, t) {
    return this.throwIfDisposed(), Ck(this, e28, t);
  };
  $().prototype.mod = function(e28) {
    return this.throwIfDisposed(), Sk(this, e28);
  };
  $().prototype.mul = function(e28) {
    return this.throwIfDisposed(), F(this, e28);
  };
  $().prototype.neg = function() {
    return this.throwIfDisposed(), ne(this);
  };
  $().prototype.norm = function(e28, t, r) {
    return this.throwIfDisposed(), ku(this, e28, t, r);
  };
  $().prototype.notEqual = function(e28) {
    return this.throwIfDisposed(), Eu(this, e28);
  };
  $().prototype.oneHot = function(e28, t = 1, r = 0) {
    return this.throwIfDisposed(), _p(this, e28, t, r);
  };
  $().prototype.onesLike = function() {
    return this.throwIfDisposed(), Cr(this);
  };
  $().prototype.pad = function(e28, t) {
    return this.throwIfDisposed(), Dl(this, e28, t);
  };
  $().prototype.pool = function(e28, t, r, n, o, s10) {
    return this.throwIfDisposed(), Ik(this, e28, t, r, n, o, s10);
  };
  $().prototype.pow = function(e28) {
    return this.throwIfDisposed(), wn(this, e28);
  };
  $().prototype.prelu = function(e28) {
    return this.throwIfDisposed(), $l(this, e28);
  };
  $().prototype.prod = function(e28, t) {
    return this.throwIfDisposed(), Tk(this, e28, t);
  };
  $().prototype.reciprocal = function() {
    return this.throwIfDisposed(), ZN(this);
  };
  $().prototype.relu = function() {
    return this.throwIfDisposed(), Ln(this);
  };
  $().prototype.relu6 = function() {
    return this.throwIfDisposed(), rx(this);
  };
  $().prototype.reshapeAs = function(e28) {
    return this.throwIfDisposed(), _(this, e28.shape);
  };
  $().prototype.reshape = function(e28) {
    return this.throwIfDisposed(), _(this, e28);
  };
  $().prototype.resizeBilinear = function(e28, t, r) {
    return this.throwIfDisposed(), cx(this, e28, t, r);
  };
  $().prototype.resizeNearestNeighbor = function(e28, t, r) {
    return this.throwIfDisposed(), px(this, e28, t, r);
  };
  $().prototype.reverse = function(e28) {
    return this.throwIfDisposed(), to(this, e28);
  };
  $().prototype.rfft = function() {
    return this.throwIfDisposed(), e1(this);
  };
  $().prototype.round = function() {
    return this.throwIfDisposed(), Qf(this);
  };
  $().prototype.rsqrt = function() {
    return this.throwIfDisposed(), th(this);
  };
  $().prototype.selu = function() {
    return this.throwIfDisposed(), eh(this);
  };
  $().prototype.separableConv2d = function(e28, t, r, n, o, s10) {
    return this.throwIfDisposed(), rh(this, e28, t, r, n, o, s10);
  };
  $().prototype.sigmoid = function() {
    return this.throwIfDisposed(), xo(this);
  };
  $().prototype.sign = function() {
    return this.throwIfDisposed(), QN(this);
  };
  $().prototype.sin = function() {
    return this.throwIfDisposed(), nh(this);
  };
  $().prototype.sinh = function() {
    return this.throwIfDisposed(), oh(this);
  };
  $().prototype.slice = function(e28, t) {
    return this.throwIfDisposed(), Qt(this, e28, t);
  };
  $().prototype.softmax = function(e28) {
    return this.throwIfDisposed(), Ol(this, e28);
  };
  $().prototype.softplus = function() {
    return this.throwIfDisposed(), Ss(this);
  };
  $().prototype.spaceToBatchND = function(e28, t) {
    return this.throwIfDisposed(), Op(this, e28, t);
  };
  $().prototype.split = function(e28, t) {
    return this.throwIfDisposed(), xr(this, e28, t);
  };
  $().prototype.sqrt = function() {
    return this.throwIfDisposed(), ge(this);
  };
  $().prototype.square = function() {
    return this.throwIfDisposed(), Xt(this);
  };
  $().prototype.squaredDifference = function(e28) {
    return this.throwIfDisposed(), Wk(this, e28);
  };
  $().prototype.squeeze = function(e28) {
    return this.throwIfDisposed(), Wo(this, e28);
  };
  $().prototype.stack = function(e28, t) {
    this.throwIfDisposed();
    let r = e28 instanceof ee ? [this, e28] : [this, ...e28];
    return Xe(r, t);
  };
  $().prototype.step = function(e28) {
    return this.throwIfDisposed(), Uo(this, e28);
  };
  $().prototype.stridedSlice = function(e28, t, r, n, o, s10, i, a) {
    return this.throwIfDisposed(), r1(this, e28, t, r, n, o, s10, i, a);
  };
  $().prototype.sub = function(e28) {
    return this.throwIfDisposed(), xt(this, e28);
  };
  $().prototype.sum = function(e28, t) {
    return this.throwIfDisposed(), ht(this, e28, t);
  };
  $().prototype.tan = function() {
    return this.throwIfDisposed(), n1(this);
  };
  $().prototype.tanh = function() {
    return this.throwIfDisposed(), Sl(this);
  };
  $().prototype.tile = function(e28) {
    return this.throwIfDisposed(), Wr(this, e28);
  };
  $().prototype.toBool = function() {
    return this.throwIfDisposed(), Z(this, "bool");
  };
  $().prototype.toFloat = function() {
    return this.throwIfDisposed(), Z(this, "float32");
  };
  $().prototype.toInt = function() {
    return this.throwIfDisposed(), Z(this, "int32");
  };
  $().prototype.topk = function(e28, t) {
    return this.throwIfDisposed(), jk(this, e28, t);
  };
  $().prototype.transpose = function(e28) {
    return this.throwIfDisposed(), qt(this, e28);
  };
  $().prototype.unique = function(e28) {
    return this.throwIfDisposed(), Hk(this, e28);
  };
  $().prototype.unsortedSegmentSum = function(e28, t) {
    return this.throwIfDisposed(), ox(this, e28, t);
  };
  $().prototype.unstack = function(e28) {
    return this.throwIfDisposed(), Zr(this, e28);
  };
  $().prototype.where = function(e28, t) {
    return this.throwIfDisposed(), Ce(e28, this, t);
  };
  $().prototype.zerosLike = function() {
    return this.throwIfDisposed(), Dt(this);
  };
  var eo = class e8 extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e8.prototype);
    }
  };
  var cn = class e9 extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e9.prototype);
    }
  };
  var P = class e10 extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e10.prototype);
    }
  };
  var Rt = class e11 extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e11.prototype);
    }
  };
  var wx = class e12 extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e12.prototype);
    }
  };
  var hh = class {
    constructor(t) {
      this.maxEntries = t || 100, this.cache = /* @__PURE__ */ new Map();
    }
    get(t) {
      let r;
      return this.cache.has(t) && (r = this.cache.get(t), this.cache.delete(t), this.cache.set(t, r)), r;
    }
    put(t, r) {
      if (this.cache.has(t)) this.cache.delete(t);
      else if (this.cache.size >= this.maxEntries) {
        let n = this.cache.keys().next().value;
        this.cache.delete(n);
      }
      this.cache.set(t, r);
    }
    getMaxEntries() {
      return this.maxEntries;
    }
    setMaxEntries(t) {
      if (t < 0) throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);
      if (this.maxEntries > t) for (let r = 0; r < this.maxEntries - t; r++) {
        let n = this.cache.keys().next().value;
        this.cache.delete(n);
      }
      this.maxEntries = t;
    }
  };
  function No(e28, t) {
    if (Array.isArray(e28)) {
      let r = [];
      for (let n = 0; n < t; n++) r = r.concat(e28);
      return r;
    } else {
      let r = new Array(t);
      return r.fill(e28), r;
    }
  }
  function ro(e28, t) {
    if (!e28) throw new wx(t);
  }
  function I1(e28, t) {
    let r = 0;
    for (let n of e28) n === t && r++;
    return r;
  }
  function Ir(e28) {
    return e28.length === 1 ? e28[0] : e28;
  }
  function ue(e28) {
    return Array.isArray(e28) ? e28 : [e28];
  }
  function Co(e28) {
    let r = e28.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    return r[0] !== "_" ? r : "private" + r;
  }
  function Qi(e28) {
    return e28.length <= 1 || e28.indexOf("_") === -1 ? e28 : e28.replace(/[_]+(\w|$)/g, (t, r) => r.toUpperCase());
  }
  var vo = {};
  function Hp(e28) {
    if (e28 == null) return null;
    let t = {};
    return t.className = e28.getClassName(), t.config = e28.getConfig(), t;
  }
  function S1(e28) {
    if (!(e28 == null || typeof e28 != "object")) if (Array.isArray(e28)) e28.forEach((t) => S1(t));
    else {
      let t = Object.keys(e28);
      for (let r of t) {
        let n = e28[r];
        n != null && typeof n == "object" && (!Array.isArray(n) && n.type === "ndarray" && typeof n.value == "number" ? e28[r] = n.value : S1(n));
      }
    }
  }
  function ks(e28, t = {}, r = {}, n = "object", o = false) {
    if (typeof e28 == "string") {
      let s10 = e28, i;
      if (s10 in r) i = r[s10];
      else if (s10 in vo) i = vo[s10];
      else if (i = t[s10], i == null) throw new P(`Unknown ${n}: ${e28}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      return i;
    } else {
      let s10 = e28;
      if (s10.className == null || s10.config == null) throw new P(`${n}: Improper config format: ${JSON.stringify(s10)}.
'className' and 'config' must set.`);
      let i = s10.className, a, u;
      if (i in r ? [a, u] = r[i] : i in vo ? [a, u] = vo.className : i in t && ([a, u] = t[i]), a == null) throw new P(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      if (u != null) {
        let l = {};
        for (let f of Object.keys(vo)) l[f] = vo[f];
        for (let f of Object.keys(r)) l[f] = r[f];
        let c = s10.config;
        c.customObjects = l;
        let p = Object.assign({}, vo);
        for (let f of Object.keys(r)) vo[f] = r[f];
        S1(s10.config);
        let m = u(a, s10.config, r, o);
        return vo = Object.assign({}, p), m;
      } else {
        let l = Object.assign({}, vo);
        for (let p of Object.keys(r)) vo[p] = r[p];
        let c = new a(s10.config);
        return vo = Object.assign({}, l), c;
      }
    }
  }
  function r5(e28, t) {
    return e28 < t ? -1 : e28 > t ? 1 : 0;
  }
  function dh(e28, t) {
    return -1 * r5(e28, t);
  }
  function So(e28) {
    if (e28 == null) return e28;
    let t = [];
    for (let r of e28) t.indexOf(r) === -1 && t.push(r);
    return t;
  }
  function PA(e28) {
    if (e28 == null) throw new P(`Invalid value in obj: ${JSON.stringify(e28)}`);
    for (let t in e28) if (e28.hasOwnProperty(t)) return false;
    return true;
  }
  function Es(e28, t, r) {
    if (r != null && e28.indexOf(r) < 0) throw new P(`${r} is not a valid ${t}.  Valid values are ${e28} or null/undefined.`);
  }
  function vx(e28, t, r = 0, n = 1 / 0) {
    return ro(r >= 0), ro(n >= r), Array.isArray(e28) && e28.length >= r && e28.length <= n && e28.every((o) => typeof o === t);
  }
  function Je(e28, t) {
    Array.isArray(e28) ? (x.assert(e28.length > 0, () => `${t} is unexpectedly an empty array.`), e28.forEach((r, n) => Je(r, `element ${n + 1} of ${t}`))) : x.assert(Number.isInteger(e28) && e28 > 0, () => `Expected ${t} to be a positive integer, but got ${LA(e28)}.`);
  }
  function LA(e28) {
    return e28 === null ? "null" : Array.isArray(e28) ? "[" + e28.map((t) => LA(t)).join(",") + "]" : typeof e28 == "string" ? `"${e28}"` : `${e28}`;
  }
  function MA(e28, t, r) {
    let n = r != null ? r() : x.now(), o;
    return (...i) => {
      let a = r != null ? r() : x.now();
      return a - n < t || (n = a, o = e28(...i)), o;
    };
  }
  function Nx(e28) {
    return e28 === "relu" ? "relu" : e28 === "linear" ? "linear" : e28 === "elu" ? "elu" : null;
  }
  var n5 = 0;
  function Sx() {
    return n5++;
  }
  var Cx = {};
  function Du(e28 = "") {
    return e28 in Cx || (Cx[e28] = 0), Cx[e28] += 1, e28 + Cx[e28].toString();
  }
  var zA = ["channelsFirst", "channelsLast"];
  var BA = ["nearest", "bilinear"];
  var VA = ["valid", "same", "causal"];
  var GA = ["max", "avg"];
  var WA = ["sum", "mul", "concat", "ave"];
  var Kp = /* @__PURE__ */ new Map();
  function Ee(e28) {
    Es(zA, "DataFormat", e28);
  }
  function jA(e28) {
    Es(BA, "InterpolationFormat", e28);
  }
  function pn(e28) {
    Es(VA, "PaddingMode", e28);
  }
  function T1(e28) {
    Es(GA, "PoolMode", e28);
  }
  var gh = [];
  var UA = "/";
  function Ho(e28, t) {
    gh.push(e28);
    try {
      let r = t();
      return gh.pop(), r;
    } catch (r) {
      throw gh.pop(), r;
    }
  }
  function o5() {
    return gh.length === 0 ? "" : gh.join(UA) + UA;
  }
  function Ix(e28) {
    if (!HA(e28)) throw new Error("Not a valid tensor name: '" + e28 + "'");
    return o5() + e28;
  }
  function Tx(e28) {
    if (!HA(e28)) throw new Error("Not a valid tensor name: '" + e28 + "'");
    Kp.has(e28) || Kp.set(e28, 0);
    let t = Kp.get(e28);
    if (Kp.set(e28, Kp.get(e28) + 1), t > 0) {
      let r = `${e28}_${t}`;
      return Kp.set(r, 1), r;
    } else return e28;
  }
  var s5 = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
  function HA(e28) {
    return !!e28.match(s5);
  }
  function KA(e28) {
    return e28 === parseInt(e28.toString(), 10);
  }
  function Io(e28, t, r) {
    t == null && (t = 0), r == null && (r = e28.length);
    let n = 1;
    for (let o = t; o < r; ++o) n *= e28[o];
    return n;
  }
  function Vl(e28) {
    if (e28.length === 0) return Number.NaN;
    let t = Number.POSITIVE_INFINITY;
    for (let r = 0; r < e28.length; r++) {
      let n = e28[r];
      n < t && (t = n);
    }
    return t;
  }
  function Ko(e28) {
    if (e28.length === 0) return Number.NaN;
    let t = Number.NEGATIVE_INFINITY;
    for (let r = 0; r < e28.length; r++) {
      let n = e28[r];
      n > t && (t = n);
    }
    return t;
  }
  function mn(e28, t) {
    if (t < e28) throw new P(`end (${t}) < begin (${e28}) is forbidden.`);
    let r = [];
    for (let n = e28; n < t; ++n) r.push(n);
    return r;
  }
  var k1;
  function pr() {
    return k1 == null && (k1 = Gy().epsilon()), k1;
  }
  function fn() {
    return "channelsLast";
  }
  function Qr(e28, t) {
    return Z(e28, t);
  }
  function ea(e28, t = -1) {
    let r = e28.shape.slice();
    return t < 0 && (t = r.length + t + 1), r.splice(t, 0, 1), _(e28, r);
  }
  function qA(e28, t) {
    return M(() => {
      if (e28.shape.length !== 2) throw new P(`repeat() expects a rank-2 tensor, but received a rank-${e28.shape.length} tensor.`);
      let r = ea(e28, 1);
      return Ex(r, [1, t, 1]);
    });
  }
  function XA(e28) {
    let t = [Io(e28.shape)];
    return _(e28, t);
  }
  function YA(e28) {
    if (e28.rank <= 1) throw new P(`batchFlatten requires a minimum rank of 2. Got rank: ${e28.rank}.`);
    let t = [e28.shape[0], Io(e28.shape, 1)];
    return _(e28, t);
  }
  function ta(e28, t, r) {
    return M(() => {
      switch (e28.rank) {
        case 1:
          return sh(e28, t, r);
        case 2:
          return nx(e28, [t, 0], [r, e28.shape[1]]);
        case 3:
          return ih(e28, [t, 0, 0], [r, e28.shape[1], e28.shape[2]]);
        case 4:
          return Pp(e28, [t, 0, 0, 0], [r, e28.shape[1], e28.shape[2], e28.shape[3]]);
        case 5:
          return Qt(e28, [t, 0, 0, 0, 0], [r, e28.shape[1], e28.shape[2], e28.shape[3], e28.shape[4]]);
        case 6:
          return Qt(e28, [t, 0, 0, 0, 0, 0], [r, e28.shape[1], e28.shape[2], e28.shape[3], e28.shape[4], e28.shape[5]]);
        default:
          throw new P(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e28.rank}`);
      }
    });
  }
  function E1(e28, t, r) {
    return M(() => {
      switch (e28.rank) {
        case 1:
          return sh(e28, t, r);
        case 2:
          return nx(e28, [0, t], [e28.shape[0], r]);
        case 3:
          return ih(e28, [0, 0, t], [e28.shape[0], e28.shape[1], r]);
        case 4:
          return Pp(e28, [0, 0, 0, t], [e28.shape[0], e28.shape[1], e28.shape[2], r]);
        default:
          throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${e28.rank}`);
      }
    });
  }
  function yh(e28, t, r, n) {
    return M(() => {
      switch (e28.rank) {
        case 1:
          return sh(e28, t, r);
        case 2:
          switch (n) {
            case 1:
              return ta(e28, t, r);
            case 2:
              return E1(e28, t, r);
            default:
              throw new P(`The axis is not within the rank of the tensor ${n}`);
          }
        case 3:
          switch (n) {
            case 1:
              return ta(e28, t, r);
            case 2:
              return ih(e28, [0, t, 0], [e28.shape[0], r, e28.shape[2]]);
            case 3:
              return E1(e28, t, r);
            default:
              throw new P(`The axis is not within the rank of the tensor ${n}`);
          }
        case 4:
          switch (n) {
            case 1:
              return ta(e28, t, r);
            case 2:
              return Pp(e28, [0, t, 0, 0], [e28.shape[0], r, e28.shape[2], e28.shape[3]]);
            case 3:
              return Pp(e28, [0, 0, t, 0], [e28.shape[0], e28.shape[1], r, e28.shape[3]]);
            case 4:
              return E1(e28, t, r);
            default:
              throw new P(`The axis is not within the rank of the tensor ${n}`);
          }
        default:
          throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${e28.rank}`);
      }
    });
  }
  function qp(e28, t = -1) {
    let r;
    return t < 0 && (r = e28[0].rank, r !== 0 ? t = r : t = 0), t === e28[0].rank && (t = -1), Ne(e28, t);
  }
  function D1(e28, t) {
    switch (e28.rank) {
      case 1:
        return EN([e28, t]);
      case 2:
        return AN([e28, t], 0);
      case 3:
        return DN([e28, t], 0);
      case 4:
        return $N([e28, t], 0);
      default:
        throw new P(`concatAlongFirstAxis() received an unsupported tensor rank: ${e28.rank}`);
    }
  }
  function Ex(e28, t) {
    if (Array.isArray(t) || (t = [t]), e28.rank !== t.length) throw new P(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e28.rank})`);
    return Wr(e28, t);
  }
  function Xp(e28, t = 0, r = 1, n, o) {
    return ex(e28, t, r, n, o);
  }
  function To(e28, t, r, n) {
    if (e28.rank < 2 || t.rank < 2) throw new Rt(`dot requires both inputs to be rank >= 2 but got x shape = ${e28.shape} and y shape = ${t.shape}`);
    if (t.rank >= 3) {
      let o = e28.shape.slice(-1)[0], s10 = t.shape.slice(-2)[0];
      if (o !== s10) throw new Rt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e28.shape} and  y shape = ${t.shape}`);
    }
    if (e28.rank === 2 && t.rank === 2) return zl.matMul({ a: e28, b: t, transposeA: false, transposeB: false, bias: n ? A1(e28.rank, n, fn()) : null, activation: r });
    {
      let o = e28.shape.slice(), s10 = o.pop();
      e28 = _(e28, [-1, s10]);
      let i = t.shape.slice(), a = i.pop(), u = i.pop(), l = [...i, a], c = Array.from({ length: t.rank }, (h, d) => d === 0 ? t.rank - 2 : d <= t.rank - 2 ? d - 1 : d);
      t = _(qt(t, c), [u, -1]);
      let p = [...o, ...l];
      return _(zl.matMul({ a: e28, b: t, transposeA: false, transposeB: false, bias: n ? A1(e28.rank, n, fn()) : null, activation: r }), p);
    }
  }
  function Ax(e28, t, r) {
    return M(() => (Array.isArray(t) ? t = sr(t, "int32") : t = Z(t, "int32"), Tl(e28, t, r)));
  }
  function Gl(e28) {
    return F(e28, e28);
  }
  function A1(e28, t, r) {
    let n = t.shape;
    if (t.rank !== 1 && t.rank !== e28) throw new P(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e28}`);
    if (e28 === 5) {
      if (r === "channelsFirst") return n.length === 1 ? _(t, [1, n[0], 1, 1, 1]) : _(t, [1, n[3], n[0], n[1], n[2]]);
      if (r === "channelsLast") return n.length === 1 ? _(t, [1, 1, 1, 1, n[0]]) : _(t, [1].concat(n));
    } else if (e28 === 4) {
      if (r === "channelsFirst") return n.length === 1 ? _(t, [1, n[0], 1, 1]) : _(t, [1, n[2], n[0], n[1]]);
      if (r === "channelsLast") return n.length === 1 ? _(t, [1, 1, 1, n[0]]) : _(t, [1].concat(n));
    } else if (e28 === 3) {
      if (r === "channelsFirst") return n.length === 1 ? _(t, [1, n[0], 1]) : _(t, [1, n[1], n[0]]);
      if (r === "channelsLast") return n.length === 1 ? _(t, [1, 1, n[0]]) : _(t, [1].concat(n));
    } else if (e28 < 3) return t;
    throw new P(`Unsupported input rank by biasAdd: ${t.rank}`);
  }
  function hn(e28, t, r) {
    return M(() => (r == null && (r = fn()), Ee(r), Y(e28, A1(e28.rank, t, r))));
  }
  function JA(e28, t = 1) {
    if (t !== 1) throw new Rt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
    return Xi(e28);
  }
  function ZA(e28) {
    return M(() => ut(e28, Y(cr(e28), 1)));
  }
  function Dx(e28, t, r, n) {
    return M(() => Xk(e28, t, r, n));
  }
  function QA(e28) {
    return M(() => {
      let t = Y(0.5, F(0.2, e28));
      return Fr(t, 0, 1);
    });
  }
  function $u(e28, t, r = false) {
    return r ? e28() : t();
  }
  var tD = ["fanIn", "fanOut", "fanAvg"];
  var eD = ["normal", "uniform", "truncatedNormal"];
  function i5(e28) {
    Es(tD, "FanMode", e28);
  }
  function a5(e28) {
    Es(eD, "Distribution", e28);
  }
  var dn = class extends K.Serializable {
    fromConfigUsesCustomObjects() {
      return false;
    }
    getConfig() {
      return {};
    }
  };
  var xh = class extends dn {
    apply(t, r) {
      return Se(t, r);
    }
  };
  xh.className = "Zeros";
  K.registerClass(xh);
  var Wl = class extends dn {
    apply(t, r) {
      return ln(t, r);
    }
  };
  Wl.className = "Ones";
  K.registerClass(Wl);
  var bh = class extends dn {
    constructor(t) {
      if (super(), typeof t != "object") throw new P(`Expected argument of type ConstantConfig but got ${t}`);
      if (t.value === void 0) throw new P(`config must have value set but got ${t}`);
      this.value = t.value;
    }
    apply(t, r) {
      return M(() => F($t(this.value), ln(t, r)));
    }
    getConfig() {
      return { value: this.value };
    }
  };
  bh.className = "Constant";
  K.registerClass(bh);
  var wh = class extends dn {
    constructor(t) {
      super(), this.DEFAULT_MINVAL = -0.05, this.DEFAULT_MAXVAL = 0.05, this.minval = t.minval || this.DEFAULT_MINVAL, this.maxval = t.maxval || this.DEFAULT_MAXVAL, this.seed = t.seed;
    }
    apply(t, r) {
      return Go(t, this.minval, this.maxval, r, this.seed);
    }
    getConfig() {
      return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    }
  };
  wh.className = "RandomUniform";
  K.registerClass(wh);
  var vh = class extends dn {
    constructor(t) {
      super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = t.mean || this.DEFAULT_MEAN, this.stddev = t.stddev || this.DEFAULT_STDDEV, this.seed = t.seed;
    }
    apply(t, r) {
      if (r = r || "float32", r !== "float32" && r !== "int32") throw new Rt(`randomNormal does not support dType ${r}.`);
      return Xp(t, this.mean, this.stddev, r, this.seed);
    }
    getConfig() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }
  };
  vh.className = "RandomNormal";
  K.registerClass(vh);
  var Nh = class extends dn {
    constructor(t) {
      super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = t.mean || this.DEFAULT_MEAN, this.stddev = t.stddev || this.DEFAULT_STDDEV, this.seed = t.seed;
    }
    apply(t, r) {
      if (r = r || "float32", r !== "float32" && r !== "int32") throw new Rt(`truncatedNormal does not support dType ${r}.`);
      return lh(t, this.mean, this.stddev, r, this.seed);
    }
    getConfig() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }
  };
  Nh.className = "TruncatedNormal";
  K.registerClass(Nh);
  var Ch = class extends dn {
    constructor(t) {
      super(), this.gain = t.gain != null ? t.gain : 1;
    }
    apply(t, r) {
      return M(() => {
        if (t.length !== 2 || t[0] !== t[1]) throw new P("Identity matrix initializer can only be used for 2D square matrices.");
        return F(this.gain, Ap(t[0]));
      });
    }
    getConfig() {
      return { gain: this.gain };
    }
  };
  Ch.className = "Identity";
  K.registerClass(Ch);
  function u5(e28, t = "channelsLast") {
    let r, n;
    if (Ee(t), e28.length === 2) r = e28[0], n = e28[1];
    else if ([3, 4, 5].indexOf(e28.length) !== -1) {
      if (t === "channelsFirst") {
        let o = Io(e28, 2);
        r = e28[1] * o, n = e28[0] * o;
      } else if (t === "channelsLast") {
        let o = Io(e28, 0, e28.length - 2);
        r = e28[e28.length - 2] * o, n = e28[e28.length - 1] * o;
      }
    } else {
      let o = Io(e28);
      r = Math.sqrt(o), n = Math.sqrt(o);
    }
    return [r, n];
  }
  var tn = class extends dn {
    constructor(t) {
      if (super(), t.scale < 0) throw new P(`scale must be a positive float. Got: ${t.scale}`);
      this.scale = t.scale == null ? 1 : t.scale, this.mode = t.mode == null ? "fanIn" : t.mode, i5(this.mode), this.distribution = t.distribution == null ? "normal" : t.distribution, a5(this.distribution), this.seed = t.seed;
    }
    apply(t, r) {
      let n = u5(t), o = n[0], s10 = n[1], i = this.scale;
      if (this.mode === "fanIn" ? i /= Math.max(1, o) : this.mode === "fanOut" ? i /= Math.max(1, s10) : i /= Math.max(1, (o + s10) / 2), this.distribution === "normal") {
        let a = Math.sqrt(i);
        if (r = r || "float32", r !== "float32" && r !== "int32") throw new Rt(`${this.getClassName()} does not support dType ${r}.`);
        return lh(t, 0, a, r, this.seed);
      } else {
        let a = Math.sqrt(3 * i);
        return Go(t, -a, a, r, this.seed);
      }
    }
    getConfig() {
      return { scale: this.scale, mode: this.mode, distribution: this.distribution, seed: this.seed };
    }
  };
  tn.className = "VarianceScaling";
  K.registerClass(tn);
  var Yp = class extends tn {
    constructor(t) {
      super({ scale: 1, mode: "fanAvg", distribution: "uniform", seed: t == null ? null : t.seed });
    }
    getClassName() {
      return tn.className;
    }
  };
  Yp.className = "GlorotUniform";
  K.registerClass(Yp);
  var Jp = class extends tn {
    constructor(t) {
      super({ scale: 1, mode: "fanAvg", distribution: "normal", seed: t == null ? null : t.seed });
    }
    getClassName() {
      return tn.className;
    }
  };
  Jp.className = "GlorotNormal";
  K.registerClass(Jp);
  var Zp = class extends tn {
    constructor(t) {
      super({ scale: 2, mode: "fanIn", distribution: "normal", seed: t == null ? null : t.seed });
    }
    getClassName() {
      return tn.className;
    }
  };
  Zp.className = "HeNormal";
  K.registerClass(Zp);
  var Qp = class extends tn {
    constructor(t) {
      super({ scale: 2, mode: "fanIn", distribution: "uniform", seed: t == null ? null : t.seed });
    }
    getClassName() {
      return tn.className;
    }
  };
  Qp.className = "HeUniform";
  K.registerClass(Qp);
  var tm = class extends tn {
    constructor(t) {
      super({ scale: 1, mode: "fanIn", distribution: "normal", seed: t == null ? null : t.seed });
    }
    getClassName() {
      return tn.className;
    }
  };
  tm.className = "LeCunNormal";
  K.registerClass(tm);
  var em = class extends tn {
    constructor(t) {
      super({ scale: 1, mode: "fanIn", distribution: "uniform", seed: t == null ? null : t.seed });
    }
    getClassName() {
      return tn.className;
    }
  };
  em.className = "LeCunUniform";
  K.registerClass(em);
  var Sh = class extends dn {
    constructor(t) {
      super(), this.DEFAULT_GAIN = 1, this.ELEMENTS_WARN_SLOW = 2e3, this.gain = t.gain == null ? this.DEFAULT_GAIN : t.gain, this.seed = t.seed;
    }
    apply(t, r) {
      return M(() => {
        if (t.length < 2) throw new Rt("Shape must be at least 2D.");
        if (r !== "int32" && r !== "float32" && r !== void 0) throw new TypeError(`Unsupported data type ${r}.`);
        r = r;
        let n = x.sizeFromShape(t.slice(0, -1)), o = t[t.length - 1], s10 = n * o;
        s10 > this.ELEMENTS_WARN_SLOW && console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s10}) elements: Slowness may result.`);
        let i = [Math.max(o, n), Math.min(o, n)], a = Xp(i, 0, 1, r, this.seed), u = xE.qr(a, false), l = u[0], p = u[1].flatten().stridedSlice([0], [Math.min(o, n) * Math.min(o, n)], [Math.min(o, n) + 1]);
        return l = F(l, p.sign()), n < o && (l = l.transpose()), F($t(this.gain), l.reshape(t));
      });
    }
    getConfig() {
      return { gain: this.gain, seed: this.seed };
    }
  };
  Sh.className = "Orthogonal";
  K.registerClass(Sh);
  var rD = { constant: "Constant", glorotNormal: "GlorotNormal", glorotUniform: "GlorotUniform", heNormal: "HeNormal", heUniform: "HeUniform", identity: "Identity", leCunNormal: "LeCunNormal", leCunUniform: "LeCunUniform", ones: "Ones", orthogonal: "Orthogonal", randomNormal: "RandomNormal", randomUniform: "RandomUniform", truncatedNormal: "TruncatedNormal", varianceScaling: "VarianceScaling", zeros: "Zeros" };
  function nD(e28, t = {}) {
    return ks(e28, K.SerializationMap.getMap().classNameMap, t, "initializer");
  }
  function we(e28) {
    return Hp(e28);
  }
  function he(e28) {
    if (typeof e28 == "string") {
      let t = e28 in rD ? rD[e28] : e28;
      if (t === "GlorotNormal") return new Jp();
      if (t === "GlorotUniform") return new Yp();
      if (t === "HeNormal") return new Zp();
      if (t === "HeUniform") return new Qp();
      if (t === "LeCunNormal") return new tm();
      if (t === "LeCunUniform") return new em();
      {
        let r = {};
        return r.className = t, r.config = {}, nD(r);
      }
    } else return e28 instanceof dn ? e28 : nD(e28);
  }
  function $x(e28) {
    return Array.isArray(e28) && Array.isArray(e28[0]);
  }
  function rm(e28) {
    return e28.length === 0 ? [] : Array.isArray(e28[0]) ? e28 : [e28];
  }
  function Ft(e28) {
    let t;
    if (Array.isArray(e28)) {
      if (e28.length !== 1) throw new P(`Expected Tensor length to be 1; got ${e28.length}`);
      t = e28[0];
    } else t = e28;
    return t;
  }
  function jt(e28) {
    if (Array.isArray(e28) && Array.isArray(e28[0])) {
      if (e28.length === 1) return e28 = e28, e28[0];
      throw new P(`Expected exactly 1 Shape; got ${e28.length}`);
    } else return e28;
  }
  function nm(e28) {
    let t = 0;
    for (let r of e28) r.shape.length === 0 ? t += 1 : t += r.shape.reduce((n, o) => n * o);
    return t;
  }
  var sD = "Variable";
  var Ih = class {
    constructor(t, r = "float32", n = sD, o = true, s10 = null) {
      this.dtype = r ?? "float32", this.shape = t.shape, this.id = Sx(), n = n ?? sD, this.originalName = Ix(n), this.name = Tx(this.originalName), this.trainable_ = o, this.constraint = s10, this.val = o1(t, this.trainable_, this.name, this.dtype);
    }
    read() {
      return this.assertNotDisposed(), this.val;
    }
    write(t) {
      return this.assertNotDisposed(), c5(this.val, t), this.val.id !== t.id && (this.val.assign(t), this.constraint != null && this.val.assign(this.constraint.apply(this.val))), this;
    }
    dispose() {
      this.assertNotDisposed(), this.val.dispose();
    }
    assertNotDisposed() {
      if (this.val.isDisposed) throw new Error(`LayersVariable ${this.name} is already disposed.`);
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(t) {
      this.trainable_ = t, this.val.trainable = t;
    }
  };
  function c5(e28, t) {
    if (e28.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e28.shape) + " vs. " + JSON.stringify(t.shape));
  }
  function Th(e28) {
    return e28.map((t) => t.read());
  }
  function om(e28) {
    e28.forEach((t) => {
      t[0].write(t[1]);
    });
  }
  var ye = class {
    constructor(t) {
      this.dtype = t.dtype, this.shape = t.shape, t.shape != null ? this.ndim = t.shape.length : this.ndim = t.ndim, this.maxNDim = t.maxNDim, this.minNDim = t.minNDim, this.axes = t.axes || {};
    }
  };
  var en = class {
    constructor(t, r, n, o, s10, i, a) {
      this.dtype = t, this.shape = r, this.sourceLayer = n, this.inputs = o, this.callArgs = s10, this.outputTensorIndex = a, this.id = Sx(), i != null && (this.originalName = Ix(i), this.name = Tx(this.originalName)), this.rank = r.length;
    }
  };
  var p5 = 0;
  var ra = class {
    constructor(t, r) {
      this.callArgs = r, this.id = p5++, this.outboundLayer = t.outboundLayer, this.inboundLayers = t.inboundLayers, this.nodeIndices = t.nodeIndices, this.tensorIndices = t.tensorIndices, this.inputTensors = t.inputTensors, this.outputTensors = t.outputTensors, this.inputMasks = t.inputMasks, this.outputMasks = t.outputMasks, this.inputShapes = t.inputShapes, this.outputShapes = t.outputShapes;
      for (let n of t.inboundLayers) n?.outboundNodes.push(this);
      t.outboundLayer.inboundNodes.push(this);
    }
    getConfig() {
      let t = [];
      for (let r of this.inboundLayers) r != null ? t.push(r.name) : t.push(null);
      return { outboundLayer: this.outboundLayer ? this.outboundLayer.name : null, inboundLayers: t, nodeIndices: this.nodeIndices, tensorIndices: this.tensorIndices };
    }
  };
  var m5 = 0;
  var Pt = class extends K.Serializable {
    constructor(t = {}) {
      super(), this._callHook = null, this._addedWeightNames = [], this._stateful = false, this.id = m5++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = false, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = false, this.inboundNodes = [], this.outboundNodes = [];
      let r = t.name;
      if (!r) {
        let n = this.getClassName();
        r = Co(n) + "_" + Du(n);
      }
      if (this.name = r, this.trainable_ = t.trainable == null ? true : t.trainable, t.inputShape != null || t.batchInputShape != null) {
        let n;
        if (t.batchInputShape != null) n = t.batchInputShape;
        else if (t.inputShape != null) {
          let s10 = null;
          t.batchSize != null && (s10 = t.batchSize), n = [s10].concat(t.inputShape);
        }
        this.batchInputShape = n;
        let o = t.dtype;
        o == null && (o = t.inputDType), o == null && (o = "float32"), this.dtype = o;
      }
      t.weights != null ? this.initialWeights = t.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = false;
    }
    static nodeKey(t, r) {
      return t.name + "_ib-" + r.toString();
    }
    getNodeAtIndex(t, r) {
      if (this.inboundNodes.length === 0) throw new cn(`The layer has never been called and thus has no defined ${r}.`);
      if (this.inboundNodes.length <= t) throw new P(`Asked to get ${r} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
      return this.inboundNodes[t];
    }
    getInputAt(t) {
      return Ir(this.getNodeAtIndex(t, "input").inputTensors);
    }
    getOutputAt(t) {
      return Ir(this.getNodeAtIndex(t, "output").outputTensors);
    }
    get input() {
      if (this.inboundNodes.length > 1) throw new eo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
      if (this.inboundNodes.length === 0) throw new eo(`Layer ${this.name} is not connected, no input to return.`);
      return Ir(this.getNodeAtIndex(0, "input").inputTensors);
    }
    get output() {
      if (this.inboundNodes.length === 0) throw new eo(`Layer ${this.name} has no inbound nodes.`);
      if (this.inboundNodes.length > 1) throw new eo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
      return Ir(this.getNodeAtIndex(0, "output").outputTensors);
    }
    get losses() {
      return this._losses;
    }
    calculateLosses() {
      return this.losses.map((t) => t());
    }
    get updates() {
      return this._updates;
    }
    get built() {
      return this._built;
    }
    set built(t) {
      this._built = t;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(t) {
      this._trainableWeights.forEach((r) => r.trainable = t), this.trainable_ = t;
    }
    get trainableWeights() {
      return this.trainable_ ? this._trainableWeights.filter((t) => t.trainable) : [];
    }
    set trainableWeights(t) {
      this._trainableWeights = t;
    }
    get nonTrainableWeights() {
      return this.trainable ? this._trainableWeights.filter((t) => !t.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    }
    set nonTrainableWeights(t) {
      this._nonTrainableWeights = t;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    get stateful() {
      return this._stateful;
    }
    resetStates() {
      if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }
    assertInputCompatibility(t) {
      let r = ue(t);
      if (this.inputSpec == null || this.inputSpec.length === 0) return;
      let n = ue(this.inputSpec);
      if (r.length !== n.length) throw new P(`Layer ${this.name} expects ${n.length} inputs, but it received ${r.length} input tensors. Input received: ${t}`);
      for (let o = 0; o < r.length; o++) {
        let s10 = r[o], i = n[o];
        if (i == null) continue;
        let a = s10.rank;
        if (i.ndim != null && a !== i.ndim) throw new P(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);
        if (i.maxNDim != null && a > i.maxNDim) throw new P(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);
        if (i.minNDim != null && a < i.minNDim) throw new P(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);
        if (i.dtype != null && s10.dtype !== i.dtype) throw new P(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s10.dtype}.`);
        if (i.axes) {
          let u = s10.shape;
          for (let l in i.axes) {
            let c = Number(l), p = i.axes[l], m = c >= 0 ? u[c] : u[u.length + c];
            if (p != null && [p, null].indexOf(m) === -1) throw new P(`Input ${o} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${p} but got shape ${u}.`);
          }
        }
        if (i.shape != null) for (let u = 0; u < i.shape.length; ++u) {
          let l = i.shape[u], c = s10.shape[u];
          if (l != null && c != null && l !== c) throw new P(`Input ${o} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s10.shape}.`);
        }
      }
    }
    call(t, r) {
      return t;
    }
    invokeCallHook(t, r) {
      this._callHook != null && this._callHook(t, r);
    }
    setCallHook(t) {
      this._callHook = t;
    }
    clearCallHook() {
      this._callHook = null;
    }
    apply(t, r) {
      r = r || {}, this.assertNotDisposed();
      let n = ue(t), o = d5(t), s10 = g5(t);
      if (o === s10) throw new P("Arguments to apply() must be all SymbolicTensors or all Tensors");
      return Ho(this.name, () => {
        if (!this.built) {
          this.assertInputCompatibility(t);
          let i = [];
          for (let a of ue(t)) i.push(a.shape);
          this.build(Ir(i)), this.built = true, this.initialWeights && this.setWeights(this.initialWeights), this._refCount === null && s10 && (this._refCount = 1);
        }
        if (this.assertInputCompatibility(t), s10) {
          let i = this.call(t, r);
          this.supportsMasking && this.setMaskMetadata(t, i);
          let a = ue(i), u = [];
          for (let l of a) n.indexOf(l) !== -1 && (l = l.clone()), u.push(l);
          if (i = Ir(u), this.activityRegularizer != null) throw new Rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return i;
        } else {
          let i = f5(t), a = this.computeOutputShape(i), u, l = h5(t);
          if (this.warnOnIncompatibleInputShape(Array.isArray(t) ? i[0] : i), a != null && a.length > 0 && Array.isArray(a[0]) ? u = a.map((c, p) => new en(l, c, this, ue(t), r, this.name, p)) : u = new en(l, a, this, ue(t), r, this.name), this.addInboundNode(t, u, null, null, i, a, r), this._refCount++, this.activityRegularizer != null) throw new Rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return u;
        }
      });
    }
    warnOnIncompatibleInputShape(t) {
      if (this.batchInputShape != null) if (t.length !== this.batchInputShape.length) console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      else {
        let r = false;
        this.batchInputShape.forEach((n, o) => {
          n != null && t[o] != null && t[o] !== n && (r = true);
        }), r && console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
    }
    get outputShape() {
      if (this.inboundNodes == null || this.inboundNodes.length === 0) throw new eo(`The layer ${this.name} has never been called and thus has no defined output shape.`);
      let t = [];
      for (let r of this.inboundNodes) {
        let n = JSON.stringify(r.outputShapes);
        t.indexOf(n) === -1 && t.push(n);
      }
      if (t.length === 1) {
        let r = this.inboundNodes[0].outputShapes;
        return Array.isArray(r) && Array.isArray(r[0]) && r.length === 1 ? r[0] : r;
      } else throw new eo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
    }
    countParams() {
      if (!this.built) throw new cn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
      return nm(this.weights);
    }
    build(t) {
      this.built = true;
    }
    getWeights(t = false) {
      return Th(t ? this.trainableWeights : this.weights);
    }
    setWeights(t) {
      M(() => {
        let r = this.weights;
        if (r.length !== t.length) throw new P(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${r.length} weights. Provided weights: ${t}...`);
        if (r.length === 0) return;
        let n = [], o = Th(r);
        for (let s10 = 0; s10 < o.length; ++s10) {
          let i = o[s10], a = r[s10], u = t[s10];
          if (!x.arraysEqual(i.shape, u.shape)) throw new P(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);
          n.push([a, u]);
        }
        om(n);
      });
    }
    addWeight(t, r, n, o, s10, i, a, u) {
      if (this._addedWeightNames.indexOf(t) !== -1) throw new P(`Duplicate weight name ${t} for layer ${this.name}`);
      this._addedWeightNames.push(t), n == null && (n = "float32"), this.fastWeightInitDuringBuild && (o = u != null ? u() : he("zeros"));
      let l = o.apply(r, n), c = new Ih(l, n, t, i, a);
      return l.dispose(), s10 != null && this.addLoss(() => s10.apply(c.read())), i == null && (i = true), i ? this._trainableWeights.push(c) : this._nonTrainableWeights.push(c), c;
    }
    setFastWeightInitDuringBuild(t) {
      this.fastWeightInitDuringBuild = t;
    }
    addLoss(t) {
      t == null || Array.isArray(t) && t.length === 0 || (t = ue(t), this._losses !== void 0 && this._losses !== null && this.losses.push(...t));
    }
    computeOutputShape(t) {
      return t;
    }
    computeMask(t, r) {
      if (!this.supportsMasking) {
        if (r != null) if (Array.isArray(r)) r.forEach((n) => {
          if (n != null) throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        });
        else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        return null;
      }
      return r;
    }
    setMaskMetadata(t, r, n) {
      if (!this.supportsMasking) return;
      let o = this.computeMask(t, n), s10 = ue(r), i = ue(o);
      if (s10.length !== i.length) throw new Error(`${this.name} outputs ${s10.length} tensors but ${s10.length} masks for those tensors`);
      for (let a = 0; a < s10.length; a++) s10[a].kerasMask = i[a];
    }
    addInboundNode(t, r, n, o, s10, i, a = null) {
      let u = ue(t);
      r = ue(r), n = ue(n), o = ue(o), s10 = rm(s10), i = rm(i);
      let l = [], c = [], p = [];
      for (let m of u) l.push(m.sourceLayer), c.push(m.nodeIndex), p.push(m.tensorIndex);
      new ra({ outboundLayer: this, inboundLayers: l, nodeIndices: c, tensorIndices: p, inputTensors: u, outputTensors: r, inputMasks: n, outputMasks: o, inputShapes: s10, outputShapes: i }, a);
      for (let m = 0; m < r.length; m++) r[m].sourceLayer = this, r[m].nodeIndex = this.inboundNodes.length - 1, r[m].tensorIndex = m;
    }
    getConfig() {
      let t = { name: this.name, trainable: this.trainable };
      return this.batchInputShape != null && (t.batchInputShape = this.batchInputShape), this.dtype != null && (t.dtype = this.dtype), t;
    }
    disposeWeights() {
      return this.weights.forEach((t) => t.dispose()), this.weights.length;
    }
    assertNotDisposed() {
      if (this._refCount === 0) throw new Error(`Layer '${this.name}' is already disposed.`);
    }
    dispose() {
      if (!this.built) throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
      if (this._refCount === null) throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
      this.assertNotDisposed();
      let t = 0;
      return --this._refCount === 0 && (t = this.disposeWeights()), { refCountAfterDispose: this._refCount, numDisposedVariables: t };
    }
  };
  function f5(e28) {
    e28 = ue(e28);
    let t = [];
    for (let r of e28) t.push(r.shape);
    return Ir(t);
  }
  function h5(e28) {
    return "float32";
  }
  function $1(e28, t, r) {
    if ((t == null || r != null && r > 0) && (t = e28.sourceLayer, r = e28.nodeIndex), t.inboundNodes.length === 0) return [e28];
    {
      let n = t.inboundNodes[r];
      if (n.inboundLayers.length === 0) return n.inputTensors;
      {
        let o = [];
        for (let s10 = 0; s10 < n.inboundLayers.length; s10++) {
          let i = n.inputTensors[s10], a = n.inboundLayers[s10], u = n.nodeIndices[s10], l = $1(i, a, u);
          for (let c of l) o.indexOf(c) === -1 && o.push(c);
        }
        return o;
      }
    }
  }
  function d5(e28) {
    let t = true;
    for (let r of ue(e28)) if (!(r instanceof en)) {
      t = false;
      break;
    }
    return t;
  }
  function g5(e28) {
    let t = true;
    for (let r of ue(e28)) if (r instanceof en) {
      t = false;
      break;
    }
    return t;
  }
  var As = class extends Pt {
    constructor(t) {
      if (super({ dtype: t.dtype, name: t.name != null ? t.name : Du("input").toString() }), t.batchSize == null && (t.batchSize = null), t.sparse == null && (t.sparse = false), this.trainable = false, this.built = true, this.sparse = t.sparse, t.inputShape != null && t.batchInputShape != null) throw new P("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      let r = t.batchInputShape;
      if (r == null) {
        if (t.inputShape == null) throw new P("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        r = [t.batchSize].concat(t.inputShape);
      } else if (t.batchSize != null) throw new P("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      let n = t.dtype || "float32";
      this.batchInputShape = r, this.dtype = n, this.inputSpec = [{ shape: r }];
      let o = new en(this.dtype, this.batchInputShape, this, [], {}, this.name);
      o.nodeIndex = 0, o.tensorIndex = 0, new ra({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: [o], outputTensors: [o], inputMasks: [null], outputMasks: [null], inputShapes: [r], outputShapes: [r] });
    }
    apply(t, r) {
      throw new P(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
    }
    dispose() {
      return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
    }
    getConfig() {
      return { batchInputShape: this.batchInputShape, dtype: this.dtype, sparse: this.sparse, name: this.name };
    }
  };
  As.className = "InputLayer";
  K.registerClass(As);
  function F1(e28) {
    if (e28.batchShape == null && e28.shape == null) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    if (e28.batchShape != null && e28.shape != null) throw new P("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    let t = e28.batchShape;
    e28.shape != null && t == null && (t = [null].concat(e28.shape));
    let r = e28.dtype;
    return r == null && (r = "float32"), new As({ batchInputShape: t, name: e28.name, dtype: r, sparse: e28.sparse }).inboundNodes[0].outputTensors[0];
  }
  function y5(e28, t) {
    if (e28.dtype == null || e28.dtype === t.dtype) return t;
    try {
      return Z(t, e28.dtype);
    } catch {
      throw new P(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e28.name}' (${e28.dtype}).`);
    }
  }
  var Ds = class e13 {
    constructor(t) {
      if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof e13) for (let r in t.id2Value) this.id2Value[r] = t.id2Value[r], r in t.id2Mask && (this.id2Mask[r] = t.id2Mask[r]);
      else {
        if (t == null) return;
        for (let r of t) this.add(r.key, r.value);
      }
    }
    add(t, r, n) {
      if (this.id2Value[t.id] == null) this.id2Value[t.id] = y5(t, r), this.name2Id[t.name] = t.id, n != null && (this.id2Mask[t.id] = n);
      else throw new P(`Duplicate key: name=${t.name}, id=${t.id}`);
      return this;
    }
    addFeed(t) {
      this.add(t.key, t.value);
    }
    hasKey(t) {
      return this.id2Value[t.id] != null;
    }
    names() {
      return Object.keys(this.name2Id);
    }
    getValue(t) {
      if (t instanceof en) {
        if (this.id2Value[t.id] == null) throw new P(`Nonexistent key: ${t.name}`);
        return this.id2Value[t.id];
      } else {
        let r = this.name2Id[t];
        if (r == null) throw new P(`Feed dict has no SymbolicTensor name: ${t}`);
        return this.id2Value[r];
      }
    }
    getMask(t) {
      if (t instanceof en) {
        if (this.id2Value[t.id] == null) throw new P(`Nonexistent key: ${t.name}`);
        return this.id2Mask[t.id];
      } else {
        let r = this.name2Id[t];
        if (r == null) throw new P(`Feed dict has no SymbolicTensor name: ${t}`);
        return this.id2Mask[r];
      }
    }
    disposeMasks() {
      this.id2Mask != null && Mt(this.id2Mask);
    }
  };
  var Fx = new hh();
  var _x = new hh();
  function aD(e28) {
    Fx?.setMaxEntries(e28), _x?.setMaxEntries(e28);
  }
  function Ul(e28, t, r, n) {
    let o = r == null ? false : r.training, s10 = Array.isArray(e28), i = s10 ? e28 : [e28], a = i.map((h) => h.name), u = [], l = t.names();
    for (let h of a) l.indexOf(h) !== -1 ? u.push(t.getValue(h)) : u.push(null);
    n != null && (n.maxNumTensors = -1 / 0, n.minNumTensors = 1 / 0);
    let c = a.join(",") + "|" + t.names().sort().join(","), p = Fx.get(c), m;
    if (p == null) {
      let h = x5(i, t);
      p = h.sorted, m = h.recipientCounts, Fx.put(c, p), _x.put(c, m);
    }
    m = {}, o || Object.assign(m, _x.get(c));
    let f = new Ds(t);
    for (let h = 0; h < p.length; ++h) {
      if (n != null) {
        let R = Mf().numTensors;
        R > n.maxNumTensors && (n.maxNumTensors = R), R < n.minNumTensors && (n.minNumTensors = R);
      }
      let d = p[h], g = d.sourceLayer;
      if (g instanceof As) continue;
      let y = [], b = [], v = [], w = false;
      for (let R of d.inputs) {
        let L = f.getValue(R), G = f.getMask(R);
        y.push(L), b.push(G), G != null && (w = true), o || (m[R.name]--, m[R.name] === 0 && !t.hasKey(R) && a.indexOf(R.name) === -1 && !L.isDisposed && R.sourceLayer.stateful !== true && v.push(L));
      }
      w && (r = r || {}, r.mask = b[0]);
      let N = ue(g.apply(y, r)), E = null;
      g.supportsMasking && (E = g.computeMask(y, b));
      let A = w5(d), D = Array.isArray(A) ? A : [A];
      for (let R = 0; R < D.length; ++R) {
        f.hasKey(D[R]) || f.add(D[R], N[R], Array.isArray(E) ? E[0] : E);
        let L = a.indexOf(D[R].name);
        L !== -1 && (u[L] = N[R]);
      }
      o || Mt(v);
    }
    return f.disposeMasks(), s10 ? u : u[0];
  }
  function x5(e28, t) {
    x.assert(e28 != null && e28.length > 0, () => "Expected at least one fetch, got none");
    let r = [], n = {};
    if (e28.length === 1) {
      let o = iD(e28[0], t);
      r = o.sorted, n = o.recipientMap;
    } else {
      let o = /* @__PURE__ */ new Set();
      for (let s10 of e28) {
        let { sorted: i, recipientMap: a } = iD(s10, t);
        for (let u of i) o.has(u.name) || (r.push(u), o.add(u.name));
        for (let u in a) n[u] == null && (n[u] = /* @__PURE__ */ new Set()), a[u].forEach((l) => n[u].add(l));
      }
    }
    return { sorted: r, recipientCounts: b5(n) };
  }
  function b5(e28) {
    let t = {};
    for (let r in e28) t[r] = e28[r].size;
    return t;
  }
  function iD(e28, t) {
    let r = /* @__PURE__ */ new Set(), n = [], o = {};
    for (let a of t.names()) r.add(a);
    let s10 = [], i = [];
    for (s10.push(e28); s10.length > 0; ) {
      let a = s10[s10.length - 1];
      if (r.has(a.name)) {
        s10.pop();
        continue;
      }
      let u = i[i.length - 1] === s10.length - 1;
      if (a.inputs.length === 0 || u) s10.pop(), n.push(a), r.add(a.name), u && i.pop();
      else {
        i.push(s10.length - 1);
        for (let l of a.inputs) o[l.name] == null && (o[l.name] = /* @__PURE__ */ new Set()), o[l.name].add(a.name), !r.has(l.name) && s10.push(l);
      }
    }
    return { sorted: n, recipientMap: o };
  }
  function w5(e28) {
    let t;
    if (e28.sourceLayer.inboundNodes.length === 1) t = e28.sourceLayer.output;
    else {
      let r = null;
      for (let n = 0; n < e28.sourceLayer.inboundNodes.length; ++n) for (let o of e28.sourceLayer.inboundNodes[n].outputTensors) if (o.id === e28.id) {
        r = n;
        break;
      }
      t = e28.sourceLayer.getOutputAt(r);
    }
    return t;
  }
  var v5 = z();
  v5.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", () => 100, aD);
  function _1(e28, t) {
    return M(() => ge(ht(F(e28, e28), t, true)));
  }
  var jl = class extends K.Serializable {
    getConfig() {
      return {};
    }
  };
  var kh = class extends jl {
    constructor(t) {
      super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = t.maxValue != null ? t.maxValue : this.defaultMaxValue, this.axis = t.axis != null ? t.axis : this.defaultAxis;
    }
    apply(t) {
      return M(() => {
        let r = _1(t, this.axis), n = Fr(r, 0, this.maxValue);
        return F(t, ut(n, Y(pr(), r)));
      });
    }
    getConfig() {
      return { maxValue: this.maxValue, axis: this.axis };
    }
  };
  kh.className = "MaxNorm";
  K.registerClass(kh);
  var Eh = class extends jl {
    constructor(t) {
      super(), this.defaultAxis = 0, this.axis = t.axis != null ? t.axis : this.defaultAxis;
    }
    apply(t) {
      return M(() => ut(t, Y(pr(), _1(t, this.axis))));
    }
    getConfig() {
      return { axis: this.axis };
    }
  };
  Eh.className = "UnitNorm";
  K.registerClass(Eh);
  var Ah = class extends jl {
    apply(t) {
      return Ln(t);
    }
  };
  Ah.className = "NonNeg";
  K.registerClass(Ah);
  var Dh = class extends jl {
    constructor(t) {
      super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = t.minValue != null ? t.minValue : this.defaultMinValue, this.maxValue = t.maxValue != null ? t.maxValue : this.defaultMaxValue, this.rate = t.rate != null ? t.rate : this.defaultRate, this.axis = t.axis != null ? t.axis : this.defaultAxis;
    }
    apply(t) {
      return M(() => {
        let r = _1(t, this.axis), n = Y(F(this.rate, Fr(r, this.minValue, this.maxValue)), F(1 - this.rate, r));
        return F(t, ut(n, Y(pr(), r)));
      });
    }
    getConfig() {
      return { minValue: this.minValue, maxValue: this.maxValue, rate: this.rate, axis: this.axis };
    }
  };
  Dh.className = "MinMaxNorm";
  K.registerClass(Dh);
  var uD = { maxNorm: "MaxNorm", minMaxNorm: "MinMaxNorm", nonNeg: "NonNeg", unitNorm: "UnitNorm" };
  function Oe(e28) {
    return Hp(e28);
  }
  function lD(e28, t = {}) {
    return ks(e28, K.SerializationMap.getMap().classNameMap, t, "constraint");
  }
  function Re(e28) {
    if (e28 == null) return null;
    if (typeof e28 == "string") {
      let r = { className: e28 in uD ? uD[e28] : e28, config: {} };
      return lD(r);
    } else return e28 instanceof jl ? e28 : lD(e28);
  }
  async function na(e28) {
    if (e28 == null) return;
    let t = [], r = [], n = [];
    for (let o in e28) {
      let s10 = e28[o];
      if (typeof s10 != "number") {
        let i = s10;
        t.push(i.data()), r.push(o), n.push(i);
      }
    }
    if (t.length > 0) {
      let o = await Promise.all(t);
      for (let s10 = 0; s10 < o.length; ++s10) e28[r[s10]] = o[s10][0];
      Mt(n);
    }
  }
  function Ox(e28) {
    if (e28 != null) for (let t in e28) {
      let r = e28[t];
      typeof r != "number" && r.dispose();
    }
  }
  var cD;
  (function(e28) {
    e28[e28.SILENT = 0] = "SILENT", e28[e28.VERBOSE = 1] = "VERBOSE";
  })(cD || (cD = {}));
  var S5 = 125;
  var Fu = class {
    constructor() {
      this.validationData = null;
    }
    setParams(t) {
      this.params = t;
    }
    async onEpochBegin(t, r) {
    }
    async onEpochEnd(t, r) {
    }
    async onBatchBegin(t, r) {
    }
    async onBatchEnd(t, r) {
    }
    async onTrainBegin(t) {
    }
    async onTrainEnd(t) {
    }
    setModel(t) {
    }
  };
  var Rx = class {
    constructor(t, r = 10) {
      t == null && (t = []), this.callbacks = t, this.queueLength = r;
    }
    append(t) {
      this.callbacks.push(t);
    }
    setParams(t) {
      for (let r of this.callbacks) r.setParams(t);
    }
    setModel(t) {
      for (let r of this.callbacks) r.setModel(t);
    }
    async onEpochBegin(t, r) {
      r == null && (r = {});
      for (let n of this.callbacks) await n.onEpochBegin(t, r);
    }
    async onEpochEnd(t, r) {
      r == null && (r = {});
      for (let n of this.callbacks) await n.onEpochEnd(t, r);
    }
    async onBatchBegin(t, r) {
      r == null && (r = {});
      for (let n of this.callbacks) await n.onBatchBegin(t, r);
    }
    async onBatchEnd(t, r) {
      r == null && (r = {});
      for (let n of this.callbacks) await n.onBatchEnd(t, r);
    }
    async onTrainBegin(t) {
      t == null && (t = {});
      for (let r of this.callbacks) await r.onTrainBegin(t);
    }
    async onTrainEnd(t) {
      t == null && (t = {});
      for (let r of this.callbacks) await r.onTrainEnd(t);
    }
  };
  var O1 = class extends Fu {
    constructor() {
      super();
    }
    async onEpochBegin(t) {
      this.seen = 0, this.totals = {};
    }
    async onBatchEnd(t, r) {
      r == null && (r = {});
      let n = r.size == null ? 0 : r.size;
      this.seen += n;
      for (let o in r) {
        let s10 = r[o];
        if (typeof s10 == "number") this.totals.hasOwnProperty(o) || (this.totals[o] = 0), this.totals[o] = this.totals[o] + s10 * n;
        else {
          let i;
          o in this.totals ? i = this.totals[o] : this.totals[o] = 0;
          let a = M(() => Y(this.totals[o], F(s10, n)));
          this.totals[o] = a, i?.dispose();
        }
      }
    }
    async onEpochEnd(t, r) {
      if (r != null) for (let n of this.params.metrics) this.totals[n] != null && (typeof this.totals[n] == "number" ? r[n] = this.totals[n] / this.seen : M(() => {
        let o = F(ut(1, this.seen), this.totals[n]);
        r[n] = o, this.totals[n].dispose(), wr(r[n]);
      }));
    }
  };
  var Px = class extends Fu {
    async onTrainBegin(t) {
      this.epoch = [], this.history = {};
    }
    async onEpochEnd(t, r) {
      r == null && (r = {}), this.epoch.push(t);
      for (let n in r) this.history[n] == null && (this.history[n] = []), this.history[n].push(r[n]);
    }
    async syncData() {
      let t = [], r = [], n = [];
      for (let s10 in this.history) {
        let i = this.history[s10];
        for (let a = 0; a < i.length; ++a) if (typeof i[a] != "number") {
          let u = i[a];
          t.push(u.data()), r.push(s10), n.push(a);
        }
      }
      let o = await Promise.all(t);
      for (let s10 = 0; s10 < o.length; ++s10) this.history[r[s10]][n[s10]].dispose(), this.history[r[s10]][n[s10]] = o[s10][0];
    }
  };
  var Lx = class extends Fu {
    constructor(t, r) {
      if (super(), this.currentEpoch = 0, this.nowFunc = t.nowFunc, this.nextFrameFunc = t.nextFrameFunc || fh, this.yieldEvery = r || "auto", this.yieldEvery === "auto" && (this.yieldEvery = S5), this.yieldEvery === "never" && t.onYield != null) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
      x.isNumber(this.yieldEvery) && (this.maybeWait = MA(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = t.onTrainBegin, this.trainEnd = t.onTrainEnd, this.epochBegin = t.onEpochBegin, this.epochEnd = t.onEpochEnd, this.batchBegin = t.onBatchBegin, this.batchEnd = t.onBatchEnd, this.yield = t.onYield;
    }
    async maybeWait(t, r, n) {
      let o = [];
      this.yield != null && (await na(n), o.push(this.yield(t, r, n))), o.push(this.nextFrameFunc()), await Promise.all(o);
    }
    async onEpochBegin(t, r) {
      this.currentEpoch = t, this.epochBegin != null && (await na(r), await this.epochBegin(t, r));
    }
    async onEpochEnd(t, r) {
      let n = [];
      this.epochEnd != null && (await na(r), n.push(this.epochEnd(t, r))), this.yieldEvery === "epoch" && n.push(this.nextFrameFunc()), await Promise.all(n);
    }
    async onBatchBegin(t, r) {
      this.batchBegin != null && (await na(r), await this.batchBegin(t, r));
    }
    async onBatchEnd(t, r) {
      let n = [];
      this.batchEnd != null && (await na(r), n.push(this.batchEnd(t, r))), this.yieldEvery === "batch" ? n.push(this.nextFrameFunc()) : x.isNumber(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, t, r)), await Promise.all(n);
    }
    async onTrainBegin(t) {
      this.trainBegin != null && (await na(t), await this.trainBegin(t));
    }
    async onTrainEnd(t) {
      this.trainEnd != null && (await na(t), await this.trainEnd(t));
    }
  };
  function Mx(e28, t) {
    return e28 == null && (e28 = {}), e28 instanceof Fu ? [e28] : Array.isArray(e28) && e28[0] instanceof Fu ? e28 : ue(e28).map((n) => new Lx(n, t));
  }
  var $h = class e14 {
    constructor() {
    }
    static registerCallbackConstructor(t, r) {
      x.assert(t >= 0 && Number.isInteger(t), () => `Verbosity level is expected to be an integer >= 0, but got ${t}`), e14.checkForDuplicate(r), e14.constructors[t] == null && (e14.constructors[t] = []), e14.constructors[t].push(r);
    }
    static checkForDuplicate(t) {
      for (let r in e14.constructors) e14.constructors[+r].forEach((o) => {
        if (o === t) throw new P("Duplicate callback constructor.");
      });
    }
    static clear() {
      e14.constructors = {};
    }
    static createCallbacks(t) {
      let r = [];
      for (let n in e14.constructors) {
        let o = +n;
        t >= o && r.push(...e14.constructors[o]);
      }
      return r.map((n) => new n());
    }
  };
  $h.constructors = {};
  function zx(e28, t, r, n, o, s10, i, a, u) {
    let l = new Px(), c = [new O1(), ...$h.createCallbacks(t)];
    e28 != null && c.push(...e28), c.push(l);
    let p = new Rx(c);
    return p.setParams({ epochs: r, initialEpoch: n, samples: o, steps: s10, batchSize: i, verbose: t, doValidation: a, metrics: u }), { callbackList: p, history: l };
  }
  function zn(e28, t = {}, r = false) {
    return ks(e28, K.SerializationMap.getMap().classNameMap, t, "layer", r);
  }
  function Fh(e28, t) {
    return M(() => {
      e28.dtype !== "float32" && (e28 = Z(e28, "float32"));
      let r = ht(Gl(e28), t, true), n = Ki(r.shape, pr()), o = ge(Pn(r, n));
      return ut(e28, o);
    });
  }
  function Hl(e28, t) {
    return M(() => ke(Gl(xt(t, e28)), -1));
  }
  function Oh(e28, t) {
    return M(() => ke(cr(xt(t, e28)), -1));
  }
  function Rh(e28, t) {
    return M(() => {
      let r = xt(e28, t), n = Fr(cr(e28), pr(), Number.MAX_VALUE), o = cr(ut(r, n));
      return F(100, ke(o, -1));
    });
  }
  function I5(e28, t) {
    return M(() => {
      let r = Fr(t, pr(), Number.MAX_VALUE), n = un(Y(1, r)), o = Fr(e28, pr(), Number.MAX_VALUE), s10 = un(Y(1, o));
      return ke(Gl(xt(n, s10)), -1);
    });
  }
  function T5(e28, t) {
    return M(() => {
      let r = Pn(0, xt(1, F(e28, t)));
      return ke(Gl(r), -1);
    });
  }
  function k5(e28, t) {
    return M(() => {
      let r = Pn(0, xt(1, F(e28, t)));
      return ke(r, -1);
    });
  }
  function E5(e28, t) {
    return M(() => {
      let r = ht(F(e28, t), -1), n = _r(F(xt(1, e28), t), -1);
      return Pn(0, Y(1, xt(n, r)));
    });
  }
  function A5(e28, t) {
    return M(() => {
      let r = Math.log(2), n = xt(t, e28), o = xt(Y(n, Ss(F(-2, n))), r);
      return ke(o, -1);
    });
  }
  function Kl(e28, t, r = false) {
    return M(() => {
      if (r) t = Ol(t);
      else {
        let n = ht(t, t.shape.length - 1, true);
        t = ut(t, n);
      }
      return t = Fr(t, pr(), 1 - pr()), ne(ht(F(Z(e28, "float32"), un(t)), t.shape.length - 1));
    });
  }
  function sm(e28, t, r = false) {
    return M(() => {
      let n = Z(Yi(XA(e28)), "int32");
      t = Fr(t, pr(), 1 - pr());
      let o = t.shape, s10 = _(_p(n, o[o.length - 1]), o);
      return Kl(s10, t, r);
    });
  }
  function D5(e28, t) {
    if (!x.arraysEqual(e28.shape, t.shape)) throw new P(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e28.shape)} and ${JSON.stringify(t.shape)}`);
    return M(() => {
      let r = Ln(t), n = ne(cr(t));
      return Y(xt(r, F(t, e28)), Xf(Nr(n)));
    });
  }
  function im(e28, t) {
    return M(() => {
      let r;
      return r = Fr(t, pr(), 1 - pr()), r = un(ut(r, xt(1, r))), ke(D5(e28, r), -1);
    });
  }
  function $5(e28, t) {
    return M(() => {
      let r = Fr(e28, pr(), 1), n = Fr(t, pr(), 1);
      return ht(F(e28, un(ut(r, n))), -1);
    });
  }
  function F5(e28, t) {
    return M(() => {
      let r = un(Y(pr(), t));
      return ke(xt(t, F(e28, r)), -1);
    });
  }
  function Bx(e28, t) {
    return M(() => {
      let r = Fh(e28, -1), n = Fh(t, -1), o = F(r, n);
      return ne(ht(o, -1));
    });
  }
  var _h = { meanSquaredError: Hl, meanAbsoluteError: Oh, meanAbsolutePercentageError: Rh, meanSquaredLogarithmicError: I5, squaredHinge: T5, hinge: k5, categoricalHinge: E5, logcosh: A5, categoricalCrossentropy: Kl, sparseCategoricalCrossentropy: sm, binaryCrossentropy: im, kullbackLeiblerDivergence: $5, poisson: F5, cosineProximity: Bx };
  function Vx(e28) {
    if (typeof e28 == "string") {
      if (e28 in _h) return _h[e28];
      let t = `Unknown loss ${e28}`;
      throw e28.toLowerCase().includes("softmaxcrossentropy") && (t = `Unknown loss ${e28}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new P(t);
    } else return e28;
  }
  function Wx(e28, t) {
    return M(() => {
      let r = F(0.5, Cr(t)), n = Qr(je(t, r), e28.dtype);
      return ke(an(e28, n), -1);
    });
  }
  function Ux(e28, t) {
    return M(() => Qr(an(ji(e28, -1), ji(t, -1)), "float32"));
  }
  function _5(e28, t) {
    return M(() => Z(ht(Jr(an(e28, 1), an(t, 1))), "float32"));
  }
  function O5(e28, t) {
    return M(() => Z(ht(Jr(an(e28, 0), an(t, 1))), "float32"));
  }
  function mD(e28, t) {
    return M(() => {
      let r = _5(e28, t), n = O5(e28, t), o = Y(r, n);
      return Z(Ce(je(o, 0), ut(r, o), 0), "float32");
    });
  }
  function R1(e28, t) {
    return im(e28, t);
  }
  function P1(e28, t) {
    return e28.rank === t.rank && (e28 = Wo(e28, [e28.rank - 1])), t = ji(t, -1), t.dtype !== e28.dtype && (t = Z(t, e28.dtype)), Z(an(e28, t), "float32");
  }
  var R5 = Hl;
  var P5 = Hl;
  var L5 = Oh;
  var M5 = Oh;
  var z5 = Rh;
  var B5 = Rh;
  var jx = Kl;
  var V5 = Bx;
  var L1 = sm;
  var Gx = { binaryAccuracy: Wx, categoricalAccuracy: Ux, precision: mD, categoricalCrossentropy: jx, sparseCategoricalCrossentropy: L1, mse: R5, MSE: P5, mae: L5, MAE: M5, mape: z5, MAPE: B5, cosine: V5 };
  function fD(e28) {
    if (typeof e28 == "string" && e28 in Gx) return Gx[e28];
    if (typeof e28 != "string" && e28 != null) return e28;
    throw new P(`Unknown metric ${e28}`);
  }
  function Ph(e28) {
    if (ro(e28 !== null, `Unknown LossOrMetricFn ${e28}`), typeof e28 == "string") return e28;
    {
      let t;
      for (let r of Object.keys(_h)) if (_h[r] === e28) {
        t = r;
        break;
      }
      if (t !== void 0) return t;
      for (let r of Object.keys(Gx)) if (Gx[r] === e28) {
        t = r;
        break;
      }
      return t !== void 0 ? t : e28.name;
    }
  }
  function dD(e28) {
    let t = { Adagrad: () => Bl.adagrad(0.01), Adadelta: () => Bl.adadelta(1, 0.95, pr()), Adam: () => Bl.adam(1e-3, 0.9, 0.999, pr()), Adamax: () => Bl.adamax(2e-3, 0.9, 0.999, pr(), 0), RMSProp: () => Bl.rmsprop(1e-3, 0.9, 0, pr()), SGD: () => Bl.sgd(0.01) };
    if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e28 in t) return t[e28]();
    throw new P(`Unknown Optimizer ${e28}`);
  }
  function z1(e28, t, r = false) {
    if (e28 == null || typeof e28 != "object" || Object.getPrototypeOf(e28) !== Object.prototype || !M1(e28)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    if (r) {
      let n = JSON.stringify(e28);
      n.length > 1048576 && console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`);
    }
  }
  function M1(e28) {
    if (e28 === null) return true;
    if (typeof e28 == "object") if (Object.getPrototypeOf(e28) === Object.prototype) {
      let t = Object.keys(e28);
      for (let r of t) if (typeof r != "string" || !M1(e28[r])) return false;
      return true;
    } else if (Array.isArray(e28)) {
      for (let t of e28) if (!M1(t)) return false;
      return true;
    } else return false;
    else {
      let t = typeof e28;
      return t === "string" || t === "number" || t === "boolean";
    }
  }
  function gD(e28, t, r, n = console.log) {
    let o = U5(e28), s10 = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
    o ? (t = t || 90, r = r || [0.32, 0.61, 0.89, 1]) : (t = t || 115, r = r || [0.24, 0.48, 0.7, 0.8, 1]), r[r.length - 1] <= 1 && (r = r.map((c) => Math.floor(t * c)));
    let i;
    if (!o) {
      s10.push("Receives inputs"), i = [];
      for (let c in e28.nodesByDepth) i.push(...e28.nodesByDepth[c]);
    }
    n("_".repeat(t)), Hx(s10, r, n), n("=".repeat(t));
    let a = e28.layers;
    for (let c = 0; c < a.length; ++c) o ? j5(a[c], r, n) : H5(a[c], r, i, n), n((c === a.length - 1 ? "=" : "_").repeat(t));
    e28.checkTrainableWeightsConsistency();
    let u = W5(e28), l = nm(e28.nonTrainableWeights);
    n(`Total params: ${u + l}`), n(`Trainable params: ${u}`), n(`Non-trainable params: ${l}`), n("_".repeat(t));
  }
  function W5(e28) {
    let t;
    return e28.collectedTrainableWeights != null ? t = nm(e28.collectedTrainableWeights) : t = nm(e28.trainableWeights), t;
  }
  function U5(e28) {
    let t = true, r = [], n = [];
    for (let o in e28.nodesByDepth) r.push(e28.nodesByDepth[o]);
    for (let o of r) {
      if (o.length > 1 || o.length === 1 && o[0].inboundLayers.length > 1) {
        t = false;
        break;
      }
      n.push(...o);
    }
    if (t) for (let o of e28.layers) {
      let s10 = false;
      for (let i of o.inboundNodes) if (n.indexOf(i) !== -1) if (s10) {
        t = false;
        break;
      } else s10 = true;
      if (!t) break;
    }
    return t;
  }
  function Hx(e28, t, r = console.log) {
    let n = "";
    for (let o = 0; o < e28.length; ++o) o > 0 && (n = n.slice(0, n.length - 1) + " "), n += e28[o], n = n.slice(0, t[o]), n += " ".repeat(t[o] - n.length);
    r(n);
  }
  function j5(e28, t, r) {
    let n, o;
    try {
      o = e28.inboundNodes.map((u) => JSON.stringify(u.inputShapes)).join(",");
    } catch {
      o = "multiple";
    }
    try {
      n = JSON.stringify(e28.outputShape);
    } catch {
      n = "multiple";
    }
    let s10 = e28.name, i = e28.getClassName(), a = [`${s10} (${i})`, o, n, e28.countParams().toString()];
    Hx(a, t, r);
  }
  function H5(e28, t, r, n) {
    let o, s10;
    try {
      s10 = e28.inboundNodes.map((p) => JSON.stringify(p.inputShapes)).join(",");
    } catch {
      s10 = "multiple";
    }
    try {
      o = JSON.stringify(e28.outputShape);
    } catch {
      o = "multiple";
    }
    let i = [];
    for (let p of e28.inboundNodes) if (!(r != null && r.length > 0 && r.indexOf(p) === -1)) for (let m = 0; m < p.inboundLayers.length; ++m) {
      let f = p.inboundLayers[m].name, h = p.nodeIndices[m], d = p.tensorIndices[m];
      i.push(`${f}[${h}][${d}]`);
    }
    let a = e28.name, u = e28.getClassName(), l = i.length === 0 ? "" : i[0], c = [`${a} (${u})`, s10, o, e28.countParams().toString(), l];
    Hx(c, t, n);
    for (let p = 1; p < i.length; ++p) Hx(["", "", "", "", i[p]], t, n);
  }
  function yD(e28, t, r) {
    return (e28 === "inboundNodes" || e28 === "outputLayers" || e28 === "inputLayers") && t === 0 && typeof r == "string";
  }
  function Lh(e28, t) {
    if (e28 === null) return null;
    if (typeof e28 == "string") return Qi(e28);
    if (typeof e28 == "number" || typeof e28 == "boolean") return e28;
    if (e28 instanceof Array) {
      let r = [], n = e28.length;
      for (let o = 0; o < n; ++o) {
        let s10 = e28[o];
        yD(t, o, s10) ? r.push(s10) : r.push(Lh(s10, t));
      }
      return r;
    } else {
      let r = {};
      for (let n of Object.keys(e28)) {
        let o = e28[n];
        if (n === "name" && typeof o == "string") r[n] = o;
        else {
          let s10 = Qi(n);
          r[s10] = Lh(o, s10);
        }
      }
      return r;
    }
  }
  function Kx(e28, t) {
    if (e28 == null) return null;
    if (typeof e28 == "string") return Co(e28);
    if (typeof e28 == "number" || typeof e28 == "boolean") return e28;
    if (e28 instanceof Array) {
      let r = [], n = e28.length;
      for (let o = 0; o < n; ++o) {
        let s10 = e28[o];
        yD(t, o, s10) ? r.push(s10) : r.push(Kx(s10, t));
      }
      return r;
    } else {
      let r = {};
      for (let n of Object.keys(e28)) {
        let o = e28[n], s10 = Co(n);
        (n === "name" || n === "className") && typeof o == "string" ? r[s10] = o : r[s10] = Kx(o, n);
      }
      return r;
    }
  }
  var am = "4.21.0";
  var K5 = (e28) => {
    let t = Object.keys(e28);
    if (t.length === 0) return false;
    let r = t[0].split("/");
    return !isNaN(parseInt(r[r.length - 1], 10));
  };
  var qx = class e15 extends Pt {
    constructor(t) {
      if (super({}), this.containerNodes = /* @__PURE__ */ new Set(), this.name = t.name, this.name == null) {
        let b = this.getClassName().toLowerCase();
        this.name = Du(b);
      }
      if (this.supportsMasking = false, this.trainable_ = true, Array.isArray(t.inputs) ? this.inputs = t.inputs.slice() : this.inputs = [t.inputs], Array.isArray(t.outputs) ? this.outputs = t.outputs.slice() : this.outputs = [t.outputs], So(this.inputs).length !== this.inputs.length) throw new P(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((b) => b.name)}`);
      So(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((b) => b.name)}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
      for (let b of this.outputs) {
        let v = b.sourceLayer, w = b.nodeIndex, N = b.tensorIndex;
        this.outputLayers.push(v), this.outputLayersNodeIndices.push(w), this.outputLayersTensorIndices.push(N);
      }
      for (let b of this.inputs) {
        let v = b.sourceLayer, w = b.nodeIndex, N = b.tensorIndex;
        ro(w === 0, "input layer has >1 nodes"), ro(N === 0, "input layer has >1 tensors"), this.inputLayers.push(v), this.inputLayersNodeIndices.push(w), this.inputLayersTensorIndices.push(N);
      }
      this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
      for (let b = 0; b < this.inputLayers.length; b++) {
        let v = this.inputLayers[b];
        if (!(v instanceof As)) throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);
        this.inputNames.push(v.name), this.feedInputShapes.push(v.batchInputShape), this.feedInputNames.push(v.name);
      }
      for (let b of this.outputLayers) this.outputNames.push(b.name);
      this.internalInputShapes = this.inputs.map((b) => b.shape), this.internalOutputShapes = this.outputs.map((b) => b.shape);
      let r = {}, n = {}, o = {}, s10 = {}, i = {}, a = [], u = (b, v, w, N, E, A) => {
        (N == null || E == null || A == null) && (N = b.sourceLayer, E = b.nodeIndex, A = b.tensorIndex);
        let D = N.inboundNodes[E];
        if (w.indexOf(D) !== -1) throw new cn(`The tensor ${b.name} at layer "${N.name}" is part of a cycle.`);
        if (v.indexOf(D) !== -1) return;
        this.containerNodes.add(e15.nodeKey(N, E)), N.id in i || (i[N.id] = Object.keys(i).length), w.indexOf(D) === -1 && w.push(D);
        let R = D.inboundLayers.length;
        for (let L = 0; L < R; L++) {
          let G = D.inputTensors[L], W = D.inboundLayers[L], U = D.nodeIndices[L], H = D.tensorIndices[L];
          u(G, v, w, W, U, H);
        }
        for (v.push(D); w.indexOf(D) >= 0; ) w.splice(w.indexOf(D), 1);
        a.push(D);
      }, l = [], c = [];
      for (let b of this.outputs) u(b, l, c);
      let p = a.slice().reverse();
      for (let b of p) {
        n[b.id] = b, b.id in r || (r[b.id] = 0);
        let v = r[b.id], w = o[b.outboundLayer.id] == null ? 0 : o[b.outboundLayer.id];
        v = Math.max(v, w), o[b.outboundLayer.id] = v, s10[b.outboundLayer.id] = b.outboundLayer, r[b.id] = v;
        for (let N = 0; N < b.inboundLayers.length; N++) {
          let E = b.inboundLayers[N], A = b.nodeIndices[N], D = E.inboundNodes[A], R = r[D.id] == null ? 0 : r[D.id];
          r[D.id] = Math.max(v + 1, R), n[D.id] = D;
        }
      }
      let m = {};
      for (let b in r) {
        let v = r[b];
        v in m || (m[v] = []), m[v].push(n[b]);
      }
      let f = {};
      for (let b in o) {
        let v = o[b];
        v in f || (f[v] = []), f[v].push(s10[b]);
      }
      let h = Object.keys(f).map((b) => parseInt(b, 10)).sort(dh);
      this.layers = [];
      for (let b of h) {
        let v = f[b];
        v.sort((w, N) => {
          let E = i[w.id], A = i[N.id];
          return E < A ? -1 : E > A ? 1 : 0;
        });
        for (let w of v) w instanceof e15 && this.internalContainerRefs.push(w), this.layers.push(w);
      }
      this.layersByDepth = f, h = Object.keys(m).map((b) => parseInt(b, 10)).sort(dh);
      let d = this.inputs.slice(), g = [];
      for (let b of h) for (let v of m[b]) {
        let w = v.outboundLayer;
        if (w != null) {
          for (let N of v.inputTensors) if (d.indexOf(N) === -1) throw new cn(`Graph disconnected: cannot obtain value for tensor ${N} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);
          for (let N of v.outputTensors) d.push(N);
          g.push(w.name);
        }
      }
      this.nodesByDepth = m;
      let y = this.layers.map((b) => b.name);
      for (let b of y) {
        let v = y.filter((w) => w === b).length;
        if (v !== 1) throw new cn(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(y));
      }
      this.outboundNodes = [], this.inboundNodes = [], new ra({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: this.inputs, outputTensors: this.outputs, inputMasks: this.inputs.map((b) => null), outputMasks: this.outputs.map((b) => null), inputShapes: this.inputs.map((b) => b.shape), outputShapes: this.outputs.map((b) => b.shape) }), this.built = true, this._refCount = 1;
    }
    assertNotDisposed() {
      if (this._refCount === 0) throw new Error(`Container '${this.name}' is already disposed.`);
    }
    dispose() {
      this.assertNotDisposed();
      let t = { refCountAfterDispose: null, numDisposedVariables: 0 };
      if (--this._refCount === 0) {
        for (let r of this.layers) t.numDisposedVariables += r.dispose().numDisposedVariables;
        for (let r of this.internalContainerRefs) t.numDisposedVariables += r.dispose().numDisposedVariables;
      }
      return t.refCountAfterDispose = this._refCount, t;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(t) {
      this.layers.forEach((r) => {
        r._trainableWeights.forEach((n) => n.trainable = t);
      }), this.trainable_ = t;
    }
    get trainableWeights() {
      if (this._trainableWeights.length > 0) throw new P("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable) return [];
      let t = [];
      for (let r of this.layers) t = t.concat(r.trainableWeights);
      return t;
    }
    get nonTrainableWeights() {
      let t = [];
      for (let r of this.layers) t.push(...r.nonTrainableWeights);
      if (!this.trainable) {
        let r = [];
        for (let n of this.layers) r.push(...n.trainableWeights);
        return r.concat(t);
      }
      return t;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    loadWeights(t, r = true) {
      let n = {}, o = 0, s10 = K5(t);
      s10 && this.parseWeights(t);
      for (let a of this.layers) for (let [u, l] of a.weights.entries()) {
        let c = s10 ? `${l.name.split("/").slice(0, -1).join("/") + "/"}${u}` : l.originalName;
        if (n[c] != null) throw new P(`Duplicate weight name: ${c}`);
        n[c] = l, o++;
      }
      let i = [];
      for (let a in t) {
        let u = a;
        if (n[a] == null) {
          let l = a.split("/");
          u = l.slice(0, -2).concat([l[l.length - 1]]).join("/");
        }
        if (n[u] != null) i.push([n[u], t[a]]);
        else if (r) throw new P(`Provided weight data has no target variable: ${a}`);
        delete n[u];
      }
      if (r) {
        let a = [];
        for (let u in n) a.push(u);
        if (a.length > 0) throw new P(`${a.length} of ${o} weights are not set: ${a}`);
      }
      om(i);
    }
    parseWeights(t) {
      for (let r in Object.keys(t)) {
        let n = r.split("/"), o = ["vars", "layer_checkpoint_dependencies"], s10 = n.map((i) => i.startsWith("_") ? i.slice(1) : i).filter((i) => !o.includes(i)).join("/");
        s10 !== r && (t[s10] = t[r], delete t[r]);
      }
    }
    updatedConfig() {
      let t = this.getConfig(), r = {};
      return r.className = this.getClassName(), r.config = t, r.kerasVersion = `tfjs-layers ${am}`, r.backend = "TensorFlow.js", r;
    }
    toJSON(t, r = true) {
      let n = Kx(this.updatedConfig());
      return r ? JSON.stringify(n) : n;
    }
    call(t, r) {
      return M(() => {
        t = ue(t);
        let n = new Ds();
        for (let o = 0; o < this.inputs.length; ++o) n.add(this.inputs[o], t[o]);
        return Ul(this.outputs, n, r);
      });
    }
    computeMask(t, r) {
      return M(() => {
        t = ue(t);
        let n;
        return r == null ? n = No(null, t.length) : n = ue(r), this.runInternalGraph(t, n)[1];
      });
    }
    computeOutputShape(t) {
      let r = rm(t);
      if (r.length !== this.inputLayers.length) throw new P(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);
      let n = {};
      for (let a = 0; a < r.length; a++) {
        let u = this.inputLayers[a], l = r[a], c = u.name + "_0_0";
        n[c] = l;
      }
      let o = Object.keys(this.nodesByDepth).map((a) => parseInt(a, 10)).sort(dh);
      if (o.length > 1) for (let a of o) {
        let u = this.nodesByDepth[a];
        for (let l of u) {
          let c = l.outboundLayer;
          if (this.inputLayers.map((d) => d.id).indexOf(c.id) !== -1) continue;
          let p = [];
          for (let d = 0; d < l.inboundLayers.length; d++) {
            let g = l.inboundLayers[d], y = l.nodeIndices[d], b = l.tensorIndices[d], v = `${g.name}_${y}_${b}`, w = n[v];
            p.push(w);
          }
          let m = c.computeOutputShape(Ir(p)), f = rm(m), h = c.inboundNodes.indexOf(l);
          for (let d = 0; d < f.length; d++) {
            let g = `${c.name}_${h}_${d}`;
            n[g] = f[d];
          }
        }
      }
      let s10 = [], i = [];
      for (let a = 0; a < this.outputLayers.length; a++) {
        let u = this.outputLayers[a], l = this.outputLayersNodeIndices[a], c = this.outputLayersTensorIndices[a], p = `${u.name}_${l}_${c}`;
        i.push(p);
      }
      for (let a = 0; a < i.length; a++) {
        let u = i[a];
        ro(u in n), s10.push(n[u]);
      }
      return Ir(s10);
    }
    runInternalGraph(t, r) {
      r == null && (r = No(null, t.length));
      let n = {};
      for (let u = 0; u < this.inputs.length; ++u) {
        let l = this.inputs[u], c = t[u], p = r[u];
        n[l.id] = [c, p];
      }
      let o = Object.keys(this.nodesByDepth).map((u) => parseInt(u, 10)).sort(dh);
      for (let u of o) {
        let l = this.nodesByDepth[u];
        for (let c of l) {
          let p = c.outboundLayer, m = c.inputTensors, f = c.outputTensors, h = new Array();
          for (let d of m) d.id in n && h.push(n[d.id]);
          if (h.length === m.length) {
            let d = {}, g, y, b, v;
            if (c.callArgs != null && (d = c.callArgs), h.length === 1) {
              let [w, N] = h[0];
              d.mask == null && (d.mask = N), b = ue(p.call(w, d)), v = ue(p.computeMask(w, N)), g = [w], y = [N];
            } else g = h.map((w) => w[0]), y = h.map((w) => w[1]), d.mask == null && (d.mask = y), b = ue(p.call(g, d)), v = ue(p.computeMask(g, y));
            if (p.activityRegularizer) throw new Rt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
            for (let w = 0; w < f.length; ++w) {
              let N = f[w], E = b[w], A = v[w];
              n[N.id] = [E, A];
            }
          }
        }
      }
      let s10 = [], i = [], a = [];
      for (let u of this.outputs) {
        ro(u.id in n, `Could not compute output ${u.name} : ${u.id}`);
        let [l, c] = n[u.id];
        a.push(l.shape), s10.push(l), i.push(c);
      }
      return [s10, i, a];
    }
    buildNodeConversionMap(t) {
      let r = {}, n;
      for (let o of this.layers) {
        n = o instanceof e15 ? 1 : 0;
        for (let s10 = 0; s10 < o.inboundNodes.length; s10++) {
          let i = e15.nodeKey(o, s10);
          this.containerNodes.has(i) && (r[i] = n, n += 1);
        }
      }
      return r;
    }
    getLayer(t, r) {
      if (r != null) return this.findLayer(r);
      if (t == null) throw new P("Provide either a layer name or layer index");
      if (typeof t == "number") return this.findLayer(t);
      for (let n of this.layers) if (n.name === t) return n;
      throw new P(`No such layer: ${t}`);
    }
    findLayer(t) {
      if (this.layers.length <= t) throw new P(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);
      return this.layers[t];
    }
    calculateLosses() {
      return M(() => {
        let t = [];
        for (let r of this.layers) for (let n = 0; n < r.inboundNodes.length; ++n) {
          let o = e15.nodeKey(r, n);
          this.containerNodes.has(o) && t.push(...r.calculateLosses());
        }
        return t;
      });
    }
    getConfig() {
      let t = { name: this.name }, r = this.buildNodeConversionMap(this.layers), n = [];
      for (let i of this.layers) {
        let a = i.getClassName(), u = i.getConfig(), l = [];
        for (let p = 0; p < i.inboundNodes.length; p++) {
          let m = i.inboundNodes[p], f = e15.nodeKey(i, p), h = {};
          if (this.containerNodes.has(f)) {
            if (m.callArgs) try {
              JSON.stringify(m.callArgs), h = m.callArgs;
            } catch {
              console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), h = {};
            }
            if (m.inboundLayers.length > 0) {
              let d = [];
              for (let g = 0; g < m.inboundLayers.length; g++) {
                let y = m.inboundLayers[g], b = m.nodeIndices[g], v = m.tensorIndices[g], w = e15.nodeKey(y, b), N = r[w];
                N == null && (N = 0), d.push([y.name, N, v, h]);
              }
              l.push(d);
            }
          }
        }
        let c = {};
        c.name = i.name, c.className = a, c.config = u, c.inboundNodes = l, n.push(c);
      }
      t.layers = n;
      let o = [];
      for (let i = 0; i < this.inputLayers.length; i++) {
        let a = this.inputLayers[i], u = this.inputLayersNodeIndices[i], l = e15.nodeKey(a, u);
        if (!this.containerNodes.has(l)) continue;
        let c = r[l];
        c == null && (c = 0);
        let p = this.inputLayersTensorIndices[i];
        o.push([a.name, c, p]);
      }
      t.inputLayers = o;
      let s10 = [];
      for (let i = 0; i < this.outputLayers.length; i++) {
        let a = this.outputLayers[i], u = this.outputLayersNodeIndices[i], l = e15.nodeKey(a, u);
        if (!this.containerNodes.has(l)) continue;
        let c = r[l];
        c == null && (c = 0);
        let p = this.outputLayersTensorIndices[i];
        s10.push([a.name, c, p]);
      }
      return t.outputLayers = s10, t;
    }
    static fromConfig(t, r, n = {}, o = false) {
      let s10 = {}, i = {};
      function a(g, y) {
        g.name in i ? i[g.name].push(y) : i[g.name] = [y];
      }
      function u(g, y) {
        let b = [], v;
        for (let w of y) {
          let N = w[0], E = w[1], A = w[2];
          if (v = w[3] == null ? {} : w[3], !(N in s10)) {
            a(g, y);
            return;
          }
          let D = s10[N];
          if (D.inboundNodes.length <= E) {
            a(g, y);
            return;
          }
          let R = D.inboundNodes[E];
          b.push(R.outputTensors[A]);
        }
        b.length > 0 && g.apply(Ir(b), v);
      }
      function l(g) {
        let y = g.name, b = zn(g, r.customObjects != null ? r.customObjects : {});
        b.setFastWeightInitDuringBuild(o), s10[y] = b, g.inboundNodes.forEach((w) => {
          if (!(w instanceof Array)) throw new P(`Corrupted configuration, expected array for nodeData: ${w}`);
          a(b, w);
        });
      }
      let c = r.name, p = r.layers;
      for (let g of p) l(g);
      for (; !PA(i); ) for (let g of p) {
        let y = s10[g.name];
        if (y.name in i) {
          let b = i[y.name];
          delete i[y.name];
          for (let v of b) u(y, v);
        }
      }
      let m = [], f = [], h = r.inputLayers;
      for (let g of h) {
        let y = g[0], b = g[1], v = g[2];
        ro(y in s10);
        let N = s10[y].inboundNodes[b].outputTensors;
        m.push(N[v]);
      }
      let d = r.outputLayers;
      for (let g of d) {
        let y = g[0], b = g[1], v = g[2];
        ro(y in s10);
        let N = s10[y].inboundNodes[b].outputTensors;
        f.push(N[v]);
      }
      return new t({ inputs: m, outputs: f, name: c });
    }
    get stateful() {
      if (this._stateful) throw new P("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
      for (let t of this.layers) if (t.stateful) return true;
      return false;
    }
    resetStates() {
      M(() => {
        this.layers.forEach((t) => {
          t.stateful && t.resetStates();
        });
      });
    }
  };
  function q5(e28, t, r) {
    let n = t.length;
    if (e28 == null || Array.isArray(e28) && e28.length === 0) return t.map((o) => null);
    if (n === 1) return Array.isArray(e28) && e28.length === 1 ? e28 : typeof e28 == "object" && t[0] in e28 ? [e28[t[0]]] : [e28];
    if (Array.isArray(e28)) {
      if (e28.length !== n) throw new Error(`Provided ${r} is an array of ${e28.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);
      return e28;
    } else if (typeof e28 == "object" && Object.keys(e28).length > 0 && typeof e28[Object.keys(e28)[0]] == "object") {
      let o = [];
      return t.forEach((s10) => {
        s10 in e28 ? o.push(e28[s10]) : o.push(null);
      }), o;
    } else throw new Error(`The model has multiple (${n}) outputs, so ${r} must be either an array with ${n} elements or an object with ${t} keys. Provided ${r} not understood: ${JSON.stringify(e28)}`);
  }
  function Xx(e28, t) {
    return q5(e28, t, "classWeight");
  }
  async function Yx(e28, t, r, n) {
    if (t != null || n != null) throw new Error("Support sampleWeight is not implemented yet");
    if (r != null) {
      let o = M(() => {
        if (e28.shape.length === 1) return _n(e28);
        if (e28.shape.length === 2) {
          if (e28.shape[1] > 1) return ji(e28, 1);
          if (e28.shape[1] === 1) return _(e28, [e28.shape[0]]);
          throw new Error(`Encountered unexpected last-dimension size (${e28.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
        } else throw new Error(`Unexpected rank of target (y) tensor (${e28.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
      }), s10 = Array.from(await o.data());
      Mt(o);
      let i = [];
      return s10.forEach((a) => {
        if (r[a] == null) throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);
        i.push(r[a]);
      }), sr(i, "float32");
    } else return null;
  }
  function xD(e28, t) {
    return F(e28, t);
  }
  var X5 = 32;
  function vD(e28, t) {
    let r, n, o = t;
    r = o.xs, n = o.ys, x.assert(r != null && n != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);
    let s10 = bD("input", e28.inputNames, r), i = bD("output", e28.outputNames, n), a = s10[0].shape[0];
    x.assert(s10.length === e28.inputs.length, () => `LayersModel has ${e28.inputs.length} inputs, but the dataset provides ${s10.length} inputs.  (Expected input keys: ${JSON.stringify(e28.inputNames)})`), x.assert(i.length === e28.outputs.length, () => `LayersModel has ${e28.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e28.outputNames)})`);
    for (let u = 0; u < s10.length; u++) x.assert(s10[u].shape[0] === a, () => `Batch size mismatch: input ${e28.inputNames[u]} has ${s10[u].shape[0]}; expected  ${a} based on input ${e28.inputNames[0]}.`);
    for (let u = 0; u < i.length; u++) x.assert(i[u].shape[0] === a, () => `Batch size mismatch: output ${e28.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${e28.inputNames[0]}.`);
    return { xs: s10, ys: i };
  }
  function bD(e28, t, r) {
    if (r instanceof ee) return [r];
    if (Array.isArray(r)) return x.assert(r.length === t.length, () => `Received an array of ${r.length} Tensors, but expected ${t.length} to match the ${e28} keys ${t}.`), r;
    {
      let n = [];
      for (let o of t) {
        if (r[o] == null) throw new P(`The feature data generated by the dataset lacks the required ${e28} key '${o}'.`);
        n.push(r[o]);
      }
      return n;
    }
  }
  function Y5(e28) {
    if (e28.length === 3) throw new Rt("Validation with sample weights is not implemented yet.");
    return { xs: e28[0], ys: e28[1] };
  }
  async function ND(e28, t, r) {
    let n = r.batchesPerEpoch != null;
    if (x.assert(e28.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), x.assert(r != null, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), x.assert(r.epochs != null && r.epochs > 0 && Number.isInteger(r.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${r.epochs}`), x.assert(!n || r.batchesPerEpoch > 0 && Number.isInteger(r.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${r.batchesPerEpoch}`), x.assert(r.validationSplit == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."), e28.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
    e28.isTraining = true;
    try {
      let o = r.validationData != null, s10, i;
      if (o) if (wD(r.validationData)) x.assert(r.validationBatches == null || r.validationBatches > 0 && Number.isInteger(r.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${r.validationBatches}`);
      else {
        let g = Y5(r.validationData);
        s10 = g.xs, i = g.ys;
      }
      let a = e28.makeTrainFunction(), u = e28.getDedupedMetricsNames(), l;
      o ? l = u.slice().concat(u.map((g) => "val_" + g)) : l = u.slice();
      let c = Mx(r.callbacks, r.yieldEvery), p = r.verbose == null ? 1 : r.verbose, { callbackList: m, history: f } = zx(c, p, r.epochs, null, null, J5(t, r), null, o, l);
      m.setModel(e28), e28.history = f, await m.onTrainBegin(), e28.stopTraining_ = false;
      let h = r.initialEpoch == null ? 0 : r.initialEpoch, d = await t.iterator();
      for (; h < r.epochs; ) {
        let g = {};
        await m.onEpochBegin(h);
        let y = 0, b = 0;
        for (n || (d = await t.iterator()); !n || y < r.batchesPerEpoch; ) {
          let v = await d.next();
          if (n && v.done) {
            console.warn(`You provided \`batchesPerEpoch\` as ${r.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${r.batchesPerEpoch * r.epochs} batches). You may need to use the repeat() function when building your dataset.`);
            break;
          }
          if (v.value != null) {
            let { xs: w, ys: N } = vD(e28, v.value), E = {};
            E.batch = b, E.size = w[0].shape[0], await m.onBatchBegin(b, E);
            let A = [];
            if (r.classWeight != null) {
              let L = Xx(r.classWeight, e28.outputNames);
              for (let G = 0; G < L.length; ++G) A.push(await Yx(N[G], null, L[G]));
            }
            let D = w.concat(N).concat(A), R = a(D);
            Mt(D);
            for (let L = 0; L < u.length; ++L) {
              let G = u[L], W = R[L];
              E[G] = W, wr(W);
            }
            await m.onBatchEnd(b, E), Ox(E), b++, y++;
          }
          if (n ? y >= r.batchesPerEpoch : v.done) {
            if (o) {
              let w;
              wD(r.validationData) ? w = ue(await e28.evaluateDataset(r.validationData, { batches: r.validationBatches })) : w = ue(e28.evaluate(s10, i, { batchSize: r.validationBatchSize == null ? X5 : r.validationBatchSize, verbose: 0 }));
              for (let N = 0; N < e28.metricsNames.length; ++N) g[`val_${e28.metricsNames[N]}`] = w[N];
            }
            break;
          }
          if (e28.stopTraining_) break;
        }
        if (await m.onEpochEnd(h, g), h++, e28.stopTraining_) break;
      }
      return await m.onTrainEnd(), await e28.history.syncData(), e28.history;
    } finally {
      e28.isTraining = false;
    }
  }
  function J5(e28, t) {
    let r = null;
    return t.batchesPerEpoch != null ? r = t.batchesPerEpoch : Number.isFinite(e28.size) && (r = e28.size), r;
  }
  function wD(e28) {
    return typeof e28.iterator == "function";
  }
  function Z5(e28) {
    return typeof e28.next == "function";
  }
  async function CD(e28, t, r) {
    r = r || {};
    let n = r.batches != null, o = e28.testFunction, s10 = [];
    if (r.verbose > 0) throw new Rt("Verbose mode is not implemented yet.");
    x.assert(!n || r.batches > 0 && Number.isInteger(r.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(r.batches)}`);
    let i = Z5(t) ? t : await t.iterator(), a = 0, u = 0;
    for (; !n || u < r.batches; ) {
      let l = await i.next();
      if (s10 = M(() => {
        if (l.value) {
          let { xs: c, ys: p } = vD(e28, l.value), m = c.concat(p), f = M(() => o(m));
          if (Mt(m), u === 0) for (let d = 0; d < f.length; ++d) s10.push($t(0));
          let h = m[0].shape[0];
          for (let d = 0; d < f.length; ++d) {
            let g = f[d], y = s10[d];
            s10[d] = M(() => Y(s10[d], F(h, g))), u > 0 && Mt(y);
          }
          Mt(f), a += h, ++u;
        }
        return s10;
      }), l.done) {
        n && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${r.batches} batches). You may need to use the repeat() function when building your dataset.`);
        break;
      }
    }
    for (let l = 0; l < s10.length; ++l) {
      let c = s10[l];
      s10[l] = ut(s10[l], a), Mt(c);
    }
    return Ir(s10);
  }
  function Jx(e28) {
    x.assert(e28 > 0 && Number.isInteger(e28), () => `batchSize is required to be a positive integer, but got ${e28}`);
  }
  function um(e28, t, r) {
    return e28 == null ? [null] : Array.isArray(e28) ? e28.map((n) => ta(n, t, r - t)) : ta(e28, t, r - t);
  }
  function Zx(e28, t) {
    return M(() => e28 == null ? null : Array.isArray(e28) ? e28.map((r) => Zx(r, t)) : Ax(e28, t.dtype === "int32" ? t : Z(t, "int32")));
  }
  function Qx(e28, t) {
    let r = [], n = 0, o = null;
    for (; n < e28; ) o = n + t, o >= e28 && (o = e28), r.push([n, o]), n = o;
    return r;
  }
  function B1(e28) {
    let t = [];
    e28 instanceof ee && (e28 = [e28]);
    for (let r = 0; r < e28.length; ++r) {
      let n = e28[r];
      if (n.rank === 1) t.push(ea(n, 1));
      else {
        if (n.rank === 0) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        t.push(n);
      }
    }
    return t;
  }
  function ko(e28, t) {
    if (e28 == null) return;
    let r = [];
    if (t instanceof ee) r.push(t.id);
    else if (Array.isArray(t)) t.forEach((o) => r.push(o.id));
    else if (t != null) for (let o in t) {
      let s10 = t[o];
      r.push(s10.id);
    }
    let n = [];
    if (e28 instanceof ee) r.indexOf(e28.id) === -1 && n.push(e28);
    else if (Array.isArray(e28)) e28.forEach((o) => {
      r.indexOf(o.id) === -1 && n.push(o);
    });
    else if (e28 != null) for (let o in e28) {
      let s10 = e28[o];
      r.indexOf(s10.id) === -1 && n.push(s10);
    }
    n.forEach((o) => {
      o.isDisposed || o.dispose();
    });
  }
  function Q5(e28) {
    return e28 instanceof ee;
  }
  function V1(e28) {
    return Array.isArray(e28);
  }
  function SD(e28) {
    return !Q5(e28) && !V1(e28);
  }
  function ID(e28, t, r, n = true, o = "") {
    if (t == null || t.length === 0) {
      if (e28 != null) {
        let i = false;
        if (V1(e28) && e28.length > 0) i = true;
        else if (SD(e28)) {
          for (let a in e28) if (e28.hasOwnProperty(a)) {
            i = true;
            break;
          }
        } else i = true;
        if (i) throw new P(`Error when checking model ${o} expected no data, but got ${e28}`);
      }
      return [];
    }
    if (e28 == null) return t.map((i) => null);
    let s10;
    if (SD(e28)) {
      e28 = e28, s10 = [];
      for (let i of t) {
        if (e28[i] == null) throw new P(`No data provided for "${i}". Need data for each key in: ${t}`);
        s10.push(e28[i]);
      }
    } else if (V1(e28)) {
      if (e28 = e28, e28.length !== t.length) throw new P(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e28}`);
      s10 = e28;
    } else {
      if (e28 = e28, t.length > 1) throw new P(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e28.shape}`);
      s10 = [e28];
    }
    if (s10 = B1(s10), r != null) for (let i = 0; i < t.length; ++i) {
      if (r[i] == null) continue;
      let a = s10[i];
      if (a.shape.length !== r[i].length) throw new P(`Error when checking ${o}: expected ${t[i]} to have ${r[i].length} dimension(s). but got array with shape ${a.shape}`);
      for (let u = 0; u < r[i].length; ++u) {
        if (u === 0 && !n) continue;
        let l = a.shape[u], c = r[i][u];
        if (c != null && c >= 0 && l !== c) throw new P(`${o} expected a batch of elements where each example has shape [${r[i].slice(1, r[i].length)}] (i.e.,tensor shape [*,${r[i].slice(1, r[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1, a.shape.length)}] (tensor shape [${a.shape}])`);
      }
    }
    return s10;
  }
  function tq(e28, t, r) {
    let n = So(e28.map((s10) => s10.shape[0]));
    n.sort();
    let o = So(t.map((s10) => s10.shape[0]));
    if (o.sort(), n.length > 1) throw new P(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e28.map((s10) => s10.shape))}`);
    if (o.length > 1) throw new P(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((s10) => s10.shape))}`);
    if (n.length > 0 && o.length > 0 && !x.arraysEqual(n, o)) throw new P(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`);
  }
  function eq(e28, t, r) {
    let n = [Hl, im, Kl];
    for (let o = 0; o < e28.length; ++o) {
      let s10 = e28[o], i = t[o], a = r[o];
      if (i != null) {
        if (i === Kl && s10.shape[s10.shape.length - 1] === 1) throw new P(`You are passing a target array of shape ${s10.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
        if (n.indexOf(i) !== -1) {
          let u = s10.shape.slice(1), l = a.slice(1);
          for (let c = 0; c < u.length; ++c) {
            let p = u[c], m = l[c];
            if (m != null && p !== m) throw new P(`A target Tensor with shape ${s10.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`);
          }
        }
      }
    }
  }
  function TD(e28, t, r, n = true, o = "") {
    let s10;
    if (Array.isArray(e28)) {
      if (e28.length !== t.length) throw new P(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e28.length} Tensors(s).`);
      s10 = e28;
    } else {
      if (t.length > 1) throw new P(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e28.shape)}.`);
      s10 = [e28];
    }
    if (r != null) for (let i = 0; i < t.length; ++i) {
      if (r[i] == null) continue;
      let a = s10[i];
      if (a.shape.length !== r[i].length) throw new P(`Error when checking ${o}: expected ${t[i]} to have ${r[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);
      for (let u = 0; u < r[i].length; ++u) {
        if (u === 0 && !n) continue;
        let l = a.shape[u], c = r[i][u];
        if (c != null && c !== l) throw new P(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(r[i])} but got array with shape ${JSON.stringify(a.shape)}.`);
      }
    }
  }
  function rq(e28, t) {
    if (e28 == null || Array.isArray(e28) && e28.length === 0) return t.map((n) => []);
    let r;
    if (typeof e28 == "string" || typeof e28 == "function") r = [e28];
    else if (Array.isArray(e28) || typeof e28 == "object") r = e28;
    else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e28}`);
    if (Array.isArray(r)) return t.map((n) => r);
    {
      let n = [];
      for (let o of t) {
        let s10 = r.hasOwnProperty(o) ? r[o] : [];
        Array.isArray(s10) || (s10 = [s10]), n.push(s10);
      }
      return n;
    }
  }
  var nq = "layers-model";
  var Eo = class extends qx {
    constructor(t) {
      super(t), this.isTraining = false;
    }
    summary(t, r, n = console.log) {
      if (!this.built) throw new P("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
      gD(this, t, r, n);
    }
    compile(t) {
      if (t.loss == null && (t.loss = []), this.loss = t.loss, typeof t.optimizer == "string") this.optimizer_ = dD(t.optimizer), this.isOptimizerOwned = true;
      else {
        if (!(t.optimizer instanceof Ur)) throw new P("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = t.optimizer, this.isOptimizerOwned = false;
      }
      let r = [];
      if (!Array.isArray(t.loss) && typeof t.loss != "string" && typeof t.loss != "function") {
        t.loss = t.loss;
        for (let i in t.loss) if (this.outputNames.indexOf(i) === -1) throw new P(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);
        for (let i of this.outputNames) t.loss[i] == null && console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`), r.push(Vx(t.loss[i]));
      } else if (Array.isArray(t.loss)) {
        if (t.loss.length !== this.outputs.length) throw new P(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);
        r = t.loss.map((a) => Vx(a));
      } else {
        let i = Vx(t.loss);
        this.outputs.forEach((a) => {
          r.push(i);
        });
      }
      this.lossFunctions = r, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
      for (let i = 0; i < this.outputs.length; ++i) {
        let a = this.internalOutputShapes[i], u = this.outputNames[i];
        this.feedOutputNames.push(u), this.feedOutputShapes.push(a), this.feedLossFns.push(this.lossFunctions[i]);
      }
      let n = [];
      this.metrics = t.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], Ho("loss", () => {
        for (let i = 0; i < this.outputs.length; ++i) {
          if (n.indexOf(i) !== -1) continue;
          let a = this.lossFunctions[i];
          this.outputs.length > 1 && (this.metricsTensors.push([a, i]), this.metricsNames.push(this.outputNames[i] + "_loss"));
        }
      });
      let o = rq(t.metrics, this.outputNames), s10 = (i, a, u) => {
        this.outputNames.length > 1 && (a = this.outputNames[i] + "_" + a), this.metricsNames.push(a), this.metricsTensors.push([u, i]);
      };
      Ho("metric", () => {
        for (let i = 0; i < this.outputs.length; ++i) {
          if (n.indexOf(i) !== -1) continue;
          let a = o[i];
          ((l) => {
            let c = "", p, m, f;
            for (let h of l) {
              if (typeof h == "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(h) !== -1) {
                let g = this.internalOutputShapes[i];
                g[g.length - 1] === 1 || this.lossFunctions[i] === im ? ["accuracy", "acc"].indexOf(h) !== -1 ? m = Wx : ["crossentropy", "ce"].indexOf(h) !== -1 && (m = R1) : this.lossFunctions[i] === sm ? ["accuracy", "acc"].indexOf(h) !== -1 ? m = P1 : ["crossentropy", "ce"].indexOf(h) !== -1 && (m = L1) : ["accuracy", "acc"].indexOf(h) !== -1 ? m = Ux : ["crossentropy", "ce"].indexOf(h) !== -1 && (m = jx);
                let y;
                ["accuracy", "acc"].indexOf(h) !== -1 ? y = "acc" : ["crossentropy", "ce"].indexOf(h) !== -1 && (y = "ce"), f = m, p = c + y;
              } else f = fD(h), p = c + Ph(h);
              let d;
              Ho(p, () => {
                d = f;
              }), s10(i, p, d);
            }
          })(a);
        }
      }), this.collectedTrainableWeights = this.trainableWeights;
    }
    checkTrainableWeightsConsistency() {
      this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }
    evaluate(t, r, n = {}) {
      let o = n.batchSize == null ? 32 : n.batchSize;
      Jx(o);
      let i = this.standardizeUserDataXY(t, r, true, o);
      try {
        let a = i[0].concat(i[1]);
        this.makeTestFunction();
        let u = this.testFunction, l = this.testLoop(u, a, o, n.verbose, n.steps);
        return Ir(l);
      } finally {
        ko(i[0], t), ko(i[1], r);
      }
    }
    async evaluateDataset(t, r) {
      return this.makeTestFunction(), CD(this, t, r);
    }
    checkNumSamples(t, r, n, o = "steps") {
      let s10;
      if (n != null) {
        if (s10 = null, r != null) throw new P(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`);
      } else if (t != null) Array.isArray(t) ? s10 = t[0].shape[0] : s10 = t.shape[0];
      else throw new P(`Either the input data should have a defined shape, or ${o} shoud be specified.`);
      return s10;
    }
    execute(t, r) {
      if (Array.isArray(r) && r.length === 0) throw new P("`outputs` is an empty Array, which is not allowed.");
      let n = Array.isArray(r), o = n ? r : [r], s10 = this.retrieveSymbolicTensors(o), i = new Ds();
      if (t instanceof ee && (t = [t]), Array.isArray(t)) {
        if (t.length !== this.inputs.length) throw new P(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
        for (let u = 0; u < this.inputs.length; ++u) i.add(this.inputs[u], t[u]);
      } else for (let u of this.inputs) {
        let l = t[u.name];
        if (l == null) throw new P(`No value is provided for the model's input ${u.name}`);
        i.add(u, l);
      }
      let a = Ul(s10, i);
      return n ? a : a[0];
    }
    retrieveSymbolicTensors(t) {
      let r = No(null, t.length), n = t.length;
      for (let o of this.layers) {
        let s10 = Array.isArray(o.output) ? o.output : [o.output], i = s10.map((a) => a.name);
        for (let a = 0; a < t.length; ++a) {
          let u = i.indexOf(t[a]);
          if (u !== -1 && (r[a] = s10[u], n--), n === 0) break;
        }
        if (n === 0) break;
      }
      if (n > 0) {
        let o = [];
        throw r.forEach((s10, i) => {
          s10 == null && o.push(t[i]);
        }), new P(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`);
      }
      return r;
    }
    predictLoop(t, r = 32, n = false) {
      return M(() => {
        let o = this.checkNumSamples(t);
        if (n) throw new Rt("Verbose predictLoop() is not implemented yet.");
        let s10 = Qx(o, r), i = this.outputs.map((a) => []);
        for (let a = 0; a < s10.length; ++a) M(() => {
          let l = s10[a][0], c = s10[a][1], p = um(t, l, c), m = [];
          if (Array.isArray(p)) for (let h = 0; h < p.length; ++h) m.push({ key: this.inputs[h], value: p[h] });
          else m.push({ key: this.inputs[0], value: p });
          let f = new Ds(m);
          return Ul(this.outputs, f);
        }).forEach((l, c) => i[c].push(l));
        return Ir(i.map((a) => Ne(a, 0)));
      });
    }
    predict(t, r = {}) {
      let n = B1(t);
      TD(n, this.inputNames, this.feedInputShapes, false);
      try {
        let o = r.batchSize == null ? 32 : r.batchSize;
        return Jx(o), this.predictLoop(n, o);
      } finally {
        ko(n, t);
      }
    }
    predictOnBatch(t) {
      TD(t, this.inputNames, this.feedInputShapes, true);
      let r = (Array.isArray(t) ? t[0] : t).shape[0];
      return this.predictLoop(t, r);
    }
    standardizeUserDataXY(t, r, n = true, o) {
      if (this.optimizer_ == null) throw new cn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      let s10 = [];
      for (let i = 0; i < this.feedOutputShapes.length; ++i) {
        let a = this.feedOutputShapes[i];
        this.feedLossFns[i] === sm ? s10.push(a.slice(0, a.length - 1).concat([1])) : s10.push(a);
      }
      if (t = ID(t, this.feedInputNames, this.feedInputShapes, false, "input"), r = ID(r, this.feedOutputNames, s10, false, "target"), tq(t, r, null), eq(r, this.feedLossFns, this.feedOutputShapes), this.stateful && o != null && o > 0 && t[0].shape[0] % o !== 0) throw new P(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);
      return [t, r];
    }
    async standardizeUserData(t, r, n, o, s10 = true, i) {
      let [a, u] = this.standardizeUserDataXY(t, r, s10, i);
      if (n != null) throw new Error("sample weight is not supported yet.");
      let l = null;
      if (o != null) {
        let c = Xx(o, this.outputNames);
        l = [];
        for (let p = 0; p < c.length; ++p) l.push(await Yx(u[p], null, c[p]));
      }
      return [a, u, l];
    }
    testLoop(t, r, n, o = 0, s10) {
      return M(() => {
        let i = this.checkNumSamples(r, n, s10, "steps"), a = [];
        if (o > 0) throw new Rt("Verbose mode is not implemented yet.");
        if (s10 != null) throw new Rt("steps mode in testLoop() is not implemented yet");
        {
          let u = Qx(i, n), l = sr(mn(0, i));
          for (let c = 0; c < u.length; ++c) {
            let p = u[c][0], m = u[c][1], f = ta(l, p, m - p), h = Zx(r, f), d = t(h);
            if (c === 0) for (let g = 0; g < d.length; ++g) a.push($t(0));
            for (let g = 0; g < d.length; ++g) {
              let y = d[g];
              a[g] = Y(a[g], F(m - p, y));
            }
          }
          for (let c = 0; c < a.length; ++c) a[c] = ut(a[c], i);
        }
        return a;
      });
    }
    getDedupedMetricsNames() {
      let t = this.metricsNames, r = [];
      for (let n = 0; n < t.length; ++n) {
        let o = t[n], s10 = o;
        if (I1(t, o) > 1) {
          let i = I1(t.slice(0, n), o);
          s10 += `_${i}`;
        }
        r.push(s10);
      }
      return r;
    }
    makeTrainFunction() {
      return (t) => {
        let r = [], n = t.slice(0, this.inputs.length), o = t.slice(this.inputs.length, this.inputs.length + this.outputs.length), s10 = t.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2), i = [], a = () => {
          let p = [];
          for (let d = 0; d < this.inputs.length; ++d) p.push({ key: this.inputs[d], value: n[d] });
          let m = new Ds(p), f = Ul(this.outputs, m, { training: true }), h;
          for (let d = 0; d < this.lossFunctions.length; ++d) {
            let g = this.lossFunctions[d], y = g(o[d], f[d]);
            s10[d] != null && (y = xD(y, s10[d]));
            let b = ke(y);
            r.push(b), d === 0 ? h = y : h = Y(h, y);
          }
          for (let d = 0; d < this.metricsTensors.length; ++d) {
            let g;
            if (this.outputs.length > 1 && d < this.outputs.length) g = r[d];
            else {
              let y = this.metricsTensors[d][0], b = this.metricsTensors[d][1];
              g = ke(y(o[b], f[b]));
            }
            wr(g), i.push(g);
          }
          return h = ke(h), this.calculateLosses().forEach((d) => {
            h = Y(h, d);
          }), h;
        }, u = this.collectedTrainableWeights.map((p) => p.read());
        return [this.optimizer_.minimize(a, true, u)].concat(i);
      };
    }
    makeTestFunction() {
      this.testFunction = (t) => M(() => {
        let r = [], n, o = t.slice(0, this.inputs.length), s10 = t.slice(this.inputs.length, this.inputs.length + this.outputs.length), i = [];
        for (let l = 0; l < this.inputs.length; ++l) i.push({ key: this.inputs[l], value: o[l] });
        let a = new Ds(i), u = Ul(this.outputs, a);
        for (let l = 0; l < this.lossFunctions.length; ++l) {
          let c = this.lossFunctions[l], p = ke(c(s10[l], u[l]));
          l === 0 ? n = p : n = Y(n, p), r.push(n);
        }
        for (let l = 0; l < this.metricsTensors.length; ++l) {
          let c = this.metricsTensors[l][0], p = this.metricsTensors[l][1], m = ke(c(s10[p], u[p]));
          r.push(m);
        }
        return r;
      });
    }
    async fit(t, r, n = {}) {
      if (this.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
      this.isTraining = true;
      let o, s10, i, a, u, l, c, p, m;
      try {
        let f = n.batchSize == null ? 32 : n.batchSize;
        Jx(f);
        let d = await this.standardizeUserData(t, r, n.sampleWeight, n.classWeight, false, f);
        o = d[0], s10 = d[1], m = d[2];
        let g = false, y;
        if (n.validationData != null && n.validationData.length > 0) {
          if (g = true, n.validationData.length === 2) u = n.validationData[0], l = n.validationData[1];
          else throw n.validationData.length === 3 ? new Rt("validationData including sample weights is not supported yet.") : new P(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);
          let L = await this.standardizeUserData(u, l, null, null, true, f);
          c = L[0], p = L[1], y = c.concat(p);
        } else if (n.validationSplit != null && n.validationSplit > 0 && n.validationSplit < 1) {
          g = true;
          let R = Math.floor(o[0].shape[0] * (1 - n.validationSplit)), L = o[0].shape[0];
          c = um(o, R, L), i = o, o = um(o, 0, R), p = um(s10, R, L), a = s10, s10 = um(s10, 0, R), y = c.concat(p);
        } else n.validationSteps != null && (g = true);
        let b = o.concat(s10).concat(m);
        this.checkTrainableWeightsConsistency();
        let v = this.makeTrainFunction(), w = this.getDedupedMetricsNames(), N, E;
        g ? (this.makeTestFunction(), N = this.testFunction, E = w.slice().concat(w.map((R) => "val_" + R))) : (N = null, y = [], E = w.slice());
        let A = Mx(n.callbacks, n.yieldEvery);
        return await this.fitLoop(v, b, w, f, n.epochs, n.verbose, A, N, y, n.shuffle, E, n.initialEpoch, null, null);
      } finally {
        this.isTraining = false, ko(o, t), ko(s10, r), ko(i, t), ko(a, r), ko(c, u), ko(p, l), m != null && Mt(m);
      }
    }
    async fitLoop(t, r, n, o, s10, i, a, u, l, c, p, m, f, h) {
      o == null && (o = 32), s10 == null && (s10 = 1), c == null && (c = true), m == null && (m = 0);
      let d = false;
      if (u != null && l != null && (d = true), h != null && (d = true, f == null)) throw new P("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
      let g = this.checkNumSamples(r, o, f, "steps_per_epoch"), y;
      g != null && (y = mn(0, g)), i == null && (i = 1);
      let { callbackList: b, history: v } = zx(a, i, s10, m, g, f, o, d, p);
      b.setModel(this), this.history = v, await b.onTrainBegin(), this.stopTraining_ = false;
      for (let w = m; w < s10; ++w) {
        await b.onEpochBegin(w);
        let N = {};
        if (f != null) throw new Rt("stepsPerEpoch mode is not implemented yet.");
        {
          if (c === "batch") throw new Rt("batch shuffling is not implemneted yet");
          c && x.shuffle(y);
          let E = sr(y), A = Qx(g, o);
          for (let D = 0; D < A.length; ++D) {
            let R = {};
            if (await b.onBatchBegin(D, R), M(() => {
              let L = A[D][0], G = A[D][1], W = ta(E, L, G - L);
              R.batch = D, R.size = G - L;
              let U = Zx(r, W), H = t(U);
              for (let j = 0; j < n.length; ++j) {
                let X = n[j], Q = H[j];
                R[X] = Q, wr(Q);
              }
              if (D === A.length - 1 && d) {
                let j = this.testLoop(u, l, o);
                for (let X = 0; X < n.length; ++X) {
                  let Q = n[X], q = j[X];
                  wr(q), N["val_" + Q] = q;
                }
              }
            }), await b.onBatchEnd(D, R), Ox(R), this.stopTraining_) break;
          }
          E.dispose();
        }
        if (await b.onEpochEnd(w, N), this.stopTraining_) break;
      }
      return await b.onTrainEnd(), await this.history.syncData(), this.history;
    }
    async fitDataset(t, r) {
      return ND(this, t, r);
    }
    async trainOnBatch(t, r) {
      let n = await this.standardizeUserData(t, r), o = n[0], s10 = n[1], a = this.makeTrainFunction()(o.concat(s10)), u = [];
      for (let l of a) {
        let c = await l.data();
        u.push(c[0]);
      }
      return Mt(a), ko(n[0], t), ko(n[1], r), Ir(u);
    }
    getNamedWeights(t) {
      let r = [], n = t != null && t.trainableOnly, o = n ? this.trainableWeights : this.weights, s10 = this.getWeights(n);
      for (let i = 0; i < o.length; ++i) n && !o[i].trainable || r.push({ name: o[i].originalName, tensor: s10[i] });
      return r;
    }
    set stopTraining(t) {
      this.stopTraining_ = t;
    }
    get stopTraining() {
      return this.stopTraining_;
    }
    get optimizer() {
      return this.optimizer_;
    }
    set optimizer(t) {
      this.optimizer_ !== t && (this.optimizer_ = t, this.isOptimizerOwned = false);
    }
    dispose() {
      let t = super.dispose();
      if (t.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
        let r = Mf().numTensors;
        this.optimizer_.dispose(), t.numDisposedVariables += r - Mf().numTensors;
      }
      return t;
    }
    getLossIdentifiers() {
      let t;
      if (typeof this.loss == "string") t = Co(this.loss);
      else if (Array.isArray(this.loss)) {
        for (let r of this.loss) if (typeof r != "string") throw new Error("Serialization of non-string loss is not supported.");
        t = this.loss.map((r) => Co(r));
      } else {
        let r = Object.keys(this.loss);
        t = {};
        let n = this.loss;
        for (let o of r) if (typeof n[o] == "string") t[o] = Co(n[o]);
        else throw new Error("Serialization of non-string loss is not supported.");
      }
      return t;
    }
    getMetricIdentifiers() {
      if (typeof this.metrics == "string" || typeof this.metrics == "function") return [Co(Ph(this.metrics))];
      if (Array.isArray(this.metrics)) return this.metrics.map((t) => Co(Ph(t)));
      {
        let t = {};
        for (let r in this.metrics) t[r] = Co(Ph(this.metrics[r]));
        return t;
      }
    }
    getTrainingConfig() {
      return { loss: this.getLossIdentifiers(), metrics: this.getMetricIdentifiers(), optimizer_config: { class_name: this.optimizer.getClassName(), config: this.optimizer.getConfig() } };
    }
    loadTrainingConfig(t) {
      if (t.weighted_metrics != null) throw new Error("Loading weight_metrics is not supported yet.");
      if (t.loss_weights != null) throw new Error("Loading loss_weights is not supported yet.");
      if (t.sample_weight_mode != null) throw new Error("Loading sample_weight_mode is not supported yet.");
      let r = Lh(t.optimizer_config), n = zn(r), o;
      if (typeof t.loss == "string") o = Qi(t.loss);
      else if (Array.isArray(t.loss)) o = t.loss.map((i) => Qi(i));
      else if (t.loss != null) {
        o = {};
        for (let i in t.loss) o[i] = Qi(t.loss[i]);
      }
      let s10;
      if (Array.isArray(t.metrics)) s10 = t.metrics.map((i) => Qi(i));
      else if (t.metrics != null) {
        s10 = {};
        for (let i in t.metrics) s10[i] = Qi(t.metrics[i]);
      }
      this.compile({ loss: o, metrics: s10, optimizer: n });
    }
    async save(t, r) {
      if (typeof t == "string") {
        let l = Zi.getSaveHandlers(t);
        if (l.length === 0) throw new P(`Cannot find any save handlers for URL '${t}'`);
        if (l.length > 1) throw new P(`Found more than one (${l.length}) save handlers for URL '${t}'`);
        t = l[0];
      }
      if (t.save == null) throw new P("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      let n = await Zi.encodeWeights(this.getNamedWeights(r)), a = { modelTopology: this.toJSON(null, false), format: nq, generatedBy: `TensorFlow.js tfjs-layers v${am}`, convertedBy: null };
      if ((r == null ? false : r.includeOptimizer) && this.optimizer != null) {
        a.trainingConfig = this.getTrainingConfig();
        let l = "optimizer", { data: c, specs: p } = await Zi.encodeWeights(await this.optimizer.getWeights(), l);
        n.specs.push(...p), n.data = Zi.concatenateArrayBuffers([n.data, c]);
      }
      return this.userDefinedMetadata != null && (z1(this.userDefinedMetadata, this.name, true), a.userDefinedMetadata = this.userDefinedMetadata), a.weightData = n.data, a.weightSpecs = n.specs, t.save(a);
    }
    setUserDefinedMetadata(t) {
      z1(t, this.name), this.userDefinedMetadata = t;
    }
    getUserDefinedMetadata() {
      return this.userDefinedMetadata;
    }
  };
  Eo.className = "Model";
  K.registerClass(Eo);
  var tb = class extends Eo {
  };
  tb.className = "Functional";
  K.registerClass(tb);
  var lm = class e16 extends Eo {
    constructor(t) {
      if (super({ inputs: [], outputs: [] }), t = t || {}, this.trainable = true, this.built = false, this.name = t.name != null ? t.name : Du("sequential_"), t.layers != null) for (let r of t.layers) this.add(r);
    }
    checkShape(t) {
      if (t.inboundNodes[0].outputTensors[0].shape.some((n) => n < 0)) throw new P(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`);
    }
    add(t) {
      let r = t instanceof e16 || t instanceof Eo, n;
      if (r) {
        if (n = t, n.outputs.length !== 1) throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        if (n.inputs.length !== 1) throw new P("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
      }
      if (this.outputs.length === 0) {
        if (t.inboundNodes.length === 0) {
          if (t.batchInputShape == null) throw new P("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
          let o = F1({ batchShape: t.batchInputShape, dtype: t.dtype, name: t.name + "_input" });
          t.apply(o);
        }
        if (r) this.outputs = n.outputs, this.inputs = n.inputs;
        else {
          if (t.inboundNodes.length !== 1) throw new P(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);
          if (t.inboundNodes[0].outputTensors.length !== 1) throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          this.checkShape(t), this.outputs = [t.inboundNodes[0].outputTensors[0]], this.inputs = $1(this.outputs[0]);
        }
        this.inboundNodes = [], new ra({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: this.inputs, outputTensors: this.outputs, inputMasks: No(null, this.inputs.length), outputMasks: [null], inputShapes: this.inputs.map((o) => o.shape), outputShapes: this.outputs[0].shape });
      } else {
        let o = t.apply(this.outputs[0]);
        if (Array.isArray(o)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(t), this.outputs = [o], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
      this.layers.push(t), this.built = false;
    }
    pop() {
      if (this.layers.length === 0) throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), this.layers.length === 0) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
      else {
        let t = this.layers.length - 1;
        this.layers[t].outboundNodes = [], this.outputs = [this.layers[t].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
    }
    call(t, r) {
      return this.model == null && this.build(), this.model.call(t, r);
    }
    build(t) {
      if (jt(t), this.inputs.length === 0 || this.outputs.length === 0) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new Eo({ inputs: this.inputs, outputs: this.outputs[0], name: this.name + "_model" }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
    }
    countParams() {
      return this.built || this.build(), super.countParams();
    }
    summary(t, r, n = console.log) {
      this.built || this.build(), super.summary(t, r, n);
    }
    setWeights(t) {
      this.model == null && this.build(), this.model.setWeights(t);
    }
    evaluate(t, r, n = {}) {
      if (!this.built) throw new cn("The model needs to be compiled before being used.");
      return this.model.evaluate(t, r, n);
    }
    async evaluateDataset(t, r) {
      if (!this.built) throw new cn("The model needs to be compiled before being used.");
      return this.model.evaluateDataset(t, r);
    }
    predict(t, r = {}) {
      return this.model == null && this.build(), this.model.predict(t, r);
    }
    predictOnBatch(t) {
      return this.model == null && this.build(), this.model.predictOnBatch(t);
    }
    compile(t) {
      this.build(), this.model.compile(t), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
    }
    get optimizer() {
      return this.model == null ? void 0 : this.model.optimizer;
    }
    set optimizer(t) {
      this.model.optimizer = t;
    }
    async fit(t, r, n = {}) {
      if (!this.built) throw new cn("The model needs to be compiled before being used.");
      return this.model.fit(t, r, n);
    }
    async fitDataset(t, r) {
      if (!this.built) throw new cn("The model needs to be compiled before being used.");
      return this.model.fitDataset(t, r);
    }
    async trainOnBatch(t, r) {
      return this.model.trainOnBatch(t, r);
    }
    static fromConfig(t, r, n = {}, o = false) {
      let s10, i = {};
      if (r instanceof Array) {
        if (r[0].className == null || r[0].className === "Merge") throw new P("Legacy serialization format not supported yet.");
        s10 = r;
      } else x.assert(r.layers != null, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), s10 = r.layers, delete r.layers, i = r;
      let a = new t(i);
      if (!(a instanceof e16)) throw new Rt(`Sequential.fromConfig called on non-Sequential input: ${a}`);
      for (let u of s10) {
        let c = zn(u, void 0, o);
        o && c.setFastWeightInitDuringBuild(true), a.add(c);
      }
      return a;
    }
    set stopTraining(t) {
      if (this.model == null) throw new P("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = t;
    }
    get stopTraining() {
      if (this.model == null) throw new P("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    }
    getConfig() {
      let t = [];
      for (let r of this.layers) {
        let n = {};
        n.className = r.getClassName(), n.config = r.getConfig(), t.push(n);
      }
      return { name: this.name, layers: t };
    }
  };
  lm.className = "Sequential";
  K.registerClass(lm);
  var Or = class extends K.Serializable {
    getConfig() {
      return {};
    }
  };
  var eb = class extends Or {
    apply(t, r = 1) {
      return JA(t, r);
    }
  };
  eb.className = "elu";
  K.registerClass(eb);
  var rb = class extends Or {
    apply(t) {
      return eh(t);
    }
  };
  rb.className = "selu";
  K.registerClass(rb);
  var nb = class extends Or {
    apply(t) {
      return Ln(t);
    }
  };
  nb.className = "relu";
  K.registerClass(nb);
  var ob = class extends Or {
    apply(t) {
      return M(() => Is(6, Ln(t)));
    }
  };
  ob.className = "relu6";
  K.registerClass(ob);
  var sb = class extends Or {
    apply(t) {
      return t;
    }
  };
  sb.className = "linear";
  K.registerClass(sb);
  var ib = class extends Or {
    apply(t) {
      return xo(t);
    }
  };
  ib.className = "sigmoid";
  K.registerClass(ib);
  var ab = class extends Or {
    apply(t) {
      return QA(t);
    }
  };
  ab.className = "hardSigmoid";
  K.registerClass(ab);
  var ub = class extends Or {
    apply(t) {
      return Ss(t);
    }
  };
  ub.className = "softplus";
  K.registerClass(ub);
  var lb = class extends Or {
    apply(t) {
      return ZA(t);
    }
  };
  lb.className = "softsign";
  K.registerClass(lb);
  var cb = class extends Or {
    apply(t) {
      return Sl(t);
    }
  };
  cb.className = "tanh";
  K.registerClass(cb);
  var cm = class extends Or {
    apply(t, r = -1) {
      return Ol(t, r);
    }
  };
  cm.className = "softmax";
  K.registerClass(cm);
  var pb = class extends Or {
    apply(t, r = -1) {
      return Yf(t, r);
    }
  };
  pb.className = "logSoftmax";
  K.registerClass(pb);
  var mb = class extends Or {
    apply(t) {
      return M(() => M(() => {
        let r = Math.sqrt(2), n = F(0.5, Y(1, Kf(ut(t, r))));
        return F(t, n);
      }));
    }
  };
  mb.className = "gelu";
  K.registerClass(mb);
  var fb = class extends Or {
    apply(t) {
      return M(() => F(0.5, F(t, Y(1, Sl(F(ge(ut(2, Math.PI)), Y(t, F(0.044715, wn(t, 3)))))))));
    }
  };
  fb.className = "gelu_new";
  K.registerClass(fb);
  var hb = class extends Or {
    apply(t) {
      return M(() => F(t, Sl(Ss(t))));
    }
  };
  hb.className = "mish";
  K.registerClass(hb);
  var db = class extends Or {
    apply(t, r = 1) {
      return M(() => F(xo(F(t, r)), t));
    }
  };
  db.className = "swish";
  K.registerClass(db);
  function qo(e28) {
    return e28.getClassName();
  }
  function G1(e28, t = {}) {
    return ks(e28, K.SerializationMap.getMap().classNameMap, t, "activation");
  }
  function Xo(e28) {
    if (e28 == null) {
      let t = {};
      return t.className = "linear", t.config = {}, G1(t);
    }
    if (typeof e28 == "string") {
      let t = {};
      return t.className = e28, t.config = {}, G1(t);
    } else return e28 instanceof Or ? e28 : G1(e28);
  }
  function sq(e28) {
    if (e28 != null && typeof e28 != "object") throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e28}`);
  }
  var gb = class extends K.Serializable {
  };
  var Mh = class extends gb {
    constructor(t) {
      super(), sq(t), this.l1 = t == null || t.l1 == null ? 0.01 : t.l1, this.l2 = t == null || t.l2 == null ? 0.01 : t.l2, this.hasL1 = this.l1 !== 0, this.hasL2 = this.l2 !== 0;
    }
    apply(t) {
      return M(() => {
        let r = Se([1]);
        return this.hasL1 && (r = Y(r, ht(F(this.l1, cr(t))))), this.hasL2 && (r = Y(r, ht(F(this.l2, Gl(t))))), _(r, []);
      });
    }
    getConfig() {
      return { l1: this.l1, l2: this.l2 };
    }
    static fromConfig(t, r) {
      return new t({ l1: r.l1, l2: r.l2 });
    }
  };
  Mh.className = "L1L2";
  K.registerClass(Mh);
  var kD = { l1l2: "L1L2" };
  function ce(e28) {
    return Hp(e28);
  }
  function ED(e28, t = {}) {
    return ks(e28, K.SerializationMap.getMap().classNameMap, t, "regularizer");
  }
  function xe(e28) {
    if (e28 == null) return null;
    if (typeof e28 == "string") {
      let r = { className: e28 in kD ? kD[e28] : e28, config: {} };
      return ED(r);
    } else return e28 instanceof gb ? e28 : ED(e28);
  }
  var zh = class extends Pt {
    constructor(t) {
      super(t ?? {}), this.supportsMasking = true, t != null && (this.maxValue = t.maxValue);
    }
    call(t, r) {
      t = Ft(t);
      let n = Ln(t);
      return this.maxValue != null && (n = Fr(n, 0, this.maxValue)), n;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = { maxValue: this.maxValue }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  zh.className = "ReLU";
  K.registerClass(zh);
  var Bh = class extends Pt {
    constructor(t) {
      super(t ?? {}), this.DEFAULT_ALPHA = 0.3, t == null && (t = {}), this.alpha = t.alpha == null ? this.DEFAULT_ALPHA : t.alpha;
    }
    call(t, r) {
      let n = Ft(t);
      return kl(n, this.alpha);
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = { alpha: this.alpha }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Bh.className = "LeakyReLU";
  K.registerClass(Bh);
  var Vh = class extends Pt {
    constructor(t) {
      if (super(t ?? {}), this.DEFAULT_ALPHA_INITIALIZER = "zeros", t == null && (t = {}), this.supportsMasking = true, this.alphaInitializer = he(t.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = xe(t.alphaRegularizer), this.alphaConstraint = Re(t.alphaConstraint), t.sharedAxes == null) this.sharedAxes = null;
      else if (Array.isArray(t.sharedAxes)) this.sharedAxes = t.sharedAxes;
      else if (typeof t.sharedAxes == "number") this.sharedAxes = [t.sharedAxes];
      else throw new P(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);
    }
    build(t) {
      t = jt(t);
      let r = t.slice(1);
      if (this.sharedAxes != null) for (let o of this.sharedAxes) r[o - 1] = 1;
      this.alpha = this.addWeight("alpha", r, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
      let n = {};
      if (this.sharedAxes != null) for (let o = 1; o < t.length; ++o) n[o] = t[o];
      this.inputSpec = [new ye({ ndim: t.length, axes: n })], this.built = true;
    }
    call(t, r) {
      return t = Ft(t), $l(t, this.alpha.read());
    }
    getConfig() {
      let t = { alphaInitializer: we(this.alphaInitializer), alphaRegularizer: ce(this.alphaRegularizer), alphaConstraint: Oe(this.alphaConstraint), sharedAxes: this.sharedAxes }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Vh.className = "PReLU";
  K.registerClass(Vh);
  var Gh = class extends Pt {
    constructor(t) {
      if (super(t ?? {}), this.DEFAULT_ALPHA = 1, t == null && (t = {}), t.alpha != null && t.alpha !== this.DEFAULT_ALPHA) throw new Rt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);
      this.alpha = t.alpha == null ? this.DEFAULT_ALPHA : t.alpha;
    }
    call(t, r) {
      let n = Ft(t);
      return Xi(n);
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = { alpha: this.alpha }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Gh.className = "ELU";
  K.registerClass(Gh);
  var Wh = class extends Pt {
    constructor(t) {
      super(t ?? {}), this.DEFAULT_THETA = 1, t == null && (t = {}), this.theta = t.theta == null ? this.DEFAULT_THETA : t.theta;
    }
    call(t, r) {
      let n = Ft(t);
      return F(n, Z(je(n, this.theta), "float32"));
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = { theta: this.theta }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Wh.className = "ThresholdedReLU";
  K.registerClass(Wh);
  var Uh = class extends Pt {
    constructor(t) {
      super(t ?? {}), this.DEFAULT_AXIS = 1, t == null && (t = {}), this.softmax = new cm().apply, this.axis = t.axis == null ? this.DEFAULT_AXIS : t.axis;
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t), o = r.mask;
        if (o != null) {
          let s10 = F(xt(ln(n.shape), Z(o, n.dtype)), $t(-1e9));
          n = Y(n, s10);
        }
        return this.axis instanceof Array ? this.axis.length > 1 ? Nr(xt(n, Jf(n, this.axis, true))) : this.softmax(n, this.axis[0]) : this.softmax(n, this.axis);
      });
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = { axis: this.axis }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Uh.className = "Softmax";
  K.registerClass(Uh);
  function _u(e28, t, r) {
    if (typeof e28 == "number") return No(e28, t);
    if (e28.length !== t) throw new P(`The ${r} argument must be an integer or tuple of ${t} integers. Received: ${e28.length} elements.`);
    for (let n = 0; n < t; ++n) {
      let o = e28[n];
      if (!KA(o)) throw new P(`The ${r} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e28)} including a non-integer number ${o}`);
    }
    return e28;
  }
  function Nn(e28, t, r, n, o = 1) {
    if (e28 == null) return e28;
    let s10 = t + (t - 1) * (o - 1), i;
    return r === "same" ? i = e28 : i = e28 - s10 + 1, Math.floor((i + n - 1) / n);
  }
  function Yo(e28, t, r, n) {
    if (e28 == null) return null;
    if (n === "valid") e28 = e28 * t + Ko([r - t, 0]);
    else if (n === "same") e28 = e28 * t;
    else throw new P(`Unsupport padding mode: ${n}.`);
    return e28;
  }
  function Zh(e28, t) {
    return M(() => (Ee(t), t === "channelsFirst" ? qt(e28, [0, 2, 3, 1]) : e28));
  }
  function W1(e28, t) {
    return M(() => (Ee(t), t === "channelsFirst" ? qt(e28, [0, 2, 3, 4, 1]) : e28));
  }
  function aq(e28, t, r, n = 1, o = "valid", s10, i = 1) {
    return M(() => {
      if (s10 == null && (s10 = fn()), Ee(s10), e28.shape.length !== 3) throw new P(`The input of a conv1dWithBias operation should be 3, but is ${e28.shape.length} instead.`);
      if (t.shape.length !== 3) throw new P(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
      if (r != null && r.shape.length !== 1) throw new P(`The bias for a conv1dWithBias operation should be 1, but is ${r.shape.length} instead`);
      if (s10 === "channelsFirst" && (e28 = qt(e28, [0, 2, 1])), o === "causal") throw new Rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      let a = Wf(e28, t, n, o === "same" ? "same" : "valid", "NWC", i);
      return r != null && (a = hn(a, r)), a;
    });
  }
  function AD(e28, t, r, n = [1, 1], o = "valid", s10, i, a = null) {
    return M(() => {
      if (s10 == null && (s10 = fn()), Ee(s10), e28.rank !== 3 && e28.rank !== 4) throw new P(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e28.rank}.`);
      if (t.rank !== 3 && t.rank !== 4) throw new P(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e28.rank}.`);
      let u = Zh(e28, s10);
      if (o === "causal") throw new Rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      return u = zl.conv2d({ x: u, filter: t, strides: n, pad: o === "same" ? "same" : "valid", dilations: i, dataFormat: "NHWC", bias: r, activation: a }), s10 === "channelsFirst" && (u = qt(u, [0, 3, 1, 2])), u;
    });
  }
  function uq(e28, t, r, n = [1, 1, 1], o = "valid", s10, i) {
    return M(() => {
      if (s10 == null && (s10 = fn()), Ee(s10), e28.rank !== 4 && e28.rank !== 5) throw new P(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e28.rank}.`);
      if (t.rank !== 4 && t.rank !== 5) throw new P(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e28.rank}.`);
      let a = W1(e28, s10);
      if (o === "causal") throw new Rt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      return a = FN(a, t, n, o === "same" ? "same" : "valid", "NDHWC", i), r != null && (a = hn(a, r)), s10 === "channelsFirst" && (a = qt(a, [0, 4, 1, 2, 3])), a;
    });
  }
  var jh = class e17 extends Pt {
    constructor(t, r) {
      if (super(r), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e17.verifyArgs(r), this.rank = t, Je(this.rank, "rank"), this.rank !== 1 && this.rank !== 2 && this.rank !== 3) throw new Rt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
      if (this.kernelSize = _u(r.kernelSize, t, "kernelSize"), this.strides = _u(r.strides == null ? 1 : r.strides, t, "strides"), this.padding = r.padding == null ? "valid" : r.padding, pn(this.padding), this.dataFormat = r.dataFormat == null ? "channelsLast" : r.dataFormat, Ee(this.dataFormat), this.activation = Xo(r.activation), this.useBias = r.useBias == null ? true : r.useBias, this.biasInitializer = he(r.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = Re(r.biasConstraint), this.biasRegularizer = xe(r.biasRegularizer), this.activityRegularizer = xe(r.activityRegularizer), this.dilationRate = _u(r.dilationRate == null ? 1 : r.dilationRate, t, "dilationRate"), this.rank === 1 && Array.isArray(this.dilationRate) && this.dilationRate.length !== 1) throw new P(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      if (this.rank === 2) {
        if (typeof this.dilationRate == "number") this.dilationRate = [this.dilationRate, this.dilationRate];
        else if (this.dilationRate.length !== 2) throw new P(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      } else if (this.rank === 3) {
        if (typeof this.dilationRate == "number") this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
        else if (this.dilationRate.length !== 3) throw new P(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      }
    }
    static verifyArgs(t) {
      if (ro("kernelSize" in t, "required key 'kernelSize' not in config"), typeof t.kernelSize != "number" && !vx(t.kernelSize, "number", 1, 3)) throw new P(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`);
    }
    getConfig() {
      let t = { kernelSize: this.kernelSize, strides: this.strides, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, activation: qo(this.activation), useBias: this.useBias, biasInitializer: we(this.biasInitializer), biasRegularizer: ce(this.biasRegularizer), activityRegularizer: ce(this.activityRegularizer), biasConstraint: Oe(this.biasConstraint) }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  var pm = class e18 extends jh {
    constructor(t, r) {
      super(t, r), this.kernel = null, e18.verifyArgs(r), this.filters = r.filters, Je(this.filters, "filters"), this.kernelInitializer = he(r.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = Re(r.kernelConstraint), this.kernelRegularizer = xe(r.kernelRegularizer);
    }
    build(t) {
      t = jt(t);
      let r = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[r] == null) throw new P(`The channel dimension of the input should be defined. Found ${t[r]}`);
      let n = t[r], o = this.kernelSize.concat([n, this.filters]);
      this.kernel = this.addWeight("kernel", o, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [{ ndim: this.rank + 2, axes: { [r]: n } }], this.built = true;
    }
    call(t, r) {
      return M(() => {
        t = Ft(t);
        let n, o = this.bias == null ? null : this.bias.read(), s10 = Nx(this.activation.getClassName());
        if (s10 != null && this.rank === 2) n = AD(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate, s10);
        else {
          if (this.rank === 1) n = aq(t, this.kernel.read(), o, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
          else if (this.rank === 2) n = AD(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate);
          else if (this.rank === 3) n = uq(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate);
          else throw new Rt("convolutions greater than 3D are not implemented yet.");
          this.activation != null && (n = this.activation.apply(n));
        }
        return n;
      });
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = [], n = this.dataFormat === "channelsLast" ? t.slice(1, t.length - 1) : t.slice(2);
      for (let s10 = 0; s10 < n.length; ++s10) {
        let i = Nn(n[s10], this.kernelSize[s10], this.padding, this.strides[s10], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[s10]);
        r.push(i);
      }
      let o = [t[0]];
      return this.dataFormat === "channelsLast" ? (o = o.concat(r), o.push(this.filters)) : (o.push(this.filters), o = o.concat(r)), o;
    }
    getConfig() {
      let t = { filters: this.filters, kernelInitializer: we(this.kernelInitializer), kernelRegularizer: ce(this.kernelRegularizer), kernelConstraint: Oe(this.kernelConstraint) }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    static verifyArgs(t) {
      if (!("filters" in t) || typeof t.filters != "number" || t.filters < 1) throw new P(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`);
    }
  };
  var mm = class e19 extends pm {
    constructor(t) {
      super(2, t), e19.verifyArgs(t);
    }
    getConfig() {
      let t = super.getConfig();
      return delete t.rank, t;
    }
    static verifyArgs(t) {
      if (typeof t.kernelSize != "number" && !vx(t.kernelSize, "number", 1, 2)) throw new P(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`);
    }
  };
  mm.className = "Conv2D";
  K.registerClass(mm);
  var fm = class e20 extends pm {
    constructor(t) {
      super(3, t), e20.verifyArgs(t);
    }
    getConfig() {
      let t = super.getConfig();
      return delete t.rank, t;
    }
    static verifyArgs(t) {
      if (typeof t.kernelSize != "number" && !(Array.isArray(t.kernelSize) && (t.kernelSize.length === 1 || t.kernelSize.length === 3))) throw new P(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`);
    }
  };
  fm.className = "Conv3D";
  K.registerClass(fm);
  var Hh = class extends mm {
    constructor(t) {
      if (super(t), this.inputSpec = [new ye({ ndim: 4 })], this.padding !== "same" && this.padding !== "valid") throw new P(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
    build(t) {
      if (t = jt(t), t.length !== 4) throw new P("Input should have rank 4; Received input shape: " + JSON.stringify(t));
      let r = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[r] == null) throw new P("The channel dimension of the inputs should be defined. Found `None`.");
      let n = t[r], o = this.kernelSize.concat([this.filters, n]);
      this.kernel = this.addWeight("kernel", o, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new ye({ ndim: 4, axes: { [r]: n } })], this.built = true;
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        if (n.shape.length !== 4) throw new P(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);
        let o = n.shape, s10 = o[0], i, a;
        this.dataFormat === "channelsFirst" ? (i = 2, a = 3) : (i = 1, a = 2);
        let u = o[i], l = o[a], c = this.kernelSize[0], p = this.kernelSize[1], m = this.strides[0], f = this.strides[1], h = Yo(u, m, c, this.padding), d = Yo(l, f, p, this.padding), g = [s10, h, d, this.filters];
        this.dataFormat !== "channelsLast" && (n = qt(n, [0, 2, 3, 1]));
        let y = Uf(n, this.kernel.read(), g, this.strides, this.padding);
        return this.dataFormat !== "channelsLast" && (y = qt(y, [0, 3, 1, 2])), this.bias != null && (y = hn(y, this.bias.read(), this.dataFormat)), this.activation != null && (y = this.activation.apply(y)), y;
      });
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t.slice(), n, o, s10;
      this.dataFormat === "channelsFirst" ? (n = 1, o = 2, s10 = 3) : (n = 3, o = 1, s10 = 2);
      let i = this.kernelSize[0], a = this.kernelSize[1], u = this.strides[0], l = this.strides[1];
      return r[n] = this.filters, r[o] = Yo(r[o], u, i, this.padding), r[s10] = Yo(r[s10], l, a, this.padding), r;
    }
    getConfig() {
      let t = super.getConfig();
      return delete t.dilationRate, t;
    }
  };
  Hh.className = "Conv2DTranspose";
  K.registerClass(Hh);
  var Kh = class extends fm {
    constructor(t) {
      if (super(t), this.inputSpec = [new ye({ ndim: 5 })], this.padding !== "same" && this.padding !== "valid") throw new P(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
    build(t) {
      if (t = jt(t), t.length !== 5) throw new P("Input should have rank 5; Received input shape: " + JSON.stringify(t));
      let r = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[r] == null) throw new P("The channel dimension of the inputs should be defined. Found `None`.");
      let n = t[r], o = this.kernelSize.concat([this.filters, n]);
      this.kernel = this.addWeight("kernel", o, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new ye({ ndim: 5, axes: { [r]: n } })], this.built = true;
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        if (n.shape.length !== 5) throw new P(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);
        let o = n.shape, s10 = o[0], i, a, u;
        this.dataFormat === "channelsFirst" ? (u = 2, i = 3, a = 4) : (u = 1, i = 2, a = 3);
        let l = o[u], c = o[i], p = o[a], m = this.kernelSize[0], f = this.kernelSize[1], h = this.kernelSize[2], d = this.strides[0], g = this.strides[1], y = this.strides[2], b = Yo(l, d, m, this.padding), v = Yo(c, g, f, this.padding), w = Yo(p, y, h, this.padding), N = [s10, b, v, w, this.filters];
        this.dataFormat !== "channelsLast" && (n = qt(n, [0, 2, 3, 4, 1]));
        let E = _N(n, this.kernel.read(), N, this.strides, this.padding);
        return this.dataFormat !== "channelsLast" && (E = qt(E, [0, 4, 1, 2, 3])), this.bias !== null && (E = hn(E, this.bias.read(), this.dataFormat)), this.activation !== null && (E = this.activation.apply(E)), E;
      });
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t.slice(), n, o, s10, i;
      this.dataFormat === "channelsFirst" ? (n = 1, o = 2, s10 = 3, i = 4) : (n = 4, o = 1, s10 = 2, i = 3);
      let a = this.kernelSize[0], u = this.kernelSize[1], l = this.kernelSize[2], c = this.strides[0], p = this.strides[1], m = this.strides[2];
      return r[n] = this.filters, r[o] = Yo(r[o], c, a, this.padding), r[s10] = Yo(r[s10], p, u, this.padding), r[i] = Yo(r[i], m, l, this.padding), r;
    }
    getConfig() {
      let t = super.getConfig();
      return delete t.dilationRate, t;
    }
  };
  Kh.className = "Conv3DTranspose";
  K.registerClass(Kh);
  var yb = class extends pm {
    constructor(t, r) {
      if (super(t, r), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, r.filters == null) throw new P("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      if (r.kernelInitializer != null || r.kernelRegularizer != null || r.kernelConstraint != null) throw new P("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      if (r.padding != null && r.padding !== "same" && r.padding !== "valid") throw new P(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);
      this.depthMultiplier = r.depthMultiplier == null ? 1 : r.depthMultiplier, this.depthwiseInitializer = he(r.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = xe(r.depthwiseRegularizer), this.depthwiseConstraint = Re(r.depthwiseConstraint), this.pointwiseInitializer = he(r.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = xe(r.pointwiseRegularizer), this.pointwiseConstraint = Re(r.pointwiseConstraint);
    }
    build(t) {
      if (t = jt(t), t.length < this.rank + 2) throw new P(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(t)}`);
      let r = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[r] == null || t[r] < 0) throw new P(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[r])}`);
      let n = t[r], o = this.kernelSize.concat([n, this.depthMultiplier]), s10 = [];
      for (let a = 0; a < this.rank; ++a) s10.push(1);
      s10.push(n * this.depthMultiplier, this.filters);
      let i = true;
      this.depthwiseKernel = this.addWeight("depthwise_kernel", o, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, i, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", s10, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, i, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, i, this.biasConstraint) : this.bias = null, this.inputSpec = [new ye({ ndim: this.rank + 2, axes: { [r]: n } })], this.built = true;
    }
    call(t, r) {
      return M(() => {
        t = Ft(t);
        let n;
        if (this.rank === 1) throw new Rt("1D separable convolution is not implemented yet.");
        return this.rank === 2 && (this.dataFormat === "channelsFirst" && (t = qt(t, [0, 2, 3, 1])), n = rh(t, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (n = hn(n, this.bias.read(), this.dataFormat)), this.activation != null && (n = this.activation.apply(n)), this.dataFormat === "channelsFirst" && (n = qt(n, [0, 3, 1, 2])), n;
      });
    }
    getConfig() {
      let t = super.getConfig();
      return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = we(this.depthwiseInitializer), t.pointwiseInitializer = we(this.pointwiseInitializer), t.depthwiseRegularizer = ce(this.depthwiseRegularizer), t.pointwiseRegularizer = ce(this.pointwiseRegularizer), t.depthwiseConstraint = Oe(this.depthwiseConstraint), t.pointwiseConstraint = Oe(this.pointwiseConstraint), t;
    }
  };
  yb.className = "SeparableConv";
  var qh = class extends yb {
    constructor(t) {
      super(2, t);
    }
  };
  qh.className = "SeparableConv2D";
  K.registerClass(qh);
  var Xh = class e21 extends pm {
    constructor(t) {
      super(1, t), e21.verifyArgs(t), this.inputSpec = [{ ndim: 3 }];
    }
    getConfig() {
      let t = super.getConfig();
      return delete t.rank, delete t.dataFormat, t;
    }
    static verifyArgs(t) {
      if (typeof t.kernelSize != "number" && !vx(t.kernelSize, "number", 1, 1)) throw new P(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`);
    }
  };
  Xh.className = "Conv1D";
  K.registerClass(Xh);
  var Yh = class extends Pt {
    constructor(t) {
      super(t), typeof t.cropping == "number" ? this.cropping = [[t.cropping, t.cropping], [t.cropping, t.cropping]] : typeof t.cropping[0] == "number" ? this.cropping = [[t.cropping[0], t.cropping[0]], [t.cropping[1], t.cropping[1]]] : this.cropping = t.cropping, this.dataFormat = t.dataFormat === void 0 ? "channelsLast" : t.dataFormat, this.inputSpec = [{ ndim: 4 }];
    }
    computeOutputShape(t) {
      return this.dataFormat === "channelsFirst" ? [t[0], t[1], t[2] - this.cropping[0][0] - this.cropping[0][1], t[3] - this.cropping[1][0] - this.cropping[1][1]] : [t[0], t[1] - this.cropping[0][0] - this.cropping[0][1], t[2] - this.cropping[1][0] - this.cropping[1][1], t[3]];
    }
    call(t, r) {
      return M(() => {
        if (t = Ft(t), this.dataFormat === "channelsLast") {
          let n = yh(t, this.cropping[0][0], t.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
          return yh(n, this.cropping[1][0], t.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
        } else {
          let n = yh(t, this.cropping[0][0], t.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
          return yh(n, this.cropping[1][0], t.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
        }
      });
    }
    getConfig() {
      let t = { cropping: this.cropping, dataFormat: this.dataFormat }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Yh.className = "Cropping2D";
  K.registerClass(Yh);
  var Jh = class extends Pt {
    constructor(t) {
      super(t), this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{ ndim: 4 }], this.size = t.size == null ? this.DEFAULT_SIZE : t.size, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Ee(this.dataFormat), this.interpolation = t.interpolation == null ? "nearest" : t.interpolation, jA(this.interpolation);
    }
    computeOutputShape(t) {
      if (this.dataFormat === "channelsFirst") {
        let r = t[2] == null ? null : this.size[0] * t[2], n = t[3] == null ? null : this.size[1] * t[3];
        return [t[0], t[1], r, n];
      } else {
        let r = t[1] == null ? null : this.size[0] * t[1], n = t[2] == null ? null : this.size[1] * t[2];
        return [t[0], r, n, t[3]];
      }
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t), o = n.shape;
        if (this.dataFormat === "channelsFirst") {
          n = qt(n, [0, 2, 3, 1]);
          let s10 = this.size[0] * o[2], i = this.size[1] * o[3], a = this.interpolation === "nearest" ? Mn.resizeNearestNeighbor(n, [s10, i]) : Mn.resizeBilinear(n, [s10, i]);
          return qt(a, [0, 3, 1, 2]);
        } else {
          let s10 = this.size[0] * o[1], i = this.size[1] * o[2];
          return this.interpolation === "nearest" ? Mn.resizeNearestNeighbor(n, [s10, i]) : Mn.resizeBilinear(n, [s10, i]);
        }
      });
    }
    getConfig() {
      let t = { size: this.size, dataFormat: this.dataFormat, interpolation: this.interpolation }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Jh.className = "UpSampling2D";
  K.registerClass(Jh);
  function lq(e28, t, r = [1, 1], n = "valid", o, s10) {
    return M(() => {
      o == null && (o = fn()), Ee(o);
      let i = Zh(e28, o);
      if (e28.rank !== 4) throw new P(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e28.rank}-D`);
      if (t.rank !== 4) throw new P(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
      return i = qi(i, t, r, n === "same" ? "same" : "valid", "NHWC", s10), o === "channelsFirst" && (i = qt(i, [0, 3, 1, 2])), i;
    });
  }
  var Qh = class extends jh {
    constructor(t) {
      super(2, t), this.depthwiseKernel = null, this.depthMultiplier = t.depthMultiplier == null ? 1 : t.depthMultiplier, this.depthwiseInitializer = he(t.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = Re(t.depthwiseConstraint), this.depthwiseRegularizer = xe(t.depthwiseRegularizer);
    }
    build(t) {
      if (t = jt(t), t.length < 4) throw new P(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);
      let r = this.dataFormat === "channelsFirst" ? 1 : 3;
      if (t[r] == null || t[r] < 0) throw new P(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[r]}).`);
      let n = t[r], o = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", o, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(t, r) {
      return M(() => {
        t = Ft(t);
        let n = lq(t, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
        return this.useBias && (n = hn(n, this.bias.read(), this.dataFormat)), this.activation != null && (n = this.activation.apply(n)), n;
      });
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = this.dataFormat === "channelsFirst" ? t[2] : t[1], n = this.dataFormat === "channelsFirst" ? t[3] : t[2], o = this.dataFormat === "channelsFirst" ? t[1] * this.depthMultiplier : t[3] * this.depthMultiplier, s10 = Nn(r, this.kernelSize[0], this.padding, this.strides[0]), i = Nn(n, this.kernelSize[1], this.padding, this.strides[1]);
      return this.dataFormat === "channelsFirst" ? [t[0], o, s10, i] : [t[0], s10, i, o];
    }
    getConfig() {
      let t = super.getConfig();
      return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = we(this.depthwiseInitializer), t.depthwiseRegularizer = ce(this.depthwiseRegularizer), t.depthwiseConstraint = Oe(this.depthwiseRegularizer), t;
    }
  };
  Qh.className = "DepthwiseConv2D";
  K.registerClass(Qh);
  function U1(e28, t, r, n) {
    if (Array.isArray(e28)) {
      if (t != null || r != null) throw new P("When inputs is an array, neither initialState or constants should be provided");
      n != null && (r = e28.slice(e28.length - n, e28.length), e28 = e28.slice(0, e28.length - n)), e28.length > 1 && (t = e28.slice(1, e28.length)), e28 = e28[0];
    }
    function o(s10) {
      return s10 == null || Array.isArray(s10) ? s10 : [s10];
    }
    return t = o(t), r = o(r), { inputs: e28, initialState: t, constants: r };
  }
  function j1(e28, t, r, n = false, o, s10, i = false, a = false) {
    return M(() => {
      let u = t.shape.length;
      if (u < 3) throw new P(`Input should be at least 3D, but is ${u}D.`);
      let l = [1, 0].concat(mn(2, u));
      if (t = qt(t, l), s10 != null) throw new Rt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
      i && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), o != null && (o = Z(Z(o, "bool"), "float32"), o.rank === u - 1 && (o = or(o, -1)), o = qt(o, l)), n && (t = to(t, 0), o != null && (o = to(o, 0)));
      let c = [], p, m = r, f = t.shape[0], h = Zr(t), d;
      o != null && (d = Zr(o));
      for (let y = 0; y < f; ++y) {
        let b = h[y], v = M(() => e28(b, m));
        if (o == null) p = v[0], m = v[1];
        else {
          let w = M(() => {
            let N = d[y], E = xt(Cr(N), N), A = Y(F(v[0], N), F(m[0], E)), D = m.map((R, L) => Y(F(v[1][L], N), F(R, E)));
            return { output: A, newStates: D };
          });
          p = w.output, m = w.newStates;
        }
        a && c.push(p);
      }
      let g;
      return a && (g = Xe(c, 1)), [p, g, m];
    });
  }
  var Jo = class e23 extends Pt {
    constructor(t) {
      super(t);
      let r;
      if (t.cell == null) throw new P("cell property is missing for the constructor of RNN.");
      if (Array.isArray(t.cell) ? r = new gm({ cells: t.cell }) : r = t.cell, r.stateSize == null) throw new P("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      this.cell = r, this.returnSequences = t.returnSequences == null ? false : t.returnSequences, this.returnState = t.returnState == null ? false : t.returnState, this.goBackwards = t.goBackwards == null ? false : t.goBackwards, this._stateful = t.stateful == null ? false : t.stateful, this.unroll = t.unroll == null ? false : t.unroll, this.supportsMasking = true, this.inputSpec = [new ye({ ndim: 3 })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
    }
    getStates() {
      if (this.states_ == null) {
        let t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        return mn(0, t).map((r) => null);
      } else return this.states_;
    }
    setStates(t) {
      this.states_ = t;
    }
    computeOutputShape(t) {
      $x(t) && (t = t[0]), t = t;
      let r = this.cell.stateSize;
      Array.isArray(r) || (r = [r]);
      let n = r[0], o;
      if (this.returnSequences ? o = [t[0], t[1], n] : o = [t[0], n], this.returnState) {
        let s10 = [];
        for (let i of r) s10.push([t[0], i]);
        return [o].concat(s10);
      } else return o;
    }
    computeMask(t, r) {
      return M(() => {
        Array.isArray(r) && (r = r[0]);
        let n = this.returnSequences ? r : null;
        if (this.returnState) {
          let o = this.states.map((s10) => null);
          return [n].concat(o);
        } else return n;
      });
    }
    get states() {
      if (this.states_ == null) {
        let t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, r = [];
        for (let n = 0; n < t; ++n) r.push(null);
        return r;
      } else return this.states_;
    }
    set states(t) {
      this.states_ = t;
    }
    build(t) {
      if (this.numConstants != null) throw new Rt("Constants support is not implemented in RNN yet.");
      $x(t) && (t = t[0]), t = t;
      let n = this.stateful ? t[0] : null, o = t.slice(2);
      this.inputSpec[0] = new ye({ shape: [n, null, ...o] });
      let s10 = [t[0]].concat(t.slice(2));
      this.cell.build(s10);
      let i;
      if (Array.isArray(this.cell.stateSize) ? i = this.cell.stateSize : i = [this.cell.stateSize], this.stateSpec != null) {
        if (!x.arraysEqual(this.stateSpec.map((a) => a.shape[a.shape.length - 1]), i)) throw new P(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
      } else this.stateSpec = i.map((a) => new ye({ shape: [null, a] }));
      this.stateful && this.resetStates();
    }
    resetStates(t, r = false) {
      M(() => {
        if (!this.stateful) throw new eo("Cannot call resetStates() on an RNN Layer that is not stateful.");
        let n = this.inputSpec[0].shape[0];
        if (n == null) throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (this.states_ == null) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((o) => Se([n, o])) : this.states_ = [Se([n, this.cell.stateSize])];
        else if (t == null) Mt(this.states_), this.keptStates != null && (Mt(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((o) => Se([n, o])) : this.states_[0] = Se([n, this.cell.stateSize]);
        else {
          if (Array.isArray(t) || (t = [t]), t.length !== this.states_.length) throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
          r === true ? this.keptStates.push(this.states_.slice()) : Mt(this.states_);
          for (let o = 0; o < this.states_.length; ++o) {
            let s10 = t[o], i = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[o] : this.cell.stateSize, a = [n, i];
            if (!x.arraysEqual(s10.shape, a)) throw new P(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s10.shape}`);
            this.states_[o] = s10;
          }
        }
        this.states_ = this.states_.map((o) => wr(o.clone()));
      });
    }
    apply(t, r) {
      let n = r == null ? null : r.initialState, o = r == null ? null : r.constants;
      r == null && (r = {});
      let s10 = U1(t, n, o, this.numConstants);
      t = s10.inputs, n = s10.initialState, o = s10.constants;
      let i = [], a = [];
      if (n != null) {
        r.initialState = n, i = i.concat(n), this.stateSpec = [];
        for (let l of n) this.stateSpec.push(new ye({ shape: l.shape }));
        a = a.concat(this.stateSpec);
      }
      if (o != null && (r.constants = o, i = i.concat(o), this.numConstants = o.length), i[0] instanceof en) {
        let l = [t].concat(i), c = this.inputSpec.concat(a), p = this.inputSpec;
        this.inputSpec = c;
        let m = super.apply(l, r);
        return this.inputSpec = p, m;
      } else return super.apply(t, r);
    }
    call(t, r) {
      return M(() => {
        let n = r == null ? null : r.mask, o = r == null ? null : r.training, s10 = r == null ? null : r.initialState;
        t = Ft(t), s10 == null && (this.stateful ? s10 = this.states_ : s10 = this.getInitialState(t));
        let i = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        if (s10.length !== i) throw new P(`RNN Layer has ${i} state(s) but was passed ${s10.length} initial state(s).`);
        this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        let a = { training: o }, l = j1((h, d) => {
          let g = this.cell.call([h].concat(d), a);
          return [g[0], g.slice(1)];
        }, t, s10, this.goBackwards, n, null, this.unroll, this.returnSequences), c = l[0], p = l[1], m = l[2];
        this.stateful && this.resetStates(m, o);
        let f = this.returnSequences ? p : c;
        return this.returnState ? [f].concat(m) : f;
      });
    }
    getInitialState(t) {
      return M(() => {
        let r = Se(t.shape);
        return r = ht(r, [1, 2]), r = ea(r), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((n) => n > 1 ? Ex(r, [1, n]) : r) : this.cell.stateSize > 1 ? [Ex(r, [1, this.cell.stateSize])] : [r];
      });
    }
    get trainableWeights() {
      return this.trainable ? this.cell.trainableWeights : [];
    }
    get nonTrainableWeights() {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    }
    setFastWeightInitDuringBuild(t) {
      super.setFastWeightInitDuringBuild(t), this.cell != null && this.cell.setFastWeightInitDuringBuild(t);
    }
    getConfig() {
      let t = super.getConfig(), r = { returnSequences: this.returnSequences, returnState: this.returnState, goBackwards: this.goBackwards, stateful: this.stateful, unroll: this.unroll };
      this.numConstants != null && (r.numConstants = this.numConstants);
      let n = this.cell.getConfig();
      return this.getClassName() === e23.className && (r.cell = { className: this.cell.getClassName(), config: n }), Object.assign(Object.assign(Object.assign({}, n), t), r);
    }
    static fromConfig(t, r, n = {}) {
      let o = r.cell, s10 = zn(o, n);
      return new t(Object.assign(r, { cell: s10 }));
    }
  };
  Jo.className = "RNN";
  K.registerClass(Jo);
  var Ou = class extends Pt {
  };
  var hm = class extends Ou {
    constructor(t) {
      super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = t.units, Je(this.units, "units"), this.activation = Xo(t.activation == null ? this.DEFAULT_ACTIVATION : t.activation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = he(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = he(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = he(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = xe(t.kernelRegularizer), this.recurrentRegularizer = xe(t.recurrentRegularizer), this.biasRegularizer = xe(t.biasRegularizer), this.kernelConstraint = Re(t.kernelConstraint), this.recurrentConstraint = Re(t.recurrentConstraint), this.biasConstraint = Re(t.biasConstraint), this.dropout = Vl([1, Ko([0, t.dropout == null ? 0 : t.dropout])]), this.recurrentDropout = Vl([1, Ko([0, t.recurrentDropout == null ? 0 : t.recurrentDropout])]), this.dropoutFunc = t.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(t) {
      t = jt(t), this.kernel = this.addWeight("kernel", [t[t.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(t, r) {
      return M(() => {
        if (t = t, t.length !== 2) throw new P(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);
        let n = t[1];
        t = t[0];
        let o = r.training == null ? false : r.training;
        0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = oa({ ones: () => Cr(t), rate: this.dropout, training: o, dropoutFunc: this.dropoutFunc })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = oa({ ones: () => Cr(n), rate: this.recurrentDropout, training: o, dropoutFunc: this.dropoutFunc }));
        let s10, i = this.dropoutMask, a = this.recurrentDropoutMask;
        i != null ? s10 = To(F(t, i), this.kernel.read()) : s10 = To(t, this.kernel.read()), this.bias != null && (s10 = hn(s10, this.bias.read())), a != null && (n = F(n, a));
        let u = Y(s10, To(n, this.recurrentKernel.read()));
        return this.activation != null && (u = this.activation.apply(u)), [u, u];
      });
    }
    getConfig() {
      let t = super.getConfig(), r = { units: this.units, activation: qo(this.activation), useBias: this.useBias, kernelInitializer: we(this.kernelInitializer), recurrentInitializer: we(this.recurrentInitializer), biasInitializer: we(this.biasInitializer), kernelRegularizer: ce(this.kernelRegularizer), recurrentRegularizer: ce(this.recurrentRegularizer), biasRegularizer: ce(this.biasRegularizer), activityRegularizer: ce(this.activityRegularizer), kernelConstraint: Oe(this.kernelConstraint), recurrentConstraint: Oe(this.recurrentConstraint), biasConstraint: Oe(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout };
      return Object.assign(Object.assign({}, t), r);
    }
  };
  hm.className = "SimpleRNNCell";
  K.registerClass(hm);
  var td = class extends Jo {
    constructor(t) {
      t.cell = new hm(t), super(t);
    }
    call(t, r) {
      return M(() => {
        this.cell.dropoutMask != null && (Mt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Mt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        let n = r == null ? null : r.mask, o = r == null ? null : r.training, s10 = r == null ? null : r.initialState;
        return super.call(t, { mask: n, training: o, initialState: s10 });
      });
    }
    static fromConfig(t, r) {
      return new t(r);
    }
  };
  td.className = "SimpleRNN";
  K.registerClass(td);
  var dm = class extends Ou {
    constructor(t) {
      if (super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", t.resetAfter) throw new P("GRUCell does not support reset_after parameter set to true.");
      this.units = t.units, Je(this.units, "units"), this.activation = Xo(t.activation === void 0 ? this.DEFAULT_ACTIVATION : t.activation), this.recurrentActivation = Xo(t.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = he(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = he(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = he(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = xe(t.kernelRegularizer), this.recurrentRegularizer = xe(t.recurrentRegularizer), this.biasRegularizer = xe(t.biasRegularizer), this.kernelConstraint = Re(t.kernelConstraint), this.recurrentConstraint = Re(t.recurrentConstraint), this.biasConstraint = Re(t.biasConstraint), this.dropout = Vl([1, Ko([0, t.dropout == null ? 0 : t.dropout])]), this.recurrentDropout = Vl([1, Ko([0, t.recurrentDropout == null ? 0 : t.recurrentDropout])]), this.dropoutFunc = t.dropoutFunc, this.implementation = t.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(t) {
      t = jt(t);
      let r = t[t.length - 1];
      this.kernel = this.addWeight("kernel", [r, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(t, r) {
      return M(() => {
        if (t = t, t.length !== 2) throw new P(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);
        let n = r.training == null ? false : r.training, o = t[1];
        t = t[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = oa({ ones: () => Cr(t), rate: this.dropout, training: n, count: 3, dropoutFunc: this.dropoutFunc })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = oa({ ones: () => Cr(o), rate: this.recurrentDropout, training: n, count: 3, dropoutFunc: this.dropoutFunc }));
        let s10 = this.dropoutMask, i = this.recurrentDropoutMask, a, u, l;
        0 < this.dropout && this.dropout < 1 && (t = F(t, s10[0]));
        let c = To(t, this.kernel.read());
        this.useBias && (c = hn(c, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (o = F(o, i[0]));
        let p = this.recurrentKernel.read(), [m, f] = xr(p, [2 * this.units, this.units], p.rank - 1), h = To(o, m), [d, g, y] = xr(c, 3, c.rank - 1), [b, v] = xr(h, 2, h.rank - 1);
        a = this.recurrentActivation.apply(Y(d, b)), u = this.recurrentActivation.apply(Y(g, v));
        let w = To(F(u, o), f);
        l = this.activation.apply(Y(y, w));
        let N = Y(F(a, o), F(Y(1, ne(a)), l));
        return [N, N];
      });
    }
    getConfig() {
      let t = super.getConfig(), r = { units: this.units, activation: qo(this.activation), recurrentActivation: qo(this.recurrentActivation), useBias: this.useBias, kernelInitializer: we(this.kernelInitializer), recurrentInitializer: we(this.recurrentInitializer), biasInitializer: we(this.biasInitializer), kernelRegularizer: ce(this.kernelRegularizer), recurrentRegularizer: ce(this.recurrentRegularizer), biasRegularizer: ce(this.biasRegularizer), activityRegularizer: ce(this.activityRegularizer), kernelConstraint: Oe(this.kernelConstraint), recurrentConstraint: Oe(this.recurrentConstraint), biasConstraint: Oe(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation, resetAfter: false };
      return Object.assign(Object.assign({}, t), r);
    }
  };
  dm.className = "GRUCell";
  K.registerClass(dm);
  var ed = class extends Jo {
    constructor(t) {
      t.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new dm(t), super(t);
    }
    call(t, r) {
      return M(() => {
        this.cell.dropoutMask != null && (Mt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Mt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        let n = r == null ? null : r.mask, o = r == null ? null : r.training, s10 = r == null ? null : r.initialState;
        return super.call(t, { mask: n, training: o, initialState: s10 });
      });
    }
    static fromConfig(t, r) {
      return r.implmentation === 0 && (r.implementation = 1), new t(r);
    }
  };
  ed.className = "GRU";
  K.registerClass(ed);
  var Ru = class extends Ou {
    constructor(t) {
      super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = t.units, Je(this.units, "units"), this.activation = Xo(t.activation === void 0 ? this.DEFAULT_ACTIVATION : t.activation), this.recurrentActivation = Xo(t.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = he(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = he(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = he(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = t.unitForgetBias, this.kernelRegularizer = xe(t.kernelRegularizer), this.recurrentRegularizer = xe(t.recurrentRegularizer), this.biasRegularizer = xe(t.biasRegularizer), this.kernelConstraint = Re(t.kernelConstraint), this.recurrentConstraint = Re(t.recurrentConstraint), this.biasConstraint = Re(t.biasConstraint), this.dropout = Vl([1, Ko([0, t.dropout == null ? 0 : t.dropout])]), this.recurrentDropout = Vl([1, Ko([0, t.recurrentDropout == null ? 0 : t.recurrentDropout])]), this.dropoutFunc = t.dropoutFunc, this.implementation = t.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(t) {
      var r;
      t = jt(t);
      let n = t[t.length - 1];
      this.kernel = this.addWeight("kernel", [n, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      let o;
      if (this.useBias) {
        if (this.unitForgetBias) {
          let s10 = this.biasInitializer, i = this.units;
          o = new (r = class extends dn {
            apply(u, l) {
              let c = s10.apply([i]), p = new Wl().apply([i]), m = s10.apply([i * 2]);
              return D1(D1(c, p), m);
            }
          }, r.className = "CustomInit", r)();
        } else o = this.biasInitializer;
        this.bias = this.addWeight("bias", [this.units * 4], null, o, this.biasRegularizer, true, this.biasConstraint);
      } else this.bias = null;
      this.built = true;
    }
    call(t, r) {
      return M(() => {
        let n = r.training == null ? false : r.training;
        if (t = t, t.length !== 3) throw new P(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
        let o = t[1], s10 = t[2];
        t = t[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = oa({ ones: () => Cr(t), rate: this.dropout, training: n, count: 4, dropoutFunc: this.dropoutFunc })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = oa({ ones: () => Cr(o), rate: this.recurrentDropout, training: n, count: 4, dropoutFunc: this.dropoutFunc }));
        let i = this.dropoutMask, a = this.recurrentDropoutMask, u, l, c, p;
        0 < this.dropout && this.dropout < 1 && (t = F(t, i[0]));
        let m = To(t, this.kernel.read());
        0 < this.recurrentDropout && this.recurrentDropout < 1 && (o = F(o, a[0])), m = Y(m, To(o, this.recurrentKernel.read())), this.useBias && (m = hn(m, this.bias.read()));
        let [f, h, d, g] = xr(m, 4, m.rank - 1);
        u = this.recurrentActivation.apply(f), l = this.recurrentActivation.apply(h), c = Y(F(l, s10), F(u, this.activation.apply(d))), p = this.recurrentActivation.apply(g);
        let y = F(p, this.activation.apply(c));
        return [y, y, c];
      });
    }
    getConfig() {
      let t = super.getConfig(), r = { units: this.units, activation: qo(this.activation), recurrentActivation: qo(this.recurrentActivation), useBias: this.useBias, kernelInitializer: we(this.kernelInitializer), recurrentInitializer: we(this.recurrentInitializer), biasInitializer: we(this.biasInitializer), unitForgetBias: this.unitForgetBias, kernelRegularizer: ce(this.kernelRegularizer), recurrentRegularizer: ce(this.recurrentRegularizer), biasRegularizer: ce(this.biasRegularizer), activityRegularizer: ce(this.activityRegularizer), kernelConstraint: Oe(this.kernelConstraint), recurrentConstraint: Oe(this.recurrentConstraint), biasConstraint: Oe(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation };
      return Object.assign(Object.assign({}, t), r);
    }
  };
  Ru.className = "LSTMCell";
  K.registerClass(Ru);
  var rd = class extends Jo {
    constructor(t) {
      t.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new Ru(t), super(t);
    }
    call(t, r) {
      return M(() => {
        this.cell.dropoutMask != null && (Mt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Mt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        let n = r == null ? null : r.mask, o = r == null ? null : r.training, s10 = r == null ? null : r.initialState;
        return super.call(t, { mask: n, training: o, initialState: s10 });
      });
    }
    static fromConfig(t, r) {
      return r.implmentation === 0 && (r.implementation = 1), new t(r);
    }
  };
  rd.className = "LSTM";
  K.registerClass(rd);
  var gm = class extends Ou {
    constructor(t) {
      super(t), this.cells = t.cells;
    }
    get stateSize() {
      let t = [];
      for (let r of this.cells.slice().reverse()) Array.isArray(r.stateSize) ? t.push(...r.stateSize) : t.push(r.stateSize);
      return t;
    }
    call(t, r) {
      return M(() => {
        t = t;
        let n = t.slice(1), o = [];
        for (let a of this.cells.slice().reverse()) Array.isArray(a.stateSize) ? o.push(n.splice(0, a.stateSize.length)) : o.push(n.splice(0, 1));
        o.reverse();
        let s10 = [], i;
        for (let a = 0; a < this.cells.length; ++a) {
          let u = this.cells[a];
          n = o[a], a === 0 ? i = [t[0]].concat(n) : i = [i[0]].concat(n), i = u.call(i, r), s10.push(i.slice(1));
        }
        n = [];
        for (let a of s10.slice().reverse()) n.push(...a);
        return [i[0]].concat(n);
      });
    }
    build(t) {
      $x(t) && (t = t[0]), t = t;
      let r;
      this.cells.forEach((n, o) => {
        Ho(`RNNCell_${o}`, () => {
          n.build(t), Array.isArray(n.stateSize) ? r = n.stateSize[0] : r = n.stateSize, t = [t[0], r];
        });
      }), this.built = true;
    }
    getConfig() {
      let t = super.getConfig(), r = (s10) => ({ className: s10.getClassName(), config: s10.getConfig() }), o = { cells: this.cells.map(r) };
      return Object.assign(Object.assign({}, t), o);
    }
    static fromConfig(t, r, n = {}) {
      let o = [];
      for (let s10 of r.cells) o.push(zn(s10, n));
      return new t({ cells: o });
    }
    get trainableWeights() {
      if (!this.trainable) return [];
      let t = [];
      for (let r of this.cells) t.push(...r.trainableWeights);
      return t;
    }
    get nonTrainableWeights() {
      let t = [];
      for (let r of this.cells) t.push(...r.nonTrainableWeights);
      if (!this.trainable) {
        let r = [];
        for (let n of this.cells) r.push(...n.trainableWeights);
        return r.concat(t);
      }
      return t;
    }
    getWeights() {
      let t = [];
      for (let r of this.cells) t.push(...r.weights);
      return Th(t);
    }
    setWeights(t) {
      let r = [];
      for (let n of this.cells) {
        let o = n.weights.length, s10 = t.splice(o);
        for (let i = 0; i < n.weights.length; ++i) r.push([n.weights[i], s10[i]]);
      }
      om(r);
    }
  };
  gm.className = "StackedRNNCells";
  K.registerClass(gm);
  function oa(e28) {
    let { ones: t, rate: r, training: n = false, count: o = 1, dropoutFunc: s10 } = e28, i = () => s10 != null ? s10(t(), r) : Dx(t(), r), a = () => $u(i, t, n);
    return !o || o <= 1 ? wr(a().clone()) : Array(o).fill(void 0).map(a).map((l) => wr(l.clone()));
  }
  var cq = function(e28, t) {
    var r = {};
    for (var n in e28) Object.prototype.hasOwnProperty.call(e28, n) && t.indexOf(n) < 0 && (r[n] = e28[n]);
    if (e28 != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, n = Object.getOwnPropertySymbols(e28); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e28, n[o]) && (r[n[o]] = e28[n[o]]);
    return r;
  };
  var xb = class extends Jo {
    constructor(t) {
      if (t.unroll) throw new Rt("Unrolling is not possible with convolutional RNNs.");
      if (Array.isArray(t.cell)) throw new Rt("It is not possible at the moment to stack convolutional cells.");
      super(t), this.inputSpec = [new ye({ ndim: 5 })];
    }
    call(t, r) {
      return M(() => {
        if (this.cell.dropoutMask != null && (Mt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Mt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), r && r.constants) throw new P("ConvRNN2D cell does not support constants");
        let n = r == null ? null : r.mask, o = r == null ? null : r.training, s10 = r == null ? null : r.initialState;
        return super.call(t, { mask: n, training: o, initialState: s10 });
      });
    }
    computeOutputShape(t) {
      let r = this.computeSingleOutputShape(t);
      return this.returnSequences || (r = [r[0], ...r.slice(2)]), this.returnState && (r = [r, ...Array(2).fill([t[0], ...r.slice(-3)])]), r;
    }
    getInitialState(t) {
      return M(() => {
        let { stateSize: r } = this.cell, n = t.shape, o = this.computeSingleOutputShape(n), s10 = [o[0], ...o.slice(2)], i = Se(s10);
        return Array.isArray(r) ? Array(r.length).fill(i) : [i];
      });
    }
    resetStates(t, r = false) {
      M(() => {
        if (!this.stateful) throw new eo("Cannot call resetStates() on an RNN Layer that is not stateful.");
        let n = this.inputSpec[0].shape, o = this.computeSingleOutputShape(n), s10 = [o[0], ...o.slice(2)];
        if (n[0] == null) throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (this.getStates() == null) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => Se(s10)) : this.states_ = [Se(s10)];
        else if (t == null) Mt(this.states_), this.keptStates != null && (Mt(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => Se(s10)) : this.states_[0] = Se(s10);
        else {
          if (Array.isArray(t) || (t = [t]), t.length !== this.states_.length) throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
          r ? this.keptStates.push(this.states_.slice()) : Mt(this.states_);
          for (let a = 0; a < this.states_.length; ++a) {
            let u = t[a], l = s10;
            if (!x.arraysEqual(u.shape, l)) throw new P(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);
            this.states_[a] = u;
          }
        }
        this.states_ = this.states_.map((a) => wr(a.clone()));
      });
    }
    computeSingleOutputShape(t) {
      let { dataFormat: r, filters: n, kernelSize: o, padding: s10, strides: i, dilationRate: a } = this.cell, u = r === "channelsFirst", l = t[u ? 3 : 2], c = t[u ? 4 : 3], p = Nn(l, o[0], s10, i[0], a[0]), m = Nn(c, o[1], s10, i[1], a[1]);
      return [...t.slice(0, 2), ...u ? [n, p, m] : [p, m, n]];
    }
  };
  xb.className = "ConvRNN2D";
  var ym = class extends Ru {
    constructor(t) {
      let { filters: r, kernelSize: n, strides: o, padding: s10, dataFormat: i, dilationRate: a } = t;
      super(Object.assign(Object.assign({}, t), { units: r })), this.filters = r, Je(this.filters, "filters"), this.kernelSize = _u(n, 2, "kernelSize"), this.kernelSize.forEach((u) => Je(u, "kernelSize")), this.strides = _u(o || 1, 2, "strides"), this.strides.forEach((u) => Je(u, "strides")), this.padding = s10 || "valid", pn(this.padding), this.dataFormat = i || "channelsLast", Ee(this.dataFormat), this.dilationRate = _u(a || 1, 2, "dilationRate"), this.dilationRate.forEach((u) => Je(u, "dilationRate"));
    }
    build(t) {
      var r;
      t = jt(t);
      let n = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[n] == null) throw new P(`The channel dimension of the input should be defined. Found ${t[n]}`);
      let o = t[n], s10 = 4, i = this.kernelSize.concat([o, this.filters * s10]);
      this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      let a = this.kernelSize.concat([this.filters, this.filters * s10]);
      if (this.recurrentKernel = this.addWeight("recurrent_kernel", a, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
        let u;
        if (this.unitForgetBias) {
          let l = this.biasInitializer, c = this.filters;
          u = new (r = class extends dn {
            apply(m, f) {
              let h = l.apply([c]), d = ln([c]), g = l.apply([c * 2]);
              return qp([h, d, g]);
            }
          }, r.className = "CustomInit", r)();
        } else u = this.biasInitializer;
        this.bias = this.addWeight("bias", [this.filters * s10], null, u, this.biasRegularizer, true, this.biasConstraint);
      }
      this.built = true;
    }
    call(t, r) {
      return M(() => {
        if (t.length !== 3) throw new P(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
        let n = r.training || false, o = t[0], s10 = t[1], i = t[2], a = 4;
        0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = oa({ ones: () => Cr(o), rate: this.dropout, training: n, count: a, dropoutFunc: this.dropoutFunc }));
        let u = this.dropoutMask, l = (ot, st, ct) => !st || !st[ct] ? ot : F(st[ct], ot), c = l(o, u, 0), p = l(o, u, 1), m = l(o, u, 2), f = l(o, u, 3);
        0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = oa({ ones: () => Cr(s10), rate: this.recurrentDropout, training: n, count: a, dropoutFunc: this.dropoutFunc }));
        let h = this.recurrentDropoutMask, d = l(s10, h, 0), g = l(s10, h, 1), y = l(s10, h, 2), b = l(s10, h, 3), v = 3, [w, N, E, A] = xr(this.kernel.read(), a, v), [D, R, L, G] = this.useBias ? xr(this.bias.read(), a) : [null, null, null, null];
        c = this.inputConv(c, w, D, this.padding), p = this.inputConv(p, N, R, this.padding), m = this.inputConv(m, E, L, this.padding), f = this.inputConv(f, A, G, this.padding);
        let [W, U, H, j] = xr(this.recurrentKernel.read(), a, v);
        d = this.recurrentConv(d, W), g = this.recurrentConv(g, U), y = this.recurrentConv(y, H), b = this.recurrentConv(b, j);
        let X = this.recurrentActivation.apply(Y(c, d)), Q = this.recurrentActivation.apply(Y(p, g)), q = Y(F(Q, i), F(X, this.activation.apply(Y(m, y)))), et = F(this.recurrentActivation.apply(Y(f, b)), this.activation.apply(q));
        return [et, et, q];
      });
    }
    getConfig() {
      let t = super.getConfig(), { units: r } = t, n = cq(t, ["units"]), o = { filters: this.filters, kernelSize: this.kernelSize, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, strides: this.strides };
      return Object.assign(Object.assign({}, n), o);
    }
    inputConv(t, r, n, o) {
      let s10 = On(t, r, this.strides, o || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
      return n ? hn(s10, n, this.dataFormat) : s10;
    }
    recurrentConv(t, r) {
      return On(t, r, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
    }
  };
  ym.className = "ConvLSTM2DCell";
  K.registerClass(ym);
  var nd = class extends xb {
    constructor(t) {
      let r = new ym(t);
      super(Object.assign(Object.assign({}, t), { cell: r }));
    }
    static fromConfig(t, r) {
      return new t(r);
    }
  };
  nd.className = "ConvLSTM2D";
  K.registerClass(nd);
  var xm = class extends Pt {
    constructor(t) {
      super(t), this.rate = Math.max(Math.min(t.rate, 1), 0), this.noiseShape = t.noiseShape, this.seed = t.seed, this.supportsMasking = true;
    }
    getNoiseShape(t) {
      if (this.noiseShape == null) return this.noiseShape;
      let r = t.shape, n = [];
      for (let o = 0; o < this.noiseShape.length; ++o) n.push(this.noiseShape[o] == null ? r[o] : this.noiseShape[o]);
      return n;
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t);
        if (0 < this.rate && this.rate < 1) {
          let o = r.training == null ? false : r.training, s10 = this.getNoiseShape(n);
          return $u(() => Dx(n, this.rate, s10, this.seed), () => n, o);
        }
        return t;
      });
    }
    getConfig() {
      let t = { rate: this.rate, noiseShape: this.noiseShape, seed: this.seed }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    dispose() {
      return super.dispose();
    }
  };
  xm.className = "Dropout";
  K.registerClass(xm);
  var od = class extends xm {
    constructor(t) {
      super(t), this.inputSpec = [{ ndim: 3 }];
    }
    getNoiseShape(t) {
      let r = t.shape;
      return [r[0], 1, r[2]];
    }
  };
  od.className = "SpatialDropout1D";
  K.registerClass(od);
  var sd = class extends Pt {
    constructor(t) {
      if (super(t), this.activation = null, this.useBias = true, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", t.batchInputShape == null && t.inputShape == null && t.inputDim != null) {
        let r = null;
        t.batchSize != null && (r = t.batchSize), this.batchInputShape = [r, t.inputDim];
      }
      this.units = t.units, Je(this.units, "units"), this.activation = Xo(t.activation), t.useBias != null && (this.useBias = t.useBias), this.kernelInitializer = he(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = he(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = Re(t.kernelConstraint), this.biasConstraint = Re(t.biasConstraint), this.kernelRegularizer = xe(t.kernelRegularizer), this.biasRegularizer = xe(t.biasRegularizer), this.activityRegularizer = xe(t.activityRegularizer), this.supportsMasking = true, this.inputSpec = [{ minNDim: 2 }];
    }
    build(t) {
      t = jt(t);
      let r = t[t.length - 1];
      this.kernel == null && (this.kernel = this.addWeight("kernel", [r, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [{ minNDim: 2, axes: { [-1]: r } }], this.built = true;
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t.slice();
      return r[r.length - 1] = this.units, r;
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t), o = Nx(this.activation.getClassName()), s10;
        return o != null ? s10 = To(n, this.kernel.read(), o, this.bias ? this.bias.read() : null) : (s10 = To(n, this.kernel.read()), this.bias != null && (s10 = hn(s10, this.bias.read())), this.activation != null && (s10 = this.activation.apply(s10))), s10;
      });
    }
    getConfig() {
      let t = { units: this.units, activation: qo(this.activation), useBias: this.useBias, kernelInitializer: we(this.kernelInitializer), biasInitializer: we(this.biasInitializer), kernelRegularizer: ce(this.kernelRegularizer), biasRegularizer: ce(this.biasRegularizer), activityRegularizer: ce(this.activityRegularizer), kernelConstraint: Oe(this.kernelConstraint), biasConstraint: Oe(this.biasConstraint) }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  sd.className = "Dense";
  K.registerClass(sd);
  var id = class extends Pt {
    constructor(t) {
      t = t || {}, super(t), this.inputSpec = [{ minNDim: 3 }], this.dataFormat = t.dataFormat;
    }
    computeOutputShape(t) {
      t = jt(t);
      for (let r of t.slice(1)) if (r == null) throw new P(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
      return [t[0], Io(t, 1)];
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t);
        if (this.dataFormat === "channelsFirst" && n.rank > 1) {
          let o = [0];
          for (let s10 = 2; s10 < n.rank; ++s10) o.push(s10);
          o.push(1), n = qt(n, o);
        }
        return YA(n);
      });
    }
    getConfig() {
      let t = {};
      this.dataFormat != null && (t.dataFormat = this.dataFormat);
      let r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  id.className = "Flatten";
  K.registerClass(id);
  var ad = class extends Pt {
    constructor(t) {
      super(t), this.supportsMasking = true, this.activation = Xo(t.activation);
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t);
        return this.activation.apply(n);
      });
    }
    getConfig() {
      let t = { activation: qo(this.activation) }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  ad.className = "Activation";
  K.registerClass(ad);
  var ud = class extends Pt {
    constructor(t) {
      super(t), this.n = t.n, this.inputSpec = [{ ndim: 2 }];
    }
    computeOutputShape(t) {
      return [t[0], this.n, t[1]];
    }
    call(t, r) {
      return M(() => (t = Ft(t), qA(t, this.n)));
    }
    getConfig() {
      let t = { n: this.n }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  ud.className = "RepeatVector";
  K.registerClass(ud);
  var ld = class extends Pt {
    constructor(t) {
      super(t), this.targetShape = t.targetShape;
      for (let r = 0; r < this.targetShape.length; ++r) this.isUnknown(this.targetShape[r]) && (this.targetShape[r] = null);
    }
    isUnknown(t) {
      return t < 0 || t == null;
    }
    fixUnknownDimension(t, r) {
      let n = "Total size of new array must be unchanged.", o = r.slice(), s10 = 1, i = null;
      for (let u = 0; u < o.length; ++u) {
        let l = o[u];
        if (this.isUnknown(l)) if (i === null) i = u;
        else throw new P("Can only specifiy one unknown dimension.");
        else s10 *= l;
      }
      let a = Io(t);
      if (i !== null) {
        if (s10 === 0 || a % s10 !== 0) throw new P(n);
        o[i] = a / s10;
      } else if (a !== s10) throw new P(n);
      return o;
    }
    computeOutputShape(t) {
      let r = false;
      for (let n = 0; n < t.length; ++n) if (this.isUnknown(t[n])) {
        r = true;
        break;
      }
      return r ? t.slice(0, 1).concat(this.targetShape) : t.slice(0, 1).concat(this.fixUnknownDimension(t.slice(1), this.targetShape));
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t), o = n.shape, s10 = o.slice(0, 1).concat(this.fixUnknownDimension(o.slice(1), this.targetShape));
        return _(n, s10);
      });
    }
    getConfig() {
      let t = { targetShape: this.targetShape }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  ld.className = "Reshape";
  K.registerClass(ld);
  var cd = class extends Pt {
    constructor(t) {
      if (super(t), t.dims == null) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      if (!Array.isArray(t.dims)) throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);
      let r = mn(1, t.dims.length + 1);
      if (!x.arraysEqual(t.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
      this.dims = t.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new ye({ ndim: this.dims.length + 1 })];
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t.slice();
      return this.dims.forEach((n, o) => {
        r[o + 1] = t[n];
      }), r;
    }
    call(t, r) {
      return qt(Ft(t), this.dimsIncludingBatch);
    }
    getConfig() {
      let t = { dims: this.dims }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  cd.className = "Permute";
  K.registerClass(cd);
  var pd = class extends Pt {
    constructor(t) {
      super(t ?? {}), this.supportsMasking = true, t != null ? this.maskValue = t.maskValue == null ? 0 : t.maskValue : this.maskValue = 0;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = super.getConfig(), r = { maskValue: this.maskValue };
      return Object.assign(r, t), r;
    }
    computeMask(t, r) {
      let n = Ft(t);
      return Sp(Eu(n, this.maskValue), -1);
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t), i = Sp(Eu(n, this.maskValue), -1, true);
        return F(n, Z(i, n.dtype));
      });
    }
  };
  pd.className = "Masking";
  K.registerClass(pd);
  var md = class extends Pt {
    constructor(t) {
      if (super(t), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", t.batchInputShape == null && t.inputShape == null) {
        let r = null;
        t.batchSize != null && (r = t.batchSize), t.inputLength == null ? this.batchInputShape = [r, null] : this.batchInputShape = [r].concat(ue(t.inputLength));
      }
      this.inputDim = t.inputDim, Je(this.inputDim, "inputDim"), this.outputDim = t.outputDim, Je(this.outputDim, "outputDim"), this.embeddingsInitializer = he(t.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = xe(t.embeddingsRegularizer), this.activityRegularizer = xe(t.activityRegularizer), this.embeddingsConstraint = Re(t.embeddingsConstraint), this.maskZero = t.maskZero, this.supportsMasking = t.maskZero, this.inputLength = t.inputLength;
    }
    build(t) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
    }
    warnOnIncompatibleInputShape(t) {
    }
    computeMask(t, r) {
      return M(() => this.maskZero ? (t = Ft(t), Eu(t, Dt(t))) : null);
    }
    computeOutputShape(t) {
      if (t = jt(t), this.inputLength == null) return [...t, this.outputDim];
      let r = ue(this.inputLength);
      if (r.length !== t.length - 1) throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
      {
        let n = 0;
        for (let o = 0; o < r.length; ++o) {
          let s10 = r[o], i = t[o + 1];
          if (s10 != null && i != null && s10 !== i) throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
          s10 == null && (r[n] = i), n++;
        }
      }
      return [t[0], ...r, this.outputDim];
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t);
        n.dtype !== "int32" && (n = Qr(n, "int32"));
        let o = Ax(this.embeddings.read(), _(n, [n.size]));
        return _(o, jt(this.computeOutputShape(n.shape)));
      });
    }
    getConfig() {
      let t = { inputDim: this.inputDim, outputDim: this.outputDim, embeddingsInitializer: we(this.embeddingsInitializer), embeddingsRegularizer: ce(this.embeddingsRegularizer), activityRegularizer: ce(this.activityRegularizer), embeddingsConstraint: Oe(this.embeddingsConstraint), maskZero: this.maskZero, inputLength: this.inputLength }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  md.className = "Embedding";
  K.registerClass(md);
  var sa = class extends Pt {
    constructor(t) {
      super(t || {}), this.supportsMasking = true;
    }
    mergeFunction(t) {
      throw new Rt();
    }
    computeElementwiseOpOutputShape(t, r) {
      if (t == null || r == null) return null;
      if (t.length < r.length) return this.computeElementwiseOpOutputShape(r, t);
      if (r.length === 0) return t;
      let n = t.slice(0, t.length - r.length);
      for (let o = 0; o < r.length; ++o) {
        let s10 = t[t.length - r.length + o], i = r[o];
        if (s10 == null || i == null || s10 < 0 || i < 0) n.push(null);
        else if (s10 === 1) n.push(i);
        else if (i === 1) n.push(s10);
        else {
          if (s10 !== i) throw new P("Operands could not be broadcast together with shapes " + JSON.stringify(t) + " " + JSON.stringify(r));
          n.push(s10);
        }
      }
      return n;
    }
    build(t) {
      if (Array.isArray(t) && !Array.isArray(t[0]) && (t = [jt(t)]), t = t, t.length < 2) throw new P(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);
      let r = [];
      for (let s10 of t) s10 != null && s10[0] !== null && r.push(s10[0]);
      if (r = So(r), r.length > 1) throw new P(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);
      let n = t[0] == null ? null : t[0].slice(1);
      for (let s10 = 1; s10 < t.length; ++s10) {
        let i = t[s10] == null ? null : t[s10].slice(1);
        n = this.computeElementwiseOpOutputShape(n, i);
      }
      let o = t.map((s10) => s10.length);
      t.indexOf(null) === -1 && So(o).length === 1 ? this.reshapeRequired = false : this.reshapeRequired = true;
    }
    call(t, r) {
      return M(() => {
        if (t = t, this.reshapeRequired) {
          let n = [], o = t.map((s10) => s10.rank);
          if (o.indexOf(null) === -1) {
            let s10 = Ko(o);
            for (let i of t) {
              let a = i.rank;
              for (let u = 0; u < s10 - a; ++u) i = ea(i, 1);
              n.push(i);
            }
            return this.mergeFunction(n);
          } else {
            let s10 = false;
            for (let u of t) {
              let l = u.rank;
              if (l == null) {
                let c = u.shape, p = c[0], m = c.slice(1).concat([p]), f = _(u, [p].concat(Io(c.slice(1))));
                f = qt(f, [1, 0]), f = _(f, m), n.push(f), s10 = true;
              } else if (l > 1) {
                let c = mn(1, l).concat([0]);
                n.push(qt(u, c)), s10 = true;
              } else n.push(u);
            }
            let i = this.mergeFunction(n), a = i.rank;
            if (s10) {
              if (a == null) {
                let u = i.shape, l = u.length, c = u[l - 1], p = [c].concat(u.slice(0, u.length - 1));
                i = _(qt(_(i, [-1, c]), [1, 0]), p);
              } else if (a > 1) {
                let u = [a - 1].concat(mn(0, a - 1));
                i = qt(i, u);
              }
            }
            return i;
          }
        } else return this.mergeFunction(t);
      });
    }
    computeOutputShape(t) {
      t = t;
      let r;
      t[0] == null ? r = null : r = t[0].slice(1);
      for (let o = 1; o < t.length; ++o) {
        let s10 = t[o] == null ? null : t[o].slice(1);
        r = this.computeElementwiseOpOutputShape(r, s10);
      }
      let n = [];
      for (let o of t) o != null && o[0] !== null && n.push(o[0]);
      return n = So(n), n.length === 1 ? r = n.concat(r) : r = [null].concat(r), r;
    }
    computeMask(t, r) {
      return M(() => {
        if (r == null) return null;
        if (!Array.isArray(r)) throw new P("`mask` should be an Array");
        if (!Array.isArray(t)) throw new P("`inputs` should be an Array");
        if (r.length !== t.length) throw new P(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${r.length})`);
        if (r.every((o) => o == null)) return null;
        r = r.map((o) => o == null ? o : or(o, 0));
        let n = r[0];
        for (let o = 1; o < r.length - 1; ++o) n = Jr(n, r[o]);
        return n;
      });
    }
  };
  var hd = class extends sa {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return M(() => {
        let r = t[0].clone();
        for (let n = 1; n < t.length; ++n) r = Y(r, t[n]);
        return r;
      });
    }
  };
  hd.className = "Add";
  K.registerClass(hd);
  var dd = class extends sa {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return M(() => {
        let r = t[0].clone();
        for (let n = 1; n < t.length; ++n) r = F(r, t[n]);
        return r;
      });
    }
  };
  dd.className = "Multiply";
  K.registerClass(dd);
  var gd = class extends sa {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return M(() => {
        let r = t[0].clone();
        for (let n = 1; n < t.length; ++n) r = Y(r, t[n]);
        return F(1 / t.length, r);
      });
    }
  };
  gd.className = "Average";
  K.registerClass(gd);
  var yd = class extends sa {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return M(() => {
        let r = t[0];
        for (let n = 1; n < t.length; ++n) r = Pn(r, t[n]);
        return r;
      });
    }
  };
  yd.className = "Maximum";
  K.registerClass(yd);
  var xd = class extends sa {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return M(() => {
        let r = t[0];
        for (let n = 1; n < t.length; ++n) r = Is(r, t[n]);
        return r;
      });
    }
  };
  xd.className = "Minimum";
  K.registerClass(xd);
  var bd = class extends sa {
    constructor(t) {
      super(t), this.DEFAULT_AXIS = -1, t == null && (t = {}), this.axis = t.axis == null ? this.DEFAULT_AXIS : t.axis, this.supportsMasking = true, this.reshapeRequired = false;
    }
    build(t) {
      if (!(Array.isArray(t) && Array.isArray(t[0])) || t.length === 1) throw new P("A `Concatenate` layer should be called on a list of at least 2 inputs");
      t = t;
      let r = true;
      for (let o of t) if (o != null) {
        r = false;
        break;
      }
      if (r) return;
      let n = [];
      for (let o = 0; o < t.length; ++o) {
        let s10 = t[o].slice();
        s10.splice(this.axis, 1);
        let i = false;
        for (let a of n) if (x.arraysEqual(a, s10)) {
          i = true;
          break;
        }
        i || n.push(s10);
      }
      if (n.length > 1) throw new P("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(t));
    }
    mergeFunction(t) {
      return M(() => qp(t, this.axis));
    }
    computeOutputShape(t) {
      if (!(Array.isArray(t) && Array.isArray(t[0]))) throw new P("A `Concatenate` layer should be called on a list of inputs.");
      let r = t, n = r[0].slice(), o = this.axis < 0 ? n.length + this.axis : this.axis;
      for (let s10 of r.slice(1)) {
        if (n[o] == null || s10[o] == null) {
          n[o] = null;
          break;
        }
        n[o] += s10[o];
      }
      return n;
    }
    computeMask(t, r) {
      if (r == null) return null;
      if (!Array.isArray(r)) throw new P("`mask` should be an array for Concatenate");
      if (!Array.isArray(t)) throw new P("`inputs` should be an array for Concatenate");
      if (r.length !== t.length) throw new P(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${t.length})`);
      return M(() => {
        let n = true;
        if (r.forEach((i) => {
          if (i != null) {
            n = false;
            return;
          }
        }), n) return null;
        let o = [];
        for (let i = 0; i < t.length; ++i) r[i] == null ? o.push(Z(Cr(t[i]), "bool")) : r[i].rank < t[i].rank ? o.push(or(r[i], -1)) : o.push(r[i]);
        let s10 = Ne(o, this.axis);
        return Bf(s10, -1, false);
      });
    }
    getConfig() {
      let t = { axis: this.axis }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  bd.className = "Concatenate";
  K.registerClass(bd);
  function fd(e28, t) {
    for (; e28 < 0; ) e28 += t;
    return e28;
  }
  function pq(e28, t, r) {
    if (e28.shape.length > 3 || t.shape.length > 3) throw new Rt("batchDot is not implemented for tensors of 4D or higher rank yet");
    if (x.assert(e28.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${e28.shape.length}`), x.assert(e28.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`), typeof r == "number" && (r = [r, r]), e28.dtype === "complex64" || t.dtype === "complex64") throw new Rt("batchDot is not implemented for complex64-type Tensors yet.");
    let n = e28.shape.length, o = t.shape.length;
    r == null && (r = [n - 1, o - 2]);
    let s10 = r;
    return M(() => {
      let i;
      if (n > o) {
        i = n - o;
        let u = [];
        for (let l = 0; l < i; ++l) u.push(1);
        t = _(t, t.shape.concat(u));
      } else if (o > n) {
        i = o - n;
        let u = [];
        for (let l = 0; l < i; ++l) u.push(1);
        e28 = _(e28, e28.shape.concat(u));
      } else i = 0;
      let a;
      if (e28.shape.length === 2 && t.shape.length === 2) s10[0] === s10[1] ? a = ht(F(e28, t), s10[0]) : a = ht(F(qt(e28, [1, 0]), t), s10[1]);
      else {
        let u = s10[0] !== e28.shape.length - 1, l = s10[1] === t.shape.length - 1;
        a = ae(e28, t, u, l);
      }
      if (i > 0) {
        let u;
        n > o ? u = n + o - 3 : u = n - 1;
        let l = [];
        for (let c = u; c < u + i; ++c) l.push(c);
        a = Wo(a, l);
      }
      return a.shape.length === 1 && (a = or(a, 1)), a;
    });
  }
  var wd = class extends sa {
    constructor(t) {
      super(t), this.axes = t.axes, this.normalize = t.normalize == null ? false : t.normalize, this.supportsMasking = true, this.reshapeRequired = false;
    }
    build(t) {
      x.assert(Array.isArray(t) && t.length === 2 && Array.isArray(t[0]) && Array.isArray(t[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      let r = t[0], n = t[1];
      if (r.length > 3 || n.length > 3) throw new Rt("Dot layer does not support tensors of 4D or higher rank yet.");
      let o = this.interpretAxes(r, n);
      if (r[o[0]] !== n[o[1]]) throw new P(`Dimension incompatibility: ${r[o[0]]} !== ${n[o[1]]}`);
    }
    mergeFunction(t) {
      if (t.length !== 2) throw new P(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);
      let r = t[0], n = t[1], o;
      return Array.isArray(this.axes) ? o = this.axes.map((s10, i) => fd(s10, t[i].shape.length)) : o = [fd(this.axes, r.shape.length), fd(this.axes, n.shape.length)], this.normalize && (r = Fh(r, o[0]), n = Fh(n, o[1])), pq(r, n, o);
    }
    interpretAxes(t, r) {
      let n;
      return Array.isArray(this.axes) ? n = this.axes : n = [fd(this.axes, t.length), fd(this.axes, r.length)], n;
    }
    computeOutputShape(t) {
      x.assert(Array.isArray(t) && t.length === 2 && Array.isArray(t[0]) && Array.isArray(t[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      let r = t[0].slice(), n = t[1].slice();
      if (r.length > 3 || n.length > 3) throw new Rt("Dot layer does not support tensors of 4D or higher rank yet.");
      let o = this.interpretAxes(r, n);
      r.splice(o[0], 1), n.splice(o[1], 1), n.splice(0, 1);
      let s10 = r.concat(n);
      return s10.length === 1 && s10.push(1), s10;
    }
    computeMask(t, r) {
      return null;
    }
    getConfig() {
      let t = { axes: this.axes, normalize: this.normalize }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  wd.className = "Dot";
  K.registerClass(wd);
  var vd = class extends Pt {
    constructor(t) {
      super(t), this.supportsMasking = true, this.stddev = t.stddev;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = super.getConfig(), r = { stddev: this.stddev };
      return Object.assign(r, t), r;
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t);
        return $u(() => Y(Xp(n.shape, 0, this.stddev), n), () => n, r.training || false);
      });
    }
  };
  vd.className = "GaussianNoise";
  K.registerClass(vd);
  var Nd = class extends Pt {
    constructor(t) {
      super(t), this.supportsMasking = true, this.rate = t.rate;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = super.getConfig(), r = { rate: this.rate };
      return Object.assign(r, t), r;
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r);
        let n = Ft(t);
        return this.rate > 0 && this.rate < 1 ? $u(() => {
          let s10 = Math.sqrt(this.rate / (1 - this.rate));
          return F(n, Xp(n.shape, 1, s10));
        }, () => n, r.training || false) : n;
      });
    }
  };
  Nd.className = "GaussianDropout";
  K.registerClass(Nd);
  var Cd = class extends Pt {
    constructor(t) {
      super(t), this.supportsMasking = true, this.rate = t.rate, this.noiseShape = t.noiseShape;
    }
    _getNoiseShape(t) {
      return this.noiseShape || Ft(t).shape;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      let t = super.getConfig(), r = { rate: this.rate };
      return Object.assign(r, t), r;
    }
    call(t, r) {
      return M(() => {
        if (this.rate < 1 && this.rate > 0) {
          let n = this._getNoiseShape(t);
          return $u(() => {
            let s10 = Ft(t), u = -1.6732632423543772 * 1.0507009873554805, l = vn(Go(n), this.rate);
            l = Qr(l, "float32");
            let c = ((1 - this.rate) * (1 + this.rate * u ** 2)) ** -0.5, p = -c * u * this.rate, m = Y(F(s10, l), F(Y(l, -1), u));
            return Y(F(m, c), p);
          }, () => Ft(t), r.training || false);
        }
        return t;
      });
    }
  };
  Cd.className = "AlphaDropout";
  K.registerClass(Cd);
  function Sd(e28, t, r, n, o, s10 = 1e-3) {
    let i;
    if (e28.rank === 2) i = SN(e28, t, r, n, o, s10);
    else if (e28.rank === 3) i = IN(e28, t, r, n, o, s10);
    else if (e28.rank === 4) i = TN(e28, t, r, n, o, s10);
    else throw new Rt(`batchNormalization is not implemented for array of rank ${e28.rank} yet`);
    return i;
  }
  function mq(e28, t, r, n, o = 1e-3) {
    return M(() => {
      let s10 = Fp(e28, n), i = s10.mean, a = s10.variance;
      return [Sd(e28, i, a, r, t, o), i, a];
    });
  }
  function fq(e28, t, r, n, o = 1e-3) {
    return M(() => {
      let s10 = Fp(e28, n), i = s10.mean, a = s10.variance, u = [];
      for (let h of mn(0, e28.rank)) n.indexOf(h) !== -1 ? u.push(1) : u.push(e28.shape[h]);
      let l = _(i, u), c = _(a, u), p = t == null ? null : _(t, u), m = r == null ? null : _(r, u);
      return [Sd(e28, l, c, m, p, o), i, a];
    });
  }
  function hq(e28, t, r, n, o = 1e-3) {
    return x.arraysEqual(n.slice().sort(), mn(0, e28.rank - 1)) ? mq(e28, t, r, n, o) : fq(e28, t, r, n, o);
  }
  var Id = class extends Pt {
    constructor(t) {
      t == null && (t = {}), super(t), this.supportsMasking = true, this.axis = t.axis == null ? -1 : t.axis, this.momentum = t.momentum == null ? 0.99 : t.momentum, this.epsilon = t.epsilon == null ? 1e-3 : t.epsilon, this.center = t.center == null ? true : t.center, this.scale = t.scale == null ? true : t.scale, this.betaInitializer = he(t.betaInitializer || "zeros"), this.gammaInitializer = he(t.gammaInitializer || "ones"), this.movingMeanInitializer = he(t.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = he(t.movingVarianceInitializer || "ones"), this.betaConstraint = Re(t.betaConstraint), this.gammaConstraint = Re(t.gammaConstraint), this.betaRegularizer = xe(t.betaRegularizer), this.gammaRegularizer = xe(t.gammaRegularizer);
    }
    build(t) {
      t = jt(t);
      let r = this.axis >= 0 ? this.axis : this.axis + t.length, n = t[r];
      if (n == null) throw new P(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);
      this.inputSpec = [new ye({ ndim: t.length, axes: { [r]: n } })];
      let o = [n];
      this.scale && (this.gamma = this.addWeight("gamma", o, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", o, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", o, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", o, null, this.movingVarianceInitializer, null, false), this.built = true;
    }
    call(t, r) {
      return M(() => {
        let n = r.training == null ? false : r.training, o = Ft(t), s10 = o.shape, i = s10.length, a = mn(0, i), u = this.axis >= 0 ? this.axis : this.axis + i;
        a.splice(u, 1);
        let l = No(1, i);
        l[u] = s10[u];
        let c = a.slice();
        c.sort();
        let p = !x.arraysEqual(c, mn(0, i).slice(0, i - 1)), m = () => {
          if (p) {
            let b = _(this.movingMean.read(), l), v = _(this.movingVariance.read(), l), w = this.center ? _(this.beta.read(), l) : null, N = this.scale ? _(this.gamma.read(), l) : null;
            return Sd(o, b, v, w, N, this.epsilon);
          } else return Sd(o, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
        };
        if (!n) return m();
        let [f, h, d] = hq(o, this.gamma.read(), this.beta.read(), a, this.epsilon), g = (b, v, w) => {
          M(() => {
            let N = 1 - w, E = b.read(), A = F(xt(E, v), N);
            b.write(xt(E, A));
          });
        };
        return (() => {
          g(this.movingMean, h, this.momentum), g(this.movingVariance, d, this.momentum);
        })(), f;
      });
    }
    getConfig() {
      let t = { axis: this.axis, momentum: this.momentum, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: we(this.betaInitializer), gammaInitializer: we(this.gammaInitializer), movingMeanInitializer: we(this.movingMeanInitializer), movingVarianceInitializer: we(this.movingVarianceInitializer), betaRegularizer: ce(this.betaRegularizer), gammaRegularizer: ce(this.gammaRegularizer), betaConstraint: Oe(this.betaConstraint), gammaConstraint: Oe(this.gammaConstraint) }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Id.className = "BatchNormalization";
  K.registerClass(Id);
  var Td = class extends Pt {
    constructor(t) {
      if (t == null && (t = {}), super(t), this.axis = t.axis == null ? -1 : t.axis, typeof this.axis == "number") {
        if (!Number.isInteger(this.axis)) throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
      } else if (Array.isArray(this.axis)) {
        for (let r of this.axis) if (!Number.isInteger(r)) throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
      } else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
      this.epsilon = t.epsilon == null ? 1e-3 : t.epsilon, this.center = t.center == null ? true : t.center, this.scale = t.scale == null ? true : t.scale, this.betaInitializer = he(t.betaInitializer || "zeros"), this.gammaInitializer = he(t.gammaInitializer || "ones"), this.betaRegularizer = xe(t.betaRegularizer), this.gammaRegularizer = xe(t.gammaRegularizer), this.supportsMasking = true;
    }
    build(t) {
      t = jt(t);
      let r = t.length;
      typeof this.axis == "number" && (this.axis = [this.axis]);
      for (let s10 = 0; s10 < this.axis.length; ++s10) this.axis[s10] < 0 && (this.axis[s10] += r);
      for (let s10 of this.axis) if (s10 < 0 || s10 >= r) throw new Error(`Invalid axis: ${s10}`);
      if (this.axis.length !== So(this.axis).length) throw new Error(`Found duplicate axes in: ${this.axis}`);
      let n = this.axis.map((s10) => t[s10]), o = true;
      this.scale ? this.gamma = this.addWeight("gamma", n, "float32", this.gammaInitializer, this.gammaRegularizer, o) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", n, "float32", this.betaInitializer, this.betaRegularizer, o) : this.beta = null, this.built = true;
    }
    call(t, r) {
      let n = Ft(t), o = n.shape, s10 = o.length;
      return M(() => {
        let { mean: a, variance: u } = Fp(n, this.axis, true), l = No(1, s10);
        for (let d of this.axis) l[d] = o[d];
        let c = (d) => d != null && d.shape.length !== s10 ? _(d, l) : d, p = this.scale ? c(this.gamma.read()) : null, m = this.center ? c(this.beta.read()) : null, f = [], h = [];
        for (let d = 0; d < s10; ++d) this.axis.indexOf(d) !== -1 ? (f.push(o[d]), h.push(1)) : (f.push(1), h.push(o[d]));
        return a = Wr(a, f), u = Wr(u, f), p != null && (p = Wr(p, h)), m != null && (m = Wr(m, h)), Sd(n, a, u, m, p, this.epsilon);
      });
    }
    getConfig() {
      let t = { axis: this.axis, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: we(this.betaInitializer), gammaInitializer: we(this.gammaInitializer), betaRegularizer: ce(this.betaRegularizer), gammaRegularizer: ce(this.gammaRegularizer) }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  Td.className = "LayerNormalization";
  K.registerClass(Td);
  function dq(e28, t, r) {
    return M(() => {
      if (e28.rank !== 4) throw new P(`temporalPadding expects input tensor to be 4-D, but received a ${e28.rank}-D tensor.`);
      if (t == null && (t = [[1, 1], [1, 1]]), t.length !== 2 || t[0].length !== 2 || t[1].length !== 2) throw new P("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
      if (r == null && (r = fn()), r !== "channelsLast" && r !== "channelsFirst") throw new P(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
      let n;
      return r === "channelsFirst" ? n = [[0, 0], [0, 0], t[0], t[1]] : n = [[0, 0], t[0], t[1], [0, 0]], Dl(e28, n);
    });
  }
  var kd = class extends Pt {
    constructor(t) {
      if (t == null && (t = {}), super(t), this.dataFormat = t.dataFormat == null ? fn() : t.dataFormat, t.padding == null) this.padding = [[1, 1], [1, 1]];
      else if (typeof t.padding == "number") this.padding = [[t.padding, t.padding], [t.padding, t.padding]];
      else {
        if (t.padding = t.padding, t.padding.length !== 2) throw new P(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);
        let r, n;
        if (typeof t.padding[0] == "number") r = [t.padding[0], t.padding[0]], n = [t.padding[1], t.padding[1]];
        else {
          if (t.padding = t.padding, t.padding[0].length !== 2) throw new P(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);
          if (r = t.padding[0], t.padding[1].length !== 2) throw new P(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);
          n = t.padding[1];
        }
        this.padding = [r, n];
      }
      this.inputSpec = [new ye({ ndim: 4 })];
    }
    computeOutputShape(t) {
      t = jt(t);
      let r, n;
      return this.dataFormat === "channelsFirst" ? (t[2] != null && t[2] >= 0 ? r = t[2] + this.padding[0][0] + this.padding[0][1] : r = null, t[3] != null && t[3] >= 0 ? n = t[3] + this.padding[1][0] + this.padding[1][1] : n = null, [t[0], t[1], r, n]) : (t[1] != null && t[1] >= 0 ? r = t[1] + this.padding[0][0] + this.padding[0][1] : r = null, t[2] != null && t[2] >= 0 ? n = t[2] + this.padding[1][0] + this.padding[1][1] : n = null, [t[0], r, n, t[3]]);
    }
    call(t, r) {
      return M(() => dq(Ft(t), this.padding, this.dataFormat));
    }
    getConfig() {
      let t = { padding: this.padding, dataFormat: this.dataFormat }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  kd.className = "ZeroPadding2D";
  K.registerClass(kd);
  function Sb(e28, t, r, n, o, s10) {
    return M(() => {
      Ee(o), T1(s10), pn(n), r == null && (r = [1, 1]), n == null && (n = "valid"), o == null && (o = fn()), s10 == null && (s10 = "max"), e28 = Zh(e28, o);
      let i, a = n === "same" ? "same" : "valid";
      return s10 === "max" ? i = Al(e28, t, r, a) : i = Cl(e28, t, r, a), o === "channelsFirst" && (i = qt(i, [0, 3, 1, 2])), i;
    });
  }
  function DD(e28, t, r, n, o, s10) {
    return M(() => {
      Ee(o), T1(s10), pn(n), r == null && (r = [1, 1, 1]), n == null && (n = "valid"), o == null && (o = fn()), s10 == null && (s10 = "max"), e28 = W1(e28, o);
      let i, a = n === "same" ? "same" : "valid";
      return s10 === "max" ? i = UN(e28, t, r, a) : i = CN(e28, t, r, a), o === "channelsFirst" && (i = qt(i, [0, 4, 1, 2, 3])), i;
    });
  }
  var bb = class extends Pt {
    constructor(t) {
      if (t.poolSize == null && (t.poolSize = 2), super(t), typeof t.poolSize == "number") this.poolSize = [t.poolSize];
      else if (Array.isArray(t.poolSize) && t.poolSize.length === 1 && typeof t.poolSize[0] == "number") this.poolSize = t.poolSize;
      else throw new P(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);
      if (Je(this.poolSize, "poolSize"), t.strides == null) this.strides = this.poolSize;
      else if (typeof t.strides == "number") this.strides = [t.strides];
      else if (Array.isArray(t.strides) && t.strides.length === 1 && typeof t.strides[0] == "number") this.strides = t.strides;
      else throw new P(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);
      Je(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, pn(this.padding), this.inputSpec = [new ye({ ndim: 3 })];
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = Nn(t[1], this.poolSize[0], this.padding, this.strides[0]);
      return [t[0], r, t[2]];
    }
    call(t, r) {
      return M(() => {
        this.invokeCallHook(t, r), t = ea(Ft(t), 2);
        let n = this.poolingFunction(Ft(t), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
        return Wo(n, [2]);
      });
    }
    getConfig() {
      let t = { poolSize: this.poolSize, padding: this.padding, strides: this.strides }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  var Ed = class extends bb {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, r, n, o, s10) {
      return Ee(s10), pn(o), Sb(t, r, n, o, s10, "max");
    }
  };
  Ed.className = "MaxPooling1D";
  K.registerClass(Ed);
  var Ad = class extends bb {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, r, n, o, s10) {
      return Ee(s10), pn(o), Sb(t, r, n, o, s10, "avg");
    }
  };
  Ad.className = "AveragePooling1D";
  K.registerClass(Ad);
  var wb = class extends Pt {
    constructor(t) {
      if (t.poolSize == null && (t.poolSize = [2, 2]), super(t), this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize], t.strides == null) this.strides = this.poolSize;
      else if (Array.isArray(t.strides)) {
        if (t.strides.length !== 2) throw new P(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);
        this.strides = t.strides;
      } else this.strides = [t.strides, t.strides];
      Je(this.poolSize, "poolSize"), Je(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Ee(this.dataFormat), pn(this.padding), this.inputSpec = [new ye({ ndim: 4 })];
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = this.dataFormat === "channelsFirst" ? t[2] : t[1], n = this.dataFormat === "channelsFirst" ? t[3] : t[2];
      return r = Nn(r, this.poolSize[0], this.padding, this.strides[0]), n = Nn(n, this.poolSize[1], this.padding, this.strides[1]), this.dataFormat === "channelsFirst" ? [t[0], t[1], r, n] : [t[0], r, n, t[3]];
    }
    call(t, r) {
      return M(() => (this.invokeCallHook(t, r), this.poolingFunction(Ft(t), this.poolSize, this.strides, this.padding, this.dataFormat)));
    }
    getConfig() {
      let t = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  var Dd = class extends wb {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, r, n, o, s10) {
      return Ee(s10), pn(o), Sb(t, r, n, o, s10, "max");
    }
  };
  Dd.className = "MaxPooling2D";
  K.registerClass(Dd);
  var $d = class extends wb {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, r, n, o, s10) {
      return Ee(s10), pn(o), Sb(t, r, n, o, s10, "avg");
    }
  };
  $d.className = "AveragePooling2D";
  K.registerClass($d);
  var vb = class extends Pt {
    constructor(t) {
      if (t.poolSize == null && (t.poolSize = [2, 2, 2]), super(t), this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize, t.poolSize], t.strides == null) this.strides = this.poolSize;
      else if (Array.isArray(t.strides)) {
        if (t.strides.length !== 3) throw new P(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);
        this.strides = t.strides;
      } else this.strides = [t.strides, t.strides, t.strides];
      Je(this.poolSize, "poolSize"), Je(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Ee(this.dataFormat), pn(this.padding), this.inputSpec = [new ye({ ndim: 5 })];
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = this.dataFormat === "channelsFirst" ? t[2] : t[1], n = this.dataFormat === "channelsFirst" ? t[3] : t[2], o = this.dataFormat === "channelsFirst" ? t[4] : t[3];
      return r = Nn(r, this.poolSize[0], this.padding, this.strides[0]), n = Nn(n, this.poolSize[1], this.padding, this.strides[1]), o = Nn(o, this.poolSize[2], this.padding, this.strides[2]), this.dataFormat === "channelsFirst" ? [t[0], t[1], r, n, o] : [t[0], r, n, o, t[4]];
    }
    call(t, r) {
      return M(() => (this.invokeCallHook(t, r), this.poolingFunction(Ft(t), this.poolSize, this.strides, this.padding, this.dataFormat)));
    }
    getConfig() {
      let t = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  var Fd = class extends vb {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, r, n, o, s10) {
      return Ee(s10), pn(o), DD(t, r, n, o, s10, "max");
    }
  };
  Fd.className = "MaxPooling3D";
  K.registerClass(Fd);
  var _d = class extends vb {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, r, n, o, s10) {
      return Ee(s10), pn(o), DD(t, r, n, o, s10, "avg");
    }
  };
  _d.className = "AveragePooling3D";
  K.registerClass(_d);
  var Nb = class extends Pt {
    constructor(t) {
      super(t), this.inputSpec = [new ye({ ndim: 3 })];
    }
    computeOutputShape(t) {
      return [t[0], t[2]];
    }
    call(t, r) {
      throw new Rt();
    }
  };
  var Od = class extends Nb {
    constructor(t) {
      super(t || {});
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        return ke(n, 1);
      });
    }
  };
  Od.className = "GlobalAveragePooling1D";
  K.registerClass(Od);
  var Rd = class extends Nb {
    constructor(t) {
      super(t || {});
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        return _r(n, 1);
      });
    }
  };
  Rd.className = "GlobalMaxPooling1D";
  K.registerClass(Rd);
  var Cb = class extends Pt {
    constructor(t) {
      super(t), this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Ee(this.dataFormat), this.inputSpec = [new ye({ ndim: 4 })];
    }
    computeOutputShape(t) {
      return t = t, this.dataFormat === "channelsLast" ? [t[0], t[3]] : [t[0], t[1]];
    }
    call(t, r) {
      throw new Rt();
    }
    getConfig() {
      let t = { dataFormat: this.dataFormat }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  var Pd = class extends Cb {
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        return this.dataFormat === "channelsLast" ? ke(n, [1, 2]) : ke(n, [2, 3]);
      });
    }
  };
  Pd.className = "GlobalAveragePooling2D";
  K.registerClass(Pd);
  var Ld = class extends Cb {
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        return this.dataFormat === "channelsLast" ? _r(n, [1, 2]) : _r(n, [2, 3]);
      });
    }
  };
  Ld.className = "GlobalMaxPooling2D";
  K.registerClass(Ld);
  var Ib = class extends Pt {
    constructor(t) {
      super(t), this.layer = t.layer;
    }
    build(t) {
      this.built = true;
    }
    get trainable() {
      return this.layer != null ? this.layer.trainable : false;
    }
    set trainable(t) {
      this.layer != null && (this.layer.trainable = t);
    }
    get trainableWeights() {
      return this.layer.trainableWeights;
    }
    get nonTrainableWeights() {
      return this.layer.nonTrainableWeights;
    }
    get updates() {
      return this.layer._updates;
    }
    get losses() {
      return this.layer.losses;
    }
    getWeights() {
      return this.layer.getWeights();
    }
    setWeights(t) {
      this.layer.setWeights(t);
    }
    getConfig() {
      let t = { layer: { className: this.layer.getClassName(), config: this.layer.getConfig() } }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    setFastWeightInitDuringBuild(t) {
      super.setFastWeightInitDuringBuild(t), this.layer != null && this.layer.setFastWeightInitDuringBuild(t);
    }
    static fromConfig(t, r, n = {}) {
      let o = r.layer, s10 = zn(o, n);
      delete r.layer;
      let i = { layer: s10 };
      return Object.assign(i, r), new t(i);
    }
  };
  var Md = class extends Ib {
    constructor(t) {
      super(t), this.supportsMasking = true;
    }
    build(t) {
      if (t = jt(t), t.length < 3) throw new P(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);
      this.inputSpec = [{ shape: t }];
      let r = [t[0]].concat(t.slice(2));
      this.layer.built || (this.layer.build(r), this.layer.built = true), super.build(t);
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = [t[0]].concat(t.slice(2)), n = this.layer.computeOutputShape(r), o = t[1];
      return [n[0], o].concat(n.slice(1));
    }
    call(t, r) {
      return M(() => (t = Ft(t), j1((i, a) => [Ft(this.layer.call(i, r)), []], t, [], false, null, null, false, true)[1]));
    }
  };
  Md.className = "TimeDistributed";
  K.registerClass(Md);
  function gq(e28) {
    Es(WA, "BidirectionalMergeMode", e28);
  }
  var yq = "concat";
  var zd = class extends Ib {
    constructor(t) {
      super(t);
      let r = t.layer.getConfig(), n = {};
      n.className = t.layer.getClassName(), n.config = r, this.forwardLayer = zn(n), r.goBackwards = r.goBackwards !== true;
      let o = {};
      if (o.className = t.layer.getClassName(), o.config = r, this.backwardLayer = zn(o), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = t.mergeMode === void 0 ? yq : t.mergeMode, gq(this.mergeMode), t.weights) throw new Rt("weights support is not implemented for Bidirectional layer yet.");
      this._stateful = t.layer.stateful, this.returnSequences = t.layer.returnSequences, this.returnState = t.layer.returnState, this.supportsMasking = true, this._trainable = true, this.inputSpec = t.layer.inputSpec, this.numConstants = null;
    }
    get trainable() {
      return this._trainable;
    }
    set trainable(t) {
      this._trainable = t, this.forwardLayer != null && (this.forwardLayer.trainable = t), this.backwardLayer != null && (this.backwardLayer.trainable = t);
    }
    getWeights() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }
    setWeights(t) {
      let r = t.length, n = Math.floor(r / 2);
      this.forwardLayer.setWeights(t.slice(0, n)), this.backwardLayer.setWeights(t.slice(n));
    }
    computeOutputShape(t) {
      let r = this.forwardLayer.computeOutputShape(t);
      Array.isArray(r) && Array.isArray(r[0]) || (r = [r]), r = r;
      let n, o, s10;
      return this.returnState && (s10 = r.slice(1)), n = r[0], n = n, this.mergeMode === "concat" ? (n[n.length - 1] *= 2, o = [n]) : this.mergeMode == null ? o = [n, n.slice()] : o = [n], this.returnState ? this.mergeMode == null ? o.concat(s10).concat(s10.slice()) : [n].concat(s10).concat(s10.slice()) : Ir(o);
    }
    apply(t, r) {
      let n = r == null ? null : r.initialState, o = r == null ? null : r.constants;
      r == null && (r = {});
      let s10 = U1(t, n, o, this.numConstants);
      if (t = s10.inputs, n = s10.initialState, o = s10.constants, Array.isArray(t) && (n = t.slice(1), t = t[0]), (n == null || n.length === 0) && o == null) return super.apply(t, r);
      let i = [], a = [];
      if (n != null) {
        let l = n.length;
        if (l % 2 > 0) throw new P("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        r.initialState = n, i.push(...n);
        let c = n.map((p) => new ye({ shape: p.shape }));
        this.forwardLayer.stateSpec = c.slice(0, l / 2), this.backwardLayer.stateSpec = c.slice(l / 2), a.push(...c);
      }
      if (o != null) throw new Rt("Support for constants in Bidirectional layers is not implemented yet.");
      let u = i[0] instanceof en;
      for (let l of i) if (l instanceof en !== u) throw new P("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
      if (u) {
        let l = [t].concat(i), c = this.inputSpec.concat(a), p = this.inputSpec;
        this.inputSpec = c;
        let m = super.apply(l, r);
        return this.inputSpec = p, m;
      } else return super.apply(t, r);
    }
    call(t, r) {
      return M(() => {
        let n = r.initialState, o, s10;
        if (n == null) o = this.forwardLayer.call(t, r), s10 = this.backwardLayer.call(t, r);
        else {
          let u = n.slice(0, n.length / 2), l = n.slice(n.length / 2);
          o = this.forwardLayer.call(t, Object.assign(r, { initialState: u })), s10 = this.backwardLayer.call(t, Object.assign(r, { initialState: l }));
        }
        let i;
        this.returnState && (Array.isArray(o) && (i = o.slice(1).concat(s10.slice(1))), o = o[0], s10 = s10[0]), this.returnSequences && (s10 = to(s10, 1));
        let a;
        return this.mergeMode === "concat" ? a = qp([o, s10]) : this.mergeMode === "sum" ? a = Y(o, s10) : this.mergeMode === "ave" ? a = F(0.5, Y(o, s10)) : this.mergeMode === "mul" ? a = F(o, s10) : this.mergeMode == null && (a = [o, s10]), this.returnState ? this.mergeMode == null ? a.concat(i) : [a].concat(i) : a;
      });
    }
    resetStates(t) {
      this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
    }
    build(t) {
      Ho(this.forwardLayer.name, () => {
        this.forwardLayer.build(t);
      }), Ho(this.backwardLayer.name, () => {
        this.backwardLayer.build(t);
      }), this.built = true;
    }
    computeMask(t, r) {
      Array.isArray(r) && (r = r[0]);
      let n;
      if (this.returnSequences ? this.mergeMode == null ? n = [r, r] : n = r : this.mergeMode == null ? n = [null, null] : n = null, this.returnState) {
        let s10 = this.forwardLayer.states.map((i) => null);
        return Array.isArray(n) ? n.concat(s10).concat(s10) : [n].concat(s10).concat(s10);
      } else return n;
    }
    get trainableWeights() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }
    get nonTrainableWeights() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }
    setFastWeightInitDuringBuild(t) {
      super.setFastWeightInitDuringBuild(t), this.forwardLayer != null && this.forwardLayer.setFastWeightInitDuringBuild(t), this.backwardLayer != null && this.backwardLayer.setFastWeightInitDuringBuild(t);
    }
    getConfig() {
      let t = { mergeMode: this.mergeMode }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    static fromConfig(t, r) {
      let n = zn(r.layer);
      if (delete r.layer, r.numConstants != null) throw new Rt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
      let o = r;
      return o.layer = n, new t(o);
    }
  };
  zd.className = "Bidirectional";
  K.registerClass(zd);
  var Bd = class extends Pt {
    constructor(t) {
      super(t), this.scale = t.scale, t.offset ? this.offset = t.offset : this.offset = 0;
    }
    getConfig() {
      let t = { scale: this.scale, offset: this.offset }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    call(t, r) {
      return M(() => (t = Ft(t), t.dtype !== "float32" && (t = Qr(t, "float32")), Y(F(t, this.scale), this.offset)));
    }
  };
  Bd.className = "Rescaling";
  K.registerClass(Bd);
  var { resizeBilinear: xq, cropAndResize: bq } = Mn;
  var Vd = class extends Pt {
    constructor(t) {
      super(t), this.height = t.height, this.width = t.width;
    }
    centerCrop(t, r, n, o, s10, i, a, u) {
      return M(() => {
        let l, c = false, p = r / i, m = n / a, f = (o + r) / i, h = (s10 + n) / a, d = [p, m, f, h], g = [];
        t.rank === 3 ? (c = true, l = Xe([t])) : l = t;
        for (let N = 0; N < l.shape[0]; N++) g.push(d);
        let y = me(g, [g.length, 4]), b = Ji(0, g.length, 1, "int32"), w = bq(l, y, b, [o, s10], "nearest");
        return c ? Qr(Ft(Zr(w)), u) : Qr(w, u);
      });
    }
    upsize(t, r, n, o) {
      return M(() => {
        let s10 = xq(t, [r, n]);
        return Qr(s10, o);
      });
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t), o = n.dtype, s10 = n.shape, i = s10[s10.length - 3], a = s10[s10.length - 2], u = 0;
        i !== this.height && (u = Math.floor((i - this.height) / 2));
        let l = 0;
        return a !== this.width && (l = Math.floor((a - this.width) / 2), l === 0 && (l = 1)), u >= 0 && l >= 0 ? this.centerCrop(n, u, l, this.height, this.width, i, a, o) : this.upsize(t, this.height, this.width, o);
      });
    }
    getConfig() {
      let t = { height: this.height, width: this.width }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t.length - 3, n = t.length - 2;
      return t[r] = this.height, t[n] = this.width, t;
    }
  };
  Vd.className = "CenterCrop";
  K.registerClass(Vd);
  function $D(e28, t, r, n) {
    let o = Ft(e28);
    if (o.dtype !== "int32" && (o = Qr(o, "int32")), t === "int") return o;
    let s10 = o.shape;
    if (o.rank === 0 && (o = or(o, -1)), t === "oneHot" && o.shape[o.shape.length - 1] !== 1 && (o = or(o, -1)), o.rank > 2) throw new P(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s10} which would result in output rank ${o.rank}.`);
    let i = ["multiHot", "oneHot"].includes(t), a = o, u;
    if (typeof n < "u" && t === "count" ? u = Jy(a, n, r, i) : u = Jy(a, [], r, i), t !== "tfIdf") return u;
    if (n) return F(u, n);
    throw new P("When outputMode is 'tfIdf', weights must be provided.");
  }
  var Gd = class extends Pt {
    constructor(t) {
      super(t), this.numTokens = t.numTokens, t.outputMode ? this.outputMode = t.outputMode : this.outputMode = "multiHot";
    }
    getConfig() {
      let t = { numTokens: this.numTokens, outputMode: this.outputMode }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    computeOutputShape(t) {
      return t = jt(t), t == null ? [this.numTokens] : this.outputMode === "oneHot" && t[t.length - 1] !== 1 ? (t.push(this.numTokens), t) : (t[t.length - 1] = this.numTokens, t);
    }
    call(t, r) {
      return M(() => {
        t = Ft(t), t.dtype !== "int32" && (t = Qr(t, "int32"));
        let n;
        if (typeof r.countWeights < "u") {
          if (this.outputMode !== "count") throw new P(`countWeights is not used when outputMode !== count.
              Received countWeights=${r.countWeights}`);
          n = Ft(r.countWeights);
        }
        let o = _r(t), s10 = Tu(t), i = je(this.numTokens, o).bufferSync().get(0), a = vn(s10, 0).bufferSync().get(0);
        if (!(i && a)) throw new P(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
        return $D(t, this.outputMode, this.numTokens, n);
      });
    }
  };
  Gd.className = "CategoryEncoding";
  K.registerClass(Gd);
  var vq = ["bilinear", "nearest"];
  var FD = new Set(vq);
  var Wd = class extends Pt {
    constructor(t) {
      if (super(t), this.height = t.height, this.width = t.width, t.interpolation) if (FD.has(t.interpolation)) this.interpolation = t.interpolation;
      else throw new P(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);
      else this.interpolation = "bilinear";
      this.cropToAspectRatio = !!t.cropToAspectRatio;
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t[2];
      return [this.height, this.width, r];
    }
    getConfig() {
      let t = { height: this.height, width: this.width, interpolation: this.interpolation, cropToAspectRatio: this.cropToAspectRatio }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    call(t, r) {
      return M(() => {
        let n = [this.height, this.width];
        if (this.interpolation === "bilinear") return Mn.resizeBilinear(t, n, !this.cropToAspectRatio);
        if (this.interpolation === "nearest") return Mn.resizeNearestNeighbor(t, n, !this.cropToAspectRatio);
        throw new Error(`Interpolation is ${this.interpolation} but only ${[...FD]} are supported`);
      });
    }
  };
  Wd.className = "Resizing";
  K.registerClass(Wd);
  var Ud = class {
    constructor(t) {
      this.seed = t;
    }
    next() {
      if (this.seed !== void 0) return this.seed++;
    }
  };
  Ud.className = "RandomSeed";
  var jd = class extends Pt {
    constructor(t) {
      super(t), this.randomGenerator = new Ud(t.seed);
    }
    getConfig() {
      let t = { seed: this.randomGenerator.seed }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
  };
  jd.className = "BaseRandomLayer";
  var Nq = ["bilinear", "nearest"];
  var _D = new Set(Nq);
  var Hd = class extends jd {
    constructor(t) {
      super(t);
      let { factor: r, interpolation: n = "bilinear" } = t;
      if (this.factor = r, Array.isArray(this.factor) && this.factor.length === 2) this.widthLower = this.factor[0], this.widthUpper = this.factor[1];
      else if (!Array.isArray(this.factor) && this.factor > 0) this.widthLower = -this.factor, this.widthUpper = this.factor;
      else throw new P(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);
      if (this.widthLower < -1 || this.widthUpper < -1) throw new P(`factor must have values larger than -1. Got: ${this.factor}`);
      if (this.widthUpper < this.widthLower) throw new P(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);
      if (n) if (_D.has(n)) this.interpolation = n;
      else throw new P(`Invalid interpolation parameter: ${n} is not implemented`);
    }
    getConfig() {
      let t = { factor: this.factor, interpolation: this.interpolation }, r = super.getConfig();
      return Object.assign(t, r), t;
    }
    computeOutputShape(t) {
      t = jt(t);
      let r = t[2];
      return [this.imgHeight, -1, r];
    }
    call(t, r) {
      return M(() => {
        let n = Ft(t);
        this.imgHeight = n.shape[n.shape.length - 3];
        let o = n.shape[n.shape.length - 2];
        this.widthFactor = Go([1], 1 + this.widthLower, 1 + this.widthUpper, "float32", this.randomGenerator.next());
        let s10 = this.widthFactor.dataSync()[0] * o;
        s10 = Math.round(s10);
        let i = [this.imgHeight, s10];
        switch (this.interpolation) {
          case "bilinear":
            return Mn.resizeBilinear(t, i);
          case "nearest":
            return Mn.resizeNearestNeighbor(t, i);
          default:
            throw new Error(`Interpolation is ${this.interpolation}
          but only ${[..._D]} are supported`);
        }
      });
    }
  };
  Hd.className = "RandomWidth";
  K.registerClass(Hd);
  var Eq = z();
  Eq.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (e28) => {
    e28 && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
  });
  var H1;
  (function(e28) {
    e28[e28.DT_INVALID = 0] = "DT_INVALID", e28[e28.DT_FLOAT = 1] = "DT_FLOAT", e28[e28.DT_DOUBLE = 2] = "DT_DOUBLE", e28[e28.DT_INT32 = 3] = "DT_INT32", e28[e28.DT_UINT8 = 4] = "DT_UINT8", e28[e28.DT_INT16 = 5] = "DT_INT16", e28[e28.DT_INT8 = 6] = "DT_INT8", e28[e28.DT_STRING = 7] = "DT_STRING", e28[e28.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e28[e28.DT_INT64 = 9] = "DT_INT64", e28[e28.DT_BOOL = 10] = "DT_BOOL", e28[e28.DT_QINT8 = 11] = "DT_QINT8", e28[e28.DT_QUINT8 = 12] = "DT_QUINT8", e28[e28.DT_QINT32 = 13] = "DT_QINT32", e28[e28.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e28[e28.DT_QINT16 = 15] = "DT_QINT16", e28[e28.DT_QUINT16 = 16] = "DT_QUINT16", e28[e28.DT_UINT16 = 17] = "DT_UINT16", e28[e28.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e28[e28.DT_HALF = 19] = "DT_HALF", e28[e28.DT_RESOURCE = 20] = "DT_RESOURCE", e28[e28.DT_VARIANT = 21] = "DT_VARIANT", e28[e28.DT_UINT32 = 22] = "DT_UINT32", e28[e28.DT_UINT64 = 23] = "DT_UINT64", e28[e28.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e28[e28.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e28[e28.DT_INT32_REF = 103] = "DT_INT32_REF", e28[e28.DT_UINT8_REF = 104] = "DT_UINT8_REF", e28[e28.DT_INT16_REF = 105] = "DT_INT16_REF", e28[e28.DT_INT8_REF = 106] = "DT_INT8_REF", e28[e28.DT_STRING_REF = 107] = "DT_STRING_REF", e28[e28.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e28[e28.DT_INT64_REF = 109] = "DT_INT64_REF", e28[e28.DT_BOOL_REF = 110] = "DT_BOOL_REF", e28[e28.DT_QINT8_REF = 111] = "DT_QINT8_REF", e28[e28.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e28[e28.DT_QINT32_REF = 113] = "DT_QINT32_REF", e28[e28.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", e28[e28.DT_QINT16_REF = 115] = "DT_QINT16_REF", e28[e28.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", e28[e28.DT_UINT16_REF = 117] = "DT_UINT16_REF", e28[e28.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", e28[e28.DT_HALF_REF = 119] = "DT_HALF_REF", e28[e28.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", e28[e28.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e28[e28.DT_UINT32_REF = 122] = "DT_UINT32_REF", e28[e28.DT_UINT64_REF = 123] = "DT_UINT64_REF";
  })(H1 || (H1 = {}));
  var OD;
  (function(e28) {
    let t;
    (function(r) {
      r[r.LEGACY = 0] = "LEGACY", r[r.V1 = 1] = "V1", r[r.V2 = 2] = "V2";
    })(t = e28.CheckpointFormatVersion || (e28.CheckpointFormatVersion = {}));
  })(OD || (OD = {}));
  var jD = ff(Zf());
  var GD = ff(Zf());
  function PD(e28, t) {
    return LD(e28, t);
  }
  function LD(e28, t, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set()) {
    if (e28 == null) return null;
    if (typeof Blob == "function" && e28 instanceof Blob) return e28.slice();
    if (n.has(e28)) throw new Error("Circular references are not supported.");
    if (r.has(e28)) return r.get(e28);
    let o = t(e28);
    if (o.recurse && o.value !== null) throw new Error("A deep map function may not return both a value and recurse=true.");
    if (o.recurse) if (bm(e28)) {
      let s10 = Array.isArray(e28) ? [] : {};
      n.add(e28);
      for (let i in e28) {
        let a = e28[i], u = LD(a, t, r, n);
        s10[i] = u;
      }
      return n.delete(e28), e28.__proto__ && (s10.__proto__ = e28.__proto__), s10;
    } else throw new Error(`Can't recurse into non-iterable type: ${e28}`);
    else return r.set(e28, o.value), o.value;
  }
  function MD(e28, t = K1) {
    return zD(e28, t);
  }
  function zD(e28, t, r = /* @__PURE__ */ new Set()) {
    let n = e28[0];
    if (r.has(n)) throw new Error("Circular references are not supported.");
    let o = t(e28);
    if (o.recurse && o.value !== null) throw new Error("A deep zip function may not return both a value and recurse=true.");
    if (o.recurse) if (bm(n)) {
      let s10 = Array.isArray(n) ? [] : {};
      r.add(n);
      for (let i in n) {
        let a = e28.map((l) => l[i]), u = zD(a, t, r);
        s10[i] = u;
      }
      return r.delete(n), s10;
    } else throw new Error(`Can't recurse into non-iterable type: ${n}`);
    else return o.value;
  }
  function K1(e28) {
    return e28 === null ? null : bm(e28[0]) ? { value: null, recurse: true } : { value: e28, recurse: false };
  }
  function bm(e28) {
    let t = false;
    if (z().get("IS_BROWSER")) t = e28 instanceof TextDecoder;
    else {
      let { StringDecoder: r } = RD();
      t = e28 instanceof r;
    }
    return e28 != null && !ArrayBuffer.isView(e28) && (Array.isArray(e28) || typeof e28 == "object" && !(e28 instanceof ee) && !(e28 instanceof Promise) && !t);
  }
  function BD(e28) {
    return e28 == null || v6(e28) || Array.isArray(e28) || typeof e28 == "object" && e28 instanceof ee || x.isTypedArray(e28);
  }
  function v6(e28) {
    return e28 === null || typeof e28 != "object" && typeof e28 != "function";
  }
  function VD(e28) {
    return PD(e28, N6);
  }
  function N6(e28) {
    return e28 instanceof ee ? { value: e28.clone(), recurse: false } : bm(e28) ? { value: null, recurse: true } : { value: e28, recurse: false };
  }
  var wm = class {
    constructor(t) {
      if (this.capacity = t, this.begin = 0, this.end = 0, t == null) throw new RangeError("Can't create a ring buffer of unknown capacity.");
      if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
      this.data = new Array(t), this.doubledCapacity = 2 * t;
    }
    wrap(t) {
      for (; t < 0; ) t += this.doubledCapacity;
      return t % this.doubledCapacity;
    }
    get(t) {
      if (t < 0) throw new RangeError("Can't get item at a negative index.");
      return this.data[t % this.capacity];
    }
    set(t, r) {
      if (t < 0) throw new RangeError("Can't set item at a negative index.");
      this.data[t % this.capacity] = r;
    }
    length() {
      let t = this.end - this.begin;
      return t < 0 && (t = this.doubledCapacity + t), t;
    }
    isFull() {
      return this.length() === this.capacity;
    }
    isEmpty() {
      return this.length() === 0;
    }
    push(t) {
      if (this.isFull()) throw new RangeError("Ring buffer is full.");
      this.set(this.end, t), this.end = this.wrap(this.end + 1);
    }
    pushAll(t) {
      for (let r of t) this.push(r);
    }
    pop() {
      if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
      this.end = this.wrap(this.end - 1);
      let t = this.get(this.end);
      return this.set(this.end, void 0), t;
    }
    unshift(t) {
      if (this.isFull()) throw new RangeError("Ring buffer is full.");
      this.begin = this.wrap(this.begin - 1), this.set(this.begin, t);
    }
    shift() {
      if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
      let t = this.get(this.begin);
      return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t;
    }
    shuffleExcise(t) {
      if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
      let r = this.wrap(this.begin + t), n = this.get(r);
      return this.set(r, this.pop()), n;
    }
  };
  var Kd = class e24 extends wm {
    constructor() {
      super(e24.INITIAL_CAPACITY);
    }
    isFull() {
      return false;
    }
    push(t) {
      super.isFull() && this.expand(), super.push(t);
    }
    unshift(t) {
      super.isFull() && this.expand(), super.unshift(t);
    }
    expand() {
      let t = this.capacity * 2, r = new Array(t), n = this.length();
      for (let o = 0; o < n; o++) r[o] = this.get(this.wrap(this.begin + o));
      this.data = r, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n;
    }
  };
  Kd.INITIAL_CAPACITY = 32;
  function WD(e28) {
    return new q1(e28);
  }
  function iC(e28) {
    return new X1(e28);
  }
  function UD(e28, t) {
    return new Eb(e28, t);
  }
  var Rr = class {
    async toArray() {
      let t = [], r = await this.next();
      for (; !r.done; ) t.push(r.value), r = await this.next();
      return t;
    }
    async toArrayForTest() {
      let t = this.prefetch(100), r = [], n = await t.next();
      for (; !n.done; ) r.push(n.value), n = await t.next();
      return r;
    }
    async resolveFully() {
      let t = await this.next();
      for (; !t.done; ) t = await this.next();
    }
    async resolveWhile(t) {
      let r = await this.next(), n = t(r.value);
      for (; !r.done && n; ) r = await this.next(), n = t(r.value);
    }
    handleErrors(t) {
      return new rC(this, t);
    }
    filter(t) {
      return new tC(this, t);
    }
    map(t) {
      return new eC(this, t);
    }
    mapAsync(t) {
      return new kb(this, t);
    }
    serialMapAsync(t) {
      return new kb(this, t).serial();
    }
    flatmap(t) {
      return new nC(this, t);
    }
    async forEachAsync(t) {
      return this.map(t).resolveFully();
    }
    async serialForEach(t) {
      return this.serialMapAsync(t).resolveWhile((r) => r === true);
    }
    rowMajorBatch(t, r = true) {
      return new Q1(this, t, r);
    }
    columnMajorBatch(t, r = true, n = K1) {
      return this.rowMajorBatch(t, r).map((s10) => MD(s10, n));
    }
    concatenate(t, r) {
      return new Eb(WD([this, t]), r);
    }
    take(t) {
      return t < 0 || t == null ? this : new Z1(this, t);
    }
    skip(t) {
      return t < 0 || t == null ? this : new J1(this, t);
    }
    prefetch(t) {
      return new Ab(this, t);
    }
    shuffle(t, r) {
      return new sC(this, t, r);
    }
    serial() {
      return new Y1(this);
    }
  };
  var q1 = class extends Rr {
    constructor(t) {
      super(), this.items = t, this.trav = 0;
    }
    summary() {
      return `Array of ${this.items.length} items`;
    }
    async next() {
      if (this.trav >= this.items.length) return { value: null, done: true };
      let t = this.items[this.trav];
      return this.trav++, { value: VD(t), done: false };
    }
  };
  var X1 = class extends Rr {
    constructor(t) {
      super(), this.nextFn = t;
    }
    summary() {
      return "Function call";
    }
    async next() {
      try {
        return this.nextFn();
      } catch (t) {
        throw t.message = `Error thrown while iterating through a dataset: ${t.message}`, t;
      }
    }
  };
  var Y1 = class extends Rr {
    constructor(t) {
      super(), this.upstream = t, this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Serial`;
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    async serialNext() {
      return this.upstream.next();
    }
  };
  var J1 = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.maxCount = r, this.count = 0, this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Skip`;
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    async serialNext() {
      for (; this.count++ < this.maxCount; ) {
        let t = await this.upstream.next();
        if (t.done) return t;
        Mt(t.value);
      }
      return this.upstream.next();
    }
  };
  var Z1 = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.maxCount = r, this.count = 0;
    }
    summary() {
      return `${this.upstream.summary()} -> Take`;
    }
    async next() {
      return this.count++ >= this.maxCount ? { value: null, done: true } : this.upstream.next();
    }
  };
  var Q1 = class extends Rr {
    constructor(t, r, n = true) {
      super(), this.upstream = t, this.batchSize = r, this.enableSmallLastBatch = n, this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> RowMajorBatch`;
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    async serialNext() {
      let t = [];
      for (; t.length < this.batchSize; ) {
        let r = await this.upstream.next();
        if (r.done) return this.enableSmallLastBatch && t.length > 0 ? { value: t, done: false } : { value: null, done: true };
        t.push(r.value);
      }
      return { value: t, done: false };
    }
  };
  var tC = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.predicate = r, this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Filter`;
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    async serialNext() {
      for (; ; ) {
        let t = await this.upstream.next();
        if (t.done || this.predicate(t.value)) return t;
        Mt(t.value);
      }
    }
  };
  var eC = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.transform = r;
    }
    summary() {
      return `${this.upstream.summary()} -> Map`;
    }
    async next() {
      let t = await this.upstream.next();
      if (t.done) return { value: null, done: true };
      let r = go.getTensorsInContainer(t.value), n = this.transform(t.value), o = go.getTensorsInContainer(n);
      for (let s10 of r) go.isTensorInList(s10, o) || s10.dispose();
      return { value: n, done: false };
    }
  };
  var rC = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.handler = r, this.count = 0, this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> handleErrors`;
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    async serialNext() {
      for (; ; ) try {
        return await this.upstream.next();
      } catch (t) {
        if (!this.handler(t)) return { value: null, done: true };
      }
    }
  };
  var kb = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.transform = r;
    }
    summary() {
      return `${this.upstream.summary()} -> AsyncMap`;
    }
    async next() {
      let t = await this.upstream.next();
      if (t.done) return { value: null, done: true };
      let r = go.getTensorsInContainer(t.value), n = await this.transform(t.value), o = go.getTensorsInContainer(n);
      for (let s10 of r) go.isTensorInList(s10, o) || s10.dispose();
      return { value: n, done: false };
    }
  };
  var qd = class extends Rr {
    constructor() {
      super(), this.outputQueue = new Kd(), this.lastRead = Promise.resolve({ value: null, done: false });
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    async serialNext() {
      for (; this.outputQueue.length() === 0; ) if (!await this.pump()) return { value: null, done: true };
      return { value: this.outputQueue.shift(), done: false };
    }
  };
  var nC = class extends qd {
    constructor(t, r) {
      super(), this.upstream = t, this.transform = r;
    }
    summary() {
      return `${this.upstream.summary()} -> Flatmap`;
    }
    async pump() {
      let t = await this.upstream.next();
      if (t.done) return false;
      let r = go.getTensorsInContainer(t.value), n = this.transform(t.value), o = go.getTensorsInContainer(n);
      this.outputQueue.pushAll(n);
      for (let s10 of r) go.isTensorInList(s10, o) || s10.dispose();
      return true;
    }
  };
  var Eb = class extends Rr {
    constructor(t, r) {
      super(), this.baseErrorHandler = r, this.lastRead = null, this.iterator = null, this.moreIterators = t;
    }
    summary() {
      return "TODO: fill in upstream of chained summaries -> Chained";
    }
    async next() {
      return this.lastRead = this.readFromChain(this.lastRead), this.lastRead;
    }
    async readFromChain(t) {
      if (await t, this.iterator == null) {
        let n = await this.moreIterators.next();
        if (n.done) return { value: null, done: true };
        this.iterator = n.value, this.baseErrorHandler != null && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler));
      }
      let r = await this.iterator.next();
      return r.done ? (this.iterator = null, this.readFromChain(t)) : r;
    }
  };
  var oC;
  (function(e28) {
    e28[e28.FAIL = 0] = "FAIL", e28[e28.SHORTEST = 1] = "SHORTEST", e28[e28.LONGEST = 2] = "LONGEST";
  })(oC || (oC = {}));
  var Ab = class extends Rr {
    constructor(t, r) {
      super(), this.upstream = t, this.bufferSize = r, this.buffer = new wm(r);
    }
    summary() {
      return `${this.upstream.summary()} -> Prefetch`;
    }
    refill() {
      for (; !this.buffer.isFull(); ) {
        let t = this.upstream.next();
        this.buffer.push(t);
      }
    }
    next() {
      return this.refill(), this.buffer.shift();
    }
  };
  var sC = class extends Ab {
    constructor(t, r, n) {
      super(t, r), this.upstream = t, this.windowSize = r, this.upstreamExhausted = false, this.random = GD.alea(n || x.now().toString()), this.lastRead = Promise.resolve({ value: null, done: false });
    }
    async next() {
      return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
    }
    randomInt(t) {
      return Math.floor(this.random() * t);
    }
    chooseIndex() {
      return this.randomInt(this.buffer.length());
    }
    async serialNext() {
      for (this.upstreamExhausted || this.refill(); !this.buffer.isEmpty(); ) {
        let t = this.chooseIndex(), r = await this.buffer.shuffleExcise(t);
        if (r.done) this.upstreamExhausted = true;
        else return this.refill(), r;
      }
      return { value: null, done: true };
    }
  };
  var ql = class {
    constructor() {
      this.size = null;
    }
    batch(t, r = true) {
      let n = this;
      x.assert(t > 0, () => `batchSize needs to be positive, but it is
      ${t}`);
      let o;
      return this.size === 1 / 0 || this.size == null ? o = this.size : r ? o = Math.ceil(this.size / t) : o = Math.floor(this.size / t), Zo(async () => (await n.iterator()).columnMajorBatch(t, r, S6), o);
    }
    concatenate(t) {
      let r = this, n;
      return this.size === 1 / 0 || t.size === 1 / 0 ? n = 1 / 0 : this.size != null && t.size != null ? n = this.size + t.size : n = null, Zo(async () => (await r.iterator()).concatenate(await t.iterator()), n);
    }
    filter(t) {
      let r = this, n;
      return this.size === 1 / 0 ? n = 1 / 0 : n = null, Zo(async () => (await r.iterator()).filter((o) => M(() => t(o))), n);
    }
    async forEachAsync(t) {
      return (await this.iterator()).forEachAsync(t);
    }
    map(t) {
      let r = this;
      return Zo(async () => (await r.iterator()).map((n) => M(() => t(n))), this.size);
    }
    mapAsync(t) {
      let r = this;
      return Zo(async () => (await r.iterator()).mapAsync(t), this.size);
    }
    prefetch(t) {
      if (t == null) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
      let r = this;
      return Zo(async () => (await r.iterator()).prefetch(t), this.size);
    }
    repeat(t) {
      let r = this, n;
      return this.size != null && t > 0 ? n = this.size * t : t === 0 ? n = 0 : this.size != null && (t === void 0 || t < 0) ? n = 1 / 0 : n = null, Zo(async () => {
        let o = iC(async () => ({ value: await r.iterator(), done: false }));
        return UD(o.take(t));
      }, n);
    }
    skip(t) {
      let r = this, n;
      return this.size != null && t >= 0 && this.size >= t ? n = this.size - t : this.size != null && (this.size < t || t === void 0 || t < 0) ? n = 0 : n = null, Zo(async () => (await r.iterator()).skip(t), n);
    }
    shuffle(t, r, n = true) {
      if (t == null || t < 0) throw this.size == null ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
      let o = this, s10 = jD.alea(r || x.now().toString());
      return Zo(async () => {
        let i = s10.int32();
        return n && (i += s10.int32()), (await o.iterator()).shuffle(t, i.toString());
      }, this.size);
    }
    take(t) {
      let r = this, n;
      return this.size != null && this.size > t ? n = t : this.size != null && this.size <= t ? n = this.size : n = null, Zo(async () => (await r.iterator()).take(t), n);
    }
    async toArray() {
      if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
      return (await this.iterator()).toArray();
    }
    async toArrayForTest() {
      if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
      return (await this.iterator()).toArrayForTest();
    }
  };
  ql.MAX_BUFFER_SIZE = 1e4;
  function Zo(e28, t = null) {
    return new class extends ql {
      constructor() {
        super(...arguments), this.size = t;
      }
      async iterator() {
        return e28();
      }
    }();
  }
  function S6(e28) {
    if (e28 === null) return null;
    let t = e28[0];
    return BD(t) ? { value: I6(e28), recurse: false } : { value: null, recurse: true };
  }
  function I6(e28) {
    if (e28.length === 0) throw new Error("Can't make a batch of zero elements.");
    return e28[0] instanceof ee ? Xe(e28) : me(e28);
  }
  var nQt = Symbol("out");
  var oQt = Symbol("field");
  var sQt = Symbol("quote");
  var iQt = Symbol("quoteafterquote");
  var aQt = Symbol("quoteinquote");
  function J(e28, t) {
    Array.isArray(e28) || (e28 = [e28]), e28.forEach((r) => {
      r != null && x.assert(r.dtype !== "complex64", () => `${t} does not support complex64 tensors in the CPU backend.`);
    });
  }
  var R6 = jr.whereImpl;
  var Xd = class e25 extends qs {
    nextDataId() {
      return e25.nextDataId++;
    }
    constructor() {
      super(), this.blockSize = 48, this.firstUse = true, this.data = new Qu(this, yo());
    }
    write(t, r, n) {
      this.firstUse && (this.firstUse = false, z().get("IS_NODE") && C.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
      let o = { id: this.nextDataId() };
      return this.data.set(o, { values: t, dtype: n, refCount: 1 }), o;
    }
    makeTensorInfo(t, r, n) {
      let o;
      if (r === "string" && n != null && n.length > 0 && x.isString(n[0])) {
        let s10 = n.map((i) => x.encodeString(i));
        o = this.write(s10, t, r);
      } else o = this.write(n, t, r);
      return { dataId: o, shape: t, dtype: r };
    }
    refCount(t) {
      return this.data.has(t) ? this.data.get(t).refCount : 0;
    }
    incRef(t) {
      let r = this.data.get(t);
      r.refCount++;
    }
    decRef(t) {
      if (this.data.has(t)) {
        let r = this.data.get(t);
        r.refCount--;
      }
    }
    move(t, r, n, o, s10) {
      this.data.set(t, { values: r, dtype: o, refCount: s10 });
    }
    numDataIds() {
      return this.data.numDataIds();
    }
    async read(t) {
      return this.readSync(t);
    }
    readSync(t) {
      let { dtype: r, complexTensorInfos: n } = this.data.get(t);
      if (r === "complex64") {
        let o = this.readSync(n.real.dataId), s10 = this.readSync(n.imag.dataId);
        return C.mergeRealAndImagArrays(o, s10);
      }
      return x.convertBackendValuesAndArrayBuffer(this.data.get(t).values, r);
    }
    bufferSync(t) {
      let r = this.readSync(t.dataId);
      if (t.dtype === "string") try {
        let n = r.map((o) => x.decodeString(o));
        return kt(t.shape, t.dtype, n);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return kt(t.shape, t.dtype, r);
    }
    makeOutput(t, r, n) {
      return yo().makeTensorFromTensorInfo(this.makeTensorInfo(r, n, t), this);
    }
    disposeData(t, r = false) {
      if (this.data.has(t)) {
        if (this.data.get(t).refCount--, !r && this.data.get(t).refCount > 0) return false;
        let { complexTensorInfos: n } = this.data.get(t);
        n != null && (this.disposeData(n.real.dataId, true), this.disposeData(n.imag.dataId, true)), this.data.delete(t);
      }
      return true;
    }
    disposeIntermediateTensorInfo(t) {
      this.disposeData(t.dataId);
    }
    async time(t) {
      let r = x.now();
      return t(), { kernelMs: x.now() - r };
    }
    memory() {
      return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
    }
    where(t) {
      J([t], "where");
      let r = this.readSync(t.dataId);
      return R6(t.shape, r);
    }
    dispose() {
    }
    floatPrecision() {
      return 32;
    }
    epsilon() {
      return super.epsilon();
    }
  };
  Xd.nextDataId = 0;
  var LC = {};
  lo(LC, { addImpl: () => lC, bincountImpl: () => Cm, bincountReduceImpl: () => Db, bitwiseAndImpl: () => cC, castImpl: () => uC, ceilImpl: () => pC, concatImpl: () => $b, equalImpl: () => mC, expImpl: () => hC, expm1Impl: () => gC, floorDivImpl: () => xC, floorImpl: () => yC, gatherNdImpl: () => Fb, gatherV2Impl: () => _b, greaterEqualImpl: () => wC, greaterImpl: () => bC, lessEqualImpl: () => NC, lessImpl: () => vC, linSpaceImpl: () => Ob, logImpl: () => CC, maxImpl: () => Rb, maximumImpl: () => SC, minimumImpl: () => IC, multiplyImpl: () => Yd, negImpl: () => TC, notEqualImpl: () => kC, prodImpl: () => EC, raggedGatherImpl: () => Pb, raggedRangeImpl: () => Lb, raggedTensorToTensorImpl: () => Mb, rangeImpl: () => zb, rsqrtImpl: () => DC, scatterImpl: () => Qo, sigmoidImpl: () => N$, simpleAbsImpl: () => aC, sliceImpl: () => FC, sparseFillEmptyRowsImpl: () => Bb, sparseReshapeImpl: () => Vb, sparseSegmentReductionImpl: () => Im, sqrtImpl: () => I$, squaredDifferenceImpl: () => _C, staticRegexReplaceImpl: () => OC, stridedSliceImpl: () => Gb, stringNGramsImpl: () => Wb, stringSplitImpl: () => Ub, stringToHashBucketFastImpl: () => jb, subImpl: () => PC, tileImpl: () => Hb, topKImpl: () => Kb, transposeImpl: () => Sm, uniqueImpl: () => qb });
  function aC(e28) {
    let t = new Float32Array(e28.length);
    for (let r = 0; r < e28.length; ++r) t[r] = Math.abs(e28[r]);
    return t;
  }
  var P6 = (e28) => {
    let { x: t } = e28.inputs, r = e28.backend;
    J(t, "abs");
    let n = new Float32Array(x.sizeFromShape(t.shape)), o = r.data.get(t.dataId).values;
    return n = aC(o), r.makeOutput(n, t.shape, t.dtype);
  };
  var HD = { kernelName: ka, backendName: "cpu", kernelFunc: P6 };
  function Jt(e28) {
    return (t, r, n, o, s10) => {
      let i = C.assertAndGetBroadcastShape(t, r), a = i.length, u = x.computeStrides(i), l = x.sizeFromShape(i), c = x.getTypedArrayFromDType(s10, l), p = t.length, m = r.length, f = x.computeStrides(t), h = x.computeStrides(r), d = C.getBroadcastDims(t, i), g = C.getBroadcastDims(r, i);
      if (d.length + g.length === 0) for (let y = 0; y < c.length; ++y) c[y] = e28(n[y % n.length], o[y % o.length]);
      else for (let y = 0; y < c.length; ++y) {
        let b = x.indexToLoc(y, a, u), v = b.slice(-p);
        d.forEach((A) => v[A] = 0);
        let w = x.locToIndex(v, p, f), N = b.slice(-m);
        g.forEach((A) => N[A] = 0);
        let E = x.locToIndex(N, m, h);
        c[y] = e28(n[w], o[E]);
      }
      return [c, i];
    };
  }
  function br(e28) {
    let { inputs: t, backend: r } = e28, { real: n, imag: o } = t, s10 = r.data.get(n.dataId).values, i = r.data.get(o.dataId).values, a = r.makeTensorInfo(n.shape, "complex64"), u = r.data.get(a.dataId);
    return u.complexTensorInfos = { real: r.makeTensorInfo(n.shape, "float32", s10), imag: r.makeTensorInfo(o.shape, "float32", i) }, a;
  }
  var KD = { kernelName: Pc, backendName: "cpu", kernelFunc: br };
  function vm(e28, t, r = "float32") {
    if (r === "complex64") {
      let o = vm(e28, t, "float32"), s10 = vm(e28, t, "float32");
      return br({ inputs: { real: o, imag: s10 }, backend: e28 });
    }
    let n = x.makeZerosTypedArray(x.sizeFromShape(t), r);
    return e28.makeTensorInfo(t, r, n);
  }
  function Hr(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    return r.incRef(n.dataId), { dataId: n.dataId, shape: n.shape, dtype: n.dtype };
  }
  var qD = { kernelName: ds, backendName: "cpu", kernelFunc: Hr };
  function Ao(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t, o = r.data.get(n.dataId).complexTensorInfos.real, s10 = r.data.get(o.dataId).values;
    return r.makeTensorInfo(o.shape, o.dtype, s10);
  }
  var XD = { kernelName: ip, backendName: "cpu", kernelFunc: Ao };
  function uC(e28, t, r, n) {
    if (n === "int32") {
      let o = Int32Array.from(e28);
      return [t, "int32", o];
    }
    if (n === "bool") {
      let o = x.toTypedArray([0], r), [s10, i] = Jt((a, u) => a !== u ? 1 : 0)(t, [], e28, o, "bool");
      return [i, "bool", s10];
    }
    throw new Error(`Error in Cast: failed to cast ${r} to ${n}`);
  }
  function Do(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { dtype: s10 } = n;
    if (s10 === "complex64") {
      if (o.dtype === "complex64") return Hr({ inputs: { x: o }, backend: r });
      let c = vm(r, o.shape, o.dtype), p = Do({ inputs: { x: o }, backend: r, attrs: { dtype: "float32" } }), m = br({ inputs: { real: p, imag: c }, backend: r });
      return r.disposeIntermediateTensorInfo(c), r.disposeIntermediateTensorInfo(p), m;
    }
    if (o.dtype === "complex64") {
      let c = Ao({ inputs: { input: o }, backend: r }), p = Do({ inputs: { x: c }, backend: r, attrs: { dtype: s10 } });
      return r.disposeIntermediateTensorInfo(c), p;
    }
    if (!x.hasEncodingLoss(o.dtype, s10)) {
      let c = Hr({ inputs: { x: o }, backend: r });
      return { dataId: c.dataId, shape: c.shape, dtype: s10 };
    }
    let i = r.data.get(o.dataId).values, [a, u, l] = uC(i, o.shape, o.dtype, s10);
    return r.makeTensorInfo(a, u, l);
  }
  var YD = { kernelName: hs, backendName: "cpu", kernelFunc: Do };
  function oe(e28, t, r, n) {
    return r == null ? ({ inputs: o, backend: s10 }) => {
      let { a: i, b: a } = o, u = s10;
      J([i, a], e28);
      let l = u.data.get(i.dataId).values, c = u.data.get(a.dataId).values, p = i.dtype === "string" ? C.fromUint8ToStringArray(l) : l, m = i.dtype === "string" ? C.fromUint8ToStringArray(c) : c, f = n || i.dtype, [h, d] = t(i.shape, a.shape, p, m, f);
      return u.makeTensorInfo(d, f, h);
    } : ({ inputs: o, backend: s10 }) => {
      let { a: i, b: a } = o, u = s10;
      if (i.dtype === "complex64" || a.dtype === "complex64") {
        let l = Do({ inputs: { x: i }, backend: u, attrs: { dtype: "complex64" } }), c = u.data.get(l.dataId), p = c.complexTensorInfos.real, m = c.complexTensorInfos.imag, f = u.data.get(p.dataId).values, h = u.data.get(m.dataId).values, d = Do({ inputs: { x: a }, backend: u, attrs: { dtype: "complex64" } }), g = u.data.get(d.dataId), y = g.complexTensorInfos.real, b = g.complexTensorInfos.imag, v = u.data.get(y.dataId).values, w = u.data.get(b.dataId).values, [N, E, A] = r(i.shape, a.shape, f, h, v, w), D = u.makeTensorInfo(A, "float32", N), R = u.makeTensorInfo(A, "float32", E), L = br({ inputs: { real: D, imag: R }, backend: u });
        return u.disposeIntermediateTensorInfo(l), u.disposeIntermediateTensorInfo(d), u.disposeIntermediateTensorInfo(D), u.disposeIntermediateTensorInfo(R), L;
      } else {
        let l = u.data.get(i.dataId).values, c = u.data.get(a.dataId).values, p = n || i.dtype, [m, f] = t(i.shape, a.shape, l, c, p);
        return u.makeTensorInfo(f, p, m);
      }
    };
  }
  function Nm(e28) {
    return (t, r, n, o, s10, i) => {
      let a = C.assertAndGetBroadcastShape(t, r), u = x.sizeFromShape(a), l = a.length, c = x.computeStrides(a), p = x.getTypedArrayFromDType("float32", u), m = x.getTypedArrayFromDType("float32", u), f = C.getBroadcastDims(t, a), h = C.getBroadcastDims(r, a), d = C.mergeRealAndImagArrays(n, o), g = C.mergeRealAndImagArrays(s10, i), y = t.length, b = x.computeStrides(t), v = r.length, w = x.computeStrides(r);
      if (f.length + h.length === 0) for (let N = 0; N < p.length; N++) {
        let E = N % d.length, A = N % g.length, D = e28(d[E * 2], d[E * 2 + 1], g[A * 2], g[A * 2 + 1]);
        p[N] = D.real, m[N] = D.imag;
      }
      else for (let N = 0; N < p.length; N++) {
        let E = x.indexToLoc(N, l, c), A = E.slice(-y);
        f.forEach((W) => A[W] = 0);
        let D = x.locToIndex(A, y, b), R = E.slice(-v);
        h.forEach((W) => R[W] = 0);
        let L = x.locToIndex(R, v, w), G = e28(d[D * 2], d[D * 2 + 1], g[L * 2], g[L * 2 + 1]);
        p[N] = G.real, m[N] = G.imag;
      }
      return [p, m, a];
    };
  }
  var lC = Jt((e28, t) => e28 + t);
  var L6 = Nm((e28, t, r, n) => ({ real: e28 + r, imag: t + n }));
  var $s = oe(Mo, lC, L6);
  var JD = { kernelName: Mo, backendName: "cpu", kernelFunc: $s };
  function Cm(e28, t, r, n, o) {
    let s10 = x.sizeFromShape(n), i = x.makeZerosTypedArray(o, r);
    for (let a = 0; a < e28.length; a++) {
      let u = e28[a];
      if (u < 0) throw new Error("Input x must be non-negative!");
      u >= o || (s10 > 0 ? i[u] += t[a] : i[u] += 1);
    }
    return i;
  }
  function Db(e28, t, r, n = false) {
    let o = e28.shape[0], s10 = e28.shape[1], i = kt([o, r], t.dtype);
    for (let a = 0; a < o; a++) for (let u = 0; u < s10; u++) {
      let l = e28.get(a, u);
      if (l < 0) throw new Error("Input x must be non-negative!");
      l >= r || (n ? i.set(1, a, l) : t.size > 0 ? i.set(i.get(a, l) + t.get(a, u), a, l) : i.set(i.get(a, l) + 1, a, l));
    }
    return i;
  }
  var cC = Jt((e28, t) => e28 & t);
  var M6 = oe(Ef, cC);
  var ZD = { kernelName: Ef, backendName: "cpu", kernelFunc: M6 };
  function Er(e28) {
    return (t, r, n) => {
      let o = x.getArrayFromDType(r, t.length);
      for (let s10 = 0; s10 < t.length; ++s10) o[s10] = e28(t[s10], n);
      return o;
    };
  }
  function Lt(e28, t, r) {
    let n = Er(t);
    return Cn(e28, n, r);
  }
  function Cn(e28, t, r) {
    return ({ inputs: n, attrs: o, backend: s10 }) => {
      let { x: i } = n;
      J(i, e28);
      let a = s10, u = a.data.get(i.dataId).values, l;
      if (i.dtype === "string") {
        if (!Array.isArray(u)) throw new Error("String tensor's value was not an instance of Array");
        l = C.fromUint8ToStringArray(u);
      } else l = u;
      let c = r || i.dtype, p = t(l, c, o);
      return a.makeTensorInfo(i.shape, c, p);
    };
  }
  var pC = Er((e28) => Math.ceil(e28));
  var z6 = Cn(ni, pC);
  var QD = { kernelName: ni, backendName: "cpu", kernelFunc: z6 };
  function $b(e28, t, r, n) {
    let o = x.getArrayFromDType(r, x.sizeFromShape(t));
    if (n && r !== "string") {
      let s10 = 0;
      e28.forEach((i) => {
        let a = x.sizeFromShape(i.shape);
        o.set(i.vals, s10), s10 += a;
      });
    } else {
      let s10 = 0;
      e28.forEach((i) => {
        let a = r === "string" ? C.fromUint8ToStringArray(i.vals) : i.vals, u = 0;
        for (let l = 0; l < i.shape[0]; ++l) {
          let c = l * t[1] + s10;
          for (let p = 0; p < i.shape[1]; ++p) o[c + p] = a[u++];
        }
        s10 += i.shape[1];
      });
    }
    return o;
  }
  var mC = Jt((e28, t) => e28 === t ? 1 : 0);
  var fC = oe(nl, mC, null, "bool");
  var t$ = { kernelName: nl, backendName: "cpu", kernelFunc: fC };
  var hC = Er((e28) => Math.exp(e28));
  var dC = Cn(ci, hC, "float32");
  var e$ = { kernelName: ci, backendName: "cpu", kernelFunc: dC };
  var gC = Er((e28) => Math.expm1(e28));
  var B6 = Cn(pi, gC);
  var r$ = { kernelName: pi, backendName: "cpu", kernelFunc: B6 };
  var yC = Er((e28) => Math.floor(e28));
  var V6 = Cn(mi, yC);
  var n$ = { kernelName: mi, backendName: "cpu", kernelFunc: V6 };
  var xC = Jt((e28, t) => Math.floor(e28 / t));
  var G6 = oe(fi, xC, null, "int32");
  var o$ = { kernelName: fi, backendName: "cpu", kernelFunc: G6 };
  function Fb(e28, t, r, n, o, s10, i, a, u) {
    let l = kt([n, s10], r);
    for (let c = 0; c < n; c++) {
      let p = [], m = 0;
      for (let f = 0; f < o; f++) {
        let h = e28[c * o + f];
        m += h * i[f], p.push(h);
      }
      if (m < 0 || m >= u / s10) throw new Error(`Invalid indices: ${p} does not index into ${a}`);
      for (let f = 0; f < s10; f++) l.values[c * s10 + f] = t.get(...t.indexToLoc(m * s10 + f));
    }
    return l;
  }
  function _b(e28, t, r) {
    let n = kt(r, e28.dtype);
    for (let o = 0; o < n.size; ++o) {
      let i = n.indexToLoc(o).slice(), a = i[0], u = i[2], l = t.locToIndex([a, u]);
      i[2] = t.values[l];
      let c = e28.locToIndex(i);
      0 <= c && c < e28.values.length && (n.values[o] = e28.values[c]);
    }
    return n;
  }
  var bC = Jt((e28, t) => e28 > t ? 1 : 0);
  var W6 = oe(ol, bC, null, "bool");
  var s$ = { kernelName: ol, backendName: "cpu", kernelFunc: W6 };
  var wC = Jt((e28, t) => e28 >= t ? 1 : 0);
  var U6 = oe(hi, wC, null, "bool");
  var i$ = { kernelName: hi, backendName: "cpu", kernelFunc: U6 };
  var vC = Jt((e28, t) => e28 < t ? 1 : 0);
  var j6 = oe(sl, vC, null, "bool");
  var a$ = { kernelName: sl, backendName: "cpu", kernelFunc: j6 };
  var NC = Jt((e28, t) => e28 <= t ? 1 : 0);
  var H6 = oe(il, NC, null, "bool");
  var u$ = { kernelName: il, backendName: "cpu", kernelFunc: H6 };
  function Ob(e28, t, r) {
    let n = (t - e28) / (r - 1), o = x.makeZerosTypedArray(r, "float32");
    o[0] = e28;
    for (let s10 = 1; s10 < o.length; s10++) o[s10] = o[s10 - 1] + n;
    return o;
  }
  var CC = Er((e28) => Math.log(e28));
  var K6 = Cn(xi, CC);
  var l$ = { kernelName: xi, backendName: "cpu", kernelFunc: K6 };
  function Rb(e28, t, r, n) {
    let o = x.getTypedArrayFromDType(n, x.sizeFromShape(r));
    for (let s10 = 0; s10 < o.length; ++s10) {
      let i = s10 * t, a = e28[i];
      for (let u = 0; u < t; ++u) {
        let l = e28[i + u];
        (Number.isNaN(l) || l > a) && (a = l);
      }
      o[s10] = a;
    }
    return o;
  }
  var SC = Jt((e28, t) => Math.max(e28, t));
  var q6 = oe(wi, SC);
  var c$ = { kernelName: wi, backendName: "cpu", kernelFunc: q6 };
  var IC = Jt((e28, t) => Math.min(e28, t));
  var X6 = oe(vi, IC);
  var p$ = { kernelName: vi, backendName: "cpu", kernelFunc: X6 };
  var Yd = Jt((e28, t) => e28 * t);
  var Y6 = Nm((e28, t, r, n) => ({ real: e28 * r - t * n, imag: e28 * n + t * r }));
  var Xl = oe(Ci, Yd, Y6);
  var m$ = { kernelName: Ci, backendName: "cpu", kernelFunc: Xl };
  function TC(e28, t, r) {
    let n = x.createScalarValue(-1, r);
    return Yd([], t, n, e28, r);
  }
  function J6(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    J(n, "neg");
    let o = r.data.get(n.dataId).values, [s10, i] = TC(o, n.shape, n.dtype);
    return r.makeTensorInfo(i, n.dtype, s10);
  }
  var f$ = { kernelName: Qa, backendName: "cpu", kernelFunc: J6 };
  var kC = Jt((e28, t) => e28 !== t ? 1 : 0);
  var Z6 = oe(cl, kC, null, "bool");
  var h$ = { kernelName: cl, backendName: "cpu", kernelFunc: Z6 };
  function Sm(e28, t, r, n, o) {
    let s10 = t.length, i = x.sizeFromShape(t), a = x.computeStrides(t), u = x.computeStrides(o), l = x.getTypedArrayFromDType(r, x.sizeFromShape(o));
    for (let c = 0; c < i; ++c) {
      let p = x.indexToLoc(c, s10, a), m = new Array(p.length);
      for (let h = 0; h < m.length; h++) m[h] = p[n[h]];
      let f = x.locToIndex(m, s10, u);
      l[f] = e28[c];
    }
    return l;
  }
  function Pe(e28) {
    let { inputs: t, attrs: r, backend: n } = e28, { x: o } = t, { perm: s10 } = r;
    J(o, "transpose");
    let i = o.shape.length, a = new Array(i);
    for (let p = 0; p < a.length; p++) a[p] = o.shape[s10[p]];
    let u = n.data.get(o.dataId).values, l = Sm(u, o.shape, o.dtype, s10, a);
    return { dataId: n.write(l, a, o.dtype), shape: a, dtype: o.dtype };
  }
  var d$ = { kernelName: ys, backendName: "cpu", kernelFunc: Pe };
  function EC(e28, t, r, n) {
    let [o, s10] = C.computeOutAndReduceShapes(e28, n), i = lr(t, "int32"), a = x.makeZerosTypedArray(x.sizeFromShape(o), i), u = x.sizeFromShape(s10);
    for (let l = 0; l < a.length; ++l) {
      let c = l * u, p = 1;
      for (let m = 0; m < u; ++m) p *= r[c + m];
      a[l] = p;
    }
    return { outVals: a, outShape: o, outDtype: i };
  }
  function Q6(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n;
    J(o, "prod");
    let a = o.shape.length, u = x.parseAxisParam(s10, o.shape), l = C.getAxesPermutation(u, a), c = u, p = o, m = [];
    l != null && (p = Pe({ inputs: { x: o }, backend: r, attrs: { perm: l } }), m.push(p), c = C.getInnerMostAxes(c.length, a));
    let f = r.data.get(p.dataId).values, { outVals: h, outShape: d, outDtype: g } = EC(p.shape, p.dtype, f, c), y = d;
    return i && (y = C.expandShapeToKeepDim(d, u)), m.forEach((b) => r.disposeIntermediateTensorInfo(b)), r.makeTensorInfo(y, g, h);
  }
  var g$ = { kernelName: su, backendName: "cpu", kernelFunc: Q6 };
  function t8(e28, t, r) {
    e28.forEach((n, o) => {
      if (n < 0 || n >= r) {
        let s10 = x.indexToLoc(o, t.length, x.computeStrides(t)).join(",");
        throw new Error(`indices[${s10}] = ${n} is not in [0, ${r})`);
      }
    });
  }
  function e82(e28, t) {
    for (let r = 0; r < e28.length; ++r) {
      let n = e28[r], o = r === e28.length - 1 ? t : e28[r + 1].length;
      if (n.length === 0) throw new Error("Ragged splits may not be empty");
      if (n[0] < 0) throw new Error("Ragged splits must be non-negative");
      if (n[n.length - 1] > o) throw new Error("Ragged splits must not point past values");
      for (let s10 = 1; s10 < n.length; ++s10) if (n[s10 - 1] > n[s10]) throw new Error("Ragged splits must be sorted in ascending order");
    }
  }
  function r8(e28, t, r, n) {
    let o = [], s10 = 0, i = t.length - 1 + r.length, a = new Array(i).fill(null).map(() => [0]);
    e82(r, n);
    let u = 1;
    for (let l = 0; l < t.length - 1; ++l) {
      u *= t[l];
      let c = t[l + 1];
      for (let p = 1; p < u + 1; ++p) a[l].push(p * c);
    }
    for (let l = 0; l < e28.length; ++l) {
      let c = e28[l], p = e28[l] + 1;
      for (let m = 0; m < r.length; ++m) {
        let f = r[m], h = m + t.length - 1;
        if (h >= 0) {
          let d = a[h], g = d[d.length - 1] - f[c];
          for (let y = c; y < p; ++y) a[h].push(f[y + 1] + g);
        }
        c = f[c], p = f[p];
      }
      p !== c && (o.push([c, p]), s10 += p - c);
    }
    return { outSplits: a, valueSlices: o, numValues: s10 };
  }
  function n8(e28) {
    let t = [];
    for (let r = 0; r < e28.length; ++r) {
      let n = e28[r].length, o = x.getArrayFromDType("int32", n);
      t.push(o), e28[r].forEach((s10, i) => o[i] = s10);
    }
    return t;
  }
  function y$(e28, t) {
    let r = e28.slice(0, t);
    for (; r.length < t; ) r.push(1);
    for (let n = t; n < e28.length; n++) r[t - 1] *= e28[n];
    return r;
  }
  function o8(e28, t, r, n, o, s10) {
    let i = y$(t, 2)[1], a = y$(s10, 2)[1], u = 0;
    for (let l of r) for (let c = l[0]; c < l[1]; ++c) {
      for (let p = 0; p < n; ++p) o[u * a + p] = e28[c * i + p];
      ++u;
    }
  }
  function s8(e28, t, r, n, o) {
    let s10 = t.slice();
    s10[0] = o;
    let i = x.getArrayFromDType(r, x.sizeFromShape(s10)), a = e28.length, u = a === 0 ? 0 : a / t[0];
    return o8(e28, t, n, u, i, s10), [i, s10];
  }
  function Pb(e28, t, r, n, o, s10, i, a) {
    if (e28.length === 0) throw new Error("paramsNestedSplits must be non empty");
    if (t[0].length === 0) throw new Error("Split tensors must not be scalars");
    let u = t[0][0] - 1;
    if (t8(s10, i, u), n.length === 0) throw new Error("params.rank must be nonzero");
    let l = n[0], { outSplits: c, valueSlices: p, numValues: m } = r8(s10, i, e28, l), f = n8(c), h = s8(r, n, o, p, m);
    return [f, h[0], h[1]];
  }
  var x$ = 2147483647;
  function Lb(e28, t, r, n, o, s10, i) {
    if (t.length > 1) throw new Error("starts must be a scalar or vector");
    if (o.length > 1) throw new Error("limits must be a scalar or vector");
    if (i.length > 1) throw new Error("deltas must be a scalar or vector");
    let a = t.length === 0, u = o.length === 0, l = i.length === 0, c = [];
    a || c.push(t[0]), u || c.push(o[0]), l || c.push(i[0]);
    for (let g = 1; g < c.length; ++g) if (c[g] !== c[g - 1]) throw new Error("starts, limits, and deltas must have the same shape");
    let p = c.length === 0 ? 1 : c[0], m = x.getArrayFromDType("int32", p + 1);
    m[0] = 0;
    for (let g = 0; g < p; ++g) {
      let y = a ? e28[0] : e28[g], b = u ? n[0] : n[g], v = l ? s10[0] : s10[g];
      if (v === 0) throw new Error("Requires delta != 0");
      let w;
      if (v > 0 && b < y || v < 0 && b > y) w = 0;
      else if (w = Math.ceil(Math.abs((b - y) / v)), w > x$) throw new Error(`Requires ((limit - start) / delta) <= ${x$}`);
      m[g + 1] = m[g] + w;
    }
    let f = m[p], h = x.getArrayFromDType(r, f), d = 0;
    for (let g = 0; g < p; ++g) {
      let y = m[g + 1] - m[g], b = a ? e28[0] : e28[g], v = l ? s10[0] : s10[g];
      for (let w = 0; w < y; ++w) h[d++] = b, b += v;
    }
    return [m, h];
  }
  var $o = C.RowPartitionType;
  var AC = class e26 {
    constructor(t, r, n, o, s10, i, a, u, l, c) {
      this.shape = t, this.shapeShape = r, this.values = n, this.valuesShape = o, this.valuesDType = s10, this.defaultValue = i, this.defaultValueShape = a, this.rowPartitionValues = u, this.rowPartitionValuesShapes = l, this.rowPartitionTypes = C.getRowPartitionTypesHelper(c), this.raggedRank = C.getRaggedRank(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(t) {
      return this.rowPartitionTypes[0] === $o.FIRST_DIM_SIZE ? this.rowPartitionTypes[t + 1] : this.rowPartitionTypes[t];
    }
    getRowPartitionTensor(t) {
      return this.rowPartitionTypes[0] === $o.FIRST_DIM_SIZE ? this.rowPartitionValues[t + 1] : this.rowPartitionValues[t];
    }
    getMaxWidth(t) {
      let r = this.getRowPartitionTensor(t - 1);
      switch (this.getRowPartitionTypeByDimension(t - 1)) {
        case $o.VALUE_ROWIDS:
          return e26.getMaxWidthValueRowID(r);
        case $o.ROW_SPLITS:
          return e26.getMaxWidthRowSplit(r);
        default:
          throw new Error(`Cannot handle partition type ${$o[this.getRowPartitionTypeByDimension(t - 1)]}`);
      }
    }
    static getMaxWidthRowSplit(t) {
      let r = t.length;
      if (r === 0 || r === 1) return 0;
      let n = 0;
      for (let o = 0; o < r - 1; ++o) {
        let s10 = t[o + 1] - t[o];
        s10 > n && (n = s10);
      }
      return n;
    }
    static getMaxWidthValueRowID(t) {
      let r = t.length;
      if (r === 0) return 0;
      let n = 0, o = t[0], s10 = 0;
      for (let i = 1; i < r; ++i) {
        let a = t[i];
        a !== o && (o = a, s10 = Math.max(i - n, s10), n = i);
      }
      return Math.max(r - n, s10);
    }
    tensorShapeFromTensor(t, r, n = true) {
      if (r.length === 0) {
        if (t[0] === -1) return [];
        throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
      }
      return w$(t, n);
    }
    calculateOutputSize(t) {
      let r = this.valuesShape, n = this.defaultValueShape;
      C.validateDefaultValueShape(n, r);
      let o = this.tensorShapeFromTensor(this.shape, this.shapeShape), i = C.combineRaggedTensorToTensorShapes(this.raggedRank, o, r);
      i[0] < 0 && (i[0] = t);
      for (let a = 1; a <= this.raggedRank; ++a) i[a] < 0 && (i[a] = this.getMaxWidth(a));
      return i;
    }
    calculateFirstParentOutputIndex(t, r, n) {
      let o = Math.min(t, n), s10 = [], i = 0;
      for (let a = 0; a < o; ++a, i += r) s10.push(i);
      for (let a = o; a < t; ++a) s10.push(-1);
      return x.assert(s10.length === t, () => "Final length of result must be equal to firstDimension."), s10;
    }
    calculateOutputIndexRowSplit(t, r, n, o) {
      let s10 = t.length, i = [];
      for (let a = 0; a < s10 - 1; ++a) {
        let u = t[a + 1] - t[a], l = Math.min(o, u), c = r[a];
        c === -1 && (l = 0);
        for (let p = 0; p < l; ++p) i.push(c), c += n;
        for (let p = 0; p < u - l; ++p) i.push(-1);
      }
      if (s10 > 0 && i.length !== t[s10 - 1]) throw new Error("Invalid row split size.");
      return i;
    }
    calculateOutputIndexValueRowID(t, r, n, o) {
      let s10 = t.length, i = [];
      if (s10 === 0) return [];
      let a = 0, u = t[0];
      if (u >= r.length) throw new Error(`Got currentValueRowId=${u}, which is not less than ${r.length}`);
      let l = r[u];
      i.push(l);
      for (let c = 1; c < s10; ++c) {
        let p = t[c];
        if (p === u) l >= 0 && (++a, a < o ? l += n : l = -1);
        else {
          if (a = 0, u = p, p >= r.length) throw new Error(`Got nextValueRowId=${p} which is not less than ${r.length}`);
          l = r[p];
        }
        i.push(l);
      }
      if (i.length !== t.length) throw new Error("Invalid row ids.");
      return i;
    }
    calculateOutputIndex(t, r, n, o) {
      let s10 = this.getRowPartitionTensor(t), i = this.getRowPartitionTypeByDimension(t);
      switch (i) {
        case $o.VALUE_ROWIDS:
          return this.calculateOutputIndexValueRowID(s10, r, n, o);
        case $o.ROW_SPLITS:
          if (s10.length - 1 > r.length) throw new Error(`Row partition size is greater than output size: ${s10.length - 1} > ${r.length}`);
          return this.calculateOutputIndexRowSplit(s10, r, n, o);
        default:
          throw new Error(`Unsupported partition type: ${$o[i]}`);
      }
    }
    getFirstDimensionSize() {
      let t = this.rowPartitionValues[0];
      if (this.rowPartitionTypes.length === 0) throw new Error("No row_partition_types given.");
      let r = this.rowPartitionTypes[0];
      switch (r) {
        case $o.FIRST_DIM_SIZE:
          return t[0];
        case $o.VALUE_ROWIDS:
          throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
        case $o.ROW_SPLITS:
          return this.rowPartitionValuesShapes[0][0] - 1;
        default:
          throw new Error(`Cannot handle type ${$o[r]}`);
      }
    }
    compute() {
      if (this.rowPartitionValues[0].length <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
      let r = this.getFirstDimensionSize(), n = this.calculateOutputSize(r), o = new Array(this.raggedRank + 1);
      o[o.length - 1] = 1;
      for (let u = o.length - 2; u >= 0; --u) o[u] = o[u + 1] * n[u + 1];
      let s10 = w$(n, false), i = x.getArrayFromDType(this.valuesDType, x.sizeFromShape(s10));
      if (o[0] * n[0] > 0) {
        let u = this.calculateFirstParentOutputIndex(r, o[0], n[0]);
        for (let l = 1; l <= this.raggedRank; ++l) u = this.calculateOutputIndex(l - 1, u, o[l], n[l]);
        this.setOutput(this.raggedRank, u, i, s10);
      }
      return [s10, i];
    }
    setOutput(t, r, n, o) {
      if (n.length === 0) return;
      let s10 = this.values, i = n, a = o.slice();
      a = a.slice(t + 1);
      let u = x.sizeFromShape(a), l = r.length, c = this.defaultValue;
      if (c.length !== u && c.length !== 1) {
        let h = this.defaultValueShape;
        M(() => {
          let d = _(c, h);
          c = Hi(d, a).dataSync();
        });
      }
      let p = 0, m = 0, f = 0;
      for (let h = 0; h <= l; ++h) {
        let d = h < l ? r[h] : -1;
        if (d === f) {
          ++f;
          continue;
        }
        if (m < f) {
          let g = s10.subarray(p * u), y = i.subarray(m * u), b = (f - m) * u;
          b$(y, g, b);
        }
        if (h >= l) {
          let g = n.length;
          d = Math.floor(g / u);
        }
        if (d > f) if (this.defaultValue.length === 1) i.subarray(f * u, d * u).fill(this.defaultValue[0]), f = d;
        else for (; d > f; ) {
          let g = i.slice(f * u);
          b$(g, c, u), ++f;
        }
        d < 0 ? (p = h + 1, m = f) : (p = h, m = f, f = m + 1);
      }
    }
  };
  function b$(e28, t, r) {
    for (let n = 0; n < r; n++) e28[n] = t[n];
  }
  function w$(e28, t) {
    let r = [];
    for (let n of e28) {
      if (n < 0) {
        if (!t) throw new Error(`Dimension ${n} must be >= 0`);
        if (n < -1) throw new Error(`Dimension ${n} must be >= -1`);
        n = -1;
      }
      r.push(n);
    }
    return r;
  }
  function Mb(e28, t, r, n, o, s10, i, a, u, l) {
    return new AC(e28, t, r, n, o, s10, i, a, u, l).compute();
  }
  function zb(e28, t, r, n) {
    let o = e28 === t, s10 = e28 < t && r < 0, i = t < e28 && r > 1;
    if (o || s10 || i) return x.makeZerosTypedArray(0, n);
    let a = Math.abs(Math.ceil((t - e28) / r)), u = x.makeZerosTypedArray(a, n);
    t < e28 && r === 1 && (r = -1), u[0] = e28;
    for (let l = 1; l < u.length; l++) u[l] = u[l - 1] + r;
    return u;
  }
  var DC = Er((e28) => 1 / Math.sqrt(e28));
  var i8 = Cn(Ai, DC);
  var v$ = { kernelName: Ai, backendName: "cpu", kernelFunc: i8 };
  function Qo(e28, t, r, n, o, s10, i, a, u, l) {
    let c = [n / o, o], p = e28.values, m = t.values;
    if (n === 0) return kt(r, t.dtype);
    let f = u instanceof pe ? u : kt(c, t.dtype);
    typeof u == "string" || typeof u == "number" ? f.values.fill(u) : typeof u == "boolean" && f.values.fill(+u);
    for (let h = 0; h < s10; h++) {
      let d = [], g = 0;
      for (let y = 0; y < i; y++) {
        let b = p[h * i + y];
        d.push(b), g += b * a[y];
      }
      if (g < 0 || g >= n / o) throw new Error(`Invalid indices: ${d} does not index into ${r}`);
      for (let y = 0; y < o; y++) l ? f.values[g * o + y] += m[h * o + y] : f.values[g * o + y] = t.rank === 0 ? m[0] : m[h * o + y];
    }
    return f;
  }
  var N$ = Er((e28) => 1 / (1 + Math.exp(-e28)));
  var $C = Lt(Oi, (e28) => 1 / (1 + Math.exp(-e28)));
  var C$ = { kernelName: Oi, backendName: "cpu", kernelFunc: $C };
  function FC(e28, t, r, n, o) {
    let s10 = Sr.isSliceContinous(n, t, r), i = x.sizeFromShape(r), a = x.computeStrides(n);
    if (s10) {
      let p = Sr.computeFlatOffset(t, a);
      return o === "string" ? e28.slice(p, p + i) : e28.subarray(p, p + i);
    }
    let u = o === "string" ? C.fromUint8ToStringArray(e28) : e28, l = kt(n, o, u), c = kt(r, o);
    for (let p = 0; p < c.size; ++p) {
      let m = c.indexToLoc(p), f = m.map((h, d) => h + t[d]);
      c.set(l.get(...f), ...m);
    }
    return o === "string" ? C.fromStringArrayToUint8(c.values) : c.values;
  }
  function Fo(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { begin: s10, size: i } = n;
    J(o, "slice");
    let [a, u] = Sr.parseSliceParams(o, s10, i);
    Sr.assertParamsValid(o, a, u);
    let l = r.data.get(o.dataId).values, c = FC(l, a, u, o.shape, o.dtype);
    return r.makeTensorInfo(u, o.dtype, c);
  }
  var S$ = { kernelName: pu, backendName: "cpu", kernelFunc: Fo };
  function Bb(e28, t, r, n, o, s10, i) {
    let a = t[0], u = s10[0], l = new Array(u), c = new Array(a), p = t[1];
    if (u === 0) {
      if (a !== 0) throw new Error(C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));
      let g = x.getArrayFromDType(r, 0), y = x.getArrayFromDType(o, 0);
      return [g, [0, p], y, l, c];
    }
    let m = true, f = 0, h = new Array(u).fill(0);
    for (let g = 0; g < a; ++g) {
      let y = e28[g * p];
      if (y < 0) throw new Error(C.getSparseFillEmptyRowsNegativeIndexErrorMessage(g, y));
      if (y >= u) throw new Error(C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g, y, u));
      ++h[y], m = m && y >= f, f = y;
    }
    let d = true;
    for (let g = 0; g < u; ++g) {
      let y = h[g] === 0;
      l[g] = y, d = d && !y, h[g] = Math.max(h[g], 1), g > 0 && (h[g] += h[g - 1]);
    }
    if (d && m) {
      let g = e28, y = n;
      for (let b = 0; b < a; ++b) c[b] = b;
      return [g, [a, p], y, l, c];
    } else {
      let g = h[u - 1], y = x.getArrayFromDType(r, g * p), b = x.getArrayFromDType(o, g), v = new Array(u).fill(0);
      for (let w = 0; w < a; ++w) {
        let N = e28[w * p], E = v[N], A = (N === 0 ? 0 : h[N - 1]) + E;
        v[N]++;
        for (let D = 0; D < p; ++D) y[A * p + D] = e28[w * p + D];
        b[A] = n[w], c[w] = A;
      }
      for (let w = 0; w < u; ++w) if (v[w] === 0) {
        let E = w === 0 ? 0 : h[w - 1];
        y[E * p + 0] = w;
        for (let A = 1; A < p; ++A) y[E * p + A] = 0;
        b[E] = i;
      }
      return [y, [g, p], b, l, c];
    }
  }
  function Vb(e28, t, r, n, o) {
    let s10 = x.sizeFromShape(n), i = t[0], a = o.length, u = [], l = 1, c = -1;
    for (let g = 0; g < a; ++g) {
      let y = o[g];
      if (y === -1) {
        if (c !== -1) throw new Error(C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c, g));
        c = g, u.push(1);
      } else {
        if (y < 0) throw new Error(C.getSparseReshapeNegativeOutputDimErrorMessage(g, y));
        l *= y, u.push(y);
      }
    }
    if (c !== -1) {
      if (l <= 0) throw new Error(C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
      let g = Math.trunc(s10 / l);
      if (l * g !== s10) throw new Error(C.getSparseReshapeInputOutputMultipleErrorMessage(n, u));
      u[c] = g;
    }
    if (x.sizeFromShape(u) !== s10) throw new Error(C.getSparseReshapeInputOutputMismatchErrorMessage(n, u));
    let m = n.length, f = [];
    if (m > 0) {
      f[m - 1] = 1;
      for (let g = m - 2; g >= 0; --g) f[g] = f[g + 1] * n[g + 1];
    }
    let h = [];
    if (a > 0) {
      h[a - 1] = 1;
      for (let g = a - 2; g >= 0; --g) h[g] = h[g + 1] * u[g + 1];
    }
    let d = x.getArrayFromDType(r, i * a);
    for (let g = 0; g < i; ++g) {
      let y = 0;
      for (let b = 0; b < m; ++b) y += e28[g * m + b] * f[b];
      for (let b = 0; b < a; ++b) d[g * a + b] = Math.trunc(y / h[b]), y %= h[b];
    }
    return [d, [i, a], u];
  }
  function Im(e28, t, r, n, o, s10 = false, i = 0) {
    let a = n.length, u = [t[0], e28.length / t[0]], l = u[1], p = a > 0 ? o[a - 1] + 1 : 0;
    if (p < 0) throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let m = t.slice();
    m[0] = p;
    let f = m.reduce((v, w) => v * w, 1), h = x.getArrayFromDType(r, f);
    if (a === 0) return p > 0 && h.fill(i), [h, m];
    if (p <= 0) throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let d = 0, g = 1, y = 0, b = o[d];
    for (; ; ) {
      let v = 0;
      if (g < a) {
        if (v = o[g], b === v) {
          ++g;
          continue;
        }
        if (b >= v) throw new Error(C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
      }
      if (b < 0 || b >= p) throw new Error(C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b, p));
      b > y && h.fill(i, y * l, b * l);
      for (let w = d; w < g; ++w) {
        let N = n[w];
        if (N < 0 || N >= u[0]) throw new Error(C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w, n[w], u[0]));
        for (let E = 0; E < l; E++) h[b * l + E] += e28[N * l + E];
      }
      if (s10) for (let w = 0; w < l; w++) h[b * l + w] /= g - d;
      if (d = g, ++g, y = b + 1, b = v, g > a) break;
    }
    return y < p && h.fill(i, y * l, p * l), [h, m];
  }
  var I$ = Er((e28) => Math.sqrt(e28));
  var a8 = Lt(Pi, (e28) => Math.sqrt(e28));
  var T$ = { kernelName: Pi, backendName: "cpu", kernelFunc: a8 };
  var _C = Jt((e28, t) => {
    let r = e28 - t;
    return r * r;
  });
  var u8 = oe(Li, _C);
  var k$ = { kernelName: Li, backendName: "cpu", kernelFunc: u8 };
  var OC = Er((e28, t) => {
    let { pattern: r, replaceGlobal: n, rewrite: o } = t;
    return e28.replace(new RegExp(r, n ? "g" : ""), o);
  });
  var l8 = Cn($f, OC);
  var E$ = { kernelName: $f, backendName: "cpu", kernelFunc: l8 };
  function Gb(e28, t, r, n) {
    let o = kt(e28, t.dtype);
    for (let s10 = 0; s10 < o.size; s10++) {
      let i = o.indexToLoc(s10), a = new Array(i.length);
      for (let u = 0; u < a.length; u++) a[u] = i[u] * r[u] + n[u];
      o.set(t.get(...a), ...i);
    }
    return o;
  }
  var RC = class {
    constructor(t, r, n, o, s10, i) {
      this.separator = x.encodeString(t), this.nGramWidths = r, this.leftPad = x.encodeString(n), this.rightPad = x.encodeString(o), this.padWidth = s10, this.preserveShort = i;
    }
    getPadWidth(t) {
      return Math.min(this.padWidth < 0 ? t - 1 : this.padWidth, t - 1);
    }
    getNumNGrams(t, r) {
      let n = this.getPadWidth(r);
      return Math.max(0, t + 2 * n - r + 1);
    }
    createNGrams(t, r, n, o, s10, i) {
      for (let a = 0; a < s10; ++a) {
        let u = this.getPadWidth(i), l = Math.max(0, u - a), c = Math.max(0, u - (s10 - (a + 1))), p = i - (l + c), m = r + (l > 0 ? 0 : a - u), f = 0;
        f += l * this.leftPad.length;
        for (let b = 0; b < p; ++b) f += t[m + b].length;
        f += c * this.rightPad.length;
        let h = l + c + p - 1;
        f += h * this.separator.length, n[o + a] = new Uint8Array(f);
        let d = n[o + a], g = 0, y = (b) => b.forEach((v) => d[g++] = v);
        for (let b = 0; b < l; ++b) y(this.leftPad), y(this.separator);
        for (let b = 0; b < p - 1; ++b) y(t[m + b]), y(this.separator);
        if (p > 0) {
          y(t[m + p - 1]);
          for (let b = 0; b < c; ++b) y(this.separator), y(this.rightPad);
        } else {
          for (let b = 0; b < c - 1; ++b) y(this.rightPad), y(this.separator);
          y(this.rightPad);
        }
      }
    }
    compute(t, r) {
      let n = t.length, o = r.length;
      if (o > 0) {
        let u = r[0];
        if (u !== 0) throw new Error(`First split value must be 0, got ${u}`);
        for (let l = 1; l < o; ++l) {
          let c = r[l] >= u;
          if (c = c && r[l] <= n, !c) throw new Error(`Invalid split value ${r[l]}, must be in [${u}, ${n}]`);
          u = r[l];
        }
        if (u !== n) throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`);
      }
      let s10 = o - 1, i = x.getArrayFromDType("int32", o);
      if (n === 0 || o === 0) {
        let u = new Array(n);
        for (let l = 0; l <= s10; ++l) i[l] = 0;
        return [u, i];
      }
      i[0] = 0;
      for (let u = 1; u <= s10; ++u) {
        let l = r[u] - r[u - 1], c = 0;
        this.nGramWidths.forEach((p) => {
          c += this.getNumNGrams(l, p);
        }), this.preserveShort && l > 0 && c === 0 && (c = 1), i[u] = i[u - 1] + c;
      }
      let a = new Array(i[s10]);
      for (let u = 0; u < s10; ++u) {
        let l = r[u], c = i[u];
        if (this.nGramWidths.forEach((p) => {
          let m = r[u + 1] - r[u], f = this.getNumNGrams(m, p);
          this.createNGrams(t, l, a, c, f, p), c += f;
        }), this.preserveShort && c === i[u]) {
          let p = r[u + 1] - r[u];
          if (p === 0) continue;
          let m = p + 2 * this.padWidth;
          this.createNGrams(t, l, a, c, 1, m);
        }
      }
      return [a, i];
    }
  };
  function Wb(e28, t, r, n, o, s10, i, a) {
    return new RC(r, n, o, s10, i, a).compute(e28, t);
  }
  function c8(e28, t, r, n) {
    if (!e28.length) return;
    if (t.length === 0) {
      for (let s10 = 0; s10 < e28.length; ++s10) n.push(e28.subarray(s10, s10 + 1));
      return;
    }
    if (t.length === 1) {
      let s10 = t[0], i = e28.indexOf(s10);
      for (; i !== -1; ) {
        let a = e28.subarray(0, i);
        (!r || a.length !== 0) && n.push(a), e28 = e28.subarray(i + 1), i = e28.indexOf(s10);
      }
      (!r || e28.length !== 0) && n.push(e28);
      return;
    }
    let o = 0;
    for (let s10 = 0; s10 < e28.length + 1; s10++) if (s10 === e28.length || t.indexOf(e28[s10]) !== -1) {
      let i = e28.subarray(o, s10);
      (!r || i.length !== 0) && n.push(i), o = s10 + 1;
    }
  }
  function Ub(e28, t, r) {
    let n = e28.length, o = [], s10 = 0, i = 0, a = new Array(n);
    for (let m = 0; m < n; ++m) {
      let f = o.length;
      c8(e28[m], t, r, o);
      let h = o.length - f;
      a[m] = h, s10 += h, i = Math.max(i, h);
    }
    let u = x.getArrayFromDType("int32", s10 * 2), l = new Array(s10), c = [n, i], p = 0;
    for (let m = 0; m < n; ++m) for (let f = 0; f < a[m]; ++f) u[p * 2] = m, u[p * 2 + 1] = f, l[p] = o[p], ++p;
    return [u, l, c];
  }
  function jb(e28, t) {
    let r = x.getArrayFromDType("int32", e28.length);
    for (let n = 0; n < e28.length; ++n) r[n] = x.fingerPrint64(e28[n]).modulo(t).getLowBitsUnsigned();
    return r;
  }
  var PC = Jt((e28, t) => e28 - t);
  var p8 = Nm((e28, t, r, n) => ({ real: e28 - r, imag: t - n }));
  var Jd = oe(Mi, PC, p8);
  var A$ = { kernelName: Mi, backendName: "cpu", kernelFunc: Jd };
  function Hb(e28, t) {
    let r = new Array(e28.rank);
    for (let o = 0; o < r.length; o++) r[o] = e28.shape[o] * t[o];
    let n = kt(r, e28.dtype);
    for (let o = 0; o < n.values.length; ++o) {
      let s10 = n.indexToLoc(o), i = new Array(e28.rank);
      for (let u = 0; u < i.length; u++) i[u] = s10[u] % e28.shape[u];
      let a = e28.locToIndex(i);
      n.values[o] = e28.values[a];
    }
    return n;
  }
  var Zd = (e28, t) => {
    let r = t.value - e28.value;
    return r === 0 ? e28.index - t.index : r;
  };
  function D$(e28, t, r = 0, n = e28.length - 1) {
    for (; n > r; ) {
      if (n - r > 600) {
        let a = n - r + 1, u = t - r + 1, l = Math.log(a), c = 0.5 * Math.exp(2 * l / 3), p = 0.5 * Math.sqrt(l * c * (a - c) / a) * Math.sign(u - a / 2), m = Math.max(r, Math.floor(t - u * c / a + p)), f = Math.min(n, Math.floor(t + (a - u) * c / a + p));
        D$(e28, t, m, f);
      }
      let o = e28[t], s10 = r, i = n;
      for (x.swap(e28, r, t), Zd(e28[n], o) > 0 && x.swap(e28, r, n); s10 < i; ) {
        for (x.swap(e28, s10, i), s10++, i--; Zd(e28[s10], o) < 0; ) s10 = s10 + 1;
        for (; Zd(e28[i], o) > 0; ) i = i - 1;
      }
      Zd(e28[r], o) === 0 ? x.swap(e28, r, i) : (i = i + 1, x.swap(e28, i, n)), i <= t && (r = i + 1), t <= i && (n = i - 1);
    }
  }
  function Kb(e28, t, r, n, o) {
    let s10 = t[t.length - 1], [i, a] = [e28.length / s10, s10], u = x.getTypedArrayFromDType(r, i * n), l = x.getTypedArrayFromDType("int32", i * n);
    for (let p = 0; p < i; p++) {
      let m = p * a, f = e28.subarray(m, m + a), h = new Array(f.length);
      f.forEach((b, v) => h[v] = { value: b, index: v }), n < h.length && (D$(h, n), h = h.slice(0, n)), o && h.sort(Zd);
      let d = p * n, g = u.subarray(d, d + n), y = l.subarray(d, d + n);
      for (let b = 0; b < n; b++) g[b] = h[b].value, y[b] = h[b].index;
    }
    let c = t.slice();
    return c[c.length - 1] = n, [kt(c, r, u), kt(c, "int32", l)];
  }
  function qb(e28, t, r, n) {
    let o = x.parseAxisParam(t, r)[0], s10 = [1, r[0], 1];
    for (let h = 0; h < o; h++) s10[0] *= r[h];
    s10[1] = r[o];
    for (let h = o + 1; h < r.length; h++) s10[2] *= r[h];
    let i = /* @__PURE__ */ new Map(), a = new Int32Array(r[o]), u = new pe(s10, n, e28), l = [], c = s10[0] === 1 && s10[2] === 1;
    for (let h = 0; h < r[o]; h++) {
      let d;
      if (c) d = e28[h].toString();
      else {
        let y = [];
        for (let b = 0; b < s10[0]; b++) for (let v = 0; v < s10[2]; v++) y.push(u.get(b, h, v));
        d = y.join(",");
      }
      let g = i.get(d);
      if (g != null) a[h] = g;
      else {
        let y = i.size;
        i.set(d, y), a[h] = y, l.push(h);
      }
    }
    let p = s10.slice();
    p[1] = i.size;
    let m = new pe(p, n);
    l.forEach((h, d) => {
      for (let g = 0; g < s10[0]; g++) for (let y = 0; y < s10[2]; y++) m.set(u.get(g, h, y), g, d, y);
    });
    let f = r.slice();
    return f[o] = p[1], { outputValues: m.values, outputShape: f, indices: a };
  }
  Vy("cpu", () => new Xd(), 1);
  var MC = Lt(ui, (e28) => e28 >= 0 ? e28 : Math.exp(e28) - 1);
  var $$ = { kernelName: ui, backendName: "cpu", kernelFunc: MC };
  function zC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { alpha: s10 } = n;
    J([o], "leakyRelu");
    let i = x.sizeFromShape(o.shape), a = r.data.get(o.dataId).values, u = x.getTypedArrayFromDType("float32", i);
    for (let l = 0; l < a.length; l++) u[l] = a[l] < 0 ? s10 * a[l] : a[l];
    return r.makeTensorInfo(o.shape, "float32", u);
  }
  var F$ = { kernelName: ja, backendName: "cpu", kernelFunc: zC };
  var m8 = Jt((e28, t) => e28 < 0 ? t * e28 : e28);
  function BC(e28) {
    let { inputs: t, backend: r } = e28, { x: n, alpha: o } = t;
    J([n, o], "prelu");
    let s10 = r.data.get(n.dataId).values, i = r.data.get(o.dataId).values, [a, u] = m8(n.shape, o.shape, s10, i, "float32");
    return r.makeTensorInfo(u, "float32", a);
  }
  var _$ = { kernelName: ou, backendName: "cpu", kernelFunc: BC };
  var VC = Lt(Ti, (e28) => Math.max(0, e28));
  var O$ = { kernelName: Ti, backendName: "cpu", kernelFunc: VC };
  var GC = Lt(ki, (e28) => Math.min(Math.max(0, e28), 6));
  var R$ = { kernelName: ki, backendName: "cpu", kernelFunc: GC };
  function Yl(e28, t, r, n, o) {
    if (r === "linear") return Hr({ inputs: { x: t }, backend: e28 });
    if (r === "relu") return VC({ inputs: { x: t }, backend: e28 });
    if (r === "elu") return MC({ inputs: { x: t }, backend: e28 });
    if (r === "relu6") return GC({ inputs: { x: t }, backend: e28 });
    if (r === "prelu") return BC({ inputs: { x: t, alpha: n }, backend: e28 });
    if (r === "leakyrelu") return zC({ inputs: { x: t }, backend: e28, attrs: { alpha: o } });
    if (r === "sigmoid") return $C({ inputs: { x: t }, backend: e28 });
    throw new Error(`Activation ${r} has not been implemented for the CPU backend.`);
  }
  function Zt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { shape: s10 } = n, i = x.sizeFromShape(o.shape), a = x.inferFromImplicitShape(s10, i), u = x.sizeFromShape(a);
    x.assert(i === u, () => `The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`), r.incRef(o.dataId);
    let l = r.data.get(o.dataId);
    if (l.complexTensorInfos != null) {
      let c = l.complexTensorInfos.real, p = l.complexTensorInfos.imag;
      c.shape = a, p.shape = a;
    }
    return { dataId: o.dataId, shape: a, dtype: o.dtype };
  }
  var P$ = { kernelName: iu, backendName: "cpu", kernelFunc: Zt };
  function WC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { a: o, b: s10 } = t, { transposeA: i, transposeB: a } = n;
    J([o, s10], "matMul");
    let u = o.shape.length, l = s10.shape.length, c = i ? o.shape[u - 2] : o.shape[u - 1], p = a ? s10.shape[l - 1] : s10.shape[l - 2], m = i ? o.shape[u - 1] : o.shape[u - 2], f = a ? s10.shape[l - 2] : s10.shape[l - 1], h = o.shape.slice(0, -2), d = s10.shape.slice(0, -2), g = x.sizeFromShape(h), y = x.sizeFromShape(d), v = Rn.assertAndGetBroadcastShape(o.shape.slice(0, -2), s10.shape.slice(0, -2)).concat([m, f]);
    x.assert(c === p, () => `Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s10.shape} and transposeA=${i} and transposeB=${a} must match.`);
    let w = i ? [g, c, m] : [g, m, c], N = a ? [y, f, p] : [y, p, f], E = Zt({ inputs: { x: o }, backend: r, attrs: { shape: w } }), A = Zt({ inputs: { x: s10 }, backend: r, attrs: { shape: N } }), D = i ? E.shape[1] : E.shape[2], R = i ? E.shape[2] : E.shape[1], L = a ? A.shape[1] : A.shape[2], G = Math.max(g, y), W = r.data.get(E.dataId).values, U = r.data.get(A.dataId).values, H = x.computeStrides(E.shape), j = x.computeStrides(A.shape), [X, Q, q] = i ? [H[0], 1, H[1]] : [H[0], H[1], 1], [et, ot, st] = a ? [1, j[1], j[0]] : [j[1], 1, j[0]], ct = R * L, lt = kt([G, R, L], E.dtype), wt = lt.values, mt = r.blockSize;
    for (let Ct = 0; Ct < G; Ct++) {
      let zt = Ct % g, Ut = Ct % y;
      for (let Vt = 0; Vt < R; Vt += mt) {
        let te = Math.min(Vt + mt, R);
        for (let re = 0; re < L; re += mt) {
          let ve = Math.min(re + mt, L);
          for (let De = 0; De < D; De += mt) {
            let ir = Math.min(De + mt, D);
            for (let $e = Vt; $e < te; $e++) for (let Ie = re; Ie < ve; Ie++) {
              let nr = 0;
              for (let Ke = De; Ke < ir; Ke++) {
                let Ws = W[zt * X + $e * Q + Ke * q], Vr = U[Ke * et + Ie * ot + Ut * st];
                nr += Ws * Vr;
              }
              wt[Ct * ct + ($e * L + Ie)] += nr;
            }
          }
        }
      }
    }
    return r.disposeIntermediateTensorInfo(E), r.disposeIntermediateTensorInfo(A), r.makeTensorInfo(v, lt.dtype, lt.values);
  }
  var L$ = { kernelName: Fa, backendName: "cpu", kernelFunc: WC };
  function f8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { a: o, b: s10, bias: i, preluActivationWeights: a } = t, { transposeA: u, transposeB: l, activation: c, leakyreluAlpha: p } = n, m, f, h, d = [];
    m = WC({ inputs: { a: o, b: s10 }, attrs: { transposeA: u, transposeB: l }, backend: r }), i && (f = $s({ inputs: { a: m, b: i }, backend: r }), d.push(m), m = f), c && (h = Yl(r, m, c, a, p), d.push(m), m = h);
    for (let y of d) r.disposeIntermediateTensorInfo(y);
    return m;
  }
  var M$ = { kernelName: pl, backendName: "cpu", kernelFunc: f8 };
  var h8 = Lt(Ys, (e28) => Math.acos(e28));
  var z$ = { kernelName: Ys, backendName: "cpu", kernelFunc: h8 };
  var d8 = Lt(Js, (e28) => Math.acosh(e28));
  var B$ = { kernelName: Js, backendName: "cpu", kernelFunc: d8 };
  function g8(e28) {
    let { inputs: t, backend: r } = e28, n = t;
    J(t, "addN");
    let o = n.map((a) => r.data.get(a.dataId).values), s10 = kt(n[0].shape, n[0].dtype), i = s10.values;
    for (let a = 0; a < n.length; a++) {
      let u = o[a];
      for (let l = 0; l < i.length; l++) i[l] += u[l];
    }
    return r.makeTensorInfo(s10.shape, s10.dtype, s10.values);
  }
  var V$ = { kernelName: Dc, backendName: "cpu", kernelFunc: g8 };
  function y8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n;
    J(o, "all");
    let a = x.parseAxisParam(s10, o.shape), u = a, l = C.getAxesPermutation(u, o.shape.length), c = o;
    l != null && (c = Pe({ inputs: { x: o }, backend: r, attrs: { perm: l } }), u = C.getInnerMostAxes(u.length, o.shape.length)), C.assertAxesAreInnerMostDims("all", u, c.shape.length);
    let [p, m] = C.computeOutAndReduceShapes(c.shape, u), f = x.sizeFromShape(m), h = x.makeZerosTypedArray(x.sizeFromShape(p), c.dtype), d = r.data.get(c.dataId).values;
    for (let y = 0; y < h.length; ++y) {
      let b = y * f, v = d[b];
      for (let w = 0; w < f; ++w) {
        let N = d[b + w];
        v = v && N;
      }
      h[y] = v;
    }
    l != null && r.disposeIntermediateTensorInfo(c);
    let g = r.makeTensorInfo(p, c.dtype, h);
    if (i) {
      let y = C.expandShapeToKeepDim(p, a), b = Zt({ inputs: { x: g }, backend: r, attrs: { shape: y } });
      return r.disposeIntermediateTensorInfo(g), b;
    }
    return g;
  }
  var G$ = { kernelName: $c, backendName: "cpu", kernelFunc: y8 };
  function x8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n;
    J(o, "any");
    let a = x.parseAxisParam(s10, o.shape), u = a, l = C.getAxesPermutation(u, o.shape.length), c = o;
    l != null && (c = Pe({ inputs: { x: o }, backend: r, attrs: { perm: l } }), u = C.getInnerMostAxes(u.length, o.shape.length)), C.assertAxesAreInnerMostDims("any", u, c.shape.length);
    let [p, m] = C.computeOutAndReduceShapes(c.shape, u), f = x.sizeFromShape(m), h = x.makeZerosTypedArray(x.sizeFromShape(p), c.dtype), d = r.data.get(c.dataId).values;
    for (let y = 0; y < h.length; ++y) {
      let b = y * f, v = d[b];
      for (let w = 0; w < f; ++w) {
        let N = d[b + w];
        v = v || N;
      }
      h[y] = v;
    }
    l != null && r.disposeIntermediateTensorInfo(c);
    let g = r.makeTensorInfo(p, c.dtype, h);
    if (i) {
      let y = C.expandShapeToKeepDim(p, a), b = Zt({ inputs: { x: g }, backend: r, attrs: { shape: y } });
      return r.disposeIntermediateTensorInfo(g), b;
    }
    return g;
  }
  var W$ = { kernelName: Fc, backendName: "cpu", kernelFunc: x8 };
  function b8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10 } = n;
    J(o, "argMax");
    let i = x.parseAxisParam(s10, o.shape), a = C.getAxesPermutation(i, o.shape.length), u = o, l = [];
    a != null && (u = Pe({ inputs: { x: o }, backend: r, attrs: { perm: a } }), l.push(u), i = C.getInnerMostAxes(i.length, u.shape.length)), i = [i[0]], C.assertAxesAreInnerMostDims("argMax", i, u.shape.length);
    let [c, p] = C.computeOutAndReduceShapes(u.shape, i), m = x.sizeFromShape(c), f = x.makeZerosTypedArray(m, "int32"), h = x.sizeFromShape(p), d = r.data.get(u.dataId).values;
    for (let g = 0; g < f.length; ++g) {
      let y = g * h, b = d[y], v = 0;
      for (let w = 0; w < h; ++w) {
        let N = d[y + w];
        N > b && (b = N, v = w);
      }
      f[g] = v;
    }
    return l.forEach((g) => r.disposeIntermediateTensorInfo(g)), r.makeTensorInfo(c, "int32", f);
  }
  var U$ = { kernelName: Ea, backendName: "cpu", kernelFunc: b8 };
  function w8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10 } = n;
    J(o, "argMin");
    let i = x.parseAxisParam(s10, o.shape), a = C.getAxesPermutation(i, o.shape.length), u = o, l = [];
    a != null && (u = Pe({ inputs: { x: o }, backend: r, attrs: { perm: a } }), l.push(u), i = C.getInnerMostAxes(i.length, u.shape.length)), i = [i[0]], C.assertAxesAreInnerMostDims("argMin", i, u.shape.length);
    let [c, p] = C.computeOutAndReduceShapes(u.shape, i), m = x.sizeFromShape(c), f = x.makeZerosTypedArray(m, "int32"), h = x.sizeFromShape(p), d = r.data.get(u.dataId).values;
    for (let g = 0; g < f.length; ++g) {
      let y = g * h, b = d[y], v = 0;
      for (let w = 0; w < h; ++w) {
        let N = d[y + w];
        N < b && (b = N, v = w);
      }
      f[g] = v;
    }
    return l.forEach((g) => r.disposeIntermediateTensorInfo(g)), r.makeTensorInfo(c, "int32", f);
  }
  var j$ = { kernelName: Aa, backendName: "cpu", kernelFunc: w8 };
  var v8 = Lt(Zs, (e28) => Math.asin(e28));
  var H$ = { kernelName: Zs, backendName: "cpu", kernelFunc: v8 };
  var N8 = Lt(Qs, (e28) => Math.asinh(e28));
  var K$ = { kernelName: Qs, backendName: "cpu", kernelFunc: N8 };
  var C8 = Lt(ti, (e28) => Math.atan(e28));
  var q$ = { kernelName: ti, backendName: "cpu", kernelFunc: C8 };
  var S8 = Jt((e28, t) => Math.atan2(e28, t));
  var I8 = oe(ri, S8);
  var X$ = { kernelName: ri, backendName: "cpu", kernelFunc: I8 };
  var T8 = Lt(ei, (e28) => Math.atanh(e28));
  var Y$ = { kernelName: ei, backendName: "cpu", kernelFunc: T8 };
  function Tm(e28, t, r, n, o, s10) {
    let i = o.strideHeight, a = o.strideWidth, u = o.dilationHeight, l = o.dilationWidth, c = o.effectiveFilterHeight, p = o.effectiveFilterWidth, m = o.padInfo.top, f = o.padInfo.left, h = s10 === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, d = kt(o.outShape, r), g = d.values, y = o.outShape[1] * o.outShape[2] * o.outShape[3], b = o.outShape[2] * o.outShape[3], v = o.outShape[3];
    for (let w = 0; w < o.batchSize; ++w) {
      let N = w * y, E = w * n[0];
      for (let A = 0; A < o.inChannels; ++A) for (let D = 0; D < o.outHeight; ++D) {
        let R = D * i - m, L = Math.max(0, R), G = Math.min(o.inHeight, c + R), W = N + D * b;
        for (let U = 0; U < o.outWidth; ++U) {
          let H = U * a - f, j = Math.max(0, H), X = Math.min(o.inWidth, p + H), Q = h, q = 0, et = 0;
          for (let st = L; st < G; st += u) {
            let ct = E + st * n[1];
            for (let lt = j; lt < X; lt += l) {
              let wt = ct + lt * n[2], mt = e28[wt + A];
              s10 === "max" && mt > Q ? Q = mt : s10 === "avg" && (q += mt, et++);
            }
            if (isNaN(Q)) break;
          }
          let ot = W + U * v + A;
          g[ot] = s10 === "avg" ? q / et : Q;
        }
      }
    }
    return d;
  }
  function Xb(e28, t, r, n, o = false, s10 = false) {
    let i = kt(n.outShape, "int32"), a = n.strideHeight, u = n.strideWidth, l = n.dilationHeight, c = n.dilationWidth, p = n.effectiveFilterHeight, m = n.effectiveFilterWidth, f = n.padInfo.top, h = n.padInfo.left, d = kt(t, r, e28);
    for (let g = 0; g < n.batchSize; ++g) for (let y = 0; y < n.inChannels; ++y) for (let b = 0; b < n.outHeight; ++b) {
      let v = b * a - f, w = v;
      for (; w < 0; ) w += l;
      let N = Math.min(n.inHeight, p + v);
      for (let E = 0; E < n.outWidth; ++E) {
        let A = E * u - h, D = A;
        for (; D < 0; ) D += c;
        let R = Math.min(n.inWidth, m + A), L = Number.NEGATIVE_INFINITY, G = -1;
        for (let W = w; W < N; W += l) {
          let U = W - v;
          for (let H = D; H < R; H += c) {
            let j = H - A, X = d.get(g, W, H, y);
            X > L && (L = X, o ? G = s10 ? ((g * n.inHeight + W) * n.inWidth + H) * n.inChannels + y : (W * n.inWidth + H) * n.inChannels + y : G = U * m + j);
          }
        }
        i.set(G, g, b, E, y);
      }
    }
    return i;
  }
  function Yb(e28, t, r, n, o, s10) {
    let i = o.strideDepth, a = o.strideHeight, u = o.strideWidth, l = o.dilationDepth, c = o.dilationHeight, p = o.dilationWidth, m = o.effectiveFilterDepth, f = o.effectiveFilterHeight, h = o.effectiveFilterWidth, d = o.padInfo.front, g = o.padInfo.top, y = o.padInfo.left, b = s10 === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v = kt(o.outShape, r), w = v.values, N = o.outShape[1] * o.outShape[2] * o.outShape[3] * o.outShape[4], E = o.outShape[2] * o.outShape[3] * o.outShape[4], A = o.outShape[3] * o.outShape[4], D = o.outShape[4];
    for (let R = 0; R < o.batchSize; ++R) {
      let L = R * N, G = R * n[0];
      for (let W = 0; W < o.inChannels; ++W) for (let U = 0; U < o.outDepth; ++U) {
        let H = U * i - d, j = H;
        for (; j < 0; ) j += l;
        let X = Math.min(o.inDepth, m + H), Q = L + U * E;
        for (let q = 0; q < o.outHeight; ++q) {
          let et = q * a - g, ot = et;
          for (; ot < 0; ) ot += c;
          let st = Math.min(o.inHeight, f + et), ct = Q + q * A;
          for (let lt = 0; lt < o.outWidth; ++lt) {
            let wt = lt * u - y, mt = wt;
            for (; mt < 0; ) mt += p;
            let Ct = Math.min(o.inWidth, h + wt), zt = ct + lt * D, Ut = b, Vt = 0, te = 0;
            for (let ve = j; ve < X; ve += l) {
              let De = G + ve * n[1];
              for (let ir = ot; ir < st; ir += c) {
                let $e = De + ir * n[2];
                for (let Ie = mt; Ie < Ct; Ie += p) {
                  let nr = $e + Ie * n[3], Ke = e28[nr + W];
                  if (s10 === "max" && Ke > Ut ? Ut = Ke : s10 === "avg" && (Vt += Ke, te++), isNaN(Ut)) break;
                }
                if (isNaN(Ut)) break;
              }
              if (isNaN(Ut)) break;
            }
            let re = zt + W;
            w[re] = s10 === "avg" ? Vt / Math.max(te, 1) : Ut;
          }
        }
      }
    }
    return v;
  }
  function J$(e28, t) {
    let r = kt(t.outShape, "int32"), n = t.strideDepth, o = t.strideHeight, s10 = t.strideWidth, i = t.dilationDepth, a = t.dilationHeight, u = t.dilationWidth, l = t.effectiveFilterDepth, c = t.effectiveFilterHeight, p = t.effectiveFilterWidth, m = t.padInfo.front, f = t.padInfo.top, h = t.padInfo.left;
    for (let d = 0; d < t.batchSize; ++d) for (let g = 0; g < t.inChannels; ++g) for (let y = 0; y < t.outDepth; ++y) {
      let b = y * n - m, v = b;
      for (; v < 0; ) v += i;
      let w = Math.min(t.inDepth, l + b);
      for (let N = 0; N < t.outHeight; ++N) {
        let E = N * o - f, A = E;
        for (; A < 0; ) A += a;
        let D = Math.min(t.inHeight, c + E);
        for (let R = 0; R < t.outWidth; ++R) {
          let L = R * s10 - h, G = L;
          for (; G < 0; ) G += u;
          let W = Math.min(t.inWidth, p + L), U = Number.NEGATIVE_INFINITY, H = -1;
          for (let j = v; j < w; j += i) {
            let X = j - b;
            for (let Q = A; Q < D; Q += a) {
              let q = Q - E;
              for (let et = G; et < W; et += u) {
                let ot = et - L, st = e28.get(d, j, Q, et, g);
                st >= U && (U = st, H = X * c * p + q * c + ot);
              }
            }
          }
          r.set(H, d, y, N, R, g);
        }
      }
    }
    return r;
  }
  function k8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t;
    J(o, "avgPool");
    let { filterSize: s10, strides: i, pad: a, dimRoundingMode: u } = n, l = 1;
    x.assert(C.eitherStridesOrDilationsAreOne(i, l), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);
    let c = C.computePool2DInfo(o.shape, s10, i, l, a, u), p;
    if (c.filterWidth === 1 && c.filterHeight === 1 && x.arraysEqual(c.inShape, c.outShape)) p = Hr({ inputs: { x: o }, backend: r });
    else {
      let m = r.data.get(o.dataId).values, f = x.computeStrides(o.shape), h = Tm(m, o.shape, o.dtype, f, c, "avg");
      p = r.makeTensorInfo(c.outShape, o.dtype, h.values);
    }
    return p;
  }
  var Z$ = { kernelName: Da, backendName: "cpu", kernelFunc: k8 };
  function E8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { filterSize: s10, strides: i, pad: a, dimRoundingMode: u, dataFormat: l } = n;
    J(o, "avgPool3d");
    let c = C.computePool3DInfo(o.shape, s10, i, 1, a, u, l), p = r.data.get(o.dataId).values, m = Yb(p, o.shape, o.dtype, x.computeStrides(o.shape), c, "avg");
    return r.makeTensorInfo(m.shape, "float32", m.values);
  }
  var Q$ = { kernelName: $a, backendName: "cpu", kernelFunc: E8 };
  function A8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10 } = t, { filterSize: i, strides: a, pad: u, dimRoundingMode: l } = n;
    J([o, s10], "avgPool3DGrad");
    let c = C.computePool3DInfo(s10.shape, i, a, 1, u, l), p = c.strideDepth, m = c.strideHeight, f = c.strideWidth, h = c.filterDepth, d = c.filterHeight, g = c.filterWidth, y = c.dilationDepth, b = c.dilationHeight, v = c.dilationWidth, w = c.effectiveFilterDepth, N = c.effectiveFilterHeight, E = c.effectiveFilterWidth, A = w - 1 - c.padInfo.front, D = E - 1 - c.padInfo.left, R = N - 1 - c.padInfo.top, L = kt(s10.shape, "float32"), G = 1 / (h * d * g), W = r.bufferSync(o);
    for (let U = 0; U < c.batchSize; ++U) for (let H = 0; H < c.inChannels; ++H) for (let j = 0; j < c.inDepth; ++j) for (let X = 0; X < c.inHeight; ++X) for (let Q = 0; Q < c.inWidth; ++Q) {
      let q = j - A, et = X - R, ot = Q - D, st = 0;
      for (let ct = 0; ct < w; ct += y) {
        let lt = (q + ct) / p;
        if (!(lt < 0 || lt >= c.outDepth || Math.floor(lt) !== lt)) for (let wt = 0; wt < N; wt += b) {
          let mt = (et + wt) / m;
          if (!(mt < 0 || mt >= c.outHeight || Math.floor(mt) !== mt)) for (let Ct = 0; Ct < E; Ct += v) {
            let zt = (ot + Ct) / f;
            if (zt < 0 || zt >= c.outWidth || Math.floor(zt) !== zt) continue;
            let Ut = W.get(U, lt, mt, zt, H);
            st += Ut;
          }
        }
      }
      L.set(st * G, U, j, X, Q, H);
    }
    return r.makeTensorInfo(L.shape, L.dtype, L.values);
  }
  var tF = { kernelName: Oc, backendName: "cpu", kernelFunc: A8 };
  function D8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10 } = t, i = s10;
    J([o, s10], "avgPoolGrad");
    let { filterSize: a, strides: u, pad: l } = n, c = C.computePool2DInfo(i.shape, a, u, 1, l), p = c.strideHeight, m = c.strideWidth, f = c.filterHeight, h = c.filterWidth, d = c.dilationHeight, g = c.dilationWidth, y = c.effectiveFilterHeight, b = c.effectiveFilterWidth, v = b - 1 - c.padInfo.left, w = y - 1 - c.padInfo.top, N = kt(i.shape, "float32"), E = 1 / (f * h), A = r.data.get(o.dataId).values, D = kt(o.shape, "float32", A);
    for (let R = 0; R < c.batchSize; ++R) for (let L = 0; L < c.inChannels; ++L) for (let G = 0; G < c.inHeight; ++G) for (let W = 0; W < c.inWidth; ++W) {
      let U = G - w, H = W - v, j = 0;
      for (let X = 0; X < y; X += d) {
        let Q = (U + X) / p;
        if (!(Q < 0 || Q >= c.outHeight || Math.floor(Q) !== Q)) for (let q = 0; q < b; q += g) {
          let et = (H + q) / m;
          if (et < 0 || et >= c.outWidth || Math.floor(et) !== et) continue;
          let ot = D.get(R, Q, et, L);
          j += ot;
        }
      }
      N.set(j * E, R, G, W, L);
    }
    return r.makeTensorInfo(N.shape, N.dtype, N.values);
  }
  var eF = { kernelName: _c, backendName: "cpu", kernelFunc: D8 };
  function $8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, scale: s10, offset: i, mean: a, variance: u } = t;
    x.assert(a.shape.length === u.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), x.assert(i == null || a.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), x.assert(s10 == null || a.shape.length === s10.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), J([o, a, u, s10, i], "batchNorm");
    let { varianceEpsilon: l } = n;
    l == null && (l = 1e-3);
    let c = r.data.get(o.dataId).values, p = r.data.get(a.dataId).values, m = r.data.get(u.dataId).values, f = s10 ? r.data.get(s10.dataId).values : new Float32Array([1]), h = i ? r.data.get(i.dataId).values : new Float32Array([0]), d = new Float32Array(c.length), g = h.length, y = f.length, b = m.length, v = p.length, w = 0, N = 0, E = 0, A = 0;
    for (let D = 0; D < c.length; ++D) d[D] = h[w++] + (c[D] - p[N++]) * f[E++] / Math.sqrt(m[A++] + l), w >= g && (w = 0), N >= v && (N = 0), E >= y && (E = 0), A >= b && (A = 0);
    return r.makeTensorInfo(o.shape, o.dtype, d);
  }
  var rF = { kernelName: Wa, backendName: "cpu", kernelFunc: $8 };
  function F8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { blockShape: s10, crops: i } = n;
    J([o], "batchToSpaceND");
    let a = s10.reduce((y, b) => y * b), u = C.getReshaped(o.shape, s10, a), l = C.getPermuted(u.length, s10.length), c = C.getReshapedPermuted(o.shape, s10, a), p = C.getSliceBeginCoords(i, s10.length), m = C.getSliceSize(c, i, s10.length), f = Zt({ inputs: { x: o }, backend: r, attrs: { shape: u } }), h = Pe({ inputs: { x: f }, backend: r, attrs: { perm: l } }), d = Zt({ inputs: { x: h }, backend: r, attrs: { shape: c } }), g = Fo({ inputs: { x: d }, backend: r, attrs: { begin: p, size: m } });
    return r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), g;
  }
  var nF = { kernelName: _a, backendName: "cpu", kernelFunc: F8 };
  function _8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, weights: s10 } = t, { size: i } = n, a = r.data.get(o.dataId).values, u = r.data.get(s10.dataId).values, l = Cm(a, u, s10.dtype, s10.shape, i);
    return r.makeTensorInfo([i], s10.dtype, l);
  }
  var oF = { kernelName: Rc, backendName: "cpu", kernelFunc: _8 };
  function O8(e28) {
    let { inputs: t, backend: r } = e28, { s0: n, s1: o } = t, s10 = r.data.get(n.dataId).values, i = r.data.get(o.dataId).values, a = C.assertAndGetBroadcastShape(Array.from(s10), Array.from(i));
    return r.makeTensorInfo([a.length], "int32", Int32Array.from(a));
  }
  var sF = { kernelName: cy, backendName: "cpu", kernelFunc: O8 };
  var R8 = Lt(oi, (e28, t) => {
    let r = t;
    return e28 > r.clipValueMax ? r.clipValueMax : e28 < r.clipValueMin ? r.clipValueMin : e28;
  });
  var iF = { kernelName: oi, backendName: "cpu", kernelFunc: R8 };
  var P8 = (e28) => {
    let { x: t } = e28.inputs, r = e28.backend, n = new Float32Array(x.sizeFromShape(t.shape)), o = r.data.get(t.dataId), s10 = o.complexTensorInfos.real, i = o.complexTensorInfos.imag, a = r.data.get(s10.dataId).values, u = r.data.get(i.dataId).values;
    for (let l = 0; l < a.length; l++) {
      let c = a[l], p = u[l];
      n[l] = Math.hypot(c, p);
    }
    return r.makeOutput(n, t.shape, "float32");
  };
  var aF = { kernelName: Oa, backendName: "cpu", kernelFunc: P8 };
  function Fs(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t, o = r.data.get(n.dataId).complexTensorInfos.imag, s10 = r.data.get(o.dataId).values;
    return r.makeTensorInfo(o.shape, o.dtype, s10);
  }
  var uF = { kernelName: Zc, backendName: "cpu", kernelFunc: Fs };
  function Pu(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { axis: o } = n, s10 = x.parseAxisParam(o, t[0].shape)[0], i = t.map((d) => d.shape);
    C.assertParamsConsistent(i, s10);
    let a = C.computeOutShape(t.map((d) => d.shape), s10);
    if (x.sizeFromShape(a) === 0) return r.makeTensorInfo(a, t[0].dtype, []);
    let u = t.filter((d) => x.sizeFromShape(d.shape) > 0);
    if (u.length === 1) return Hr({ inputs: { x: u[0] }, backend: r });
    if (u[0].dtype === "complex64") {
      let d = u.map((w) => Ao({ inputs: { input: w }, backend: r })), g = u.map((w) => Fs({ inputs: { input: w }, backend: r })), y = Pu({ inputs: d, backend: r, attrs: { axis: s10 } }), b = Pu({ inputs: g, backend: r, attrs: { axis: s10 } }), v = br({ inputs: { real: y, imag: b }, backend: r });
      return d.forEach((w) => r.disposeIntermediateTensorInfo(w)), g.forEach((w) => r.disposeIntermediateTensorInfo(w)), r.disposeIntermediateTensorInfo(y), r.disposeIntermediateTensorInfo(b), v;
    }
    let l = u.map((d) => {
      let y = [-1, x.sizeFromShape(d.shape.slice(s10))];
      return Zt({ inputs: { x: d }, backend: r, attrs: { shape: y } });
    }), c = l.map((d) => ({ vals: r.data.get(d.dataId).values, shape: d.shape }));
    a = C.computeOutShape(l.map((d) => d.shape), 1);
    let p = l[0].shape[0] === 1, m = $b(c, a, t[0].dtype, p), f = C.computeOutShape(u.map((d) => d.shape), s10), h = r.makeTensorInfo(f, t[0].dtype, m);
    return l.forEach((d) => r.disposeIntermediateTensorInfo(d)), h;
  }
  var lF = { kernelName: Ra, backendName: "cpu", kernelFunc: Pu };
  function UC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dataFormat: u, dilations: l, dimRoundingMode: c } = n;
    J([o, s10], "conv2d");
    let p = C.convertConv2DDataFormat(u), m = C.computeConv2DInfo(o.shape, s10.shape, i, l, a, c, false, p), f = m.filterHeight, h = m.filterWidth, d = m.dilationHeight, g = m.dilationWidth, y = m.padInfo.left, b = m.padInfo.top, v = m.dataFormat === "channelsLast", w = new pe(m.outShape, o.dtype), N = x.computeStrides(o.shape), E = x.computeStrides(s10.shape), A = N[0], D = v ? N[1] : N[2], R = v ? N[2] : 1, L = v ? 1 : N[1], G = w.strides[0], W = v ? w.strides[1] : w.strides[2], U = v ? w.strides[2] : 1, H = v ? 1 : w.strides[1], j = r.data.get(o.dataId).values, X = r.data.get(s10.dataId).values, Q = w.values;
    for (let q = 0; q < m.batchSize; ++q) {
      let et = q * A, ot = q * G;
      for (let st = 0; st < m.outHeight; ++st) {
        let ct = ot + st * W, lt = st * m.strideHeight - b;
        for (let wt = 0; wt < f; ++wt) {
          let mt = lt + wt * d;
          if (mt < 0 || mt >= m.inHeight) continue;
          let Ct = wt * E[0], zt = et + mt * D;
          for (let Ut = 0; Ut < m.outWidth; ++Ut) {
            let Vt = ct + Ut * U, te = Ut * m.strideWidth - y;
            for (let re = 0; re < h; ++re) {
              let ve = te + re * g;
              if (ve < 0 || ve >= m.inWidth) continue;
              let De = Ct + re * E[1], ir = zt + ve * R, $e = De;
              for (let Ie = 0; Ie < m.inChannels; ++Ie) {
                let nr = j[ir + Ie * L];
                for (let Ke = 0; Ke < m.outChannels; ++Ke) Q[Vt + Ke * H] += nr * X[$e + Ke];
                $e += m.outChannels;
              }
            }
          }
        }
      }
    }
    return r.makeTensorInfo(w.shape, w.dtype, Q);
  }
  var cF = { kernelName: Pa, backendName: "cpu", kernelFunc: UC };
  function L8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, dy: s10 } = t, { strides: i, pad: a, dataFormat: u, dimRoundingMode: l, filterShape: c } = n;
    J([o, s10], "conv2dBackpropFilter");
    let p = C.convertConv2DDataFormat(u), m = C.computeConv2DInfo(o.shape, c, i, 1, a, l, false, p), { strideHeight: f, strideWidth: h, filterHeight: d, filterWidth: g } = m, y = m.dataFormat === "channelsLast", b = new pe(m.filterShape, "float32"), v = m.padInfo.left, w = m.padInfo.top, N = r.data.get(o.dataId).values, E = r.data.get(s10.dataId).values, A = new pe(o.shape, o.dtype, N), D = new pe(s10.shape, s10.dtype, E);
    for (let R = 0; R < d; ++R) {
      let L = Math.max(0, Math.ceil((w - R) / f)), G = Math.min(m.outHeight, (m.inHeight + w - R) / f);
      for (let W = 0; W < g; ++W) {
        let U = Math.max(0, Math.ceil((v - W) / h)), H = Math.min(m.outWidth, (m.inWidth + v - W) / h);
        for (let j = 0; j < m.inChannels; ++j) for (let X = 0; X < m.outChannels; ++X) {
          let Q = 0;
          for (let q = 0; q < m.batchSize; ++q) for (let et = L; et < G; ++et) {
            let ot = R + et * f - w;
            for (let st = U; st < H; ++st) {
              let ct = W + st * h - v;
              y ? Q += A.get(q, ot, ct, j) * D.get(q, et, st, X) : Q += A.get(q, j, ot, ct) * D.get(q, X, et, st);
            }
          }
          b.set(Q, R, W, j, X);
        }
      }
    }
    return r.makeTensorInfo(b.shape, b.dtype, b.values);
  }
  var pF = { kernelName: Lc, backendName: "cpu", kernelFunc: L8 };
  function M8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, filter: s10 } = t, { inputShape: i, strides: a, pad: u, dataFormat: l, dimRoundingMode: c } = n;
    J([o, s10], "conv2dBackpropInput");
    let p = x.computeStrides(s10.shape), m = x.computeStrides(o.shape), f = C.convertConv2DDataFormat(l), h = C.computeConv2DInfo(i, s10.shape, a, 1, u, c, false, f), d = new pe(h.inShape, "float32"), g = d.values, y = r.data.get(o.dataId).values, b = r.data.get(s10.dataId).values, [v, w, N] = p, { batchSize: E, filterHeight: A, filterWidth: D, inChannels: R, inHeight: L, inWidth: G, outChannels: W, outHeight: U, outWidth: H, strideHeight: j, strideWidth: X } = h;
    f = h.dataFormat;
    let Q = A - 1 - h.padInfo.top, q = D - 1 - h.padInfo.left, et = f === "channelsLast", ot = d.strides[0], st = et ? d.strides[1] : d.strides[2], ct = et ? d.strides[2] : 1, lt = et ? 1 : d.strides[1], wt = m[0], mt = et ? m[1] : m[2], Ct = et ? m[2] : 1, zt = et ? 1 : m[1];
    for (let Ut = 0; Ut < E; ++Ut) for (let Vt = 0; Vt < R; ++Vt) for (let te = 0; te < L; ++te) {
      let re = te - Q, ve = Math.max(0, Math.ceil(re / j)), De = Math.min(U, (A + re) / j);
      for (let ir = 0; ir < G; ++ir) {
        let $e = ir - q, Ie = Math.max(0, Math.ceil($e / X)), nr = Math.min(H, (D + $e) / X), Ke = 0;
        for (let Vr = ve; Vr < De; ++Vr) {
          let ba = Vr * j - re;
          for (let jn = Ie; jn < nr; ++jn) {
            let Yu = jn * X - $e, Po = wt * Ut + mt * Vr + Ct * jn, Us = v * (A - 1 - ba) + w * (D - 1 - Yu) + N * Vt;
            for (let wa = 0; wa < W; ++wa) {
              let va = y[Po + zt * wa], Na = b[Us + wa];
              Ke += va * Na;
            }
          }
        }
        let Ws = ot * Ut + st * te + ct * ir + lt * Vt;
        g[Ws] = Ke;
      }
    }
    return r.makeTensorInfo(d.shape, d.dtype, d.values);
  }
  var mF = { kernelName: La, backendName: "cpu", kernelFunc: M8 };
  function z8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dilations: u } = n;
    J([o, s10], "conv3d");
    let l = C.computeConv3DInfo(o.shape, s10.shape, i, u, a), { filterDepth: c, filterHeight: p, filterWidth: m, dilationDepth: f, dilationHeight: h, dilationWidth: d, padInfo: g } = l, y = g.front, b = g.left, v = g.top, w = new pe(l.outShape, o.dtype), N = r.data.get(o.dataId).values, E = r.data.get(s10.dataId).values, A = w.values, D = x.computeStrides(o.shape), R = x.computeStrides(s10.shape);
    for (let L = 0; L < l.batchSize; ++L) {
      let G = L * D[0], W = L * w.strides[0];
      for (let U = 0; U < l.outDepth; ++U) {
        let H = W + U * w.strides[1], j = U * l.strideDepth - y;
        for (let X = 0; X < c; ++X) {
          let Q = j + X * f;
          if (Q < 0 || Q >= l.inDepth) continue;
          let q = X * R[0], et = G + Q * D[1];
          for (let ot = 0; ot < l.outHeight; ++ot) {
            let st = H + ot * w.strides[2], ct = ot * l.strideHeight - v;
            for (let lt = 0; lt < p; ++lt) {
              let wt = ct + lt * h;
              if (wt < 0 || wt >= l.inHeight) continue;
              let mt = q + lt * R[1], Ct = et + wt * D[2];
              for (let zt = 0; zt < l.outWidth; ++zt) {
                let Ut = st + zt * l.outChannels, Vt = zt * l.strideWidth - b;
                for (let te = 0; te < m; ++te) {
                  let re = Vt + te * d;
                  if (re < 0 || re >= l.inWidth) continue;
                  let ve = mt + te * R[2], De = Ct + re * l.inChannels, ir = ve;
                  for (let $e = 0; $e < l.inChannels; ++$e) {
                    let Ie = N[De + $e];
                    for (let nr = 0; nr < l.outChannels; ++nr) A[Ut + nr] += Ie * E[ir + nr];
                    ir += l.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }
    return r.makeTensorInfo(w.shape, w.dtype, w.values);
  }
  var fF = { kernelName: Ma, backendName: "cpu", kernelFunc: z8 };
  function B8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, dy: s10 } = t, { strides: i, pad: a, filterShape: u } = n;
    J([o, s10], "conv3dBackpropFilterV2");
    let l = x.computeStrides(o.shape), c = x.computeStrides(s10.shape), p = C.computeConv3DInfo(o.shape, u, i, 1, a), m = p.strideDepth, f = p.strideHeight, h = p.strideWidth, d = p.filterDepth, g = p.filterHeight, y = p.filterWidth, b = new pe(p.filterShape, "float32"), v = b.values, [w, N, E, A] = b.strides, D = r.data.get(s10.dataId).values, [R, L, G, W] = c, U = r.data.get(o.dataId).values, [H, j, X, Q] = l, q = p.padInfo.front, et = p.padInfo.left, ot = p.padInfo.top;
    for (let st = 0; st < d; ++st) {
      let ct = Math.max(0, Math.ceil((q - st) / m)), lt = Math.min(p.outDepth, (p.inDepth + q - st) / m), wt = st * w;
      for (let mt = 0; mt < g; ++mt) {
        let Ct = Math.max(0, Math.ceil((ot - mt) / f)), zt = Math.min(p.outHeight, (p.inHeight + ot - mt) / f), Ut = mt * N + wt;
        for (let Vt = 0; Vt < y; ++Vt) {
          let te = Math.max(0, Math.ceil((et - Vt) / h)), re = Math.min(p.outWidth, (p.inWidth + et - Vt) / h), ve = Vt * E + Ut;
          for (let De = 0; De < p.inChannels; ++De) {
            let ir = De * A + ve;
            for (let $e = 0; $e < p.outChannels; ++$e) {
              let Ie = 0;
              for (let nr = 0; nr < p.batchSize; ++nr) {
                let Ke = nr * H, Ws = nr * R;
                for (let Vr = ct; Vr < lt; ++Vr) {
                  let jn = (st + Vr * m - q) * j + Ke, Yu = Vr * L + Ws;
                  for (let Po = Ct; Po < zt; ++Po) {
                    let wa = (mt + Po * f - ot) * X + jn, va = Po * G + Yu;
                    for (let Na = te; Na < re; ++Na) {
                      let mv = (Vt + Na * h - et) * Q + wa, fv = Na * W + va;
                      Ie += U[mv + De] * D[fv + $e];
                    }
                  }
                }
              }
              v[ir + $e] = Ie;
            }
          }
        }
      }
    }
    return r.makeTensorInfo(b.shape, b.dtype, b.values);
  }
  var hF = { kernelName: Mc, backendName: "cpu", kernelFunc: B8 };
  function V8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, filter: s10 } = t, { pad: i, strides: a, inputShape: u } = n;
    J([o], "conv3dBackpropInputV2");
    let l = x.computeStrides(o.shape), c = x.computeStrides(s10.shape), p = C.computeConv3DInfo(u, s10.shape, a, 1, i), m = new pe(p.inShape, "float32"), f = m.values, [h, d, g, y] = m.strides, b = r.data.get(o.dataId).values, [v, w, N, E] = l, A = r.data.get(s10.dataId).values, [D, R, L, G] = c, { batchSize: W, filterDepth: U, filterHeight: H, filterWidth: j, inChannels: X, inDepth: Q, inHeight: q, inWidth: et, outChannels: ot, outDepth: st, outHeight: ct, outWidth: lt, strideDepth: wt, strideHeight: mt, strideWidth: Ct } = p, zt = U - 1 - p.padInfo.front, Ut = H - 1 - p.padInfo.top, Vt = j - 1 - p.padInfo.left;
    for (let te = 0; te < W; ++te) for (let re = 0; re < X; ++re) for (let ve = 0; ve < Q; ++ve) {
      let De = ve - zt, ir = Math.max(0, Math.ceil(De / wt)), $e = Math.min(st, (U + De) / wt);
      for (let Ie = 0; Ie < q; ++Ie) {
        let nr = Ie - Ut, Ke = Math.max(0, Math.ceil(nr / mt)), Ws = Math.min(ct, (H + nr) / mt);
        for (let Vr = 0; Vr < et; ++Vr) {
          let ba = Vr - Vt, jn = Math.max(0, Math.ceil(ba / Ct)), Yu = Math.min(lt, (j + ba) / Ct), Po = 0;
          for (let Us = ir; Us < $e; ++Us) {
            let wa = Us * wt - De;
            for (let va = Ke; va < Ws; ++va) {
              let Na = va * mt - nr;
              for (let mf = jn; mf < Yu; ++mf) {
                let mv = mf * Ct - ba, fv = v * te + w * Us + N * va + E * mf, SB = D * (U - 1 - wa) + R * (H - 1 - Na) + L * (j - 1 - mv) + G * re;
                for (let Kg = 0; Kg < ot; ++Kg) {
                  let IB = b[fv + Kg], TB = A[SB + Kg];
                  Po += IB * TB;
                }
              }
            }
          }
          f[h * te + d * ve + g * Ie + y * Vr + re] = Po;
        }
      }
    }
    return r.makeTensorInfo(m.shape, m.dtype, m.values);
  }
  var dF = { kernelName: zc, backendName: "cpu", kernelFunc: V8 };
  var G8 = Lt(si, (e28) => Math.cos(e28));
  var gF = { kernelName: si, backendName: "cpu", kernelFunc: G8 };
  var W8 = Lt(ii, (e28) => Math.cosh(e28));
  var yF = { kernelName: ii, backendName: "cpu", kernelFunc: W8 };
  function U8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { image: o, boxes: s10, boxInd: i } = t, { cropSize: a, method: u, extrapolationValue: l } = n, [c, p, m, f] = o.shape, h = s10.shape[0], [d, g] = a, y = kt([h, d, g, f], "float32"), b = r.data.get(s10.dataId).values, v = r.data.get(i.dataId).values, w = r.data.get(o.dataId).values, N = x.computeStrides(o.shape), E = x.computeStrides(y.shape);
    for (let A = 0; A < h; A++) {
      let D = A * 4, R = b[D], L = b[D + 1], G = b[D + 2], W = b[D + 3], U = v[A];
      if (U >= c) continue;
      let H = d > 1 ? (G - R) * (p - 1) / (d - 1) : 0, j = g > 1 ? (W - L) * (m - 1) / (g - 1) : 0;
      for (let X = 0; X < d; X++) {
        let Q = d > 1 ? R * (p - 1) + X * H : 0.5 * (R + G) * (p - 1);
        if (Q < 0 || Q > p - 1) {
          for (let q = 0; q < g; q++) for (let et = 0; et < f; et++) {
            let ot = et + q * E[2] + X * E[1] + A * E[0];
            y.values[ot] = l;
          }
          continue;
        }
        if (u === "bilinear") {
          let q = Math.floor(Q), et = Math.ceil(Q), ot = Q - q;
          for (let st = 0; st < g; st++) {
            let ct = g > 1 ? L * (m - 1) + st * j : 0.5 * (L + W) * (m - 1);
            if (ct < 0 || ct > m - 1) {
              for (let Ct = 0; Ct < f; Ct++) {
                let zt = Ct + st * E[2] + X * E[1] + A * E[0];
                y.values[zt] = l;
              }
              continue;
            }
            let lt = Math.floor(ct), wt = Math.ceil(ct), mt = ct - lt;
            for (let Ct = 0; Ct < f; Ct++) {
              let zt = Ct + lt * N[2] + q * N[1] + U * N[0], Ut = w[zt];
              zt = Ct + wt * N[2] + q * N[1] + U * N[0];
              let Vt = w[zt];
              zt = Ct + lt * N[2] + et * N[1] + U * N[0];
              let te = w[zt];
              zt = Ct + wt * N[2] + et * N[1] + U * N[0];
              let re = w[zt], ve = Ut + (Vt - Ut) * mt, De = te + (re - te) * mt;
              zt = Ct + st * E[2] + X * E[1] + A * E[0], y.values[zt] = ve + (De - ve) * ot;
            }
          }
        } else for (let q = 0; q < g; ++q) {
          let et = g > 1 ? L * (m - 1) + q * j : 0.5 * (L + W) * (m - 1);
          if (et < 0 || et > m - 1) {
            for (let ct = 0; ct < f; ct++) {
              let lt = ct + q * E[2] + X * E[1] + A * E[0];
              y.values[lt] = l;
            }
            continue;
          }
          let ot = Math.round(et), st = Math.round(Q);
          for (let ct = 0; ct < f; ct++) {
            let lt = ct + ot * N[2] + st * N[1] + U * N[0], wt = ct + q * E[2] + X * E[1] + A * E[0];
            y.values[wt] = w[lt];
          }
        }
      }
    }
    return r.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  var xF = { kernelName: Vc, backendName: "cpu", kernelFunc: U8 };
  function j8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, exclusive: i, reverse: a } = n;
    J(o, "cumprod");
    let u = C.getAxesPermutation([s10], o.shape.length), l = o;
    u != null && (l = Pe({ inputs: { x: o }, backend: r, attrs: { perm: u } }));
    let c = C.getInnerMostAxes(1, o.shape.length)[0];
    if (c !== l.shape.length - 1) throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${c}`);
    let p = lr(l.dtype, "int32"), m = x.makeOnesTypedArray(x.sizeFromShape(l.shape), p), f = r.data.get(l.dataId).values, h = l.shape[l.shape.length - 1], d = a ? (y, b) => y + h - b - 1 : (y, b) => y + b;
    for (let y = 0; y < f.length; y += h) for (let b = 0; b < h; b++) {
      let v = d(y, b);
      if (b === 0) m[v] = i ? 1 : f[v];
      else {
        let w = d(y, b - 1);
        m[v] = i ? f[w] * m[w] : f[v] * m[w];
      }
    }
    let g = r.makeTensorInfo(l.shape, p, m);
    if (u != null) {
      let y = C.getUndoAxesPermutation(u), b = Pe({ inputs: { x: g }, backend: r, attrs: { perm: y } });
      return r.disposeIntermediateTensorInfo(g), r.disposeIntermediateTensorInfo(l), b;
    }
    return g;
  }
  var bF = { kernelName: Bc, backendName: "cpu", kernelFunc: j8 };
  function H8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, exclusive: i, reverse: a } = n;
    J(o, "cumsum");
    let u = C.getAxesPermutation([s10], o.shape.length), l = o;
    u != null && (l = Pe({ inputs: { x: o }, backend: r, attrs: { perm: u } }));
    let c = C.getInnerMostAxes(1, o.shape.length)[0];
    if (c !== l.shape.length - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${c}`);
    let p = lr(l.dtype, "int32"), m = x.makeZerosTypedArray(x.sizeFromShape(l.shape), p), f = r.data.get(l.dataId).values, h = l.shape[l.shape.length - 1], d = a ? (y, b) => y + h - b - 1 : (y, b) => y + b;
    for (let y = 0; y < f.length; y += h) for (let b = 0; b < h; b++) {
      let v = d(y, b);
      if (b === 0) m[v] = i ? 0 : f[v];
      else {
        let w = d(y, b - 1);
        m[v] = i ? f[w] + m[w] : f[v] + m[w];
      }
    }
    let g = r.makeTensorInfo(l.shape, p, m);
    if (u != null) {
      let y = C.getUndoAxesPermutation(u), b = Pe({ inputs: { x: g }, backend: r, attrs: { perm: y } });
      return r.disposeIntermediateTensorInfo(g), r.disposeIntermediateTensorInfo(l), b;
    }
    return g;
  }
  var wF = { kernelName: za, backendName: "cpu", kernelFunc: H8 };
  function K8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, weights: s10 } = t, { size: i, binaryOutput: a } = n;
    if (o.shape.length === 1) {
      let u = r.data.get(o.dataId).values, l = r.data.get(s10.dataId).values, c = Cm(u, l, s10.dtype, s10.shape, i);
      return r.makeTensorInfo([i], s10.dtype, c);
    } else if (o.shape.length === 2) {
      let u = r.bufferSync(o), l = r.bufferSync(s10), c = Db(u, l, i, a);
      return r.makeTensorInfo(c.shape, s10.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`);
  }
  var vF = { kernelName: Gc, backendName: "cpu", kernelFunc: K8 };
  function q8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { blockSize: s10, dataFormat: i } = n;
    x.assert(i === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);
    let a = o.shape[0], u = o.shape[1], l = o.shape[2], c = o.shape[3], p = u * s10, m = l * s10, f = c / (s10 * s10), h = r.data.get(o.dataId).values, d = new Float32Array(a * p * m * f), g = 0;
    for (let y = 0; y < a; ++y) for (let b = 0; b < p; ++b) {
      let v = Math.floor(b / s10), w = b % s10;
      for (let N = 0; N < m; ++N) {
        let E = Math.floor(N / s10), A = N % s10, D = (w * s10 + A) * f;
        for (let R = 0; R < f; ++R) {
          let G = R + D + c * (E + l * (v + u * y));
          d[g++] = h[G];
        }
      }
    }
    return r.makeTensorInfo([a, p, m, f], o.dtype, d);
  }
  var NF = { kernelName: Wc, backendName: "cpu", kernelFunc: q8 };
  function jC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dilations: u, dimRoundingMode: l } = n;
    J([o, s10], "depthwiseConv2DNative");
    let c = x.computeStrides(o.shape), p = x.computeStrides(s10.shape), m = u;
    m == null && (m = [1, 1]), x.assert(C.eitherStridesOrDilationsAreOne(i, m), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);
    let f = C.computeConv2DInfo(o.shape, s10.shape, i, m, a, l, true), { filterHeight: h, filterWidth: d, dilationHeight: g, dilationWidth: y, padInfo: b } = f, v = b.left, w = b.top, N = f.outChannels / f.inChannels, E = new pe(f.outShape, o.dtype), A = r.data.get(o.dataId).values, D = r.data.get(s10.dataId).values, R = E.values;
    for (let L = 0; L < f.batchSize; ++L) {
      let G = L * c[0], W = L * E.strides[0];
      for (let U = 0; U < f.outHeight; ++U) {
        let H = W + U * E.strides[1], j = U * f.strideHeight - w;
        for (let X = 0; X < h; ++X) {
          let Q = j + X * g;
          if (Q < 0 || Q >= f.inHeight) continue;
          let q = X * p[0], et = G + Q * c[1];
          for (let ot = 0; ot < f.outWidth; ++ot) {
            let st = H + ot * E.strides[2], ct = ot * f.strideWidth - v;
            for (let lt = 0; lt < d; ++lt) {
              let wt = ct + lt * y;
              if (wt < 0 || wt >= f.inWidth) continue;
              let mt = q + lt * p[1], Ct = et + wt * f.inChannels, zt = st, Ut = mt;
              for (let Vt = 0; Vt < f.inChannels; ++Vt) {
                let te = A[Ct + Vt];
                for (let re = 0; re < N; ++re) R[zt + re] += te * D[Ut + re];
                zt += N, Ut += N;
              }
            }
          }
        }
      }
    }
    return r.makeTensorInfo(E.shape, E.dtype, E.values);
  }
  var CF = { kernelName: Ba, backendName: "cpu", kernelFunc: jC };
  function X8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, dy: s10 } = t, { strides: i, dilations: a, pad: u, dimRoundingMode: l, filterShape: c } = n;
    J([o, s10], "depthwiseConv2dNativeBackpropFilter");
    let p = C.computeConv2DInfo(o.shape, c, i, a, u, l, true), { strideHeight: m, strideWidth: f, filterHeight: h, filterWidth: d } = p, g = new pe(p.filterShape, "float32"), y = p.padInfo.left, b = p.padInfo.top, v = p.outChannels / p.inChannels, w = r.data.get(o.dataId).values, N = new pe(o.shape, o.dtype, w), E = r.data.get(s10.dataId).values, A = new pe(s10.shape, s10.dtype, E);
    for (let D = 0; D < h; ++D) {
      let R = Math.max(0, Math.ceil((b - D) / m)), L = Math.min(p.outHeight, (p.inHeight + b - D) / m);
      for (let G = 0; G < d; ++G) {
        let W = Math.max(0, Math.ceil((y - G) / f)), U = Math.min(p.outWidth, (p.inWidth + y - G) / f);
        for (let H = 0; H < p.outChannels; ++H) {
          let j = Math.trunc(H / v), X = H % v, Q = 0;
          for (let q = 0; q < p.batchSize; ++q) for (let et = R; et < L; ++et) {
            let ot = D + et * m - b;
            for (let st = W; st < U; ++st) {
              let ct = G + st * f - y;
              Q += N.get(q, ot, ct, j) * A.get(q, et, st, H);
            }
          }
          g.set(Q, D, G, j, X);
        }
      }
    }
    return r.makeTensorInfo(g.shape, g.dtype, g.values);
  }
  var SF = { kernelName: Uc, backendName: "cpu", kernelFunc: X8 };
  function Y8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, filter: s10 } = t, { strides: i, dilations: a, pad: u, dimRoundingMode: l, inputShape: c } = n;
    J([o, s10], "depthwiseConv2DNativeBackpropInput");
    let p = x.computeStrides(o.shape), m = x.computeStrides(s10.shape), f = C.computeConv2DInfo(c, s10.shape, i, a, u, l, true), h = new pe(f.inShape, "float32"), d = h.values, [g, y, b] = h.strides, v = r.data.get(o.dataId).values, [w, N, E] = p, A = r.data.get(s10.dataId).values, [D, R, L] = m, { batchSize: G, filterHeight: W, filterWidth: U, inChannels: H, inHeight: j, inWidth: X, outChannels: Q, outHeight: q, outWidth: et, strideHeight: ot, strideWidth: st } = f, ct = W - 1 - f.padInfo.top, lt = U - 1 - f.padInfo.left, wt = Q / H;
    for (let mt = 0; mt < G; ++mt) for (let Ct = 0; Ct < H; ++Ct) for (let zt = 0; zt < j; ++zt) {
      let Ut = zt - ct, Vt = Math.max(0, Math.ceil(Ut / ot)), te = Math.min(q, (W + Ut) / ot);
      for (let re = 0; re < X; ++re) {
        let ve = re - lt, De = Math.max(0, Math.ceil(ve / st)), ir = Math.min(et, (U + ve) / st), $e = 0;
        for (let Ie = Vt; Ie < te; ++Ie) {
          let nr = Ie * ot - Ut;
          for (let Ke = De; Ke < ir; ++Ke) {
            let Ws = Ke * st - ve, Vr = w * mt + N * Ie + E * Ke, ba = D * (W - 1 - nr) + R * (U - 1 - Ws) + L * Ct;
            for (let jn = 0; jn < wt; ++jn) {
              let Yu = Ct * wt + jn, Po = v[Vr + Yu], Us = A[ba + jn];
              $e += Po * Us;
            }
          }
        }
        d[g * mt + y * zt + b * re + Ct] = $e;
      }
    }
    return r.makeTensorInfo(h.shape, h.dtype, h.values);
  }
  var IF = { kernelName: jc, backendName: "cpu", kernelFunc: Y8 };
  function J8(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t, o = x.sizeFromShape(n.shape), s10 = r.data.get(n.dataId).values, i = kt([o, o], n.dtype), a = i.values;
    for (let l = 0; l < s10.length; l++) a[l * o + l] = s10[l];
    let u = [...n.shape, ...n.shape];
    return r.makeTensorInfo(u, i.dtype, i.values);
  }
  var TF = { kernelName: py, backendName: "cpu", kernelFunc: J8 };
  var kF = { kernelName: Va, backendName: "cpu", kernelFunc: ({ inputs: e28, backend: t, attrs: r }) => {
    let { x: n, filter: o } = e28, { strides: s10, pad: i, dilations: a } = r, u = t, l = u.data.get(n.dataId).values, c = n.shape.length, p = u.data.get(o.dataId).values, m = o.shape.length, { batchSize: f, inHeight: h, inWidth: d, inChannels: g, outHeight: y, outWidth: b, padInfo: v, strideHeight: w, strideWidth: N, filterHeight: E, filterWidth: A, dilationHeight: D, dilationWidth: R, outShape: L } = C.computeDilation2DInfo(n.shape, o.shape, s10, i, "NHWC", a), G = x.sizeFromShape(L), W = L.length, U = x.getArrayFromDType(n.dtype, G);
    for (let j = 0; j < f; ++j) for (let X = 0; X < y; ++X) {
      let Q = X * w - v.top;
      for (let q = 0; q < b; ++q) {
        let et = q * N - v.left;
        for (let ot = 0; ot < g; ++ot) {
          let st = Number.MIN_SAFE_INTEGER;
          for (let lt = 0; lt < E; ++lt) {
            let wt = Q + lt * D;
            if (wt >= 0 && wt < h) for (let mt = 0; mt < A; ++mt) {
              let Ct = et + mt * R;
              if (Ct >= 0 && Ct < d) {
                let zt = x.locToIndex([j, wt, Ct, ot], c, x.computeStrides(n.shape)), Ut = x.locToIndex([lt, mt, ot], m, x.computeStrides(o.shape)), Vt = l[zt] + p[Ut];
                Vt > st && (st = Vt);
              }
            }
          }
          let ct = x.locToIndex([j, X, q, ot], W, x.computeStrides(L));
          U[ct] = st;
        }
      }
    }
    return { dataId: u.write(x.toTypedArray(U, n.dtype), L, n.dtype), shape: L, dtype: n.dtype };
  } };
  var EF = { kernelName: Df, backendName: "cpu", kernelFunc: ({ inputs: e28, backend: t, attrs: r }) => {
    let { x: n, filter: o, dy: s10 } = e28, { strides: i, pad: a, dilations: u } = r, l = t, c = x.toNestedArray(n.shape, l.data.get(n.dataId).values), p = x.toNestedArray(o.shape, l.data.get(o.dataId).values), { batchSize: m, inHeight: f, inWidth: h, inChannels: d, outHeight: g, outWidth: y, padInfo: b, strideHeight: v, strideWidth: w, filterHeight: N, filterWidth: E, dilationHeight: A, dilationWidth: D, outShape: R } = C.computeDilation2DInfo(n.shape, o.shape, i, a, "NHWC", u);
    x.assert(s10.rank === R.length, () => `Error in ${Df}, dy must have the same rank as output ${R.length}, but got ${s10.rank}`);
    let L = x.toNestedArray(R, l.data.get(s10.dataId).values), G = x.makeZerosNestedTypedArray(o.shape, o.dtype);
    for (let U = 0; U < m; ++U) for (let H = 0; H < g; ++H) {
      let j = H * v - b.top;
      for (let X = 0; X < y; ++X) {
        let Q = X * w - b.left;
        for (let q = 0; q < d; ++q) {
          let et = Number.MIN_SAFE_INTEGER, ot = 0, st = 0;
          for (let ct = 0; ct < N; ++ct) {
            let lt = j + ct * A;
            if (lt >= 0 && lt < f) for (let wt = 0; wt < E; ++wt) {
              let mt = Q + wt * D;
              if (mt >= 0 && mt < h) {
                let Ct = c[U][lt][mt][q] + p[ct][wt][q];
                Ct > et && (et = Ct, ot = ct, st = wt);
              }
            }
          }
          G[ot][st][q] += L[U][H][X][q];
        }
      }
    }
    return { dataId: l.write(x.toTypedArray(G, n.dtype), o.shape, o.dtype), shape: o.shape, dtype: o.dtype };
  } };
  var AF = { kernelName: Af, backendName: "cpu", kernelFunc: ({ inputs: e28, backend: t, attrs: r }) => {
    let { x: n, filter: o, dy: s10 } = e28, { strides: i, pad: a, dilations: u } = r, l = t, c = x.toNestedArray(n.shape, l.data.get(n.dataId).values), p = x.toNestedArray(o.shape, l.data.get(o.dataId).values), { batchSize: m, inHeight: f, inWidth: h, inChannels: d, outHeight: g, outWidth: y, padInfo: b, strideHeight: v, strideWidth: w, filterHeight: N, filterWidth: E, dilationHeight: A, dilationWidth: D, outShape: R } = C.computeDilation2DInfo(n.shape, o.shape, i, a, "NHWC", u);
    x.assert(s10.rank === R.length, () => `Error in ${Af}, dy must have the same rank as output ${R.length}, but got ${s10.rank}`);
    let L = x.toNestedArray(R, l.data.get(s10.dataId).values), G = x.makeZerosNestedTypedArray(n.shape, n.dtype);
    for (let U = 0; U < m; ++U) for (let H = 0; H < g; ++H) {
      let j = H * v - b.top;
      for (let X = 0; X < y; ++X) {
        let Q = X * w - b.left;
        for (let q = 0; q < d; ++q) {
          let et = Number.MIN_SAFE_INTEGER, ot = j < 0 ? 0 : j, st = Q < 0 ? 0 : Q;
          for (let ct = 0; ct < N; ++ct) {
            let lt = j + ct * A;
            if (lt >= 0 && lt < f) for (let wt = 0; wt < E; ++wt) {
              let mt = Q + wt * D;
              if (mt >= 0 && mt < h) {
                let Ct = c[U][lt][mt][q] + p[ct][wt][q];
                Ct > et && (et = Ct, ot = lt, st = mt);
              }
            }
          }
          G[U][ot][st][q] += L[U][H][X][q];
        }
      }
    }
    return { dataId: l.write(x.toTypedArray(G, n.dtype), n.shape, n.dtype), shape: n.shape, dtype: n.dtype };
  } };
  function Z8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { image: o } = t, { canvas: s10, options: i } = n, { contextOptions: a, imageOptions: u } = i || {}, l = u?.alpha || 1, c = a?.contextType || "2d";
    if (c !== "2d") throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);
    let p = s10.getContext(c, a?.contextAttributes || {});
    if (p == null) throw new Error(`Could not get the context with ${c} type.`);
    let [m, f] = o.shape.slice(0, 2), h = o.shape.length === 2 ? 1 : o.shape[2], d = r.data.get(o.dataId).values, g = o.dtype === "float32" ? 255 : 1, y = new Uint8ClampedArray(f * m * 4);
    for (let v = 0; v < m * f; ++v) {
      let w = [0, 0, 0, 255 * l];
      for (let E = 0; E < h; E++) {
        let A = d[v * h + E];
        if (o.dtype === "float32") {
          if (A < 0 || A > 1) throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${A}.`);
        } else if (o.dtype === "int32" && (A < 0 || A > 255)) throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${A}.`);
        h === 1 ? (w[0] = A * g, w[1] = A * g, w[2] = A * g) : w[E] = A * g;
      }
      let N = v * 4;
      y[N + 0] = Math.round(w[0]), y[N + 1] = Math.round(w[1]), y[N + 2] = Math.round(w[2]), y[N + 3] = Math.round(w[3]);
    }
    s10.width = f, s10.height = m;
    let b = new ImageData(y, f, m);
    return p.putImageData(b, 0, 0), o;
  }
  var DF = { kernelName: oT, backendName: "cpu", kernelFunc: Z8 };
  function ia(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n;
    J(o, "sum");
    let a;
    o.dtype === "bool" ? a = Do({ inputs: { x: o }, backend: r, attrs: { dtype: "int32" } }) : a = Hr({ inputs: { x: o }, backend: r });
    let u = a.shape.length, l = x.parseAxisParam(s10, a.shape), c = C.getAxesPermutation(l, u), p = l, m = a;
    c != null && (m = Pe({ inputs: { x: a }, backend: r, attrs: { perm: c } }), p = C.getInnerMostAxes(p.length, u)), C.assertAxesAreInnerMostDims("sum", p, m.shape.length);
    let [f, h] = C.computeOutAndReduceShapes(m.shape, p), d = C.upcastType(m.dtype, "int32"), g = vm(r, f, d), y = x.sizeFromShape(h), b = r.data.get(g.dataId).values, v = r.data.get(m.dataId).values;
    for (let w = 0; w < b.length; ++w) {
      let N = w * y, E = 0;
      for (let A = 0; A < y; ++A) E += v[N + A];
      b[w] = E;
    }
    if (i) {
      let w = C.expandShapeToKeepDim(g.shape, l), N = g;
      g = Zt({ inputs: { x: g }, backend: r, attrs: { shape: w } }), r.disposeIntermediateTensorInfo(N);
    }
    return r.disposeIntermediateTensorInfo(a), c != null && r.disposeIntermediateTensorInfo(m), g;
  }
  var $F = { kernelName: mu, backendName: "cpu", kernelFunc: ia };
  function Q8(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { equation: o } = n, s10 = t, { allDims: i, summedDims: a, idDims: u } = C.decodeEinsumEquation(o, s10.length);
    C.checkEinsumDimSizes(i.length, u, s10);
    let { path: l, steps: c } = C.getEinsumComputePath(a, u), p = c.length, m = null, f = i.length, h = [];
    for (let d = 0; d < p; ++d) {
      for (let g of c[d]) {
        let { permutationIndices: y, expandDims: b } = C.getEinsumPermutation(f, u[g]), v;
        C.isIdentityPermutation(y) ? v = s10[g] : (v = Pe({ inputs: { x: s10[g] }, backend: r, attrs: { perm: y } }), h.push(v));
        let w = v.shape.slice();
        for (let N = 0; N < b.length; ++N) w.splice(b[N], 0, 1);
        x.arraysEqual(v.shape, w) || (v = Zt({ inputs: { x: v }, backend: r, attrs: { shape: w } }), h.push(v)), m === null ? m = v : (m = Xl({ inputs: { a: v, b: m }, backend: r }), h.push(m));
      }
      d < p - 1 && (l[d] >= 0 && (m = ia({ inputs: { x: m }, backend: r, attrs: { axis: l[d] - (i.length - f), keepDims: false } }), h.push(m)), f--);
    }
    for (let d of h) d !== m && r.disposeIntermediateTensorInfo(d);
    return m;
  }
  var FF = { kernelName: Hc, backendName: "cpu", kernelFunc: Q8 };
  function tX(e28) {
    let { inputs: t, backend: r } = e28, { dy: n, y: o } = t;
    J([n, o], "eluGrad");
    let s10 = new Float32Array(x.sizeFromShape(o.shape)), i = r.data.get(o.dataId).values, a = r.data.get(n.dataId).values;
    for (let u = 0; u < i.length; ++u) {
      let l = i[u];
      l >= 0 ? s10[u] = a[u] : s10[u] = a[u] * (l + 1);
    }
    return r.makeTensorInfo(o.shape, "float32", s10);
  }
  var _F = { kernelName: Kc, backendName: "cpu", kernelFunc: tX };
  var eX = C.ERF_P;
  var rX = C.ERF_A1;
  var nX = C.ERF_A2;
  var oX = C.ERF_A3;
  var sX = C.ERF_A4;
  var iX = C.ERF_A5;
  var aX = Lt(li, (e28) => {
    let t = Math.sign(e28), r = Math.abs(e28), n = 1 / (1 + eX * r);
    return t * (1 - ((((iX * n + sX) * n + oX) * n + nX) * n + rX) * n * Math.exp(-r * r));
  });
  var OF = { kernelName: li, backendName: "cpu", kernelFunc: aX };
  function km(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { input: o } = t, { dim: s10 } = n, i = o.shape.length, a = o.shape.slice(), u = s10;
    return s10 < 0 && (x.assert(-(i + 1) <= s10, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), u = i + s10 + 1), a.splice(u, 0, 1), Zt({ inputs: { x: o }, backend: r, attrs: { shape: a } });
  }
  var RF = { kernelName: Ga, backendName: "cpu", kernelFunc: km };
  var uX = Jt((e28, t) => e28 / t);
  var Qd = oe(ai, uX);
  var tg = { kernelName: ai, backendName: "cpu", kernelFunc: Qd };
  function Jb(e28, t, r) {
    let n = e28.shape, o = n[0], s10 = n[1], i = r.data.get(e28.dataId), a = i.complexTensorInfos.real, u = i.complexTensorInfos.imag, l = [o, s10], c = x.sizeFromShape(l), p = x.getTypedArrayFromDType("float32", c), m = x.getTypedArrayFromDType("float32", c);
    for (let g = 0; g < o; g++) {
      let y = Fo({ inputs: { x: a }, backend: r, attrs: { begin: [g, 0], size: [1, s10] } }), b = Fo({ inputs: { x: u }, backend: r, attrs: { begin: [g, 0], size: [1, s10] } }), v = br({ inputs: { real: y, imag: b }, backend: r }), { real: w, imag: N } = lX(v, t, r), E = C.mergeRealAndImagArrays(w, N);
      for (let A = 0; A < s10; A++) {
        let D = C.getComplexWithIndex(E, A);
        p[g * s10 + A] = D.real, m[g * s10 + A] = D.imag;
      }
      r.disposeIntermediateTensorInfo(y), r.disposeIntermediateTensorInfo(b), r.disposeIntermediateTensorInfo(v);
    }
    let f = r.makeTensorInfo(l, "float32", p), h = r.makeTensorInfo(l, "float32", m), d = br({ inputs: { real: f, imag: h }, backend: r });
    return r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(h), d;
  }
  function lX(e28, t, r) {
    let n = x.sizeFromShape(e28.shape), o = r.data.get(e28.dataId), s10 = r.data.get(o.complexTensorInfos.real.dataId).values, i = r.data.get(o.complexTensorInfos.imag.dataId).values;
    if (cX(n)) {
      let a = HC(s10, i, n, t, r), u = [e28.shape[0], e28.shape[1]];
      if (t) {
        let l = r.makeTensorInfo(u, "float32", a.real), c = r.makeTensorInfo(u, "float32", a.imag), p = r.makeTensorInfo([], "float32", x.createScalarValue(n, "float32")), m = Hr({ inputs: { x: p }, backend: r }), f = tg.kernelFunc({ inputs: { a: l, b: p }, backend: r }), h = tg.kernelFunc({ inputs: { a: c, b: m }, backend: r }), d = r.data.get(f.dataId).values, g = r.data.get(h.dataId).values;
        return r.disposeIntermediateTensorInfo(l), r.disposeIntermediateTensorInfo(c), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(h), { real: d, imag: g };
      }
      return a;
    } else {
      let a = C.mergeRealAndImagArrays(s10, i), u = pX(a, n, t);
      return C.splitRealAndImagArrays(u);
    }
  }
  function cX(e28) {
    return (e28 & e28 - 1) === 0;
  }
  function HC(e28, t, r, n, o) {
    if (r === 1) return { real: e28, imag: t };
    let s10 = C.mergeRealAndImagArrays(e28, t), i = r / 2, a = C.complexWithEvenIndex(s10), u = a.real, l = a.imag, c = [u.length], p = o.makeTensorInfo(c, "float32", u), m = o.makeTensorInfo(c, "float32", l), f = br({ inputs: { real: p, imag: m }, backend: o }), h = C.complexWithOddIndex(s10), d = h.real, g = h.imag, y = [d.length], b = o.makeTensorInfo(y, "float32", d), v = o.makeTensorInfo(y, "float32", g), w = br({ inputs: { real: b, imag: v }, backend: o }), N = HC(u, l, i, n, o), E = N.real, A = N.imag, D = [E.length], R = o.makeTensorInfo(D, "float32", E), L = o.makeTensorInfo(D, "float32", A), G = br({ inputs: { real: R, imag: L }, backend: o }), W = HC(d, g, i, n, o), U = W.real, H = W.imag, j = [U.length], X = o.makeTensorInfo(j, "float32", U), Q = o.makeTensorInfo(j, "float32", H), q = br({ inputs: { real: X, imag: Q }, backend: o }), et = C.exponents(r, n), ot = [et.real.length], st = o.makeTensorInfo(ot, "float32", et.real), ct = o.makeTensorInfo(ot, "float32", et.imag), lt = br({ inputs: { real: st, imag: ct }, backend: o }), wt = Xl({ inputs: { a: lt, b: q }, backend: o }), mt = $s({ inputs: { a: G, b: wt }, backend: o }), Ct = Jd({ inputs: { a: G, b: wt }, backend: o }), zt = Ao({ inputs: { input: mt }, backend: o }), Ut = Ao({ inputs: { input: Ct }, backend: o }), Vt = Fs({ inputs: { input: mt }, backend: o }), te = Fs({ inputs: { input: Ct }, backend: o }), re = Pu({ inputs: [zt, Ut], backend: o, attrs: { axis: 0 } }), ve = Pu({ inputs: [Vt, te], backend: o, attrs: { axis: 0 } }), De = o.data.get(re.dataId).values, ir = o.data.get(ve.dataId).values;
    return o.disposeIntermediateTensorInfo(p), o.disposeIntermediateTensorInfo(m), o.disposeIntermediateTensorInfo(f), o.disposeIntermediateTensorInfo(b), o.disposeIntermediateTensorInfo(v), o.disposeIntermediateTensorInfo(w), o.disposeIntermediateTensorInfo(R), o.disposeIntermediateTensorInfo(L), o.disposeIntermediateTensorInfo(G), o.disposeIntermediateTensorInfo(X), o.disposeIntermediateTensorInfo(Q), o.disposeIntermediateTensorInfo(q), o.disposeIntermediateTensorInfo(st), o.disposeIntermediateTensorInfo(ct), o.disposeIntermediateTensorInfo(lt), o.disposeIntermediateTensorInfo(wt), o.disposeIntermediateTensorInfo(mt), o.disposeIntermediateTensorInfo(Ct), o.disposeIntermediateTensorInfo(zt), o.disposeIntermediateTensorInfo(Vt), o.disposeIntermediateTensorInfo(Ut), o.disposeIntermediateTensorInfo(te), o.disposeIntermediateTensorInfo(re), o.disposeIntermediateTensorInfo(ve), { real: De, imag: ir };
  }
  function pX(e28, t, r) {
    let n = new Float32Array(t * 2);
    for (let o = 0; o < t; o++) {
      let s10 = 0, i = 0;
      for (let a = 0; a < t; a++) {
        let u = C.exponent(o * a, t, r), l = C.getComplexWithIndex(e28, a);
        s10 += l.real * u.real - l.imag * u.imag, i += l.real * u.imag + l.imag * u.real;
      }
      r && (s10 /= t, i /= t), C.assignToTypedArray(n, s10, i, o);
    }
    return n;
  }
  function mX(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t, o = x.sizeFromShape(n.shape), s10 = n.shape[n.shape.length - 1], i = o / s10, a = Zt({ inputs: { x: n }, backend: r, attrs: { shape: [i, s10] } }), u = Jb(a, false, r), l = Zt({ inputs: { x: u }, backend: r, attrs: { shape: n.shape } });
    return r.disposeIntermediateTensorInfo(a), r.disposeIntermediateTensorInfo(u), l;
  }
  var PF = { kernelName: qc, backendName: "cpu", kernelFunc: mX };
  function eg(e28) {
    let { backend: t, attrs: r } = e28, { shape: n, value: o, dtype: s10 } = r, i = s10 || x.inferDtype(o), a = x.getArrayFromDType(i, x.sizeFromShape(n));
    return fX(a, o, i), t.makeTensorInfo(n, i, a);
  }
  var LF = { kernelName: Xc, backendName: "cpu", kernelFunc: eg };
  function fX(e28, t, r) {
    e28.fill(t);
  }
  var MF = { kernelName: Yc, backendName: "cpu", kernelFunc: ({ inputs: e28, attrs: t, backend: r }) => {
    let { image: n } = e28, o = r, s10 = x.getTypedArrayFromDType(n.dtype, x.sizeFromShape(n.shape)), [i, a, u, l] = n.shape, c = o.data.get(n.dataId).values;
    for (let m = 0; m < i; m++) {
      let f = m * u * a * l;
      for (let h = 0; h < a; h++) {
        let d = h * (u * l);
        for (let g = 0; g < u; g++) {
          let y = g * l;
          for (let b = 0; b < l; b++) {
            let v = Math.round(u - g - 1), w = f + d + y + b, N = c[w];
            if (v >= 0 && v < u) {
              let E = v * l, A = f + d + E + b;
              N = c[A];
            }
            s10[w] = N;
          }
        }
      }
    }
    return { dataId: o.write(s10, n.shape, n.dtype), shape: n.shape, dtype: n.dtype };
  } };
  function hX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10, bias: i, preluActivationWeights: a } = t, { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: m, activation: f, leakyreluAlpha: h } = n, d = UC({ inputs: { x: o, filter: s10 }, backend: r, attrs: { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: m } });
    if (i) {
      let g = d;
      if (c === "NCHW" && i.shape.length === 1 && i.shape[0] !== 1) {
        let y = Zt({ inputs: { x: i }, backend: r, attrs: { shape: [i.shape[0], 1, 1] } });
        d = $s({ inputs: { a: d, b: y }, backend: r }), r.disposeIntermediateTensorInfo(y);
      } else d = $s({ inputs: { a: d, b: i }, backend: r });
      r.disposeIntermediateTensorInfo(g);
    }
    if (f) {
      let g = d;
      if (c === "NCHW" && f === "prelu" && a.shape.length === 1 && a.shape[0] !== 1) {
        let y = Zt({ inputs: { x: a }, backend: r, attrs: { shape: [a.shape[0], 1, 1] } });
        d = Yl(r, d, f, y, h), r.disposeIntermediateTensorInfo(y);
      } else d = Yl(r, d, f, a, h);
      r.disposeIntermediateTensorInfo(g);
    }
    return d;
  }
  var zF = { kernelName: ml, backendName: "cpu", kernelFunc: hX };
  function dX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10, bias: i, preluActivationWeights: a } = t, { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: m, activation: f, leakyreluAlpha: h } = n, d = jC({ inputs: { x: o, filter: s10 }, backend: r, attrs: { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: m } });
    if (i) {
      let g = d;
      d = $s({ inputs: { a: d, b: i }, backend: r }), r.disposeIntermediateTensorInfo(g);
    }
    if (f) {
      let g = d;
      d = Yl(r, d, f, a, h), r.disposeIntermediateTensorInfo(g);
    }
    return d;
  }
  var BF = { kernelName: fl, backendName: "cpu", kernelFunc: dX };
  function gX(e28) {
    let { inputs: t, backend: r } = e28, { params: n, indices: o } = t, s10 = x.sizeFromShape(n.shape), i = o.shape, a = i[i.length - 1], [u, l, c, p] = C.prepareAndValidate(n, o);
    if (l === 0) return r.makeTensorInfo(u, n.dtype, []);
    let m = r.data.get(o.dataId).values, f = r.bufferSync(n), h = Fb(m, f, n.dtype, l, a, c, p, n.shape, s10);
    return r.makeTensorInfo(u, n.dtype, h.values);
  }
  var VF = { kernelName: my, backendName: "cpu", kernelFunc: gX };
  function yX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, indices: s10 } = t, { axis: i, batchDims: a } = n;
    J([o, s10], "gatherV2");
    let u = x.parseAxisParam(i, o.shape)[0], l = r.data.get(s10.dataId).values, c = o.shape[u];
    for (let w = 0; w < l.length; ++w) {
      let N = l[w];
      x.assert(N <= c - 1 && N >= 0, () => `GatherV2: the index value ${N} is not in [0, ${c - 1}]`);
    }
    let p = a;
    a == null && (p = 0);
    let m = x.sizeFromShape(s10.shape), f = C.segment_util.collectGatherOpShapeInfo(o, s10, u, p), h = Zt({ inputs: { x: o }, backend: r, attrs: { shape: [f.batchSize, f.outerSize, f.dimSize, f.sliceSize] } }), d = Zt({ inputs: { x: s10 }, backend: r, attrs: { shape: [f.batchSize, m / f.batchSize] } }), g = [f.batchSize, f.outerSize, m / f.batchSize, f.sliceSize], y = r.bufferSync(d), b = r.bufferSync(h), v = _b(b, y, g);
    return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), r.makeTensorInfo(f.outputShape, v.dtype, v.values);
  }
  var GF = { kernelName: Ua, backendName: "cpu", kernelFunc: yX };
  function xX(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t, o = x.sizeFromShape(n.shape), s10 = n.shape[n.shape.length - 1], i = o / s10, a = Zt({ inputs: { x: n }, backend: r, attrs: { shape: [i, s10] } }), u = Jb(a, true, r), l = Zt({ inputs: { x: u }, backend: r, attrs: { shape: n.shape } });
    return r.disposeIntermediateTensorInfo(a), r.disposeIntermediateTensorInfo(u), l;
  }
  var WF = { kernelName: Jc, backendName: "cpu", kernelFunc: xX };
  var bX = Lt(di, (e28) => Number.isFinite(e28) ? 1 : 0, "bool");
  var UF = { kernelName: di, backendName: "cpu", kernelFunc: bX };
  var wX = Lt(gi, (e28) => Math.abs(e28) === 1 / 0 ? 1 : 0, "bool");
  var jF = { kernelName: gi, backendName: "cpu", kernelFunc: wX };
  var vX = Lt(yi, (e28) => Number.isNaN(e28) ? 1 : 0, "bool");
  var HF = { kernelName: yi, backendName: "cpu", kernelFunc: vX };
  function NX(e28) {
    let { backend: t, attrs: r } = e28, { start: n, stop: o, num: s10 } = r, i = Ob(n, o, s10);
    return t.makeTensorInfo([i.length], "float32", i);
  }
  var KF = { kernelName: fy, backendName: "cpu", kernelFunc: NX };
  var CX = Lt(bi, (e28) => Math.log1p(e28));
  var qF = { kernelName: bi, backendName: "cpu", kernelFunc: CX };
  var SX = Jt((e28, t) => e28 && t);
  var IX = oe(al, SX, null, "bool");
  var XF = { kernelName: al, backendName: "cpu", kernelFunc: IX };
  var TX = Lt(ul, (e28) => e28 ? 0 : 1, "bool");
  var YF = { kernelName: ul, backendName: "cpu", kernelFunc: TX };
  var kX = Jt((e28, t) => e28 || t);
  var EX = oe(ll, kX, null, "bool");
  var JF = { kernelName: ll, backendName: "cpu", kernelFunc: EX };
  function AX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { depthRadius: s10, bias: i, alpha: a, beta: u } = n;
    J(o, "LRN");
    let l = o.shape[3], c = l - 1, p = r.data.get(o.dataId).values, m = x.sizeFromShape(o.shape), f = new Float32Array(m);
    function h(d) {
      let g = d % l, y = d - g + Math.max(0, g - s10), b = d - g + Math.min(g + s10, c), v = 0;
      for (; y <= b; y++) {
        let w = p[y];
        v += w * w;
      }
      return v;
    }
    for (let d = 0; d < m; d++) {
      let g = h(d), y = p[d] * Math.pow(i + a * g, -u);
      f[d] = y;
    }
    return r.makeTensorInfo(o.shape, o.dtype, f);
  }
  var ZF = { kernelName: Ha, backendName: "cpu", kernelFunc: AX };
  function DX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, y: s10, dy: i } = t, { depthRadius: a, bias: u, alpha: l, beta: c } = n;
    J(i, "LRNGrad");
    let p = x.sizeFromShape(i.shape), m = i.shape[3], f = r.data.get(i.dataId).values, h = r.data.get(o.dataId).values, d = r.data.get(s10.dataId).values, g = new Float32Array(p), y = p;
    for (let b = 0; b < y; b++) {
      let v = b % m, w = b - v + Math.max(0, v - a), N = b - v + Math.min(m, v + a + 1), E = 0;
      for (let A = w; A < N; A++) E += Math.pow(h[A], 2);
      E = l * E + u;
      for (let A = w; A < N; A++) {
        let D = -2 * l * c * h[A] * d[b] / E;
        b === A && (D += Math.pow(E, -c)), D *= f[b], g[A] += D;
      }
    }
    return r.makeTensorInfo(i.shape, o.dtype, g);
  }
  var QF = { kernelName: Qc, backendName: "cpu", kernelFunc: DX };
  function KC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { reductionIndices: s10, keepDims: i } = n, a = r, u = o.shape, l = u.length, c = x.parseAxisParam(s10, u), p = c, m = C.getAxesPermutation(p, l), f = a.data.get(o.dataId).values;
    if (m != null) {
      let w = new Array(l);
      for (let N = 0; N < w.length; N++) w[N] = u[m[N]];
      f = Sm(f, u, o.dtype, m, w), p = C.getInnerMostAxes(p.length, l), u = w;
    }
    J(o, "max"), C.assertAxesAreInnerMostDims("max", p, l);
    let [h, d] = C.computeOutAndReduceShapes(u, p), g = x.sizeFromShape(d), y = Rb(f, g, h, o.dtype), b = a.write(y, h, o.dtype), v = h;
    return i && (v = C.expandShapeToKeepDim(h, c)), { dataId: b, shape: v, dtype: o.dtype };
  }
  var t_ = { kernelName: Ka, backendName: "cpu", kernelFunc: KC };
  function $X(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t;
    J(o, "maxPool");
    let { filterSize: s10, strides: i, pad: a, dimRoundingMode: u } = n, l = 1;
    x.assert(C.eitherStridesOrDilationsAreOne(i, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);
    let c = C.computePool2DInfo(o.shape, s10, i, l, a, u), p;
    if (c.filterWidth === 1 && c.filterHeight === 1 && x.arraysEqual(c.inShape, c.outShape)) p = Hr({ inputs: { x: o }, backend: r });
    else {
      let m = r.data.get(o.dataId).values, f = x.computeStrides(o.shape), h = Tm(m, o.shape, o.dtype, f, c, "max");
      p = r.makeTensorInfo(c.outShape, o.dtype, h.values);
    }
    return p;
  }
  var e_ = { kernelName: qa, backendName: "cpu", kernelFunc: $X };
  function FX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { filterSize: s10, strides: i, pad: a, dimRoundingMode: u, dataFormat: l } = n;
    J(o, "maxPool3d");
    let c = C.computePool3DInfo(o.shape, s10, i, 1, a, u, l), p = r.data.get(o.dataId).values, m = Yb(p, o.shape, o.dtype, x.computeStrides(o.shape), c, "max");
    return r.makeTensorInfo(m.shape, "float32", m.values);
  }
  var r_ = { kernelName: Xa, backendName: "cpu", kernelFunc: FX };
  function _X(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10 } = t, { filterSize: i, strides: a, pad: u, dimRoundingMode: l } = n;
    J([o, s10], "maxPool3DGrad");
    let c = C.computePool3DInfo(s10.shape, i, a, 1, u, l), p = r.bufferSync(s10), m = J$(p, c), f = c.strideDepth, h = c.strideHeight, d = c.strideWidth, g = c.dilationDepth, y = c.dilationHeight, b = c.dilationWidth, v = c.effectiveFilterDepth, w = c.effectiveFilterHeight, N = c.effectiveFilterWidth, E = v - 1 - c.padInfo.front, A = N - 1 - c.padInfo.left, D = w - 1 - c.padInfo.top, R = kt(s10.shape, "float32"), L = r.bufferSync(o);
    for (let G = 0; G < c.batchSize; ++G) for (let W = 0; W < c.inChannels; ++W) for (let U = 0; U < c.inDepth; ++U) for (let H = 0; H < c.inHeight; ++H) for (let j = 0; j < c.inWidth; ++j) {
      let X = U - E, Q = H - D, q = j - A, et = 0;
      for (let ot = 0; ot < v; ot += g) {
        let st = (X + ot) / f;
        if (!(st < 0 || st >= c.outDepth || Math.floor(st) !== st)) for (let ct = 0; ct < w; ct += y) {
          let lt = (Q + ct) / h;
          if (!(lt < 0 || lt >= c.outHeight || Math.floor(lt) !== lt)) for (let wt = 0; wt < N; wt += b) {
            let mt = (q + wt) / d;
            if (mt < 0 || mt >= c.outWidth || Math.floor(mt) !== mt) continue;
            let Ct = v * w * N - 1 - m.get(G, st, lt, mt, W), zt = ot * w * N + ct * N + wt, Ut = Ct === zt ? 1 : 0;
            if (Ut === 0) continue;
            let Vt = L.get(G, st, lt, mt, W);
            et += Vt * Ut;
          }
        }
      }
      R.set(et, G, U, H, j, W);
    }
    return r.makeTensorInfo(R.shape, R.dtype, R.values);
  }
  var n_ = { kernelName: ep, backendName: "cpu", kernelFunc: _X };
  function OX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10, output: i } = t, a = s10;
    J([s10, i], "maxPoolGrad");
    let { filterSize: u, strides: l, pad: c, dimRoundingMode: p } = n, m = C.computePool2DInfo(a.shape, u, l, 1, c, p), f = r.data.get(a.dataId).values, h = kt(m.outShape, a.dtype, Xb(f, a.shape, a.dtype, m).values), d = m.strideHeight, g = m.strideWidth, y = m.dilationHeight, b = m.dilationWidth, v = m.effectiveFilterHeight, w = m.effectiveFilterWidth, N = w - 1 - m.padInfo.left, E = v - 1 - m.padInfo.top, A = kt(a.shape, "float32"), D = r.data.get(o.dataId).values, R = kt(o.shape, "float32", D);
    for (let L = 0; L < m.batchSize; ++L) for (let G = 0; G < m.inChannels; ++G) for (let W = 0; W < m.inHeight; ++W) for (let U = 0; U < m.inWidth; ++U) {
      let H = W - E, j = U - N, X = 0;
      for (let Q = 0; Q < v; Q += y) {
        let q = (H + Q) / d;
        if (!(q < 0 || q >= m.outHeight || Math.floor(q) !== q)) for (let et = 0; et < w; et += b) {
          let ot = (j + et) / g;
          if (ot < 0 || ot >= m.outWidth || Math.floor(ot) !== ot) continue;
          let st = v * w - 1 - h.get(L, q, ot, G), ct = Q * w + et, lt = st === ct ? 1 : 0;
          if (lt === 0) continue;
          let wt = R.get(L, q, ot, G);
          X += wt * lt;
        }
      }
      A.set(X, L, W, U, G);
    }
    return r.makeTensorInfo(A.shape, A.dtype, A.values);
  }
  var o_ = { kernelName: tp, backendName: "cpu", kernelFunc: OX };
  function s_(e28, t, r, n, o) {
    let s10 = x.computeStrides(t), i = Tm(e28, t, r, s10, o, "max"), a = Xb(e28, t, r, o, true, n);
    return [i.values, a.values];
  }
  var i_ = { kernelName: hy, backendName: "cpu", kernelFunc: ({ inputs: e28, attrs: t, backend: r }) => {
    let { x: n } = e28, { filterSize: o, strides: s10, pad: i, includeBatchInIndex: a } = t, u = r;
    J(n, "MaxPoolWithArgmax");
    let l = u.data.get(n.dataId).values, c = C.computePool2DInfo(n.shape, o, s10, [1, 1], i), [p, m] = s_(l, n.shape, n.dtype, a, c), f = u.write(p, c.outShape, n.dtype), h = u.write(m, c.outShape, n.dtype);
    return [{ dataId: f, shape: c.outShape, dtype: n.dtype }, { dataId: h, shape: c.outShape, dtype: "int32" }];
  } };
  function RX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n, a = x.parseAxisParam(s10, o.shape), l = C.computeOutAndReduceShapes(o.shape, a)[1], c = x.sizeFromShape(l), p = [], m = r.makeTensorInfo([], "float32", new Float32Array([c]));
    p.push(m);
    let f = Do({ inputs: { x: o }, backend: r, attrs: { dtype: "float32" } });
    p.push(f);
    let h = Qd({ inputs: { a: f, b: m }, backend: r });
    p.push(h);
    let d = ia({ inputs: { x: h }, backend: r, attrs: { axis: s10, keepDims: i } });
    return p.forEach((g) => r.disposeIntermediateTensorInfo(g)), d;
  }
  var a_ = { kernelName: Ya, backendName: "cpu", kernelFunc: RX };
  function PX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n;
    J(o, "min");
    let a = x.parseAxisParam(s10, o.shape), u = a, l = C.getAxesPermutation(u, o.shape.length), c = o;
    l != null && (c = Pe({ inputs: { x: o }, backend: r, attrs: { perm: l } }), u = C.getInnerMostAxes(u.length, o.shape.length)), C.assertAxesAreInnerMostDims("min", u, c.shape.length);
    let [p, m] = C.computeOutAndReduceShapes(c.shape, u), f = x.sizeFromShape(m), h = x.makeZerosTypedArray(x.sizeFromShape(p), c.dtype), d = r.data.get(c.dataId).values;
    for (let y = 0; y < h.length; ++y) {
      let b = y * f, v = d[b];
      for (let w = 0; w < f; ++w) {
        let N = d[b + w];
        (Number.isNaN(N) || N < v) && (v = N);
      }
      h[y] = v;
    }
    l != null && r.disposeIntermediateTensorInfo(c);
    let g = r.makeTensorInfo(p, c.dtype, h);
    if (i) {
      let y = C.expandShapeToKeepDim(p, a), b = Zt({ inputs: { x: g }, backend: r, attrs: { shape: y } });
      return r.disposeIntermediateTensorInfo(g), b;
    }
    return g;
  }
  var u_ = { kernelName: Ja, backendName: "cpu", kernelFunc: PX };
  function LX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { paddings: s10, mode: i } = n;
    J(o, "mirrorPad");
    let a = s10.map((v, w) => v[0] + o.shape[w] + v[1]), u = s10.map((v) => v[0]), l = s10.map((v, w) => v[0] + o.shape[w]), c = i === "reflect" ? 0 : 1, p = r.data.get(o.dataId).values, m = o.shape.length, f = x.computeStrides(o.shape), h = x.sizeFromShape(a), d = a.length, g = x.computeStrides(a), y = x.getTypedArrayFromDType(o.dtype, h);
    for (let v = 0; v < h; v++) {
      let w = x.indexToLoc(v, d, g);
      for (let E = 0; E < d; E++) w[E] < u[E] ? w[E] = u[E] * 2 - w[E] - c : w[E] >= l[E] && (w[E] = (l[E] - 1) * 2 - w[E] + c);
      w = w.map((E, A) => E - u[A]);
      let N = x.locToIndex(w, m, f);
      y[v] = p[N];
    }
    return { dataId: r.write(y, a, o.dtype), shape: a, dtype: o.dtype };
  }
  var l_ = { kernelName: Za, backendName: "cpu", kernelFunc: LX };
  var MX = Jt((e28, t) => {
    let r = e28 % t;
    return e28 < 0 && t < 0 || e28 >= 0 && t >= 0 ? r : (r + t) % t;
  });
  var zX = oe(Ni, MX);
  var c_ = { kernelName: Ni, backendName: "cpu", kernelFunc: zX };
  var m_ = ff(Zf());
  function qC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { logits: o } = t, { dim: s10 } = n, i = o.shape.length, a = s10;
    if (a === -1 && (a = i - 1), a !== i - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);
    let u = x.parseAxisParam([a], o.shape), l = KC({ inputs: { x: o }, backend: r, attrs: { reductionIndices: u, keepDims: false } }), c = C.expandShapeToKeepDim(l.shape, u), p = Zt({ inputs: { x: l }, backend: r, attrs: { shape: c } }), m = Jd({ inputs: { a: o, b: p }, backend: r }), f = dC({ inputs: { x: m }, backend: r }), h = ia({ inputs: { x: f }, backend: r, attrs: { axis: u, keepDims: false } }), d = Zt({ inputs: { x: h }, backend: r, attrs: { shape: c } }), g = Qd({ inputs: { a: f, b: d }, backend: r });
    return r.disposeIntermediateTensorInfo(l), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), g;
  }
  var p_ = { kernelName: du, backendName: "cpu", kernelFunc: qC };
  function BX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { logits: o } = t, { numSamples: s10, seed: i, normalized: a } = n;
    J(o, "multinomial");
    let u = a ? o : qC({ inputs: { logits: o }, backend: r, attrs: { dim: -1 } }), l = u.shape[0], c = u.shape[1], p = r.data.get(u.dataId).values, m = [l, s10], f = x.makeZerosTypedArray(x.sizeFromShape(m), "int32");
    for (let h = 0; h < l; ++h) {
      let d = h * c, g = new Float32Array(c - 1);
      g[0] = p[d];
      for (let v = 1; v < g.length; ++v) g[v] = g[v - 1] + p[d + v];
      let y = m_.alea(i.toString()), b = h * s10;
      for (let v = 0; v < s10; ++v) {
        let w = y();
        f[b + v] = g.length;
        for (let N = 0; N < g.length; N++) if (w < g[N]) {
          f[b + v] = N;
          break;
        }
      }
    }
    return a || r.disposeIntermediateTensorInfo(u), r.makeTensorInfo(m, "int32", f);
  }
  var f_ = { kernelName: dy, backendName: "cpu", kernelFunc: BX };
  var VX = jr.nonMaxSuppressionV3Impl;
  function GX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { boxes: o, scores: s10 } = t, { maxOutputSize: i, iouThreshold: a, scoreThreshold: u } = n;
    J(o, "NonMaxSuppression");
    let l = r.data.get(o.dataId).values, c = r.data.get(s10.dataId).values, { selectedIndices: p } = VX(l, c, i, a, u);
    return r.makeTensorInfo([p.length], "int32", new Int32Array(p));
  }
  var h_ = { kernelName: rp, backendName: "cpu", kernelFunc: GX };
  var WX = jr.nonMaxSuppressionV4Impl;
  function UX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { boxes: o, scores: s10 } = t, { maxOutputSize: i, iouThreshold: a, scoreThreshold: u, padToMaxOutputSize: l } = n;
    J(o, "NonMaxSuppressionPadded");
    let c = r.data.get(o.dataId).values, p = r.data.get(s10.dataId).values, { selectedIndices: m, validOutputs: f } = WX(c, p, i, a, u, l);
    return [r.makeTensorInfo([m.length], "int32", new Int32Array(m)), r.makeTensorInfo([], "int32", new Int32Array([f]))];
  }
  var d_ = { kernelName: np, backendName: "cpu", kernelFunc: UX };
  var jX = jr.nonMaxSuppressionV5Impl;
  function HX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { boxes: o, scores: s10 } = t, { maxOutputSize: i, iouThreshold: a, scoreThreshold: u, softNmsSigma: l } = n;
    J(o, "NonMaxSuppressionWithScore");
    let c = r.data.get(o.dataId).values, p = r.data.get(s10.dataId).values, m = i, f = a, h = u, d = l, { selectedIndices: g, selectedScores: y } = jX(c, p, m, f, h, d);
    return [r.makeTensorInfo([g.length], "int32", new Int32Array(g)), r.makeTensorInfo([y.length], "float32", new Float32Array(y))];
  }
  var g_ = { kernelName: op, backendName: "cpu", kernelFunc: HX };
  function KX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { indices: o } = t, { dtype: s10, depth: i, onValue: a, offValue: u } = n;
    J(o, "oneHot");
    let l = x.sizeFromShape(o.shape), c = new Float32Array(l * i);
    c.fill(u);
    let p = r.data.get(o.dataId).values;
    for (let m = 0; m < l; ++m) p[m] >= 0 && p[m] < i && (c[m * i + p[m]] = a);
    return r.makeTensorInfo([...o.shape, i], s10, c);
  }
  var y_ = { kernelName: eu, backendName: "cpu", kernelFunc: KX };
  function rg(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    if (n.dtype === "string") throw new Error("zerosLike is not supported for string tensors");
    if (n.dtype === "complex64") {
      let o = Ao({ inputs: { input: n }, backend: r }), s10 = rg({ inputs: { x: o }, backend: r }), i = Fs({ inputs: { input: n }, backend: r }), a = rg({ inputs: { x: i }, backend: r }), u = br({ inputs: { real: s10, imag: a }, backend: r });
      return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s10), r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(a), u;
    } else return eg({ backend: r, attrs: { shape: n.shape, value: 0, dtype: n.dtype } });
  }
  var x_ = { kernelName: xu, backendName: "cpu", kernelFunc: rg };
  function b_(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    if (n.dtype === "string") throw new Error("onesLike is not supported for string tensors");
    if (n.dtype === "complex64") {
      let o = Ao({ inputs: { input: n }, backend: r }), s10 = b_({ inputs: { x: o }, backend: r }), i = Fs({ inputs: { input: n }, backend: r }), a = rg({ inputs: { x: i }, backend: r }), u = br({ inputs: { real: s10, imag: a }, backend: r });
      return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s10), r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(a), u;
    } else return eg({ backend: r, attrs: { shape: n.shape, value: 1, dtype: n.dtype } });
  }
  var w_ = { kernelName: tu, backendName: "cpu", kernelFunc: b_ };
  function XC(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { axis: o } = n;
    if (t.length === 1) return km({ inputs: { input: t[0] }, backend: r, attrs: { dim: o } });
    let s10 = t[0].shape, i = t[0].dtype;
    t.forEach((c) => {
      x.assertShapesMatch(s10, c.shape, "All tensors passed to stack must have matching shapes"), x.assert(i === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let a = [], u = t.map((c) => {
      let p = km({ inputs: { input: c }, backend: r, attrs: { dim: o } });
      return a.push(p), p;
    }), l = Pu({ inputs: u, backend: r, attrs: { axis: o } });
    return a.forEach((c) => r.disposeIntermediateTensorInfo(c)), l;
  }
  var v_ = { kernelName: ru, backendName: "cpu", kernelFunc: XC };
  function qX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { paddings: s10, constantValue: i } = n;
    J(o, "pad");
    let a = s10.map((b, v) => b[0] + o.shape[v] + b[1]), u = s10.map((b) => b[0]), l = r.data.get(o.dataId).values, c = x.sizeFromShape(o.shape), p = o.shape.length, m = x.computeStrides(o.shape), f = x.sizeFromShape(a), h = a.length, d = x.computeStrides(a), g = x.getTypedArrayFromDType(o.dtype, f);
    i !== 0 && g.fill(i);
    for (let b = 0; b < c; b++) {
      let w = x.indexToLoc(b, p, m).map((E, A) => E + u[A]), N = x.locToIndex(w, h, d);
      g[N] = l[b];
    }
    return { dataId: r.write(g, a, o.dtype), shape: a, dtype: o.dtype };
  }
  var Zb = { kernelName: nu, backendName: "cpu", kernelFunc: qX };
  var XX = Jt((e28, t) => Math.pow(e28, t));
  var YX = oe(Si, XX);
  var N_ = { kernelName: Si, backendName: "cpu", kernelFunc: YX };
  function JX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { paramsNestedSplits: o, paramsDenseValues: s10, indices: i } = t, { outputRaggedRank: a } = n, u = o.map((y) => r.data.get(y.dataId).values), l = o.map((y) => y.shape), c = r.data.get(s10.dataId).values, p = r.data.get(i.dataId).values, [m, f, h] = Pb(u, l, c, s10.shape, s10.dtype, p, i.shape, a), d = m.map((y) => r.makeTensorInfo([y.length], "int32", y)), g = r.makeTensorInfo(h, s10.dtype, f);
    return d.concat([g]);
  }
  var C_ = { kernelName: gy, backendName: "cpu", kernelFunc: JX };
  function ZX(e28) {
    let { inputs: t, backend: r } = e28, { starts: n, limits: o, deltas: s10 } = t, i = r.data.get(n.dataId).values, a = r.data.get(o.dataId).values, u = r.data.get(s10.dataId).values, [l, c] = Lb(i, n.shape, n.dtype, a, o.shape, u, s10.shape), p = r.makeTensorInfo([l.length], "int32", l), m = r.makeTensorInfo([c.length], n.dtype, c);
    return [p, m];
  }
  var S_ = { kernelName: yy, backendName: "cpu", kernelFunc: ZX };
  function QX(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { shape: o, values: s10, defaultValue: i, rowPartitionTensors: a } = t, { rowPartitionTypes: u } = n, l = r.data.get(o.dataId).values, c = r.data.get(s10.dataId).values, p = r.data.get(i.dataId).values, m = a.map((g) => r.data.get(g.dataId).values), f = a.map((g) => g.shape), [h, d] = Mb(l, o.shape, c, s10.shape, s10.dtype, p, i.shape, m, f, u);
    return r.makeTensorInfo(h, s10.dtype, d);
  }
  var I_ = { kernelName: xy, backendName: "cpu", kernelFunc: QX };
  function t7(e28) {
    let { backend: t, attrs: r } = e28, { start: n, stop: o, dtype: s10, step: i } = r, a = zb(n, o, i, s10);
    return t.makeTensorInfo([a.length], s10, a);
  }
  var T_ = { kernelName: sp, backendName: "cpu", kernelFunc: t7 };
  var e72 = Lt(Ii, (e28) => 1 / e28);
  var k_ = { kernelName: Ii, backendName: "cpu", kernelFunc: e72 };
  function r7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o } = t, { alignCorners: s10, halfPixelCenters: i, size: a } = n;
    J(o, "resizeBilinear");
    let u = x.computeStrides(o.shape), [l, c] = a, [p, m, f, h] = o.shape, d = r.data.get(o.dataId).values, g = new Float32Array(x.sizeFromShape([p, l, c, h])), y = [s10 && l > 1 ? m - 1 : m, s10 && c > 1 ? f - 1 : f], b = [s10 && l > 1 ? l - 1 : l, s10 && c > 1 ? c - 1 : c], v = 0, w = y[0] / b[0], N = y[1] / b[1];
    for (let E = 0; E < p; E++) for (let A = 0; A < l; A++) {
      let D;
      i ? D = w * (A + 0.5) - 0.5 : D = w * A;
      let R = Math.max(0, Math.floor(D)), L = D - R, G = Math.min(m - 1, Math.ceil(D)), W = E * u[0] + R * u[1], U = E * u[0] + G * u[1];
      for (let H = 0; H < c; H++) {
        let j;
        i ? j = N * (H + 0.5) - 0.5 : j = N * H;
        let X = Math.max(0, Math.floor(j)), Q = j - X, q = Math.min(f - 1, Math.ceil(j)), et = W + X * u[2], ot = U + X * u[2], st = W + q * u[2], ct = U + q * u[2];
        for (let lt = 0; lt < h; lt++) {
          let wt = d[et + lt], mt = d[ot + lt], Ct = d[st + lt], zt = d[ct + lt], Ut = wt + (Ct - wt) * Q, Vt = mt + (zt - mt) * Q, te = Ut + (Vt - Ut) * L;
          g[v++] = te;
        }
      }
    }
    return r.makeTensorInfo([p, l, c, h], "float32", g);
  }
  var E_ = { kernelName: uu, backendName: "cpu", kernelFunc: r7 };
  function n7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o, dy: s10 } = t, { alignCorners: i } = n;
    J([s10, o], "resizeBilinearGrad");
    let a = x.computeStrides(o.shape), [u, l, c, p] = o.shape, [, m, f] = s10.shape, h = new Float32Array(u * l * c * p), d = [i && m > 1 ? l - 1 : l, i && f > 1 ? c - 1 : c], g = [i && m > 1 ? m - 1 : m, i && f > 1 ? f - 1 : f], y = d[0] / g[0], b = d[1] / g[1], v = r.data.get(s10.dataId).values, w = 0;
    for (let N = 0; N < u; N++) {
      let E = N * a[0];
      for (let A = 0; A < m; A++) {
        let D = A * y, R = Math.floor(D), L = Math.min(Math.ceil(D), l - 1), G = E + R * a[1], W = E + L * a[1], U = D - R, H = 1 - U;
        for (let j = 0; j < f; j++) {
          let X = j * b, Q = Math.floor(X), q = Math.min(Math.ceil(X), c - 1), et = X - Q, ot = 1 - et, st = G + Q * a[2], ct = G + q * a[2], lt = W + Q * a[2], wt = W + q * a[2], mt = H * ot, Ct = H * et, zt = U * ot, Ut = U * et;
          for (let Vt = 0; Vt < p; Vt++) {
            let te = v[w++];
            h[st + Vt] += te * mt, h[ct + Vt] += te * Ct, h[lt + Vt] += te * zt, h[wt + Vt] += te * Ut;
          }
        }
      }
    }
    return r.makeTensorInfo([u, c, l, p], "float32", h);
  }
  var A_ = { kernelName: up, backendName: "cpu", kernelFunc: n7 };
  function o7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o } = t, { alignCorners: s10, halfPixelCenters: i, size: a } = n;
    J(o, "resizeNearestNeighbor");
    let u = x.computeStrides(o.shape), [l, c] = a, [p, m, f, h] = o.shape, d = r.data.get(o.dataId).values, g = new Float32Array(p * l * c * h), y = [s10 && l > 1 ? m - 1 : m, s10 && c > 1 ? f - 1 : f], b = [s10 && l > 1 ? l - 1 : l, s10 && c > 1 ? c - 1 : c], v = y[0] / b[0], w = y[1] / b[1], N = 0;
    for (let E = 0; E < p; E++) {
      let A = E * u[0];
      for (let D = 0; D < l; D++) {
        let R = i ? v * (D + 0.5) : v * D, L = Math.min(m - 1, s10 ? Math.round(R) : Math.floor(R));
        i && (L = Math.max(0, L));
        let G = A + L * u[1];
        for (let W = 0; W < c; W++) {
          let U = i ? w * (W + 0.5) : w * W, H = Math.min(f - 1, s10 ? Math.round(U) : Math.floor(U));
          i && (H = Math.max(0, H));
          let j = G + H * u[2];
          for (let X = 0; X < h; X++) {
            let Q = d[j + X];
            g[N++] = Q;
          }
        }
      }
    }
    return r.makeTensorInfo([p, l, c, h], o.dtype, g);
  }
  var D_ = { kernelName: au, backendName: "cpu", kernelFunc: o7 };
  function s7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o, dy: s10 } = t, { alignCorners: i } = n;
    J([s10, o], "resizeNearestNeighborGrad");
    let a = x.computeStrides(o.shape), u = x.computeStrides(s10.shape), [l, c, p, m] = o.shape, [, f, h] = s10.shape, d = new Float32Array(l * c * p * m), g = r.data.get(s10.dataId).values, y = [i && f > 1 ? c - 1 : c, i && h > 1 ? p - 1 : p], b = [i && f > 1 ? f - 1 : f, i && h > 1 ? h - 1 : h], v = y[0] / b[0], w = y[1] / b[1], N = 1 / v, E = 1 / w, A = Math.ceil(N) * 2 + 2, D = Math.ceil(E) * 2 + 2;
    for (let R = 0; R < l; R++) {
      let L = R * a[0];
      for (let G = 0; G < c; G++) {
        let W = L + G * a[1], U = Math.floor(G * N), H = Math.floor(U - A / 2);
        for (let j = 0; j < p; j++) {
          let X = W + j * a[2], Q = Math.floor(j * E), q = Math.floor(Q - D / 2);
          for (let et = 0; et < m; et++) {
            let ot = 0;
            for (let st = 0; st < A; st++) {
              let ct = st + H;
              if (ct < 0 || ct >= f) continue;
              let lt = L + ct * u[1], wt = ct * v, mt = Math.min(c - 1, i ? Math.round(wt) : Math.floor(wt));
              if (G === mt) for (let Ct = 0; Ct < D; Ct++) {
                let zt = Ct + q;
                if (zt < 0 || zt >= h) continue;
                let Ut = lt + zt * u[2], Vt = zt * w, te = Math.min(p - 1, i ? Math.round(Vt) : Math.floor(Vt));
                j === te && (ot += g[Ut + et]);
              }
            }
            d[X + et] = ot;
          }
        }
      }
    }
    return r.makeTensorInfo(o.shape, o.dtype, d);
  }
  var $_ = { kernelName: ap, backendName: "cpu", kernelFunc: s7 };
  function i7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { dims: s10 } = n;
    J(o, "reverse");
    let i = o.shape.length, a = x.parseAxisParam(s10, o.shape);
    if (i === 0) return Hr({ inputs: { x: o }, backend: r });
    let u = new pe(o.shape, o.dtype), l = r.bufferSync(o);
    for (let c = 0; c < u.size; c++) {
      let p = u.indexToLoc(c), m = p.slice();
      a.forEach((f) => m[f] = o.shape[f] - 1 - m[f]), u.set(l.get(...m), ...p);
    }
    return r.makeTensorInfo(u.shape, u.dtype, u.values);
  }
  var F_ = { kernelName: lu, backendName: "cpu", kernelFunc: i7 };
  var __ = { kernelName: hp, backendName: "cpu", kernelFunc: ({ inputs: e28, attrs: t, backend: r }) => {
    let { image: n } = e28, { radians: o, fillValue: s10, center: i } = t, a = r, u = x.getTypedArrayFromDType(n.dtype, x.sizeFromShape(n.shape)), [l, c, p, m] = n.shape, [f, h] = C.getImageCenter(i, c, p), d = 255, g = Math.sin(o), y = Math.cos(o), b = a.data.get(n.dataId).values;
    for (let w = 0; w < l; w++) {
      let N = w * p * c * m;
      for (let E = 0; E < c; E++) {
        let A = E * (p * m);
        for (let D = 0; D < p; D++) {
          let R = D * m;
          for (let L = 0; L < m; L++) {
            let G = [l, E, D, L], W = G[2], U = G[1], H = (W - f) * y - (U - h) * g, j = (W - f) * g + (U - h) * y;
            H = Math.round(H + f), j = Math.round(j + h);
            let X = s10;
            if (typeof s10 != "number" && (L === 3 ? X = d : X = s10[L]), H >= 0 && H < p && j >= 0 && j < c) {
              let q = j * (p * m), et = H * m, ot = N + q + et + L;
              X = b[ot];
            }
            let Q = N + A + R + L;
            u[Q] = X;
          }
        }
      }
    }
    return { dataId: a.write(u, n.shape, n.dtype), shape: n.shape, dtype: n.dtype };
  } };
  var a7 = Lt(Ei, (e28) => {
    let t = Math.floor(e28);
    return e28 - t < 0.5 ? Math.floor(e28) : e28 - t > 0.5 ? Math.ceil(e28) : t % 2 === 0 ? t : t + 1;
  });
  var O_ = { kernelName: Ei, backendName: "cpu", kernelFunc: a7 };
  function u7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { indices: o, updates: s10 } = t, { shape: i } = n, { sliceRank: a, numUpdates: u, sliceSize: l, strides: c, outputSize: p } = C.calculateShapes(s10, o, i), m = true, f = r.bufferSync(o), h = r.bufferSync(s10), d = Qo(f, h, i, p, l, u, a, c, 0, m);
    return r.makeTensorInfo(i, d.dtype, d.values);
  }
  var R_ = { kernelName: by, backendName: "cpu", kernelFunc: u7 };
  function l7(e28, t) {
    let r = 0, n = e28.length, o = 0;
    for (; r < n; ) o = Math.floor((r + n) / 2), e28[o] < t ? r = o + 1 : n = o;
    return n;
  }
  function c7(e28, t) {
    let r = 0, n = e28.length, o = 0;
    for (; r < n; ) o = Math.floor((r + n) / 2), e28[o] <= t ? r = o + 1 : n = o;
    return n;
  }
  function P_(e28, t, r, n, o, s10) {
    let i = x.getArrayFromDType("int32", r * o);
    for (let a = 0; a < r; ++a) {
      let u = e28.slice(a * n, (a + 1) * n), l = a * o;
      for (let c = 0; c < o; ++c) i[l + c] = s10 === "left" ? l7(u, t[c + l]) : c7(u, t[c + l]);
    }
    return i;
  }
  function p7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { sortedSequence: o, values: s10 } = t, { side: i } = n, a = r.data.get(o.dataId).values, u = r.data.get(s10.dataId).values, l = P_(a, u, o.shape[0], o.shape[1], s10.shape[1], i);
    return r.makeTensorInfo(s10.shape, "int32", l);
  }
  var L_ = { kernelName: vy, backendName: "cpu", kernelFunc: p7 };
  function m7(e28) {
    let { inputs: t, backend: r } = e28, { condition: n, t: o, e: s10 } = t;
    J([n, o, s10], "select");
    let i = n.shape.length, a = r.data.get(n.dataId).values, u = r.data.get(o.dataId).values, l = r.data.get(s10.dataId).values, c = lr(o.dtype, s10.dtype), p = x.makeZerosTypedArray(x.sizeFromShape(o.shape), c), m = 0, f = i === 0 || i > 1 || o.shape.length === 1 ? 1 : x.sizeFromShape(o.shape.slice(1));
    for (let h = 0; h < a.length; h++) for (let d = 0; d < f; d++) a[h] === 1 ? p[m++] = u[h] : p[m++] = l[h];
    return r.makeTensorInfo(o.shape, c, p);
  }
  var M_ = { kernelName: cu, backendName: "cpu", kernelFunc: m7 };
  var f7 = C.SELU_SCALEALPHA;
  var h7 = C.SELU_SCALE;
  var d7 = Lt(Di, (e28) => e28 >= 0 ? h7 * e28 : f7 * (Math.exp(e28) - 1));
  var z_ = { kernelName: Di, backendName: "cpu", kernelFunc: d7 };
  var g7 = Lt(_i, (e28) => e28 < 0 ? -1 : e28 > 0 ? 1 : 0);
  var B_ = { kernelName: _i, backendName: "cpu", kernelFunc: g7 };
  var y7 = Lt($i, (e28) => Math.sin(e28));
  var V_ = { kernelName: $i, backendName: "cpu", kernelFunc: y7 };
  var x7 = Lt(Fi, (e28) => Math.sinh(e28));
  var G_ = { kernelName: Fi, backendName: "cpu", kernelFunc: x7 };
  var b7 = 11920928955078125e-23;
  var W_ = Math.log(b7) + 2;
  var w7 = Lt(Ri, (e28) => {
    let t = e28 > -W_, r = e28 < W_, n = Math.exp(e28), o;
    return r ? o = n : t ? o = e28 : o = Math.log(1 + n), o;
  });
  var U_ = { kernelName: Ri, backendName: "cpu", kernelFunc: w7 };
  function v7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { blockShape: s10, paddings: i } = n;
    J([o], "spaceToBatchND");
    let a = x.sizeFromShape(s10), u = [[0, 0]];
    u.push(...i);
    for (let E = 1 + s10.length; E < o.shape.length; ++E) u.push([0, 0]);
    let l = Zb.kernelFunc({ inputs: { x: o }, backend: r, attrs: { paddings: u, constantValue: 0 } }), c = C.getReshaped(l.shape, s10, a, false), p = C.getPermuted(c.length, s10.length, false), m = C.getReshapedPermuted(l.shape, s10, a, false), d = Zt({ inputs: { x: l }, backend: r, attrs: { shape: c } }), b = Pe({ inputs: { x: d }, backend: r, attrs: { perm: p } }), N = Zt({ inputs: { x: b }, backend: r, attrs: { shape: m } });
    return r.disposeIntermediateTensorInfo(l), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(b), N;
  }
  var j_ = { kernelName: fu, backendName: "cpu", kernelFunc: v7 };
  function N7(e28) {
    let { inputs: t, backend: r } = e28, { indices: n, values: o, denseShape: s10, defaultValue: i } = t;
    if (s10.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
        ${s10.shape}`);
    if (n.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);
    if (o.shape.length !== 1) throw new Error(`Values must be a vector, saw:
        ${o.shape}`);
    if (i.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);
    let a = r.data.get(n.dataId).values, u = r.data.get(o.dataId).values, l = r.data.get(s10.dataId).values, c = r.data.get(i.dataId).values[0], [p, m, f, h, d] = Bb(a, n.shape, n.dtype, u, o.dtype, l, c);
    return [r.makeTensorInfo(m, n.dtype, p), r.makeTensorInfo([m[0]], o.dtype, f), r.makeTensorInfo([h.length], "bool", new Uint8Array(h.map((g) => Number(g)))), r.makeTensorInfo([d.length], n.dtype, new Int32Array(d))];
  }
  var H_ = { kernelName: Ny, backendName: "cpu", kernelFunc: N7 };
  function C7(e28) {
    let { inputs: t, backend: r } = e28, { inputIndices: n, inputShape: o, newShape: s10 } = t;
    if (n.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);
    if (o.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);
    if (s10.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${s10.shape}`);
    let i = Array.from(r.data.get(o.dataId).values), a = r.data.get(n.dataId).values, u = Array.from(r.data.get(s10.dataId).values), [l, c, p] = Vb(a, n.shape, n.dtype, i, u);
    return [r.makeTensorInfo(c, n.dtype, l), r.makeTensorInfo([p.length], s10.dtype, new Int32Array(p))];
  }
  var K_ = { kernelName: Cy, backendName: "cpu", kernelFunc: C7 };
  function S7(e28) {
    let { inputs: t, backend: r } = e28, { data: n, indices: o, segmentIds: s10 } = t;
    if (n.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (o.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);
    if (s10.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
          ${s10.shape}`);
    if (o.shape[0] !== s10.shape[0]) throw new Error("segmentIds and indices should have same size.");
    let i = r.data.get(n.dataId).values, a = r.data.get(o.dataId).values, u = r.data.get(s10.dataId).values, [l, c] = Im(i, n.shape, n.dtype, a, u, true);
    return r.makeTensorInfo(c, n.dtype, l);
  }
  var q_ = { kernelName: Sy, backendName: "cpu", kernelFunc: S7 };
  function I7(e28) {
    let { inputs: t, backend: r } = e28, { data: n, indices: o, segmentIds: s10 } = t;
    if (n.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (o.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);
    if (s10.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
         ${s10.shape}`);
    if (o.shape[0] !== s10.shape[0]) throw new Error("segmentIds and indices should have same size.");
    let i = r.data.get(n.dataId).values, a = r.data.get(o.dataId).values, u = r.data.get(s10.dataId).values, [l, c] = Im(i, n.shape, n.dtype, a, u);
    return r.makeTensorInfo(c, n.dtype, l);
  }
  var X_ = { kernelName: Iy, backendName: "cpu", kernelFunc: I7 };
  function T7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { sparseIndices: o, sparseValues: s10, defaultValue: i } = t, { outputShape: a } = n, { sliceRank: u, numUpdates: l, sliceSize: c, strides: p, outputSize: m } = C.calculateShapes(s10, o, a), f = false, h = r.bufferSync(o), d;
    switch (s10.dtype) {
      case "bool": {
        let g = r.bufferSync(s10), y = !!r.data.get(i.dataId).values[0];
        d = Qo(h, g, a, m, c, l, u, p, y, f);
        break;
      }
      case "float32": {
        let g = r.bufferSync(s10), y = r.data.get(i.dataId).values[0];
        d = Qo(h, g, a, m, c, l, u, p, y, f);
        break;
      }
      case "int32": {
        let g = r.bufferSync(s10), y = r.data.get(i.dataId).values[0];
        d = Qo(h, g, a, m, c, l, u, p, y, f);
        break;
      }
      case "string": {
        let g = r.bufferSync(s10), y = x.decodeString(r.data.get(i.dataId).values[0]);
        d = Qo(h, g, a, m, c, l, u, p, y, f);
        break;
      }
      default:
        throw new Error(`Unsupported type ${s10.dtype}`);
    }
    return r.makeTensorInfo(a, d.dtype, d.values);
  }
  var Y_ = { kernelName: Ty, backendName: "cpu", kernelFunc: T7 };
  function k7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { numOrSizeSplits: s10, axis: i } = n, a = x.parseAxisParam(i, o.shape)[0], u = C.prepareSplitSize(o, s10, a), l = new Array(o.shape.length).fill(0), c = o.shape.slice();
    return u.map((p) => {
      let m = [...c];
      m[a] = p;
      let f = Fo({ inputs: { x: o }, backend: r, attrs: { begin: l, size: m } });
      return l[a] += p, f;
    });
  }
  var J_ = { kernelName: hu, backendName: "cpu", kernelFunc: k7 };
  var Z_ = { kernelName: lp, backendName: "cpu", kernelFunc: ({ inputs: e28, backend: t }) => {
    let { x: r } = e28, n = t;
    J(r, "square");
    let o = n.data.get(r.dataId).values, s10 = new Float32Array(o.length);
    for (let a = 0; a < o.length; ++a) {
      let u = o[a];
      s10[a] = u * u;
    }
    return { dataId: n.write(s10, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
  } };
  var E7 = Lt(Vi, (e28, t) => {
    let r = t;
    return isNaN(e28) ? NaN : e28 > 0 ? 1 : r.alpha;
  });
  var Q_ = { kernelName: Vi, backendName: "cpu", kernelFunc: E7 };
  function A7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { begin: s10, end: i, strides: a, beginMask: u, endMask: l, ellipsisMask: c, newAxisMask: p, shrinkAxisMask: m } = n;
    J(o, "stridedSlice");
    let { finalShapeSparse: f, finalShape: h, isIdentity: d, sliceDim0: g, isSimpleSlice: y, begin: b, end: v, strides: w } = Sr.sliceInfo(o.shape, s10, i, a, u, l, c, p, m), N;
    if (d) N = Zt({ inputs: { x: o }, backend: r, attrs: { shape: h } });
    else if (g || y) {
      x.assert(o.shape.length >= 1, () => `Input must have rank at least 1, got: ${o.shape.length}`);
      let E = Sr.computeOutShape(b, v, w), A = Fo({ inputs: { x: o }, backend: r, attrs: { begin: b, size: E } });
      N = Zt({ inputs: { x: A }, backend: r, attrs: { shape: h } }), r.disposeIntermediateTensorInfo(A);
    } else {
      let E = r.bufferSync(o), A = Gb(f, E, w, b);
      N = r.makeTensorInfo(h, A.dtype, A.values);
    }
    return N;
  }
  var tO = { kernelName: cp, backendName: "cpu", kernelFunc: A7 };
  function D7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { separator: o, nGramWidths: s10, leftPad: i, rightPad: a, padWidth: u, preserveShortSequences: l } = n, { data: c, dataSplits: p } = t, m = r.data.get(c.dataId).values, f = r.data.get(p.dataId).values, [h, d] = Wb(m, f, o, s10, i, a, u, l);
    return [r.makeTensorInfo([h.length], "string", h), r.makeTensorInfo(p.shape, "int32", d)];
  }
  var eO = { kernelName: ky, backendName: "cpu", kernelFunc: D7 };
  function $7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { skipEmpty: o } = n, { input: s10, delimiter: i } = t;
    if (s10.dtype !== "string") throw new Error("Input must be of datatype string");
    if (s10.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${s10.shape}`);
    if (i.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
    let a = r.data.get(s10.dataId).values, u = r.data.get(i.dataId).values[0], [l, c, p] = Ub(a, u, o), m = c.length;
    return [r.makeTensorInfo([m, 2], "int32", l), r.makeTensorInfo([m], "string", c), r.makeTensorInfo([2], "int32", new Int32Array(p))];
  }
  var rO = { kernelName: Ey, backendName: "cpu", kernelFunc: $7 };
  function F7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { numBuckets: o } = n, { input: s10 } = t;
    if (s10.dtype !== "string") throw new Error("Input must be of datatype string");
    if (o <= 0) throw new Error("Number of buckets must be at least 1");
    let i = r.data.get(s10.dataId).values, a = jb(i, o);
    return r.makeTensorInfo(s10.shape, "int32", a);
  }
  var nO = { kernelName: Ay, backendName: "cpu", kernelFunc: F7 };
  var _7 = Lt(zi, (e28) => Math.tan(e28));
  var oO = { kernelName: zi, backendName: "cpu", kernelFunc: _7 };
  var O7 = Lt(Bi, (e28) => Math.tanh(e28));
  var sO = { kernelName: Bi, backendName: "cpu", kernelFunc: O7 };
  function R7(e28) {
    let { inputs: t, backend: r } = e28, { tensor: n, indices: o, updates: s10 } = t, { sliceRank: i, numUpdates: a, sliceSize: u, strides: l, outputSize: c } = C.calculateShapes(s10, o, n.shape), p = false, m = r.bufferSync(o), f = r.bufferSync(s10), h = r.bufferSync(n), d = Qo(m, f, n.shape, c, u, a, i, l, h, p);
    return r.makeTensorInfo(n.shape, d.dtype, d.values);
  }
  var iO = { kernelName: wy, backendName: "cpu", kernelFunc: R7 };
  function P7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { reps: s10 } = n;
    J(o, "tile");
    let i = Hb(r.bufferSync(o), s10);
    return r.makeTensorInfo(i.shape, i.dtype, i.values);
  }
  var aO = { kernelName: gs, backendName: "cpu", kernelFunc: P7 };
  function L7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { k: s10, sorted: i } = n;
    J(o, "topk");
    let a = r.data.get(o.dataId).values, [u, l] = Kb(a, o.shape, o.dtype, s10, i);
    return [r.makeTensorInfo(u.shape, u.dtype, u.values), r.makeTensorInfo(l.shape, l.dtype, l.values)];
  }
  var uO = { kernelName: pp, backendName: "cpu", kernelFunc: L7 };
  function M7(e28) {
    let { inputs: t, attrs: r, backend: n } = e28, { image: o, transforms: s10 } = t, { interpolation: i, fillMode: a, fillValue: u, outputShape: l } = r, [c, p, m, f] = o.shape, [h, d] = l ?? [p, m], g = [c, h, d, f], y = x.computeStrides(o.shape), b = y[0], v = y[1], w = y[2], N = x.computeStrides(g), E = N[0], A = N[1], D = N[2], R = x.getTypedArrayFromDType(o.dtype, x.sizeFromShape(g));
    R.fill(u);
    let L = n.data.get(o.dataId).values, G = n.data.get(s10.dataId).values;
    for (let U = 0; U < c; ++U) {
      let H = s10.shape[0] === 1 ? G : G.subarray(U * 8, U * 8 + 8);
      for (let j = 0; j < h; ++j) for (let X = 0; X < d; ++X) for (let Q = 0; Q < f; ++Q) {
        let q, et = H[6] * X + H[7] * j + 1;
        if (et === 0) continue;
        let ot = (H[0] * X + H[1] * j + H[2]) / et, st = (H[3] * X + H[4] * j + H[5]) / et, ct = lO(ot, m, a), lt = lO(st, p, a);
        switch (i) {
          case "nearest":
            q = W7(L, p, m, b, v, w, U, lt, ct, Q, u);
            break;
          case "bilinear":
            q = U7(L, p, m, b, v, w, U, lt, ct, Q, u);
            break;
          default:
            throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`);
        }
        let wt = U * E + j * A + X * D + Q;
        R[wt] = q;
      }
      return n.makeTensorInfo(g, o.dtype, R);
    }
    return { dataId: n.write(R, g, o.dtype), shape: o.shape, dtype: o.dtype };
  }
  var cO = { kernelName: mp, backendName: "cpu", kernelFunc: M7 };
  function lO(e28, t, r) {
    switch (r) {
      case "reflect":
        return z7(e28, t);
      case "wrap":
        return B7(e28, t);
      case "nearest":
        return G7(e28, t);
      case "constant":
      default:
        return V7(e28, t);
    }
  }
  function z7(e28, t) {
    let r = e28;
    if (r < 0) if (t <= 1) r = 0;
    else {
      let n = 2 * t;
      r < n && (r = n * Math.trunc(-r / n) + r), r = r < -t ? r + n : -r - 1;
    }
    else if (r > t - 1) if (t <= 1) r = 0;
    else {
      let n = 2 * t;
      r -= n * Math.trunc(r / n), r >= t && (r = n - r - 1);
    }
    return x.clamp(0, r, t - 1);
  }
  function B7(e28, t) {
    let r = e28;
    if (r < 0) if (t <= 1) r = 0;
    else {
      let n = t - 1;
      r += t * (Math.trunc(-r / n) + 1);
    }
    else if (r > t - 1) if (t <= 1) r = 0;
    else {
      let n = t - 1;
      r -= t * Math.trunc(r / n);
    }
    return x.clamp(0, r, t - 1);
  }
  function V7(e28, t) {
    return e28;
  }
  function G7(e28, t) {
    return x.clamp(0, e28, t - 1);
  }
  function ng(e28, t, r, n, o, s10, i, a, u, l, c) {
    let p = i * n + a * o + u * s10 + l;
    return 0 <= a && a < t && 0 <= u && u < r ? e28[p] : c;
  }
  function W7(e28, t, r, n, o, s10, i, a, u, l, c) {
    let p = Math.round(a), m = Math.round(u);
    return ng(e28, t, r, n, o, s10, i, p, m, l, c);
  }
  function U7(e28, t, r, n, o, s10, i, a, u, l, c) {
    let p = Math.floor(a), m = Math.floor(u), f = p + 1, h = m + 1, d = (h - u) * ng(e28, t, r, n, o, s10, i, p, m, l, c) + (u - m) * ng(e28, t, r, n, o, s10, i, p, h, l, c), g = (h - u) * ng(e28, t, r, n, o, s10, i, f, m, l, c) + (u - m) * ng(e28, t, r, n, o, s10, i, f, h, l, c);
    return (f - a) * d + (a - p) * g;
  }
  function j7(e28) {
    let { inputs: t, attrs: r, backend: n } = e28, { axis: o } = r, { x: s10 } = t;
    J(s10, "unique");
    let i = n.data.get(s10.dataId).values, { outputValues: a, outputShape: u, indices: l } = qb(i, o, s10.shape, s10.dtype);
    return [n.makeTensorInfo(u, s10.dtype, a), n.makeTensorInfo([l.length], "int32", l)];
  }
  var pO = { kernelName: fp, backendName: "cpu", kernelFunc: j7 };
  function H7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { value: o } = t, { axis: s10 } = n;
    s10 < 0 && (s10 += o.shape.length);
    let i = o.shape.length, a = o.shape[s10], u = new Array(i - 1), l = 0;
    for (let f = 0; f < i; f++) f !== s10 && (u[l++] = o.shape[f]);
    let c = new Array(i).fill(0), p = o.shape.slice();
    p[s10] = 1;
    let m = new Array(a);
    for (let f = 0; f < m.length; f++) {
      c[s10] = f;
      let h = Fo({ inputs: { x: o }, backend: r, attrs: { begin: c, size: p } });
      m[f] = Zt({ inputs: { x: h }, backend: r, attrs: { shape: u } }), r.disposeIntermediateTensorInfo(h);
    }
    return m;
  }
  var mO = { kernelName: gu, backendName: "cpu", kernelFunc: H7 };
  function K7(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, segmentIds: s10 } = t, { numSegments: i } = n;
    J(o, "unsortedSegmentSum");
    let a = o.shape.length, u = s10.shape.length, l = [], c = [], p = a - u, m = s10;
    for (let h = 0; h < p; ++h) {
      let d = km({ inputs: { input: m }, backend: r, attrs: { dim: h + 1 } });
      m = d, c.push(d);
    }
    for (let h = 0; h < i; ++h) {
      let d = x.createScalarValue(h, "int32"), g = r.makeTensorInfo([], "int32", d), y = fC({ inputs: { a: g, b: m }, backend: r }), b = Do({ inputs: { x: y }, backend: r, attrs: { dtype: "float32" } }), v = Xl({ inputs: { a: b, b: o }, backend: r }), w = ia({ inputs: { x: v }, backend: r, attrs: { axis: 0, keepDims: false } });
      l.push(w), c.push(g), c.push(y), c.push(b), c.push(v), c.push(w);
    }
    let f = XC({ inputs: l, backend: r, attrs: { axis: 0 } });
    return c.forEach((h) => r.disposeIntermediateTensorInfo(h)), f;
  }
  var fO = { kernelName: yu, backendName: "cpu", kernelFunc: K7 };
  var q7 = [M$, HD, z$, B$, JD, V$, G$, W$, U$, j$, H$, K$, q$, X$, Y$, Z$, Q$, tF, eF, L$, rF, nF, oF, ZD, sF, YD, QD, iF, KD, aF, lF, cF, pF, mF, fF, hF, dF, gF, yF, xF, bF, wF, vF, NF, CF, SF, IF, TF, kF, EF, AF, DF, FF, $$, _F, t$, OF, e$, RF, r$, PF, LF, MF, n$, o$, zF, BF, VF, GF, s$, i$, qD, WF, uF, UF, jF, HF, F$, a$, u$, KF, l$, qF, XF, YF, JF, ZF, QF, t_, c$, e_, r_, n_, o_, i_, a_, u_, p$, l_, c_, f_, m$, f$, h_, d_, g_, h$, y_, w_, v_, Zb, N_, _$, g$, C_, S_, I_, T_, XD, tg, k_, O$, R$, P$, E_, A_, D_, $_, F_, __, O_, v$, R_, L_, M_, z_, C$, B_, V_, G_, S$, p_, U_, j_, H_, K_, q_, X_, Y_, J_, T$, Z_, k$, E$, Q_, tO, eO, rO, nO, A$, $F, oO, sO, iO, aO, uO, cO, d$, pO, mO, fO, x_];
  for (let e28 of q7) $y(e28);
  var Jl = {};
  var Qb = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
  function hO(e28, t) {
    Jl[e28] = t;
  }
  function Bn(e28, t) {
    if (!(e28 in Jl) || t != null) {
      let n = Y7(e28, t);
      if (n !== null) Jl[e28] = n;
      else return console.log("Could not get context for WebGL version", e28), null;
    }
    let r = Jl[e28];
    return r == null || r.isContextLost() ? (delete Jl[e28], Bn(e28)) : (r.disable(r.DEPTH_TEST), r.disable(r.STENCIL_TEST), r.disable(r.BLEND), r.disable(r.DITHER), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SAMPLE_COVERAGE), r.enable(r.SCISSOR_TEST), r.enable(r.CULL_FACE), r.cullFace(r.BACK), Jl[e28]);
  }
  function X7(e28) {
    if (!z().getBool("IS_SAFARI") && typeof OffscreenCanvas < "u" && e28 === 2) return new OffscreenCanvas(300, 150);
    if (typeof document < "u") return document.createElement("canvas");
    throw new Error("Cannot create a canvas in this context");
  }
  function Y7(e28, t) {
    if (e28 !== 1 && e28 !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    let r = t ?? X7(e28);
    return r.addEventListener("webglcontextlost", (n) => {
      n.preventDefault(), delete Jl[e28];
    }, false), z().getBool("SOFTWARE_WEBGL_ENABLED") && (Qb.failIfMajorPerformanceCaveat = false), e28 === 1 ? r.getContext("webgl", Qb) || r.getContext("experimental-webgl", Qb) : r.getContext("webgl2", Qb);
  }
  var Lu;
  (function(e28) {
    e28[e28.DENSE = 0] = "DENSE", e28[e28.SHARED_BATCH = 1] = "SHARED_BATCH";
  })(Lu || (Lu = {}));
  var Kr;
  (function(e28) {
    e28[e28.RENDER = 0] = "RENDER", e28[e28.UPLOAD = 1] = "UPLOAD", e28[e28.PIXELS = 2] = "PIXELS", e28[e28.DOWNLOAD = 3] = "DOWNLOAD";
  })(Kr || (Kr = {}));
  var Pr;
  (function(e28) {
    e28[e28.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e28[e28.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e28[e28.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e28[e28.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e28[e28.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
  })(Pr || (Pr = {}));
  function Zl(e28, t) {
    return [t, e28];
  }
  function dO(e28, t) {
    return e28 * t;
  }
  function og(e28) {
    let t = x.sizeFromShape(e28), r = Math.ceil(t / 4);
    return x.sizeToSquarishShape(r);
  }
  function _s(e28, t) {
    return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e28 / 2))];
  }
  function gO(e28, t) {
    let [r, n] = _s(e28, t);
    return r * n * 4;
  }
  function sg(e28, t) {
    let r = e28, n, o, s10, i, a, u, l, c, p, m;
    return z().getNumber("WEBGL_VERSION") === 2 ? (n = r.R32F, o = r.R16F, s10 = r.RGBA16F, i = r.RGBA32F, a = r.RED, l = 4, c = 1, p = r.HALF_FLOAT, m = r.FLOAT, u = r.RGBA8) : (n = e28.RGBA, o = e28.RGBA, s10 = e28.RGBA, i = r.RGBA, a = e28.RGBA, l = 4, c = 4, p = t != null ? t.HALF_FLOAT_OES : null, m = e28.FLOAT, u = e28.RGBA), { internalFormatFloat: n, internalFormatHalfFloat: o, internalFormatPackedHalfFloat: s10, internalFormatPackedFloat: i, textureFormatFloat: a, downloadTextureFormat: u, downloadUnpackNumChannels: l, defaultNumChannels: c, textureTypeHalfFloat: p, textureTypeFloat: m };
  }
  function vt(e28, t) {
    let r = t();
    return z().getBool("DEBUG") && J7(e28), r;
  }
  function J7(e28) {
    let t = e28.getError();
    if (t !== e28.NO_ERROR) throw new Error("WebGL Error: " + t9(e28, t));
  }
  var Z7 = 596e-10;
  var Q7 = 65504;
  function yO(e28) {
    return !!(z().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || e28 === 0 || Z7 < Math.abs(e28) && Math.abs(e28) < Q7);
  }
  function t9(e28, t) {
    switch (t) {
      case e28.NO_ERROR:
        return "NO_ERROR";
      case e28.INVALID_ENUM:
        return "INVALID_ENUM";
      case e28.INVALID_VALUE:
        return "INVALID_VALUE";
      case e28.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case e28.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case e28.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case e28.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${t}`;
    }
  }
  function ig(e28, t) {
    return aa(e28, () => e28.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
  }
  function xO(e28, t) {
    let r = aa(e28, () => e28.createShader(e28.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    if (vt(e28, () => e28.shaderSource(r, t)), vt(e28, () => e28.compileShader(r)), e28.getShaderParameter(r, e28.COMPILE_STATUS) === false) throw console.log(e28.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
    return r;
  }
  function bO(e28, t) {
    let r = aa(e28, () => e28.createShader(e28.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    if (vt(e28, () => e28.shaderSource(r, t)), vt(e28, () => e28.compileShader(r)), z().get("ENGINE_COMPILE_ONLY")) return r;
    if (e28.getShaderParameter(r, e28.COMPILE_STATUS) === false) throw tS(t, e28.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
    return r;
  }
  var e92 = /ERROR: [0-9]+:([0-9]+):/g;
  function tS(e28, t) {
    let r = e92.exec(t);
    if (r == null) {
      console.log(`Couldn't parse line number in error: ${t}`), console.log(e28);
      return;
    }
    let n = +r[1], o = e28.split(`
`), s10 = o.length.toString().length + 2, i = o.map((p, m) => x.rightPad((m + 1).toString(), s10) + p), a = 0;
    for (let p = 0; p < i.length; p++) a = Math.max(i[p].length, a);
    let u = i.slice(0, n - 1), l = i.slice(n - 1, n), c = i.slice(n);
    console.log(u.join(`
`)), console.log(t.split(`
`)[0]), console.log(`%c ${x.rightPad(l[0], a)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join(`
`));
  }
  function wO(e28) {
    return aa(e28, () => e28.createProgram(), "Unable to create WebGLProgram.");
  }
  function vO(e28, t) {
    if (vt(e28, () => e28.linkProgram(t)), !z().get("ENGINE_COMPILE_ONLY") && e28.getProgramParameter(t, e28.LINK_STATUS) === false) throw console.log(e28.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
  }
  function e0(e28, t) {
    if (vt(e28, () => e28.validateProgram(t)), e28.getProgramParameter(t, e28.VALIDATE_STATUS) === false) throw console.log(e28.getProgramInfoLog(t)), new Error("Shader program validation failed.");
  }
  function NO(e28, t) {
    let r = aa(e28, () => e28.createBuffer(), "Unable to create WebGLBuffer");
    return vt(e28, () => e28.bindBuffer(e28.ARRAY_BUFFER, r)), vt(e28, () => e28.bufferData(e28.ARRAY_BUFFER, t, e28.STATIC_DRAW)), r;
  }
  function CO(e28, t) {
    let r = aa(e28, () => e28.createBuffer(), "Unable to create WebGLBuffer");
    return vt(e28, () => e28.bindBuffer(e28.ELEMENT_ARRAY_BUFFER, r)), vt(e28, () => e28.bufferData(e28.ELEMENT_ARRAY_BUFFER, t, e28.STATIC_DRAW)), r;
  }
  function SO(e28) {
    return aa(e28, () => e28.createTexture(), "Unable to create WebGLTexture.");
  }
  function IO(e28, t) {
    let r = z().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e28 <= 0 || t <= 0) {
      let n = `[${e28}x${t}]`;
      throw new Error("Requested texture size " + n + " is invalid.");
    }
    if (e28 > r || t > r) {
      let n = `[${e28}x${t}]`, o = `[${r}x${r}]`;
      throw new Error("Requested texture size " + n + " greater than WebGL maximum on this browser / GPU " + o + ".");
    }
  }
  function TO(e28) {
    return aa(e28, () => e28.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function eS(e28, t, r, n, o, s10, i) {
    let a = e28.getAttribLocation(t, r);
    return a === -1 ? false : (vt(e28, () => e28.bindBuffer(e28.ARRAY_BUFFER, n)), vt(e28, () => e28.vertexAttribPointer(a, o, e28.FLOAT, false, s10, i)), vt(e28, () => e28.enableVertexAttribArray(a)), true);
  }
  function r9(e28, t, r) {
    o9(e28, r), vt(e28, () => e28.activeTexture(e28.TEXTURE0 + r)), vt(e28, () => e28.bindTexture(e28.TEXTURE_2D, t));
  }
  function kO(e28, t, r) {
    return aa(e28, () => e28.getUniformLocation(t, r), 'uniform "' + r + '" not present in program.');
  }
  function EO(e28, t, r) {
    return e28.getUniformLocation(t, r);
  }
  function AO(e28, t, r, n) {
    vt(e28, () => r9(e28, t, n)), vt(e28, () => e28.uniform1i(r, n));
  }
  function r0(e28, t, r) {
    vt(e28, () => e28.bindFramebuffer(e28.FRAMEBUFFER, r)), vt(e28, () => e28.framebufferTexture2D(e28.FRAMEBUFFER, e28.COLOR_ATTACHMENT0, e28.TEXTURE_2D, t, 0));
  }
  function rS(e28, t) {
    vt(e28, () => e28.bindFramebuffer(e28.FRAMEBUFFER, t)), vt(e28, () => e28.framebufferTexture2D(e28.FRAMEBUFFER, e28.COLOR_ATTACHMENT0, e28.TEXTURE_2D, null, 0));
  }
  function ag(e28) {
    let t = e28.checkFramebufferStatus(e28.FRAMEBUFFER);
    if (t !== e28.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + n9(e28, t));
  }
  function n9(e28, t) {
    switch (t) {
      case e28.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case e28.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case e28.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case e28.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${t}`;
    }
  }
  function aa(e28, t, r) {
    let n = vt(e28, () => t());
    if (n == null) throw new Error(r);
    return n;
  }
  function o9(e28, t) {
    let r = e28.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, n = t + e28.TEXTURE0;
    if (n < e28.TEXTURE0 || n > r) {
      let o = `[gl.TEXTURE0, gl.TEXTURE${r}]`;
      throw new Error(`textureUnit must be in ${o}.`);
    }
  }
  function Mu(e28, t = 2) {
    return x.sizeFromShape(e28.slice(0, e28.length - t));
  }
  function zu(e28) {
    if (e28.length === 0) throw Error("Cannot get rows and columns of an empty shape array.");
    return [e28.length > 1 ? e28[e28.length - 2] : 1, e28[e28.length - 1]];
  }
  function ug(e28) {
    let t = [1, 1, 1];
    return e28.length === 0 || e28.length === 1 && e28[0] === 1 || (t = [Mu(e28), ...zu(e28)]), t;
  }
  function DO(e28, t = false) {
    let r = z().getNumber("WEBGL_MAX_TEXTURE_SIZE"), n = z().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    n === 1 / 0 && z().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (n = r / 2), t && (r = r * 2, n = n * 2, e28 = e28.map((a, u) => u >= e28.length - 2 ? x.nearestLargerEven(e28[u]) : e28[u]), e28.length === 1 && (e28 = [2, e28[0]])), e28.length !== 2 && (e28 = x.squeezeShape(e28).newShape);
    let o = x.sizeFromShape(e28), s10 = null;
    e28.length <= 1 && o <= r ? s10 = [1, o] : e28.length === 2 && e28[0] <= r && e28[1] <= r ? s10 = e28 : e28.length === 3 && e28[0] * e28[1] <= r && e28[2] <= r ? s10 = [e28[0] * e28[1], e28[2]] : e28.length === 3 && e28[0] <= r && e28[1] * e28[2] <= r ? s10 = [e28[0], e28[1] * e28[2]] : e28.length === 4 && e28[0] * e28[1] * e28[2] <= r && e28[3] <= r ? s10 = [e28[0] * e28[1] * e28[2], e28[3]] : e28.length === 4 && e28[0] <= r && e28[1] * e28[2] * e28[3] <= r && (s10 = [e28[0], e28[1] * e28[2] * e28[3]]);
    let i = s10 != null && Math.max(...s10) > n && Math.min(...s10) <= (t ? 2 : 1) && Math.min(...s10) > 0;
    if (s10 == null || i) if (t) {
      let a = Mu(e28), u = 2, l = 2;
      e28.length && ([u, l] = zu(e28)), o = a * (u / 2) * (l / 2), s10 = x.sizeToSquarishShape(o).map((c) => c * 2);
    } else s10 = x.sizeToSquarishShape(o);
    return s10;
  }
  function t0(e28) {
    return e28 % 2 === 0;
  }
  function Ql(e28, t) {
    if (e28 = e28.slice(-2), t = t.slice(-2), x.arraysEqual(e28, t) || !e28.length || !t.length || e28[0] === 0 || e28[1] === 0 || t[0] === 0 || t[1] === 0) return true;
    if (e28.length !== t.length) {
      let r = e28[e28.length - 1], n = t[t.length - 1];
      if (r === n || t0(r) && t0(n) && (e28[0] === 1 || t[0] === 1)) return true;
    }
    return e28[1] === t[1] && t0(e28[0]) && t0(t[0]);
  }
  var JC;
  var ZC;
  function $O(e28) {
    if (JC == null) {
      let t = Bn(e28);
      JC = t.getParameter(t.MAX_TEXTURE_SIZE);
    }
    return JC;
  }
  function FO(e28) {
    if (ZC == null) {
      let t = Bn(e28);
      ZC = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, ZC);
  }
  function _O(e28) {
    if (e28 === 0) return 0;
    let t, r = Bn(e28);
    return no(r, "EXT_disjoint_timer_query_webgl2") && e28 === 2 ? t = 2 : no(r, "EXT_disjoint_timer_query") ? t = 1 : t = 0, t;
  }
  function no(e28, t) {
    return e28.getExtension(t) != null;
  }
  function nS(e28) {
    try {
      if (Bn(e28) != null) return true;
    } catch (t) {
      return console.log("Error when getting WebGL context: ", t), false;
    }
    return false;
  }
  function OO(e28) {
    if (e28 === 0) return false;
    let t = Bn(e28);
    if (e28 === 1) {
      if (!no(t, "OES_texture_float")) return false;
    } else if (!no(t, "EXT_color_buffer_float")) return false;
    return QC(t);
  }
  function RO(e28) {
    if (e28 === 0) return false;
    let t = Bn(e28);
    if (e28 === 1) {
      if (!no(t, "OES_texture_float") || !no(t, "WEBGL_color_buffer_float")) return false;
    } else {
      if (no(t, "EXT_color_buffer_float")) return QC(t);
      let n = "EXT_color_buffer_half_float";
      if (no(t, n)) {
        let o = t.getExtension(n);
        return s9(t, o);
      }
      return false;
    }
    return QC(t);
  }
  function QC(e28) {
    let t = sg(e28), r = e28.createTexture();
    e28.bindTexture(e28.TEXTURE_2D, r), e28.texImage2D(e28.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
    let s10 = e28.createFramebuffer();
    e28.bindFramebuffer(e28.FRAMEBUFFER, s10), e28.framebufferTexture2D(e28.FRAMEBUFFER, e28.COLOR_ATTACHMENT0, e28.TEXTURE_2D, r, 0);
    let i = e28.checkFramebufferStatus(e28.FRAMEBUFFER) === e28.FRAMEBUFFER_COMPLETE;
    return e28.bindTexture(e28.TEXTURE_2D, null), e28.bindFramebuffer(e28.FRAMEBUFFER, null), e28.deleteTexture(r), e28.deleteFramebuffer(s10), i;
  }
  function s9(e28, t) {
    let r = sg(e28, t), n = e28.createTexture();
    e28.bindTexture(e28.TEXTURE_2D, n), e28.texImage2D(e28.TEXTURE_2D, 0, r.internalFormatHalfFloat, 1, 1, 0, r.textureFormatFloat, r.textureTypeHalfFloat, null);
    let i = e28.createFramebuffer();
    e28.bindFramebuffer(e28.FRAMEBUFFER, i), e28.framebufferTexture2D(e28.FRAMEBUFFER, e28.COLOR_ATTACHMENT0, e28.TEXTURE_2D, n, 0);
    let a = e28.checkFramebufferStatus(e28.FRAMEBUFFER) === e28.FRAMEBUFFER_COMPLETE;
    return e28.bindTexture(e28.TEXTURE_2D, null), e28.bindFramebuffer(e28.FRAMEBUFFER, null), e28.deleteTexture(n), e28.deleteFramebuffer(i), a;
  }
  function PO(e28) {
    return e28 !== 2 ? false : Bn(e28).fenceSync != null;
  }
  function Os(e28, t) {
    Array.isArray(e28) || (e28 = [e28]), e28.forEach((r) => {
      r != null && x.assert(r.dtype !== "complex64", () => `${t} does not support complex64 tensors in the WebGL backend.`);
    });
  }
  var _t = z();
  _t.registerFlag("HAS_WEBGL", () => _t.getNumber("WEBGL_VERSION") > 0);
  _t.registerFlag("WEBGL_VERSION", () => nS(2) ? 2 : nS(1) ? 1 : 0);
  _t.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  _t.registerFlag("WEBGL_BUFFER_SUPPORTED", () => _t.get("WEBGL_VERSION") === 2);
  _t.registerFlag("WEBGL_CPU_FORWARD", () => true);
  _t.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  _t.registerFlag("WEBGL_PACK", () => _t.getBool("HAS_WEBGL"));
  _t.registerFlag("WEBGL_PACK_NORMALIZATION", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_CLIP", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_REDUCE", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_LAZILY_UNPACK", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_CONV_IM2COL", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => _t.getBool("WEBGL_PACK"));
  _t.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => $O(_t.getNumber("WEBGL_VERSION")));
  _t.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => FO(_t.getNumber("WEBGL_VERSION")));
  _t.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    let e28 = _t.getNumber("WEBGL_VERSION");
    return e28 === 0 ? 0 : _O(e28);
  });
  _t.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => _t.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !vu.isMobile());
  _t.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => OO(_t.getNumber("WEBGL_VERSION")));
  _t.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => _t.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : _t.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
  _t.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => RO(_t.getNumber("WEBGL_VERSION")));
  _t.registerFlag("WEBGL_FENCE_API_ENABLED", () => PO(_t.getNumber("WEBGL_VERSION")));
  _t.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => _t.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
  _t.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (e28) => {
    if (typeof e28 != "number") throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e28}.`);
    if (e28 < 0 && e28 !== -1) throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e28}.`);
  });
  _t.registerFlag("WEBGL_FLUSH_THRESHOLD", () => vu.isMobile() ? 1 : -1, (e28) => {
    if (typeof e28 != "number") throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e28}.`);
    if (e28 < 0 && e28 !== -1) throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e28}.`);
  });
  _t.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  _t.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  _t.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  _t.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  _t.registerFlag("WEBGL_EXP_CONV", () => false);
  _t.registerFlag("SOFTWARE_WEBGL_ENABLED", () => _t.getBool("IS_TEST"));
  _t.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0);
  _t.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  _t.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  _t.registerFlag("ENGINE_COMPILE_ONLY", () => false);
  function Le() {
    let e28, t, r, n, o, s10, i, a, u, l;
    return z().getNumber("WEBGL_VERSION") === 2 ? (e28 = "#version 300 es", t = "in", r = "out", n = "in", o = "texture", s10 = "outputColor", i = "out vec4 outputColor;", a = z().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", u = "", l = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (e28 = "", t = "attribute", r = "varying", n = "varying", o = "texture2D", s10 = "gl_FragColor", i = "", a = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, u = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, l = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), { version: e28, attribute: t, varyingVs: r, varyingFs: n, texture2D: o, output: s10, defineOutput: i, defineSpecialNaN: a, defineSpecialInf: u, defineRound: l };
  }
  function ts(e28, t, r = "index") {
    let n = x.computeStrides(t);
    return n.map((o, s10) => {
      let i = `int ${e28[s10]} = ${r} / ${o}`, a = s10 === n.length - 1 ? `int ${e28[s10 + 1]} = ${r} - ${e28[s10]} * ${o}` : `index -= ${e28[s10]} * ${o}`;
      return `${i}; ${a};`;
    }).join("");
  }
  function tc(e28, t, r = "index") {
    let n = x.computeStrides(t);
    return n.map((o, s10) => {
      let i = `int ${e28[s10]} = ${r} / outShapeStrides[${s10}]`, a = s10 === n.length - 1 ? `int ${e28[s10 + 1]} = ${r} - ${e28[s10]} * outShapeStrides[${s10}]` : `index -= ${e28[s10]} * outShapeStrides[${s10}]`;
      return `${i}; ${a};`;
    }).join("");
  }
  function i9(e28, t) {
    let r = e28.length, n = e28.map((s10) => `${t}[${s10}]`), o = new Array(r - 1);
    o[r - 2] = n[r - 1];
    for (let s10 = r - 3; s10 >= 0; --s10) o[s10] = `(${o[s10 + 1]} * ${n[s10 + 1]})`;
    return o;
  }
  function LO(e28, t, r = "index") {
    let n = e28.map((s10, i) => i), o = i9(n, t);
    return o.map((s10, i) => {
      let a = `int ${e28[i]} = ${r} / ${o[i]}`, u = i === o.length - 1 ? `int ${e28[i + 1]} = ${r} - ${e28[i]} * ${o[i]}` : `index -= ${e28[i]} * ${o[i]}`;
      return `${a}; ${u};`;
    }).join("");
  }
  function Em(e28) {
    let t = x.computeStrides(e28).map((r) => r.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`;
  }
  function Am() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  var o0 = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
  var { getBroadcastDims: MO } = C;
  function zO(e28, t, r) {
    let n = [];
    if (e28.forEach((f) => {
      let h = x.sizeFromShape(f.shapeInfo.logicalShape);
      if (f.shapeInfo.isUniform ? n.push(`uniform float ${f.name}${h > 1 ? `[${h}]` : ""};`) : (n.push(`uniform sampler2D ${f.name};`), n.push(`uniform int offset${f.name};`)), r.enableShapeUniforms) {
        let { uniformShape: d } = s0(r.packedInputs, f.shapeInfo.logicalShape, f.shapeInfo.texShape);
        switch (d.length) {
          case 1:
            n.push(`uniform int ${f.name}Shape;`);
            break;
          case 2:
            n.push(`uniform ivec2 ${f.name}Shape;`);
            break;
          case 3:
            n.push(`uniform ivec3 ${f.name}Shape;`);
            break;
          case 4:
            n.push(`uniform ivec4 ${f.name}Shape;`);
            break;
          default:
            break;
        }
        n.push(`uniform ivec2 ${f.name}TexShape;`);
      }
    }), r.enableShapeUniforms) {
      switch (t.logicalShape.length) {
        case 1:
          n.push("uniform int outShape;");
          break;
        case 2:
          n.push("uniform ivec2 outShape;"), n.push("uniform int outShapeStrides;");
          break;
        case 3:
          n.push("uniform ivec3 outShape;"), n.push("uniform ivec2 outShapeStrides;");
          break;
        case 4:
          n.push("uniform ivec4 outShape;"), n.push("uniform ivec3 outShapeStrides;");
          break;
        default:
          break;
      }
      n.push("uniform ivec2 outTexShape;");
    }
    r.customUniforms && r.customUniforms.forEach((f) => {
      n.push(`uniform ${f.type} ${f.name}${f.arrayIndex ? `[${f.arrayIndex}]` : ""};`);
    });
    let o = n.join(`
`), s10 = e28.map((f) => a9(f, t, r.packedInputs, r.enableShapeUniforms)).join(`
`), i = t.texShape, a = Le(), u = c9(a), l, c, p = f9(a);
    return t.isPacked ? (l = u9(t.logicalShape, i, r.enableShapeUniforms), c = m9(a)) : (l = l9(t.logicalShape, i, r.enableShapeUniforms), c = p9(a)), r.packedInputs && (p += y9), [p, u, c, o, l, s10, r.userCode].join(`
`);
  }
  function $m(e28, t = false) {
    let r = e28.shapeInfo.logicalShape;
    switch (r.length) {
      case 0:
        return A9(e28, t);
      case 1:
        return $9(e28, t);
      case 2:
        return _9(e28, t);
      case 3:
        return R9(e28, t);
      case 4:
        return L9(e28, t);
      case 5:
        return M9(e28);
      case 6:
        return z9(e28);
      default:
        throw new Error(`${r.length}-D input sampling is not yet supported`);
    }
  }
  function BO(e28, t) {
    switch (e28.shapeInfo.logicalShape.length) {
      case 0:
        return E9(e28);
      case 1:
        return D9(e28, t);
      case 2:
        return F9(e28, t);
      case 3:
        return O9(e28, t);
      default:
        return P9(e28, t);
    }
  }
  function a9(e28, t, r = false, n) {
    let o = "";
    r ? o += BO(e28, n) : o += $m(e28, n);
    let s10 = e28.shapeInfo.logicalShape, i = t.logicalShape;
    return s10.length <= i.length && (r ? o += B9(e28, t) : o += V9(e28, t)), o;
  }
  function u9(e28, t, r) {
    switch (e28.length) {
      case 0:
        return VO();
      case 1:
        return x9(e28, t, r);
      case 2:
        return T9(e28, t, r);
      case 3:
        return w9(e28, t, r);
      default:
        return N9(e28, t, r);
    }
  }
  function l9(e28, t, r) {
    switch (e28.length) {
      case 0:
        return VO();
      case 1:
        return b9(e28, t, r);
      case 2:
        return k9(e28, t, r);
      case 3:
        return v9(e28, t, r);
      case 4:
        return C9(e28, t, r);
      case 5:
        return S9(e28, t);
      case 6:
        return I9(e28, t);
      default:
        throw new Error(`${e28.length}-D output sampling is not yet supported`);
    }
  }
  function c9(e28) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e28.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function p9(e28) {
    return `
    void setOutput(float val) {
      ${e28.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function m9(e28) {
    return `
    void setOutput(vec4 val) {
      ${e28.output} = val;
    }
  `;
  }
  function f9(e28) {
    return `${e28.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e28.varyingFs} vec2 resultUV;
    ${e28.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e28.defineSpecialNaN}
    ${e28.defineSpecialInf}
    ${e28.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${h9}
    ${d9}
    ${g9}
  `;
  }
  var h9 = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var d9 = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var g9 = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var y9 = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function VO() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function x9(e28, t, r) {
    let n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
    return n[0] === 1 ? r ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    ` : n[1] === 1 ? r ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    ` : r ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `;
  }
  function b9(e28, t, r) {
    return t[0] === 1 ? r ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    ` : t[1] === 1 ? r ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    ` : r ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `;
  }
  function w9(e28, t, r) {
    if (r) return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    let n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], o = Math.ceil(e28[2] / 2), s10 = o * Math.ceil(e28[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s10};
      index -= b * ${s10};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function v9(e28, t, r) {
    if (r) return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${tc(["r", "c", "d"], e28)}
    return ivec3(r, c, d);
  }
`;
    let n = ts(["r", "c", "d"], e28);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `;
  }
  function N9(e28, t, r) {
    if (r) return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    let n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], o = Math.ceil(e28[e28.length - 1] / 2), s10 = o * Math.ceil(e28[e28.length - 2] / 2), i = s10, a = "", u = "b, r, c";
    for (let l = 2; l < e28.length - 1; l++) i *= e28[e28.length - l - 1], a = `
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    ` + a, u = `b${l}, ` + u;
    return `
    ivec${e28.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s10};
      index -= b * ${s10};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${e28.length}(${u});
    }
  `;
  }
  function C9(e28, t, r) {
    if (r) return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${tc(["r", "c", "d", "d2"], e28)}
      return ivec4(r, c, d, d2);
    }
  `;
    let n = ts(["r", "c", "d", "d2"], e28);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function S9(e28, t) {
    let r = ts(["r", "c", "d", "d2", "d3"], e28);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${r}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function I9(e28, t) {
    let r = ts(["r", "c", "d", "d2", "d3", "d4"], e28);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${r}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function T9(e28, t, r) {
    let n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
    if (x.arraysEqual(e28, t)) return r ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;
    let o = Math.ceil(e28[1] / 2);
    return r ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function k9(e28, t, r) {
    return x.arraysEqual(e28, t) ? r ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    ` : e28[1] === 1 ? r ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : e28[0] === 1 ? r ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : r ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e28[1]};
      int c = index - r * ${e28[1]};
      return ivec2(r, c);
    }
  `;
  }
  function ec(e28) {
    return `offset${e28}`;
  }
  function E9(e28) {
    let t = e28.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1), n = Le();
    return `
    vec4 ${r}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `;
  }
  function A9(e28, t) {
    let r = e28.name, n = "get" + r.charAt(0).toUpperCase() + r.slice(1);
    if (e28.shapeInfo.isUniform) return `float ${n}() {return ${r};}`;
    let [o, s10] = e28.shapeInfo.texShape;
    if (o === 1 && s10 === 1) return `
      float ${n}() {
        return sampleTexture(${r}, halfCR);
      }
    `;
    let i = ec(r);
    if (t) return `
    float ${n}() {
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], ${i});
      return sampleTexture(${r}, uv);
    }
  `;
    let [a, u] = e28.shapeInfo.texShape;
    return `
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${r}, uv);
    }
  `;
  }
  function D9(e28, t) {
    let r = e28.name, n = "get" + r.charAt(0).toUpperCase() + r.slice(1), o = e28.shapeInfo.texShape, s10 = Le();
    if (t) return `
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s10.texture2D}(${r}, uv);
    }
  `;
    let i = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];
    return `
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s10.texture2D}(${r}, uv);
    }
  `;
  }
  function $9(e28, t) {
    let r = e28.name, n = "get" + r.charAt(0).toUpperCase() + r.slice(1);
    if (e28.shapeInfo.isUniform) return `
      float ${n}(int index) {
        ${Fm(e28)}
      }
    `;
    let o = e28.shapeInfo.texShape, s10 = o[0], i = o[1];
    if (i === 1 && s10 === 1) return `
      float ${n}(int index) {
        return sampleTexture(${r}, halfCR);
      }
    `;
    let a = ec(r);
    return i === 1 ? t ? `
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    ` : `
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s10}.0);
        return sampleTexture(${r}, uv);
      }
    ` : s10 === 1 ? t ? `
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    ` : `
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${r}, uv);
      }
    ` : t ? `
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${a});
      return sampleTexture(${r}, uv);
    }
  ` : `
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s10}, ${i}, index + ${a});
      return sampleTexture(${r}, uv);
    }
  `;
  }
  function F9(e28, t) {
    let r = e28.shapeInfo.logicalShape, n = e28.name, o = "get" + n.charAt(0).toUpperCase() + n.slice(1), s10 = e28.shapeInfo.texShape, i = s10[0], a = s10[1], u = Le();
    if (s10 != null && x.arraysEqual(r, s10)) return t ? `
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    ` : `
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;
    if (t) return `
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;
    let l = [Math.ceil(s10[0] / 2), Math.ceil(s10[1] / 2)], c = Math.ceil(r[1] / 2);
    return `
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;
  }
  function _9(e28, t) {
    let r = e28.shapeInfo.logicalShape, n = e28.name, o = "get" + n.charAt(0).toUpperCase() + n.slice(1), s10 = e28.shapeInfo.texShape;
    if (s10 != null && x.arraysEqual(r, s10)) {
      if (t) return `
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;
      let m = s10[0], f = s10[1];
      return `
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `;
    }
    let { newShape: i, keptDims: a } = x.squeezeShape(r), u = i;
    if (u.length < r.length) {
      let m = _m(e28, u), f = ["row", "col"];
      return `
      ${$m(m, t)}
      float ${o}(int row, int col) {
        return ${o}(${Om(f, a)});
      }
    `;
    }
    if (e28.shapeInfo.isUniform) return `
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${r[1]}, 1)));
        ${Fm(e28)}
      }
    `;
    let l = s10[0], c = s10[1], p = ec(n);
    return c === 1 ? t ? `
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    ` : `
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${r[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  ` : l === 1 ? t ? `
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    ` : `
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${r[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  ` : t ? `
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    ` : `
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${r[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`;
  }
  function O9(e28, t) {
    let r = e28.shapeInfo.logicalShape, n = e28.name, o = "get" + n.charAt(0).toUpperCase() + n.slice(1), s10 = e28.shapeInfo.texShape, i = [Math.ceil(s10[0] / 2), Math.ceil(s10[1] / 2)];
    if (r[0] === 1) {
      let m = r.slice(1), f = [1, 2], h = _m(e28, m), d = ["b", "row", "col"];
      return `
        ${BO(h, t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Om(d, f)});
        }
      `;
    }
    let a = Le();
    if (t) return `
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;
    let u = i[0], l = i[1], c = Math.ceil(r[2] / 2), p = c * Math.ceil(r[1] / 2);
    return `
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;
  }
  function R9(e28, t) {
    let r = e28.shapeInfo.logicalShape, n = e28.name, o = "get" + n.charAt(0).toUpperCase() + n.slice(1), s10 = r[1] * r[2], i = r[2], { newShape: a, keptDims: u } = x.squeezeShape(r), l = a;
    if (l.length < r.length) {
      let d = _m(e28, l), g = ["row", "col", "depth"];
      return `
        ${$m(d, t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Om(g, u)});
        }
      `;
    }
    if (e28.shapeInfo.isUniform) return `
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s10}, ${i}, 1)));
        ${Fm(e28)}
      }
    `;
    let c = e28.shapeInfo.texShape, p = c[0], m = c[1], f = e28.shapeInfo.flatOffset;
    if (m === s10 && f == null) return t ? `
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    ` : `
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;
    if (m === i && f == null) return t ? `
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    ` : `
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${r[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;
    let h = ec(n);
    return t ? `
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${h};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    ` : `
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s10} + col * ${i} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `;
  }
  function P9(e28, t) {
    let r = e28.name, n = "get" + r.charAt(0).toUpperCase() + r.slice(1), o = Le();
    if (t) return `
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${r}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${r}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${r}, uv);
    }
  `;
    let s10 = e28.shapeInfo.logicalShape, i = s10.length, a = e28.shapeInfo.texShape, u = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)], l = u[0], c = u[1], p = Math.ceil(s10[i - 1] / 2), m = p * Math.ceil(s10[i - 2] / 2), f = "int b, int row, int col", h = `b * ${m} + (row / 2) * ${p} + (col / 2)`;
    for (let d = 2; d < i - 1; d++) f = `int b${d}, ` + f, m *= s10[i - d - 1], h = `b${d} * ${m} + ` + h;
    return `
    vec4 ${n}(${f}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${r}, uv);
    }
  `;
  }
  function L9(e28, t) {
    let r = e28.shapeInfo.logicalShape, n = e28.name, o = "get" + n.charAt(0).toUpperCase() + n.slice(1), s10 = r[3], i = r[2] * s10, a = r[1] * i, { newShape: u, keptDims: l } = x.squeezeShape(r);
    if (u.length < r.length) {
      let b = _m(e28, u), v = ["row", "col", "depth", "depth2"];
      return `
      ${$m(b, t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Om(v, l)});
      }
    `;
    }
    if (e28.shapeInfo.isUniform) return `
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s10}, 1)));
        ${Fm(e28)}
      }
    `;
    let c = e28.shapeInfo.flatOffset, p = e28.shapeInfo.texShape, m = p[0], f = p[1], h = `int stride2 = ${n}Shape[3];`, d = `int stride1 = ${n}Shape[2] * stride2;`, g = `int stride0 = ${n}Shape[1] * stride1;`;
    if (f === a && c == null) return t ? `
      float ${o}(int row, int col, int depth, int depth2) {
        ${h}
        ${d}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    ` : `
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s10}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;
    if (f === s10 && c == null) return t ? `
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    ` : `
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r[1] * r[2]}, ${r[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;
    let y = ec(n);
    return t ? `
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${d}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  ` : `
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s10} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `;
  }
  function M9(e28) {
    let t = e28.shapeInfo.logicalShape, r = e28.name, n = "get" + r.charAt(0).toUpperCase() + r.slice(1), o = t[4], s10 = t[3] * o, i = t[2] * s10, a = t[1] * i, { newShape: u, keptDims: l } = x.squeezeShape(t);
    if (u.length < t.length) {
      let d = _m(e28, u), g = ["row", "col", "depth", "depth2", "depth3"];
      return `
      ${$m(d)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Om(g, l)});
      }
    `;
    }
    if (e28.shapeInfo.isUniform) return `
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s10}, ${o})) +
          depth3;
        ${Fm(e28)}
      }
    `;
    let c = e28.shapeInfo.flatOffset, p = e28.shapeInfo.texShape, m = p[0], f = p[1];
    if (f === a && c == null) return `
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s10}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    if (f === o && c == null) return `
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3]},
               ${t[2] * t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    let h = ec(r);
    return `
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s10} +
          depth2 * ${o} + depth3 + ${h};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${r}, uv);
    }
  `;
  }
  function z9(e28) {
    let t = e28.shapeInfo.logicalShape, r = e28.name, n = "get" + r.charAt(0).toUpperCase() + r.slice(1), { newShape: o, keptDims: s10 } = x.squeezeShape(t);
    if (o.length < t.length) {
      let g = _m(e28, o), y = ["row", "col", "depth", "depth2", "depth3", "depth4"];
      return `
      ${$m(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Om(y, s10)});
      }
    `;
    }
    let i = t[5], a = t[4] * i, u = t[3] * a, l = t[2] * u, c = t[1] * l;
    if (e28.shapeInfo.isUniform) return `
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Fm(e28)}
      }
    `;
    let p = e28.shapeInfo.flatOffset, m = e28.shapeInfo.texShape, f = m[0], h = m[1];
    if (h === c && p == null) return `
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    if (h === i && p == null) return `
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3] * t[4]},
               ${t[2] * t[3] * t[4]},
               ${t[3] * t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    let d = ec(r);
    return `
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${d};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${r}, uv);
    }
  `;
  }
  function Fm(e28) {
    let t = e28.name, r = x.sizeFromShape(e28.shapeInfo.logicalShape);
    return r < 2 ? `return ${t};` : `
    for (int i = 0; i < ${r}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `;
  }
  function B9(e28, t) {
    let r = e28.name, n = r.charAt(0).toUpperCase() + r.slice(1), o = "get" + n + "AtOutCoords", s10 = e28.shapeInfo.logicalShape.length, i = t.logicalShape.length, a = MO(e28.shapeInfo.logicalShape, t.logicalShape), u = Wt(i), l = i - s10, c, p = ["x", "y", "z", "w", "u", "v"];
    s10 === 0 ? c = "" : i < 2 && a.length >= 1 ? c = "coords = 0;" : c = a.map((b) => `coords.${p[b + l]} = 0;`).join(`
`);
    let m = "";
    i < 2 && s10 > 0 ? m = "coords" : m = e28.shapeInfo.logicalShape.map((b, v) => `coords.${p[v + l]}`).join(", ");
    let f = "return outputValue;", d = x.sizeFromShape(e28.shapeInfo.logicalShape) === 1, y = x.sizeFromShape(t.logicalShape) === 1;
    if (s10 === 1 && !d && !y) f = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    else if (d && !y) i === 1 ? f = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : f = `
        return vec4(outputValue.x);
      `;
    else if (a.length) {
      let b = s10 - 2, v = s10 - 1;
      a.indexOf(b) > -1 && a.indexOf(v) > -1 ? f = "return vec4(outputValue.x);" : a.indexOf(b) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : a.indexOf(v) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);");
    }
    return `
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `;
  }
  function V9(e28, t) {
    let r = e28.name, n = r.charAt(0).toUpperCase() + r.slice(1), o = "get" + n + "AtOutCoords", s10 = t.texShape, i = e28.shapeInfo.texShape, a = e28.shapeInfo.logicalShape.length, u = t.logicalShape.length;
    if (!e28.shapeInfo.isUniform && a === u && e28.shapeInfo.flatOffset == null && x.arraysEqual(i, s10)) return `
      float ${o}() {
        return sampleTexture(${r}, resultUV);
      }
    `;
    let l = Wt(u), c = MO(e28.shapeInfo.logicalShape, t.logicalShape), p = u - a, m, f = ["x", "y", "z", "w", "u", "v"];
    a === 0 ? m = "" : u < 2 && c.length >= 1 ? m = "coords = 0;" : m = c.map((d) => `coords.${f[d + p]} = 0;`).join(`
`);
    let h = "";
    return u < 2 && a > 0 ? h = "coords" : h = e28.shapeInfo.logicalShape.map((d, g) => `coords.${f[g + p]}`).join(", "), `
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${h});
    }
  `;
  }
  function Wt(e28) {
    if (e28 <= 1) return "int";
    if (e28 === 2) return "ivec2";
    if (e28 === 3) return "ivec3";
    if (e28 === 4) return "ivec4";
    if (e28 === 5) return "ivec5";
    if (e28 === 6) return "ivec6";
    throw Error(`GPU for rank ${e28} is not yet supported`);
  }
  function s0(e28, t, r) {
    let { newShape: n, keptDims: o } = x.squeezeShape(t), s10 = t.length, i = e28 && s10 === 3 && t[0] === 1, a = i ? t.slice(1) : n, u = !e28 && s10 > 1 && !x.arraysEqual(t, r) && n.length < s10 || i;
    return { useSqueezeShape: u, uniformShape: u ? a : t, keptDims: o };
  }
  function _m(e28, t) {
    let r = JSON.parse(JSON.stringify(e28));
    return r.shapeInfo.logicalShape = t, r;
  }
  function Om(e28, t) {
    return t.map((r) => e28[r]).join(", ");
  }
  function WO(e28, t, r, n) {
    let o = r.map((c, p) => {
      let m = { logicalShape: c.shape, texShape: c.isUniform ? null : c.texData.texShape, isUniform: c.isUniform, isPacked: c.isUniform ? false : c.texData.isPacked, flatOffset: null };
      return c.texData != null && c.texData.slice != null && c.texData.slice.flatOffset > 0 && (m.flatOffset = c.texData.slice.flatOffset), { name: t.variableNames[p], shapeInfo: m };
    }), s10 = o.map((c) => c.shapeInfo), i = { logicalShape: n.shape, texShape: n.texData.texShape, isUniform: false, isPacked: n.texData.isPacked, flatOffset: null }, a = zO(o, i, t), u = bO(e28.gl, a), l = e28.createProgram(u);
    return z().get("ENGINE_COMPILE_ONLY") ? { program: t, fragmentShader: u, source: a, webGLProgram: l, inShapeInfos: s10, outShapeInfo: i, variablesLocations: null, customUniformLocations: null, infLoc: null, nanLoc: null, outShapeLocation: null, outShapeStridesLocation: null, outTexShapeLocation: null } : (e28.buildVao(l), Object.assign({ program: t, fragmentShader: u, source: a, webGLProgram: l, inShapeInfos: s10, outShapeInfo: i }, oS(e28, t, l)));
  }
  function oS(e28, t, r) {
    let n = [], o = [], s10, i, a, u = null, l = null;
    l = e28.getUniformLocation(r, "NAN", false), z().getNumber("WEBGL_VERSION") === 1 && (u = e28.getUniformLocation(r, "INFINITY", false));
    let c = false;
    for (let p of t.variableNames) {
      let m = { name: p, uniform: e28.getUniformLocation(r, p, c), offset: e28.getUniformLocation(r, `offset${p}`, c) };
      t.enableShapeUniforms && (m.shape = e28.getUniformLocation(r, `${p}Shape`, c), m.texShape = e28.getUniformLocation(r, `${p}TexShape`, c)), n.push(m);
    }
    if (t.enableShapeUniforms && (s10 = e28.getUniformLocation(r, "outShape", c), a = e28.getUniformLocation(r, "outShapeStrides", c), i = e28.getUniformLocation(r, "outTexShape", c)), t.customUniforms) for (let p of t.customUniforms) o.push(e28.getUniformLocation(r, p.name, c));
    return { variablesLocations: n, customUniformLocations: o, infLoc: u, nanLoc: l, outShapeLocation: s10, outShapeStridesLocation: a, outTexShapeLocation: i };
  }
  function GO(e28, t) {
    if (e28.length !== t.length) throw Error(`Binary was compiled with ${e28.length} inputs, but was executed with ${t.length} inputs`);
    e28.forEach((r, n) => {
      let o = r.logicalShape, s10 = t[n], i = s10.shape;
      if (!x.arraysEqual(o, i)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);
      if (r.isUniform && s10.isUniform) return;
      let a = r.texShape, u = s10.isUniform ? null : s10.texData.texShape;
      if (!x.arraysEqual(a, u)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`);
    });
  }
  function UO(e28, t, r, n, o) {
    t.program.enableShapeUniforms || (GO(t.inShapeInfos, r), GO([t.outShapeInfo], [n]));
    let s10 = n.texData.texture, i = n.texData.texShape;
    n.texData.isPacked ? e28.setOutputPackedMatrixTexture(s10.texture, i[0], i[1]) : e28.setOutputMatrixTexture(s10.texture, i[0], i[1]), e28.setProgram(t.webGLProgram), e28.bindVertexArray(t.webGLProgram.vao), z().getNumber("WEBGL_VERSION") === 1 && t.infLoc !== null && e28.gl.uniform1f(t.infLoc, 1 / 0), t.nanLoc !== null && e28.gl.uniform1f(t.nanLoc, NaN);
    for (let u = 0; u < r.length; ++u) {
      let l = r[u], { uniform: c, offset: p, shape: m, texShape: f } = t.variablesLocations[u];
      if (m) {
        let { uniformShape: h } = s0(t.program.packedInputs, l.shape, l.texData.texShape);
        switch (h.length) {
          case 1:
            e28.gl.uniform1iv(m, new Int32Array(h));
            break;
          case 2:
            e28.gl.uniform2iv(m, new Int32Array(h));
            break;
          case 3:
            e28.gl.uniform3iv(m, new Int32Array(h));
            break;
          case 4:
            e28.gl.uniform4iv(m, new Int32Array(h));
            break;
          default:
            break;
        }
      }
      if (f && e28.gl.uniform2i(f, l.texData.texShape[0], l.texData.texShape[1]), c != null) {
        if (l.isUniform) {
          if (x.sizeFromShape(l.shape) < 2) e28.gl.uniform1f(c, l.uniformValues[0]);
          else {
            let h = l.uniformValues;
            h instanceof Float32Array || (h = new Float32Array(h)), e28.gl.uniform1fv(c, h);
          }
          continue;
        }
        l.texData.slice != null && p != null && e28.gl.uniform1i(p, l.texData.slice.flatOffset), e28.setInputMatrixTexture(l.texData.texture.texture, c, u);
      }
    }
    let a = t.outShapeLocation;
    if (a) switch (n.shape.length) {
      case 1:
        e28.gl.uniform1iv(a, new Int32Array(n.shape));
        break;
      case 2:
        e28.gl.uniform2iv(a, new Int32Array(n.shape));
        break;
      case 3:
        e28.gl.uniform3iv(a, new Int32Array(n.shape));
        break;
      case 4:
        e28.gl.uniform4iv(a, new Int32Array(n.shape));
        break;
      default:
        break;
    }
    if (t.outShapeStridesLocation) {
      let u = x.computeStrides(n.shape);
      switch (n.shape.length) {
        case 2:
          e28.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(u));
          break;
        case 3:
          e28.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(u));
          break;
        case 4:
          e28.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(u));
          break;
        default:
          break;
      }
    }
    if (t.outTexShapeLocation && e28.gl.uniform2i(t.outTexShapeLocation, n.texData.texShape[0], n.texData.texShape[1]), t.program.customUniforms && o) for (let u = 0; u < t.program.customUniforms.length; ++u) {
      let l = t.program.customUniforms[u], c = t.customUniformLocations[u], p = o[u];
      if (l.type === "float") e28.gl.uniform1fv(c, p);
      else if (l.type === "vec2") e28.gl.uniform2fv(c, p);
      else if (l.type === "vec3") e28.gl.uniform3fv(c, p);
      else if (l.type === "vec4") e28.gl.uniform4fv(c, p);
      else if (l.type === "int") e28.gl.uniform1iv(c, p);
      else if (l.type === "ivec2") e28.gl.uniform2iv(c, p);
      else if (l.type === "ivec3") e28.gl.uniform3iv(c, p);
      else if (l.type === "ivec4") e28.gl.uniform4iv(c, p);
      else throw Error(`uniform type ${l.type} is not supported yet.`);
    }
    e28.executeProgram();
  }
  function jO(e28, t, r) {
    let n = "";
    t.concat(r).forEach((i) => {
      let a = i.texData != null && i.texData.slice != null && i.texData.slice.flatOffset > 0;
      if (e28.enableShapeUniforms && !i.isUniform) {
        let u = i.texData.texShape, { useSqueezeShape: l, uniformShape: c, keptDims: p } = s0(e28.packedInputs, i.shape, u), m = "", f = "", h = "";
        if (c.length === 1 && e28.packedInputs) {
          let N = [Math.ceil(u[0] / 2), Math.ceil(u[1] / 2)];
          m = `${N[0] > 1}_${N[1] > 1}`;
        } else if (c.length === 2 && !e28.packedInputs) f = `${c[0] > 1}_${c[1] > 1}`;
        else if (c.length > 2 && !e28.packedInputs) {
          let N = x.computeStrides(c);
          h = `${N[0] === u[1]}_${N[N.length - 1] === u[1]}`;
        }
        let d = i.shape.length, g = c.length === 2 && x.arraysEqual(i.shape, u), y = x.sizeFromShape(i.shape) === 1, b = C.getBroadcastDims(i.shape, r.shape), v = !e28.packedInputs && d === r.shape.length && x.arraysEqual(u, r.texData.texShape), w = e28.packedInputs || c.length > 2 ? "" : `${u[0] > 1}_${u[1] > 1}`;
        n += `${d}_${v}_${l ? p : ""}_${c.length}_${y}_${b}_${g}_${m}_${f}_${h}_${w}_${a}`;
      } else {
        let u = i.isUniform ? "uniform" : i.texData.texShape;
        n += `${i.shape}_${u}_${a}`;
      }
    });
    let o = e28.userCode, s10 = e28.constructor.name;
    return s10 += "_" + n + "_" + o + `${z().getNumber("WEBGL_VERSION")}`, s10;
  }
  function fe(e28) {
    return z().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e28 <= 4;
  }
  var i0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = Lu.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let r = Le();
      this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? tc(["r", "c", "d"], t) : ts(["r", "c", "d"], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${r.output} = result;
      }
    `;
    }
  };
  var a0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = Lu.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let r = Le();
      this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? tc(["r", "c", "d"], t) : ts(["r", "c", "d"], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${r.output} = result;
      }
    `;
    }
  };
  var u0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.outTexUsage = Kr.DOWNLOAD;
      let r = Le();
      this.outputShape = t, this.userCode = `
      ${o0}

      void main() {
        float x = getAAtOutCoords();
        ${r.output} = encode_float(x);
      }
    `;
    }
  };
  var l0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = Kr.DOWNLOAD;
      let r = Le();
      this.outputShape = t, this.userCode = `
      ${o0}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${r.output} = encode_float(x);
      }
    `;
    }
  };
  var U9 = { R: 0, G: 1, B: 2, A: 3 };
  var lg = class {
    constructor(t, r = false, n = "RGBA") {
      this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let o = Le();
      this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length);
      let s10 = "result";
      r && (s10 = "floor(result * 255. + 0.5)");
      let i = "";
      for (let a = 0; a < n.length; a++) {
        let u = n[a];
        i += `
          if(offset == ${a}) {
            result = values[${U9[u]}];
          }`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? Am() : Em(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s10}, 0., 0., 0.);
      }
    `;
    }
  };
  var c0 = class {
    constructor(t, r = false) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let n = Le();
      this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length);
      let o = "", s10 = "result";
      r && (s10 = "floor(result * 255. + 0.5)");
      for (let i = 0; i <= 1; i++) for (let a = 0; a <= 1; a++) {
        let u = i * 2 + a;
        o += `
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms ? "outShape[2]" : `${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms ? "outShape[1]" : `${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `;
      }
      this.userCode = `
        ${this.enableShapeUniforms ? Am() : Em(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s10};
        }
    `;
    }
  };
  function HO(e28) {
    let t = Le(), r = `${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return xO(e28, r);
  }
  function KO(e28) {
    let t = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return NO(e28, t);
  }
  function qO(e28) {
    let t = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return CO(e28, t);
  }
  function cg(e28, t, r, n, o, s10) {
    IO(t, r);
    let i = SO(e28), a = e28.TEXTURE_2D;
    return vt(e28, () => e28.bindTexture(a, i)), vt(e28, () => e28.texParameteri(a, e28.TEXTURE_WRAP_S, e28.CLAMP_TO_EDGE)), vt(e28, () => e28.texParameteri(a, e28.TEXTURE_WRAP_T, e28.CLAMP_TO_EDGE)), vt(e28, () => e28.texParameteri(a, e28.TEXTURE_MIN_FILTER, e28.NEAREST)), vt(e28, () => e28.texParameteri(a, e28.TEXTURE_MAG_FILTER, e28.NEAREST)), z().getNumber("WEBGL_VERSION") === 1 ? vt(e28, () => e28.texImage2D(a, 0, n, t, r, 0, o, s10, null)) : vt(e28, () => e28.texStorage2D(a, 1, n, t, r)), vt(e28, () => e28.bindTexture(e28.TEXTURE_2D, null)), { texture: i, texShape: [r, t] };
  }
  function sS(e28) {
    return e28.internalFormatFloat;
  }
  function XO(e28, t, r, n) {
    let [o, s10] = Zl(t, r);
    return cg(e28, o, s10, sS(n), n.textureFormatFloat, e28.FLOAT);
  }
  function iS(e28) {
    return e28.internalFormatHalfFloat;
  }
  function YO(e28, t, r, n) {
    let [o, s10] = Zl(t, r);
    return cg(e28, o, s10, iS(n), n.textureFormatFloat, n.textureTypeHalfFloat);
  }
  function aS(e28) {
    return e28.downloadTextureFormat;
  }
  function JO(e28, t, r, n) {
    let [o, s10] = Zl(t, r);
    return cg(e28, o, s10, aS(n), e28.RGBA, e28.UNSIGNED_BYTE);
  }
  function uS(e28) {
    return e28.internalFormatPackedFloat;
  }
  function ZO(e28, t, r, n) {
    let [o, s10] = _s(t, r);
    return cg(e28, o, s10, uS(n), e28.RGBA, e28.FLOAT);
  }
  function lS(e28) {
    return e28.internalFormatPackedHalfFloat;
  }
  function QO(e28, t, r, n) {
    let [o, s10] = _s(t, r);
    return cg(e28, o, s10, lS(n), e28.RGBA, n.textureTypeHalfFloat);
  }
  function tR(e28, t, r) {
    return vt(e28, () => e28.bindBuffer(e28.ARRAY_BUFFER, r)), eS(e28, t, "clipSpacePos", r, 3, 20, 0) && eS(e28, t, "uv", r, 2, 20, 12);
  }
  function eR(e28, t, r, n, o, s10) {
    vt(e28, () => e28.bindTexture(e28.TEXTURE_2D, t));
    let i, a, u;
    o instanceof Uint8Array ? (i = new Uint8Array(r * n * 4), a = e28.UNSIGNED_BYTE, u = e28.RGBA) : (i = new Float32Array(r * n * 4), a = e28.FLOAT, u = s10.internalFormatPackedFloat), i.set(o), z().getNumber("WEBGL_VERSION") === 2 ? vt(e28, () => e28.texSubImage2D(e28.TEXTURE_2D, 0, 0, 0, r, n, e28.RGBA, a, i)) : vt(e28, () => e28.texImage2D(e28.TEXTURE_2D, 0, u, r, n, 0, e28.RGBA, a, i)), vt(e28, () => e28.bindTexture(e28.TEXTURE_2D, null));
  }
  function rR(e28, t, r) {
    vt(e28, () => e28.bindTexture(e28.TEXTURE_2D, t)), r.data instanceof Uint8Array ? z().getNumber("WEBGL_VERSION") === 2 ? vt(e28, () => e28.texSubImage2D(e28.TEXTURE_2D, 0, 0, 0, r.width, r.height, e28.RGBA, e28.UNSIGNED_BYTE, r.data)) : vt(e28, () => e28.texImage2D(e28.TEXTURE_2D, 0, e28.RGBA, r.width, r.height, 0, e28.RGBA, e28.UNSIGNED_BYTE, r.data)) : z().getNumber("WEBGL_VERSION") === 2 ? vt(e28, () => e28.texSubImage2D(e28.TEXTURE_2D, 0, 0, 0, e28.RGBA, e28.UNSIGNED_BYTE, r)) : vt(e28, () => e28.texImage2D(e28.TEXTURE_2D, 0, e28.RGBA, e28.RGBA, e28.UNSIGNED_BYTE, r)), vt(e28, () => e28.bindTexture(e28.TEXTURE_2D, null));
  }
  function nR(e28, t, r, n) {
    let o = e28.createBuffer();
    vt(e28, () => e28.bindBuffer(e28.PIXEL_PACK_BUFFER, o));
    let a = 4 * 4 * t * r;
    return vt(e28, () => e28.bufferData(e28.PIXEL_PACK_BUFFER, a, e28.STREAM_READ)), vt(e28, () => e28.readPixels(0, 0, r, t, e28.RGBA, e28.FLOAT, 0)), vt(e28, () => e28.bindBuffer(e28.PIXEL_PACK_BUFFER, null)), o;
  }
  function oR(e28, t, r) {
    let n = e28, o = new Float32Array(r);
    return n.bindBuffer(n.PIXEL_PACK_BUFFER, t), n.getBufferSubData(n.PIXEL_PACK_BUFFER, 0, o), n.bindBuffer(n.PIXEL_PACK_BUFFER, null), o;
  }
  function sR(e28, t, r, n) {
    let [o, s10] = Zl(t, r), i = 4, a = new Uint8Array(dO(t * r, i));
    return vt(e28, () => e28.readPixels(0, 0, o, s10, n.downloadTextureFormat, e28.UNSIGNED_BYTE, a)), new Float32Array(a.buffer);
  }
  function iR(e28, t, r, n, o, s10, i, a) {
    let u = e28, l = new Float32Array(gO(s10, i));
    return u.bindBuffer(u.PIXEL_PACK_BUFFER, t), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), l;
  }
  function aR(e28, t, r) {
    let n = new Float32Array(t * r * 4);
    return vt(e28, () => e28.readPixels(0, 0, r, t, e28.RGBA, e28.FLOAT, n)), n;
  }
  var Rm = class {
    constructor(t) {
      this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
      let r = z().getNumber("WEBGL_VERSION");
      if (t != null ? (this.gl = t, hO(r, t)) : this.gl = Bn(r), t = this.gl, z().getNumber("WEBGL_VERSION") === 2) {
        let s10 = t;
        this.createVertexArray = () => vt(s10, () => s10.createVertexArray()), this.bindVertexArray = (i) => vt(s10, () => s10.bindVertexArray(i)), this.deleteVertexArray = (i) => vt(s10, () => s10.deleteVertexArray(i)), this.getVertexArray = () => vt(s10, () => s10.getParameter(s10.VERTEX_ARRAY_BINDING));
      } else if (t != null) {
        let s10 = t.getExtension("OES_vertex_array_object");
        if (s10 == null) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        this.createVertexArray = () => vt(t, () => s10.createVertexArrayOES()), this.bindVertexArray = (i) => vt(t, () => s10.bindVertexArrayOES(i)), this.deleteVertexArray = (i) => vt(t, () => s10.deleteVertexArrayOES(i)), this.getVertexArray = () => vt(t, () => t.getParameter(s10.VERTEX_ARRAY_BINDING_OES));
      }
      let n = "WEBGL_color_buffer_float", o = "EXT_color_buffer_half_float";
      if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), z().getNumber("WEBGL_VERSION") === 1) {
        let s10 = "OES_texture_float", i = "OES_texture_half_float";
        if (this.textureFloatExtension = ig(this.gl, s10), no(this.gl, i)) this.textureHalfFloatExtension = ig(this.gl, i);
        else if (z().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        if (this.colorBufferFloatExtension = this.gl.getExtension(n), no(this.gl, o)) this.colorBufferHalfFloatExtension = ig(this.gl, o);
        else if (z().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      } else if (n = "EXT_color_buffer_float", no(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);
      else if (no(this.gl, o)) this.colorBufferHalfFloatExtension = this.gl.getExtension(o);
      else throw new Error("GL context does not support color renderable floats");
      this.vertexBuffer = KO(this.gl), this.indexBuffer = qO(this.gl), this.framebuffer = TO(this.gl), this.textureConfig = sg(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return z().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed) return;
      this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      let t = this.gl;
      vt(t, () => t.finish()), vt(t, () => t.bindFramebuffer(t.FRAMEBUFFER, null)), vt(t, () => t.deleteFramebuffer(this.framebuffer)), vt(t, () => t.bindBuffer(t.ARRAY_BUFFER, null)), vt(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)), vt(t, () => t.deleteBuffer(this.indexBuffer)), this.disposed = true;
    }
    createFloat32MatrixTexture(t, r) {
      return this.throwIfDisposed(), XO(this.gl, t, r, this.textureConfig);
    }
    createFloat16MatrixTexture(t, r) {
      return this.throwIfDisposed(), YO(this.gl, t, r, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(t, r) {
      return this.throwIfDisposed(), JO(this.gl, t, r, this.textureConfig);
    }
    uploadPixelDataToTexture(t, r) {
      this.throwIfDisposed(), rR(this.gl, t, r);
    }
    uploadDenseMatrixToTexture(t, r, n, o) {
      this.throwIfDisposed(), eR(this.gl, t, r, n, o, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(t, r) {
      return this.throwIfDisposed(), QO(this.gl, t, r, this.textureConfig);
    }
    createPackedMatrixTexture(t, r) {
      return this.throwIfDisposed(), ZO(this.gl, t, r, this.textureConfig);
    }
    deleteMatrixTexture(t) {
      this.throwIfDisposed(), this.outputTexture === t && (rS(this.gl, this.framebuffer), this.outputTexture = null), vt(this.gl, () => this.gl.deleteTexture(t));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(t, r, n) {
      return this.downloadMatrixDriver(t, () => sR(this.gl, r, n, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(t, r, n, o, s10, i) {
      return iR(this.gl, t, r, n, o, s10, i, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(t, r) {
      return oR(this.gl, t, r);
    }
    createBufferFromTexture(t, r, n) {
      this.bindTextureToFrameBuffer(t);
      let o = nR(this.gl, r, n, this.textureConfig);
      return this.unbindTextureToFrameBuffer(), o;
    }
    createAndWaitForFence() {
      let t = this.createFence(this.gl);
      return this.pollFence(t);
    }
    createFence(t) {
      let r, n;
      if (z().getBool("WEBGL_FENCE_API_ENABLED")) {
        let o = t, s10 = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
        t.flush(), n = () => {
          let i = o.clientWaitSync(s10, 0, 0);
          return i === o.ALREADY_SIGNALED || i === o.CONDITION_SATISFIED;
        }, r = s10;
      } else z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (r = this.beginQuery(), this.endQuery(), n = () => this.isQueryAvailable(r, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n = () => true;
      return { query: r, isFencePassed: n };
    }
    downloadMatrixFromPackedTexture(t, r, n) {
      return this.downloadMatrixDriver(t, () => aR(this.gl, r, n));
    }
    createProgram(t) {
      this.throwIfDisposed();
      let r = this.gl;
      this.vertexShader == null && (this.vertexShader = HO(r));
      let n = wO(r);
      vt(r, () => r.attachShader(n, this.vertexShader)), vt(r, () => r.attachShader(n, t)), vO(r, n);
      let o = Object.assign(n, { vao: this.createVertexArray() });
      return this.debug && e0(r, o), o;
    }
    buildVao(t) {
      this.setProgram(t), this.bindVertexArray(t.vao);
      let r = this.gl;
      vt(r, () => r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), tR(r, t, this.vertexBuffer);
    }
    deleteProgram(t) {
      this.throwIfDisposed(), t === this.program && (this.program = null), t != null && (vt(this.gl, () => this.gl.deleteProgram(t)), this.deleteVertexArray(t.vao));
    }
    setProgram(t) {
      this.throwIfDisposed(), this.program = t, this.program != null && this.debug && e0(this.gl, this.program), vt(this.gl, () => this.gl.useProgram(t));
    }
    getUniformLocation(t, r, n = true) {
      return this.throwIfDisposed(), n ? kO(this.gl, t, r) : EO(this.gl, t, r);
    }
    getAttributeLocation(t, r) {
      return this.throwIfDisposed(), vt(this.gl, () => this.gl.getAttribLocation(t, r));
    }
    getUniformLocationNoThrow(t, r) {
      return this.throwIfDisposed(), this.gl.getUniformLocation(t, r);
    }
    setInputMatrixTexture(t, r, n) {
      this.throwIfDisposed(), this.throwIfNoProgram(), AO(this.gl, t, r, n);
    }
    setOutputMatrixTexture(t, r, n) {
      this.setOutputMatrixTextureDriver(t, n, r);
    }
    setOutputPackedMatrixTexture(t, r, n) {
      this.throwIfDisposed();
      let [o, s10] = _s(r, n);
      this.setOutputMatrixTextureDriver(t, o, s10);
    }
    setOutputMatrixWriteRegion(t, r, n, o) {
      this.setOutputMatrixWriteRegionDriver(n, t, o, r);
    }
    setOutputPackedMatrixWriteRegion(t, r, n, o) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      this.program != null && e0(this.gl, this.program), ag(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed(), this.throwIfNoProgram();
      let t = this.gl;
      if (this.debug) {
        let r = this.getVertexArray();
        console.assert(r === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
      }
      vt(t, () => t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed(), vt(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = ig(this.gl, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        let n = this.gl, o = this.getQueryTimerExtensionWebGL2(), s10 = n.createQuery();
        return n.beginQuery(o.TIME_ELAPSED_EXT, s10), s10;
      }
      let t = this.getQueryTimerExtensionWebGL1(), r = t.createQueryEXT();
      return t.beginQueryEXT(t.TIME_ELAPSED_EXT, r), r;
    }
    endQuery() {
      if (z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        let r = this.gl, n = this.getQueryTimerExtensionWebGL2();
        r.endQuery(n.TIME_ELAPSED_EXT);
        return;
      }
      let t = this.getQueryTimerExtensionWebGL1();
      t.endQueryEXT(t.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(t) {
      return await x.repeatedTry(() => this.disposed || this.isQueryAvailable(t, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(t, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(t, r) {
      if (r === 0) return null;
      if (r === 2) {
        let n = this.gl;
        return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
      } else {
        let n = this.getQueryTimerExtensionWebGL1();
        return n.getQueryObjectEXT(t, n.QUERY_RESULT_EXT) / 1e6;
      }
    }
    isQueryAvailable(t, r) {
      if (r === 0) return true;
      if (r === 2) {
        let n = this.gl, o = this.getQueryTimerExtensionWebGL2(), s10 = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(o.GPU_DISJOINT_EXT)), s10 && !this.disjoint;
      } else {
        let n = this.getQueryTimerExtensionWebGL1(), o = n.getQueryObjectEXT(t, n.QUERY_RESULT_AVAILABLE_EXT);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)), o && !this.disjoint;
      }
    }
    pollFence(t) {
      return new Promise((r) => {
        this.addItemToPoll(() => t.isFencePassed(), () => r());
      });
    }
    pollItems() {
      let t = H9(this.itemsToPoll.map((r) => r.isDoneFn));
      for (let r = 0; r <= t; ++r) {
        let { resolveFn: n } = this.itemsToPoll[r];
        n();
      }
      this.itemsToPoll = this.itemsToPoll.slice(t + 1);
    }
    addItemToPoll(t, r) {
      if (this.itemsToPoll.push({ isDoneFn: t, resolveFn: r }), this.itemsToPoll.length > 1) return;
      let n;
      "setTimeoutCustom" in z().platform && (n = z().platform.setTimeoutCustom.bind(z().platform)), x.repeatedTry(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, n);
    }
    bindTextureToFrameBuffer(t) {
      this.throwIfDisposed(), r0(this.gl, t, this.framebuffer), this.debug && ag(this.gl);
    }
    unbindTextureToFrameBuffer() {
      this.outputTexture != null ? (r0(this.gl, this.outputTexture, this.framebuffer), this.debug && ag(this.gl)) : rS(this.gl, this.framebuffer);
    }
    downloadMatrixDriver(t, r) {
      this.bindTextureToFrameBuffer(t);
      let n = r();
      return this.unbindTextureToFrameBuffer(), n;
    }
    setOutputMatrixTextureDriver(t, r, n) {
      this.throwIfDisposed();
      let o = this.gl;
      r0(o, t, this.framebuffer), this.debug && ag(o), this.outputTexture = t, vt(o, () => o.viewport(0, 0, r, n)), vt(o, () => o.scissor(0, 0, r, n));
    }
    setOutputMatrixWriteRegionDriver(t, r, n, o) {
      this.throwIfDisposed(), vt(this.gl, () => this.gl.scissor(t, r, n, o));
    }
    throwIfDisposed() {
      if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }
    throwIfNoProgram() {
      if (this.program == null) throw new Error("No GPU program is currently set.");
    }
  };
  function H9(e28) {
    let t = 0;
    for (; t < e28.length && e28[t](); ++t) ;
    return t - 1;
  }
  var { addImpl: uR, bincountImpl: p0, bincountReduceImpl: lR, bitwiseAndImpl: cR, castImpl: pR, ceilImpl: mR, concatImpl: fR, equalImpl: hR, expImpl: dR, expm1Impl: gR, floorImpl: yR, gatherNdImpl: xR, gatherV2Impl: bR, greaterImpl: wR, greaterEqualImpl: vR, lessImpl: NR, lessEqualImpl: CR, linSpaceImpl: SR, logImpl: IR, maxImpl: TR, maximumImpl: kR, minimumImpl: ER, multiplyImpl: AR, negImpl: DR, notEqualImpl: $R, prodImpl: FR, raggedGatherImpl: _R, raggedRangeImpl: OR, raggedTensorToTensorImpl: RR, rangeImpl: PR, rsqrtImpl: LR, scatterImpl: MR, sigmoidImpl: zR, simpleAbsImpl: m0, sliceImpl: BR, sparseFillEmptyRowsImpl: VR, sparseReshapeImpl: GR, sparseSegmentReductionImpl: f0, sqrtImpl: WR, staticRegexReplaceImpl: UR, stridedSliceImpl: jR, stringNGramsImpl: HR, stringSplitImpl: KR, stringToHashBucketFastImpl: qR, subImpl: XR, tileImpl: YR, topKImpl: JR, transposeImpl: rc, uniqueImpl: ZR } = LC;
  function cS(e28, t) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, t).map((r) => `${e28}.${r}`);
  }
  function Ze(e28, t) {
    return t === 1 ? [e28] : cS(e28, t);
  }
  function QR(e28, t) {
    if (e28 === 1) return "rc";
    let r = "";
    for (let n = 0; n < e28; n++) r += t[n], n < e28 - 1 && (r += ",");
    return r;
  }
  var h0 = class {
    constructor(t) {
      if (this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t, this.rank = t.length, this.enableShapeUniforms = fe(this.outputShape.length), this.rank === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      else {
        let r = Ze("rc", this.rank), n = Wt(this.rank), o = this.getOutOfBoundsCondition(r), s10 = this.getSetup(r), i = this.getOutput(r);
        this.userCode = `
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s10}

            setOutput(vec4(${i}));
          }
        }
      `;
      }
    }
    getSourceCoordsArr(t) {
      let r = [];
      for (let n = 0; n <= 1; n++) for (let o = 0; o <= 1; o++) {
        let s10 = `${n === 0 ? "r" : "rp1"}, ${o === 0 ? "c" : "cp1"}`;
        for (let i = 2; i < this.rank; i++) s10 = `${t[t.length - 1 - i]},` + s10;
        r.push(s10);
      }
      return r;
    }
    getOutOfBoundsCondition(t) {
      if (this.rank === 1) return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
      let r = "";
      for (let n = this.rank - 2; n < this.rank; n++) r += `${t[n]} >= ${this.enableShapeUniforms ? `outShape[${n}]` : this.outputShape[n]}`, n < this.rank - 1 && (r += "||");
      return r;
    }
    getSetup(t) {
      if (this.rank === 1) return "";
      let r = t.slice(-2), n = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], o = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
      return `
      int r = ${r[0]};
      int c = ${r[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `;
    }
    getOutput(t) {
      let r = this.getSourceCoordsArr(t);
      return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${r[0]}),
            cEdge ? 0. : getA(${r[1]}),
            rEdge ? 0. : getA(${r[2]}),
            rEdge || cEdge ? 0. : getA(${r[3]})`;
    }
  };
  var Pm = class {
    constructor(t, r) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length);
      let n = "";
      for (let o = 0; o < 4; o++) {
        let s10 = "thisRC = rc;";
        o % 2 === 1 && (s10 += "thisRC.z += 1;"), o > 1 && (s10 += "thisRC.y += 1;"), n += `
        ${s10}
        ${o > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${K9(r, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? Am() : Em(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : t[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : t[2]};

        ${n}

        setOutput(result);
      }
    `;
    }
  };
  function K9(e28, t) {
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t ? LO(["r", "c", "d"], "inputShape") : ts(["r", "c", "d"], e28)}
      return ivec3(r, c, d);
    }
  `;
  }
  var d0 = class {
    constructor(t) {
      this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = false;
    }
    acquireTexture(t, r, n) {
      let o = eP(r, n), s10 = rP(t, o, n);
      s10 in this.freeTextures || (this.freeTextures[s10] = []), s10 in this.usedTextures || (this.usedTextures[s10] = []);
      let i = tP(t, o, this.gpgpu.gl, this.gpgpu.textureConfig, n);
      if (this.freeTextures[s10].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= i, this.log();
        let u = this.freeTextures[s10].pop();
        return this.usedTextures[s10].push(u), u;
      }
      let a;
      return o === Pr.PACKED_2X2_FLOAT32 ? a = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Pr.PACKED_2X2_FLOAT16 ? a = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Pr.UNPACKED_FLOAT32 ? a = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Pr.UNPACKED_FLOAT16 ? a = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Pr.PACKED_4X1_UNSIGNED_BYTE && (a = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[s10].push(a), this.numUsedTextures++, this._numBytesAllocated += i, this.log(), a;
    }
    releaseTexture(t, r, n, o) {
      if (this.freeTextures == null) return;
      let s10 = eP(n, o), i = rP(r, s10, o);
      i in this.freeTextures || (this.freeTextures[i] = []);
      let a = tP(r, s10, this.gpgpu.gl, this.gpgpu.textureConfig, o), u = z().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
      u !== -1 && this._numBytesAllocated > u ? (this.gpgpu.deleteMatrixTexture(t.texture), this._numBytesAllocated -= a) : (this.freeTextures[i].push(t), this.numFreeTextures++, this._numBytesFree += a), this.numUsedTextures--;
      let l = this.usedTextures[i], c = l && l.indexOf(t);
      if (c == null || c < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      l[c] = l[l.length - 1], l.pop(), this.log();
    }
    log() {
      if (!this.logEnabled) return;
      let t = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${t})`);
      let r = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * r)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures != null) {
        for (let t in this.freeTextures) this.freeTextures[t].forEach((r) => {
          this.gpgpu.deleteMatrixTexture(r.texture);
        });
        for (let t in this.usedTextures) this.usedTextures[t].forEach((r) => {
          this.gpgpu.deleteMatrixTexture(r.texture);
        });
        this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
      }
    }
  };
  function q9(e28, t) {
    let r = e28;
    if (t === r.R32F) return 4;
    if (t === r.R16F) return 2;
    if (t === r.RGBA32F) return 16;
    if (t === e28.RGBA) return 16;
    if (t === r.RGBA16F) return 8;
    if (t === r.RGBA8) return 4;
    throw new Error(`Unknown internal format ${t}`);
  }
  function tP(e28, t, r, n, o) {
    let s10 = X9(t, n), i;
    if (o) {
      let [u, l] = _s(e28[0], e28[1]);
      i = u * l;
    } else {
      let [u, l] = Zl(e28[0], e28[1]);
      i = u * l;
    }
    let a = q9(r, s10);
    return i * a;
  }
  function X9(e28, t) {
    switch (e28) {
      case Pr.PACKED_2X2_FLOAT32:
        return uS(t);
      case Pr.PACKED_2X2_FLOAT16:
        return lS(t);
      case Pr.UNPACKED_FLOAT32:
        return sS(t);
      case Pr.UNPACKED_FLOAT16:
        return iS(t);
      case Pr.PACKED_4X1_UNSIGNED_BYTE:
        return aS(t);
      default:
        throw new Error(`Unknown physical texture type ${e28}`);
    }
  }
  function Y9(e28) {
    return z().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e28 ? Pr.PACKED_2X2_FLOAT32 : Pr.UNPACKED_FLOAT32 : e28 ? Pr.PACKED_2X2_FLOAT16 : Pr.UNPACKED_FLOAT16;
  }
  function eP(e28, t) {
    if (e28 === Kr.UPLOAD) return Pr.PACKED_2X2_FLOAT32;
    if (e28 === Kr.RENDER || e28 == null) return Y9(t);
    if (e28 === Kr.DOWNLOAD || e28 === Kr.PIXELS) return Pr.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error(`Unknown logical texture type ${e28}`);
  }
  function rP(e28, t, r) {
    return `${e28[0]}_${e28[1]}_${t}_${r}`;
  }
  var Lr = class {
    constructor(t, r) {
      this.variableNames = ["A"], this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${r}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  var gr = "if (isnan(x)) return x;";
  var nP = "return x;";
  var pS = "return abs(x);";
  var oP = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  var sP = gr + `
  return (x < 0.0) ? 0.0 : x;
`;
  var iP = gr + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var Rs = "return x;";
  var aP = "return 1.0 / (1.0 + exp(-1.0 * x));";
  var lP = "return x;";
  var cP = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var pP = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var mP = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var fP = "return 1.0 / (1.0 + exp(-1.0 * x));";
  var Sn = class {
    constructor(t, r) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${r}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  var g0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length);
      let r = t.length, n = Ze("rc", r), o = Wt(r), s10 = QR(r, n), i = n.slice(-2), a = r <= 1 ? "rc" : `vec2(${i.join(",")})`;
      this.userCode = `
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s10});

        setOutput(getChannel(packedInput, ${a}));
      }
    `;
    }
  };
  var Z9 = jr.whereImpl;
  var Q9 = 1e-7;
  var tY = 1e-4;
  var y0 = {};
  function eY(e28) {
    return e28 in y0 || (y0[e28] = {}), y0[e28];
  }
  var rY = z().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  var nY = 600;
  function oY() {
    return z().global.screen == null ? 1024 : z().global.screen.height * z().global.screen.width * window.devicePixelRatio * nY / 1024 / 1024;
  }
  var pg = class e27 extends qs {
    nextDataId() {
      return e27.nextDataId++;
    }
    constructor(t) {
      if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !z().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
      let r;
      if (t != null) {
        if (t instanceof Rm) r = t;
        else {
          let n = Bn(z().getNumber("WEBGL_VERSION"), t);
          r = new Rm(n);
        }
        this.binaryCache = {}, this.gpgpuCreatedLocally = false;
      } else {
        let n = Bn(z().getNumber("WEBGL_VERSION"));
        r = new Rm(n), this.binaryCache = eY(z().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = r, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new d0(this.gpgpu), this.numMBBeforeWarning = oY(), this.texData = new Qu(this, yo());
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    writeTexture(t, r, n, o, s10, i) {
      let a = this.makeTensorInfo(r, n), u = this.texData.get(a.dataId);
      u.isPacked = false, u.texture = { texture: t, texShape: [o, s10] }, u.texShape = [o, s10];
      let l = ug(r), c = new lg(l, false, i), p = this.runWebGLProgram(c, [a], n, [[o, s10]]);
      return p.shape = r, u.texture = null, this.disposeIntermediateTensorInfo(a), p.dataId;
    }
    write(t, r, n) {
      if ((z().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || z().getBool("DEBUG")) && this.checkNumericalProblems(t), n === "complex64" && t != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      let o = { id: this.nextDataId() };
      return this.texData.set(o, { shape: r, dtype: n, values: t, usage: Kr.UPLOAD, refCount: 1 }), o;
    }
    refCount(t) {
      return this.texData.has(t) ? this.texData.get(t).refCount : 0;
    }
    incRef(t) {
      let r = this.texData.get(t);
      r.refCount++;
    }
    decRef(t) {
      if (this.texData.has(t)) {
        let r = this.texData.get(t);
        r.refCount--;
      }
    }
    move(t, r, n, o, s10) {
      if (z().getBool("DEBUG") && this.checkNumericalProblems(r), o === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.texData.set(t, { shape: n, dtype: o, values: r, usage: Kr.UPLOAD, refCount: s10 });
    }
    disposeIntermediateTensorInfo(t) {
      this.disposeData(t.dataId);
    }
    readSync(t) {
      let r = this.texData.get(t), { values: n, dtype: o, complexTensorInfos: s10, slice: i, shape: a, isPacked: u } = r;
      if (i != null) {
        let m;
        u ? m = new Sn(a, Rs) : m = new Lr(a, Rs);
        let f = this.runWebGLProgram(m, [{ dataId: t, shape: a, dtype: o }], o), h = this.readSync(f.dataId);
        return this.disposeIntermediateTensorInfo(f), h;
      }
      if (n != null) return this.convertAndCacheOnCPU(t);
      if (o === "string") return n;
      let l = this.activeTimers != null, c;
      l && (c = x.now());
      let p;
      if (o === "complex64") {
        let m = this.readSync(s10.real.dataId), f = this.readSync(s10.imag.dataId);
        p = C.mergeRealAndImagArrays(m, f);
      } else p = this.getValuesFromTexture(t);
      return l && (this.downloadWaitMs += x.now() - c), this.convertAndCacheOnCPU(t, p);
    }
    async read(t) {
      if (this.pendingRead.has(t)) {
        let h = this.pendingRead.get(t);
        return new Promise((d) => h.push(d));
      }
      let r = this.texData.get(t), { values: n, shape: o, slice: s10, dtype: i, complexTensorInfos: a, isPacked: u } = r;
      if (s10 != null) {
        let h;
        u ? h = new Sn(o, Rs) : h = new Lr(o, Rs);
        let d = this.runWebGLProgram(h, [{ dataId: t, shape: o, dtype: i }], i), g = this.read(d.dataId);
        return this.disposeIntermediateTensorInfo(d), g;
      }
      if (n != null) return this.convertAndCacheOnCPU(t);
      if (z().getBool("DEBUG") && !z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && z().getNumber("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      let l = null, c;
      if (i !== "complex64" && z().get("WEBGL_BUFFER_SUPPORTED")) {
        c = this.decode(t);
        let h = this.texData.get(c.dataId);
        l = this.gpgpu.createBufferFromTexture(h.texture.texture, ...og(o));
      }
      this.pendingRead.set(t, []), i !== "complex64" && await this.gpgpu.createAndWaitForFence();
      let p;
      if (i === "complex64") {
        let h = await Promise.all([this.read(a.real.dataId), this.read(a.imag.dataId)]), d = h[0], g = h[1];
        p = C.mergeRealAndImagArrays(d, g);
      } else if (l == null) p = this.getValuesFromTexture(t);
      else {
        let h = x.sizeFromShape(o);
        p = this.gpgpu.downloadFloat32MatrixFromBuffer(l, h);
      }
      if (c != null && this.disposeIntermediateTensorInfo(c), l != null) {
        let h = this.gpgpu.gl;
        vt(h, () => h.deleteBuffer(l));
      }
      let m = this.convertAndCacheOnCPU(t, p), f = this.pendingRead.get(t);
      return this.pendingRead.delete(t), f.forEach((h) => h(m)), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t) && yo().removeDataId(t, this), this.pendingDeletes--), m;
    }
    readToGPU(t, r = {}) {
      let n = this.texData.get(t), { values: o, shape: s10, slice: i, dtype: a, isPacked: u, texture: l } = n;
      if (a === "complex64") throw new Error("Does not support reading texture for complex64 dtype.");
      if (i != null) {
        let f;
        u ? f = new Sn(s10, Rs) : f = new Lr(s10, Rs);
        let h = this.runWebGLProgram(f, [{ dataId: t, shape: s10, dtype: a }], a), d = this.readToGPU(h, r);
        return this.disposeIntermediateTensorInfo(h), d;
      }
      if (l == null) throw o != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      let c = this.decode(t, r.customTexShape), p = yo().makeTensorFromTensorInfo(c), m = this.texData.get(c.dataId);
      return Object.assign({ tensorRef: p }, m.texture);
    }
    bufferSync(t) {
      let r = this.readSync(t.dataId);
      if (t.dtype === "string") try {
        let n = r.map((o) => x.decodeString(o));
        return kt(t.shape, t.dtype, n);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return kt(t.shape, t.dtype, r);
    }
    checkNumericalProblems(t) {
      if (t != null) for (let r = 0; r < t.length; r++) {
        let n = t[r];
        if (!yO(n)) throw z().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${n} cannot be represented on this device.`);
      }
    }
    getValuesFromTexture(t) {
      let { shape: r, dtype: n, isPacked: o } = this.texData.get(t), s10 = x.sizeFromShape(r);
      if (z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        let m = this.decode(t), f = this.texData.get(m.dataId), h = this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture, ...og(r)).subarray(0, s10);
        return this.disposeIntermediateTensorInfo(m), h;
      }
      let i = z().getBool("WEBGL_PACK") && o === true, a = i ? ug(r) : r, u = i ? new l0(a) : new u0(a), l = this.runWebGLProgram(u, [{ shape: a, dtype: n, dataId: t }], "float32"), c = this.texData.get(l.dataId), p = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture, c.texShape[0], c.texShape[1]).subarray(0, s10);
      return this.disposeIntermediateTensorInfo(l), p;
    }
    timerAvailable() {
      return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(t) {
      let r = this.activeTimers, n = [], o = false;
      this.programTimersStack == null ? (this.programTimersStack = n, o = true) : this.activeTimers.push(n), this.activeTimers = n, t();
      let s10 = x.flatten(this.activeTimers.map((u) => u.query)).filter((u) => u != null), i = x.flatten(this.activeTimers.map((u) => u.name)).filter((u) => u != null);
      this.activeTimers = r, o && (this.programTimersStack = null);
      let a = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null };
      return (async () => {
        if (z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          let u = await Promise.all(s10);
          a.kernelMs = x.sum(u), a.getExtraProfileInfo = () => u.map((l, c) => ({ name: i[c], ms: l })).map((l) => `${l.name}: ${l.ms}`).join(", ");
        } else a.kernelMs = { error: "WebGL query timers are not supported in this environment." };
        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, a;
      })();
    }
    memory() {
      return { unreliable: false, numBytesInGPU: this.numBytesInGPU, numBytesInGPUAllocated: this.textureManager.numBytesAllocated, numBytesInGPUFree: this.textureManager.numBytesFree };
    }
    startTimer() {
      return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: x.now(), endMs: null };
    }
    endTimer(t) {
      return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = x.now(), t);
    }
    async getQueryTime(t) {
      if (z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this.gpgpu.waitForQueryAndGetTime(t);
      let r = t;
      return r.endMs - r.startMs;
    }
    disposeData(t, r = false) {
      if (this.pendingDisposal.has(t)) return false;
      if (!this.texData.has(t)) return true;
      if (r ? this.texData.get(t).refCount = 0 : this.texData.get(t).refCount--, !r && this.texData.get(t).refCount > 0) return false;
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), this.pendingDeletes++, false;
      this.releaseGPUData(t);
      let { complexTensorInfos: n } = this.texData.get(t);
      return n != null && (this.disposeData(n.real.dataId, r), this.disposeData(n.imag.dataId, r)), this.texData.delete(t), true;
    }
    releaseGPUData(t) {
      let { texture: r, dtype: n, texShape: o, usage: s10, isPacked: i, slice: a } = this.texData.get(t), u = a && a.origDataId || t, l = this.dataRefCount.get(u);
      l > 1 ? this.dataRefCount.set(u, l - 1) : (this.dataRefCount.delete(u), r != null && (this.numBytesInGPU -= this.computeBytes(o, n), this.textureManager.releaseTexture(r, o, s10, i)));
      let c = this.texData.get(t);
      c.texture = null, c.texShape = null, c.isPacked = false, c.slice = null;
    }
    getTexture(t) {
      return this.uploadToGPU(t), this.texData.get(t).texture.texture;
    }
    getDataInfo(t) {
      return this.texData.get(t);
    }
    shouldExecuteOnCPU(t, r = rY) {
      return z().getBool("WEBGL_CPU_FORWARD") && t.every((n) => this.texData.get(n.dataId).texture == null && x.sizeFromShape(n.shape) < r);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(t) {
      C.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      let r = t.dataSync();
      return Z9(t.shape, r);
    }
    packedUnaryOp(t, r, n) {
      let o = new Sn(t.shape, r), s10 = this.compileAndRun(o, [t], n);
      return yo().makeTensorFromTensorInfo(s10);
    }
    abs(t) {
      if (this.shouldExecuteOnCPU([t]) && t.dtype !== "complex64") {
        let o = m0(this.texData.get(t.dataId).values);
        return this.makeOutput(t.shape, t.dtype, o);
      }
      if (z().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, pS, t.dtype);
      let r = new Lr(t.shape, pS), n = this.compileAndRun(r, [t]);
      return yo().makeTensorFromTensorInfo(n);
    }
    makeTensorInfo(t, r, n) {
      let o;
      if (r === "string" && n != null && n.length > 0 && x.isString(n[0])) {
        let s10 = n.map((i) => x.encodeString(i));
        o = this.write(s10, t, r);
      } else o = this.write(n, t, r);
      return this.texData.get(o).usage = null, { dataId: o, shape: t, dtype: r };
    }
    makeOutput(t, r, n) {
      return yo().makeTensorFromTensorInfo(this.makeTensorInfo(t, r, n), this);
    }
    unpackTensor(t) {
      let r = new g0(t.shape);
      return this.runWebGLProgram(r, [t], t.dtype);
    }
    packTensor(t) {
      let r = new h0(t.shape);
      return this.runWebGLProgram(r, [t], t.dtype, null, true);
    }
    packedReshape(t, r) {
      let n = [Mu(t.shape), ...zu(t.shape)], o = { dtype: t.dtype, shape: n, dataId: t.dataId }, s10 = [Mu(r), ...zu(r)], i = new Pm(s10, n), a = true, u = [n], l = this.runWebGLProgram(i, [o], t.dtype, u, a);
      return { dataId: l.dataId, shape: r, dtype: l.dtype };
    }
    decode(t, r) {
      let n = this.texData.get(t), { isPacked: o, shape: s10, dtype: i } = n;
      if (r != null) {
        let m = x.sizeFromShape(s10), f = r[0] * r[1] * 4;
        x.assert(m <= f, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
      }
      let a = ug(s10), u;
      o ? u = new a0(a) : u = new i0(a);
      let l = true, c = [r ?? og(a)], p = this.runWebGLProgram(u, [{ shape: a, dtype: i, dataId: t }], i, c, l, r);
      return { dtype: i, shape: s10, dataId: p.dataId };
    }
    runWebGLProgram(t, r, n, o, s10 = false, i) {
      let a = this.makeTensorInfo(t.outputShape, n), u = this.texData.get(a.dataId);
      if (t.packedOutput && (u.isPacked = true), t.outPackingScheme === Lu.DENSE) {
        let y = i ?? og(t.outputShape);
        u.texShape = y.map((b) => b * 2);
      }
      if (t.outTexUsage != null && (u.usage = t.outTexUsage), x.sizeFromShape(a.shape) === 0) return u.values = x.getTypedArrayFromDType(a.dtype, 0), a;
      let l = [], c = r.map((y) => {
        if (y.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        let b = this.texData.get(y.dataId);
        if (b.texture == null) {
          if (!t.packedInputs && x.sizeFromShape(y.shape) <= z().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return { shape: y.shape, texData: null, isUniform: true, uniformValues: b.values };
          t.packedInputs && (b.isPacked = true, b.shape = y.shape);
        }
        if (this.uploadToGPU(y.dataId), !!b.isPacked != !!t.packedInputs) y = b.isPacked ? this.unpackTensor(y) : this.packTensor(y), l.push(y), b = this.texData.get(y.dataId);
        else if (b.isPacked && !Ql(b.shape, y.shape)) {
          let v = y, w = y.shape;
          y.shape = b.shape, y = this.packedReshape(y, w), l.push(y), b = this.texData.get(y.dataId), v.shape = w;
        }
        return { shape: y.shape, texData: b, isUniform: false };
      });
      this.uploadToGPU(a.dataId);
      let p = { shape: a.shape, texData: u, isUniform: false }, m = jO(t, c, p), f = this.getAndSaveBinary(m, () => WO(this.gpgpu, t, c, p)), h = this.activeTimers != null, d;
      h && (d = this.startTimer()), z().get("ENGINE_COMPILE_ONLY") || UO(this.gpgpu, f, c, p, o), l.forEach((y) => this.disposeIntermediateTensorInfo(y)), h && (d = this.endTimer(d), this.activeTimers.push({ name: t.constructor.name, query: this.getQueryTime(d) }));
      let g = z().getNumber("WEBGL_FLUSH_THRESHOLD");
      if (g > 0) {
        let y = x.now();
        y - this.lastGlFlushTime > g && (this.gpgpu.gl.flush(), this.lastGlFlushTime = y);
      }
      if (!z().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && s10 === false) {
        let y = this.unpackTensor(a);
        return this.disposeIntermediateTensorInfo(a), y;
      }
      return a;
    }
    compileAndRun(t, r, n, o, s10 = false) {
      return n = n || r[0].dtype, this.runWebGLProgram(t, r, n, o, s10);
    }
    getAndSaveBinary(t, r) {
      return t in this.binaryCache || (this.binaryCache[t] = r()), this.binaryCache[t];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      this.disposed || (z().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((r) => {
        this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram), delete this.binaryCache[r];
      }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
    }
    floatPrecision() {
      return this.floatPrecisionValue == null && (this.floatPrecisionValue = M(() => {
        if (!z().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          let t = z().getBool("DEBUG");
          z().set("DEBUG", false);
          let r = this.abs($t(1e-8)).dataSync()[0];
          if (z().set("DEBUG", t), r > 0) return 32;
        }
        return 16;
      })), this.floatPrecisionValue;
    }
    epsilon() {
      return this.floatPrecision() === 32 ? Q9 : tY;
    }
    uploadToGPU(t) {
      let r = this.texData.get(t), { shape: n, dtype: o, values: s10, texture: i, usage: a, isPacked: u } = r;
      if (i != null) return;
      let l = this.activeTimers != null, c;
      l && (c = x.now());
      let p = r.texShape;
      if (p == null && (p = DO(n, u), r.texShape = p), s10 != null) {
        let m = ug(n), f, h = p[1], d = p[0], g = s10 instanceof Uint8Array || s10 instanceof Uint8ClampedArray;
        (u || !g) && ([h, d] = _s(p[0], p[1])), u ? f = new c0(m, g) : f = new lg(m, g);
        let y = g ? [d, h] : p, b = this.makeTensorInfo(y, o), v = this.texData.get(b.dataId);
        g ? v.usage = Kr.PIXELS : v.usage = Kr.UPLOAD, v.texShape = y, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId), h, d, s10);
        let w = [[d, h]], E = this.runWebGLProgram(f, [b], o, w, true), A = this.texData.get(E.dataId);
        r.texShape = A.texShape, r.isPacked = A.isPacked, r.usage = A.usage, z().get("ENGINE_COMPILE_ONLY") ? this.disposeData(E.dataId) : (r.texture = A.texture, r.values = null, this.texData.delete(E.dataId)), this.disposeIntermediateTensorInfo(b), l && (this.uploadWaitMs += x.now() - c);
      } else {
        let m = this.acquireTexture(p, a, o, u);
        r.texture = m;
      }
    }
    convertAndCacheOnCPU(t, r) {
      let n = this.texData.get(t), { dtype: o } = n;
      return r != null && (n.values = sY(r, o)), n.values;
    }
    acquireTexture(t, r, n, o) {
      if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        let s10 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${s10} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(t, r, o);
    }
    computeBytes(t, r) {
      return t[0] * t[1] * x.bytesPerElement(r);
    }
    checkCompileCompletion() {
      for (let [, t] of Object.entries(this.binaryCache)) this.checkCompletion_(t);
    }
    async checkCompileCompletionAsync() {
      let t = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (let [, r] of Object.entries(this.binaryCache)) t.push(this.checkCompletionAsync_(r));
        return Promise.all(t);
      } else {
        for (let [, r] of Object.entries(this.binaryCache)) {
          let n = new Promise((o) => {
            try {
              this.checkCompletion_(r), o(true);
            } catch (s10) {
              throw s10;
            }
          });
          t.push(n);
        }
        return Promise.all(t);
      }
    }
    async checkCompletionAsync_(t) {
      return this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(t) : (await fh(), this.checkCompletionAsync_(t));
    }
    checkCompletion_(t) {
      if (this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)), this.gpgpu.gl.getShaderParameter(t.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false ? (tS(t.source, this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
      return true;
    }
    getUniformLocations() {
      for (let t of Object.values(this.binaryCache)) {
        this.gpgpu.buildVao(t.webGLProgram);
        let { variablesLocations: r, customUniformLocations: n, infLoc: o, nanLoc: s10, outShapeLocation: i, outShapeStridesLocation: a, outTexShapeLocation: u } = oS(this.gpgpu, t.program, t.webGLProgram);
        t.variablesLocations = r, t.customUniformLocations = n, t.infLoc = o, t.nanLoc = s10, t.outShapeLocation = i, t.outShapeStridesLocation = a, t.outTexShapeLocation = u;
      }
    }
    createTensorFromGPUData(t, r, n) {
      t.channels = t.channels || "RGBA";
      let { texture: o, height: s10, width: i, channels: a } = t, u = yo().backend;
      if (!u.gpgpu.gl.isTexture(o)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
      let l = u.writeTexture(o, r, n, s10, i, a);
      return yo().makeTensorFromDataId(l, r, n, u);
    }
  };
  pg.nextDataId = 0;
  function sY(e28, t) {
    if (t === "float32" || t === "complex64") return e28;
    if (t === "int32" || t === "bool") {
      let r = t === "int32" ? new Int32Array(e28.length) : new Uint8Array(e28.length);
      for (let n = 0; n < r.length; ++n) r[n] = Math.round(e28[n]);
      return r;
    } else throw new Error(`Unknown dtype ${t}`);
  }
  vu.isBrowser() && Vy("webgl", () => new pg(), 2);
  var Lm = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  var In = class {
    constructor(t, r, n) {
      this.variableNames = ["A", "B"], this.outputShape = C.assertAndGetBroadcastShape(r, n), this.enableShapeUniforms = fe(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  };
  var Gn = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
  var Vn = class {
    constructor(t, r, n, o = false) {
      this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = C.assertAndGetBroadcastShape(r, n);
      let s10 = this.outputShape.length;
      this.enableShapeUniforms = fe(s10);
      let i = "";
      if (o) if (s10 === 0 || x.sizeFromShape(this.outputShape) === 1) i = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      else if (i = `
          ${Wt(s10)} coords = getOutputCoords();
        `, s10 === 1) this.enableShapeUniforms ? i += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : i += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
      else {
        let u = Ze("coords", s10);
        this.enableShapeUniforms ? i += `
            bool nextRowOutOfBounds =
              (${u[s10 - 2]} + 1) >= outShape[${s10} - 2];
            bool nextColOutOfBounds =
              (${u[s10 - 1]} + 1) >= outShape[${s10} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : i += `
            bool nextRowOutOfBounds =
              (${u[s10 - 2]} + 1) >= ${this.outputShape[s10 - 2]};
            bool nextColOutOfBounds =
              (${u[s10 - 1]} + 1) >= ${this.outputShape[s10 - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
      }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `;
    }
  };
  function Qe(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    return r.incRef(n.dataId), { dataId: n.dataId, shape: n.shape, dtype: n.dtype };
  }
  var hP = { kernelName: ds, backendName: "webgl", kernelFunc: Qe };
  function Tn(e28) {
    let { inputs: t, backend: r } = e28, { real: n, imag: o } = t, s10 = r.makeTensorInfo(n.shape, "complex64"), i = r.texData.get(s10.dataId), a = Qe({ inputs: { x: n }, backend: r }), u = Qe({ inputs: { x: o }, backend: r });
    return i.complexTensorInfos = { real: a, imag: u }, s10;
  }
  var dP = { kernelName: Pc, backendName: "webgl", kernelFunc: Tn };
  var mS = "return (a < 0.) ? b * a : a;";
  var fS = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function iY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { alpha: s10 } = n, i = r.makeTensorInfo([], "float32", x.createScalarValue(s10, "float32")), a = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Vn(fS, o.shape, i.shape) : new In(mS, o.shape, i.shape), u = r.runWebGLProgram(a, [o, i], "float32");
    return r.disposeIntermediateTensorInfo(i), u;
  }
  var gP = { kernelName: ja, backendName: "webgl", kernelFunc: iY };
  var hS = "return (a < 0.) ? b * a : a;";
  var dS = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function aY(e28) {
    let { inputs: t, backend: r } = e28, { x: n, alpha: o } = t, s10 = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Vn(dS, n.shape, o.shape) : new In(hS, n.shape, o.shape);
    return r.runWebGLProgram(s10, [n, o], "float32");
  }
  var yP = { kernelName: ou, backendName: "webgl", kernelFunc: aY };
  var _o = "if (isnan(x)) return x;";
  function St({ opSnippet: e28, packedOpSnippet: t, cpuKernelImpl: r, dtype: n }) {
    return ({ inputs: o, backend: s10 }) => {
      let { x: i } = o, a = s10, u = n || i.dtype;
      if (a.shouldExecuteOnCPU([i]) && r != null) {
        let p = a.texData.get(i.dataId), m = r(p.values, u);
        return a.makeTensorInfo(i.shape, u, m);
      }
      let l = z().getBool("WEBGL_PACK_UNARY_OPERATIONS") && t != null, c;
      return l ? c = new Sn(i.shape, t) : c = new Lr(i.shape, e28), a.runWebGLProgram(c, [i], u);
    };
  }
  function le({ opSnippet: e28, packedOpSnippet: t, checkOutOfBounds: r = false, supportsComplex: n = false, cpuKernelImpl: o, dtype: s10 }) {
    return ({ inputs: i, backend: a }) => {
      let { a: u, b: l } = i, c = a;
      if (n && u.dtype === "complex64") {
        let h = c.texData.get(u.dataId), d = c.texData.get(l.dataId), [g, y] = [[h.complexTensorInfos.real, d.complexTensorInfos.real], [h.complexTensorInfos.imag, d.complexTensorInfos.imag]].map((v) => {
          let [w, N] = v, E = { dataId: w.dataId, dtype: w.dtype, shape: u.shape }, A = { dataId: N.dataId, dtype: N.dtype, shape: l.shape }, D = new In(e28, u.shape, l.shape);
          return c.runWebGLProgram(D, [E, A], lr(w.dtype, N.dtype));
        }), b = Tn({ inputs: { real: g, imag: y }, backend: c });
        return c.disposeIntermediateTensorInfo(g), c.disposeIntermediateTensorInfo(y), b;
      }
      let p = s10 || lr(u.dtype, l.dtype);
      if ((u.dtype === "string" || l.dtype === "string" || c.shouldExecuteOnCPU([u, l])) && o != null) {
        let h = c.texData.get(u.dataId).values, d = c.texData.get(l.dataId).values, g = u.dtype === "string" ? C.fromUint8ToStringArray(h) : h, y = u.dtype === "string" ? C.fromUint8ToStringArray(d) : d, [b, v] = o(u.shape, l.shape, g, y, p), w = c.makeTensorInfo(v, p), N = c.texData.get(w.dataId);
        return N.values = b, w;
      }
      let m = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") && t != null, f;
      return m ? f = new Vn(t, u.shape, l.shape, r) : f = new In(e28, u.shape, l.shape), c.runWebGLProgram(f, [u, l], p);
    };
  }
  function ua(e28, t = false) {
    if (e28 === "linear") return t ? lP : nP;
    if (e28 === "relu") return t ? pP : sP;
    if (e28 === "elu") return t ? cP : oP;
    if (e28 === "relu6") return t ? mP : iP;
    if (e28 === "prelu") return t ? dS : hS;
    if (e28 === "leakyrelu") return t ? fS : mS;
    if (e28 === "sigmoid") return t ? fP : aP;
    throw new Error(`Activation ${e28} has not been implemented for the WebGL backend.`);
  }
  var Mm = class {
    constructor(t, r, n, o = false, s10 = false, i = false, a = null, u = false, l = false) {
      this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = n, this.enableShapeUniforms = fe(this.outputShape.length);
      let c = o ? t[1] : t[2], p = Math.ceil(c / 2), m = o ? "i * 2, rc.y" : "rc.y, i * 2", f = s10 ? "rc.z, i * 2" : "i * 2, rc.z", h = o ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], d = s10 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], g = "", y = "";
      a && (u ? g = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }` : l ? g = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }` : g = `vec4 activation(vec4 x) {
          ${a}
        }`, y = "result = activation(result);");
      let b = i ? "result += getBiasAtOutCoords();" : "";
      i && this.variableNames.push("bias"), u && this.variableNames.push("preluActivationWeights"), l && this.variableNames.push("leakyreluAlpha");
      let v = "rc.x", w = "rc.x";
      t[0] < r[0] ? v = `imod(rc.x, ${t[0]})` : r[0] < t[0] && (w = `imod(rc.x, ${r[0]})`), this.userCode = `
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${w};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${d[0]});
          result += (${h[1]} * ${d[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `;
    }
  };
  var gS = { REAL: "return areal * breal - aimag * bimag;", IMAG: "return areal * bimag + aimag * breal;" };
  var mg = class {
    constructor(t, r, n) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = C.assertAndGetBroadcastShape(r, n), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  };
  var xP = "return a * b;";
  function fg(e28) {
    let { inputs: t, backend: r } = e28, { a: n, b: o } = t, s10 = C.upcastType(n.dtype, o.dtype);
    if (n.dtype === "complex64") {
      let a = r.texData.get(n.dataId), u = r.texData.get(o.dataId), l = new mg(gS.REAL, n.shape, o.shape), c = new mg(gS.IMAG, n.shape, o.shape), p = [{ dataId: a.complexTensorInfos.real.dataId, dtype: a.complexTensorInfos.real.dtype, shape: n.shape }, { dataId: a.complexTensorInfos.imag.dataId, dtype: a.complexTensorInfos.imag.dtype, shape: n.shape }, { dataId: u.complexTensorInfos.real.dataId, dtype: u.complexTensorInfos.real.dtype, shape: o.shape }, { dataId: u.complexTensorInfos.imag.dataId, dtype: u.complexTensorInfos.imag.dtype, shape: o.shape }], m = r.runWebGLProgram(l, p, "float32"), f = r.runWebGLProgram(c, p, "float32"), h = Tn({ inputs: { real: m, imag: f }, backend: r });
      return r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(f), h;
    }
    if (r.shouldExecuteOnCPU([n, o])) {
      let a = r.texData.get(n.dataId), u = r.texData.get(o.dataId), [l, c] = AR(n.shape, o.shape, a.values, u.values, s10), p = r.makeTensorInfo(c, s10), m = r.texData.get(p.dataId);
      return m.values = l, p;
    }
    let i;
    return z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? i = new Vn(xP, n.shape, o.shape) : i = new In(xP, n.shape, o.shape), r.runWebGLProgram(i, [n, o], s10);
  }
  var bP = { kernelName: Ci, backendName: "webgl", kernelFunc: fg };
  function wP(e28, t, r) {
    let n = [Mu(e28.shape), ...zu(e28.shape)], o = { dtype: e28.dtype, shape: n, dataId: e28.dataId }, s10 = [Mu(t), ...zu(t)], i = new Pm(s10, n), a = true, u = [n], l = r.runWebGLProgram(i, [o], e28.dtype, u, a);
    return { dataId: l.dataId, shape: t, dtype: l.dtype };
  }
  function rt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { shape: s10 } = n, i = r, a = x.sizeFromShape(o.shape), u = x.inferFromImplicitShape(s10, a), l = x.sizeFromShape(u);
    x.assert(a === l, () => `The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);
    let c = i.texData.get(o.dataId);
    return c.isPacked && !Ql(o.shape, u) && !(c.texture !== null && Ql(c.shape, u)) ? wP(o, u, i) : (i.incRef(o.dataId), { dataId: o.dataId, shape: u, dtype: o.dtype });
  }
  var vP = { kernelName: iu, backendName: "webgl", kernelFunc: rt };
  var hg = class {
    constructor(t, r) {
      this.variableNames = ["x"];
      let { windowSize: n, batchSize: o, inSize: s10, outSize: i } = t;
      this.outputShape = [o, i];
      let a = Math.floor(n / 4) * 4, u = n % 4, l = "sumValue += dot(values, ones);";
      if (r != null) {
        let p = 1 / r;
        l = `sumValue += dot(values * ${x.isInt(p) ? p.toPrecision(2) : p}, ones);`;
      }
      let c = "";
      s10 % n > 0 && (c = `
        if (inIdx < 0 || inIdx >= ${s10}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `;
    }
  };
  var x0 = class {
    constructor(t, r) {
      this.variableNames = ["x"];
      let { windowSize: n, batchSize: o, inSize: s10, outSize: i } = t;
      this.outputShape = [o, i];
      let a = "0.0", u = "";
      r === "prod" ? a = "1.0" : r === "min" ? (a = "1.0 / 1e-20", u = "min") : r === "max" && (a = "-1.0 / 1e-20", u = "max");
      let l = `${r}(${r}(${r}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      r === "sum" ? l = "sumValue" : r === "prod" ? l = "prodValue" : r === "all" ? l = "allValue" : r === "any" && (l = "anyValue");
      let c = Math.floor(n / 4) * 4, p = n % 4, m = `
      if (${r === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${r === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${r === "min"} || ${r === "max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, f = "vec4";
      r === "all" ? (a = "1.0", m = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, f = "bvec4") : r === "any" && (a = "0.0", m = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, f = "bvec4");
      let h = "";
      s10 % n > 0 && (h = `
        if (inIdx < 0 || inIdx >= ${s10}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p === 1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p === 2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p === 3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `;
    }
  };
  function lY(e28) {
    let t = [];
    for (; t.length === 0 || t[t.length - 1].outSize !== 1; ) {
      let r = t.length ? t[t.length - 1].outSize : e28[1], n = C.computeOptimalWindowSize(r);
      t.push({ inSize: r, windowSize: n, outSize: Math.ceil(r / n) });
    }
    return t;
  }
  function Wn(e28, t, r, n) {
    let o = lY(e28.shape), s10 = e28;
    for (let i = 0; i < o.length; i++) {
      let { inSize: a, windowSize: u, outSize: l } = o[i], c, p;
      r === "mean" ? c = i === 0 ? new hg({ windowSize: u, inSize: a, batchSize: e28.shape[0], outSize: l }, a) : new hg({ windowSize: u, inSize: a, batchSize: e28.shape[0], outSize: l }) : c = new x0({ windowSize: u, inSize: a, batchSize: e28.shape[0], outSize: l }, r), p = s10, s10 = n.runWebGLProgram(c, [s10], t), p.dataId !== e28.dataId && n.disposeIntermediateTensorInfo(p);
    }
    return s10;
  }
  var b0 = class {
    constructor(t, r) {
      this.variableNames = ["A"];
      let n = new Array(t.length);
      for (let i = 0; i < n.length; i++) n[i] = t[r[i]];
      this.outputShape = n, this.rank = n.length;
      let o = Wt(this.rank), s10 = cY(r);
      this.userCode = `
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s10}));
    }
    `;
    }
  };
  function cY(e28) {
    let t = e28.length;
    if (t > 6) throw Error(`Transpose for rank ${t} is not yet supported`);
    let r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], n = new Array(t);
    for (let o = 0; o < e28.length; o++) n[e28[o]] = r[o];
    return n.join();
  }
  var w0 = class {
    constructor(t, r) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
      let n = new Array(t.length);
      for (let c = 0; c < n.length; c++) n[c] = t[r[c]];
      if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      let o = Wt(this.rank), s10 = cS("rc", this.rank), i = new Array(this.rank);
      for (let c = 0; c < r.length; c++) i[r[c]] = s10[c];
      let a = `vec2(${i.slice(-2).join()})`, u = `++${s10[this.rank - 1]} < ${n[this.rank - 1]}`, l = `getChannel(getA(${i.join()}), ${a})`;
      this.userCode = `
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s10[this.rank - 1]};
      if(++${s10[this.rank - 2]} < ${n[this.rank - 2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `;
    }
  };
  function Bu(e28, t, r) {
    let n = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new w0(e28.shape, t) : new b0(e28.shape, t);
    return r.runWebGLProgram(n, [e28], e28.dtype);
  }
  function NP(e28, t, r, n) {
    let o = t, s10 = e28.shape.length, i = x.parseAxisParam(o, e28.shape), a = i, u = C.getAxesPermutation(a, s10), l = u != null, c = e28;
    l && (c = Bu(e28, u, n), a = C.getInnerMostAxes(a.length, s10)), C.assertAxesAreInnerMostDims("sum", a, s10);
    let [p, m] = C.computeOutAndReduceShapes(c.shape, a), f = p;
    r && (f = C.expandShapeToKeepDim(p, i));
    let h = x.sizeFromShape(m), g = x.sizeFromShape(e28.shape) / h, y = rt({ inputs: { x: c }, attrs: { shape: [g, h] }, backend: n }), b = bl(e28.dtype), v = Wn(y, b, "sum", n), w = rt({ inputs: { x: v }, attrs: { shape: f }, backend: n });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(v), l && n.disposeIntermediateTensorInfo(c), w;
  }
  function nc(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n;
    return NP(o, s10, i, r);
  }
  var CP = { kernelName: mu, backendName: "webgl", kernelFunc: nc };
  function Ae(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { perm: s10 } = n, i = r, a = o.shape.length, u = new Array(a);
    for (let c = 0; c < u.length; c++) u[c] = o.shape[s10[c]];
    let l;
    if (i.shouldExecuteOnCPU([o])) {
      let p = i.texData.get(o.dataId).values, m = rc(p, o.shape, o.dtype, s10, u);
      l = i.makeTensorInfo(u, o.dtype);
      let f = i.texData.get(l.dataId);
      f.values = m;
    } else l = Bu(o, s10, i);
    return l;
  }
  var SP = { kernelName: ys, backendName: "webgl", kernelFunc: Ae };
  var yS = 1e3;
  function oc({ a: e28, b: t, transposeA: r, transposeB: n, backend: o, bias: s10 = null, preluActivationWeights: i = null, leakyreluAlpha: a = 0, activation: u = null }) {
    let l = e28.shape.length, c = t.shape.length, p = r ? e28.shape[l - 2] : e28.shape[l - 1], m = n ? t.shape[c - 1] : t.shape[c - 2], f = r ? e28.shape[l - 1] : e28.shape[l - 2], h = n ? t.shape[c - 2] : t.shape[c - 1], d = e28.shape.slice(0, -2), g = t.shape.slice(0, -2), y = x.sizeFromShape(d), b = x.sizeFromShape(g), w = Rn.assertAndGetBroadcastShape(e28.shape.slice(0, -2), t.shape.slice(0, -2)).concat([f, h]);
    x.assert(p === m, () => `Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${e28.shape} and ${t.shape} and transposeA=${r} and transposeB=${n} must match.`);
    let N = r ? [y, p, f] : [y, f, p], E = n ? [b, h, m] : [b, m, h], A = rt({ inputs: { x: e28 }, backend: o, attrs: { shape: N } }), D = rt({ inputs: { x: t }, backend: o, attrs: { shape: E } }), R = [A, D], L = Math.max(y, b), G = r ? A.shape[1] : A.shape[2], W = s10 != null, U = i != null, H = u === "leakyrelu", j = u != null ? ua(u, true) : null, X = W || U || H || j != null, Q;
    if ((f === 1 || h === 1) && G > yS && X === false) {
      let et = A, ot = D;
      r && (et = Ae({ inputs: { x: A }, backend: o, attrs: { perm: [0, 2, 1] } }), R.push(et)), n && (ot = Ae({ inputs: { x: D }, backend: o, attrs: { perm: [0, 2, 1] } }), R.push(ot));
      let st = h !== 1, ct = h === 1, lt = et;
      st && (lt = rt({ inputs: { x: et }, backend: o, attrs: { shape: [L, G, 1] } }), R.push(lt));
      let wt = h === 1 ? 2 : 1, mt = ot;
      ct && (mt = rt({ inputs: { x: ot }, backend: o, attrs: { shape: [L, 1, G] } }), R.push(mt));
      let Ct = fg({ inputs: { a: lt, b: mt }, backend: o });
      Q = nc({ inputs: { x: Ct }, backend: o, attrs: { axis: wt, keepDims: true } }), R.push(Ct);
    } else {
      let et = lr(e28.dtype, t.dtype), ot = new Mm(N, E, [L, f, h], r, n, W, j, U, H), st = [A, D];
      if (s10 != null && st.push(s10), U && st.push(i), H) {
        let ct = o.makeTensorInfo([], "float32", x.createScalarValue(a, "float32"));
        st.push(ct), R.push(ct);
      }
      Q = o.runWebGLProgram(ot, st, et);
    }
    let q = rt({ inputs: { x: Q }, backend: o, attrs: { shape: w } });
    R.push(Q);
    for (let et of R) o.disposeIntermediateTensorInfo(et);
    return q;
  }
  function pY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { a: o, b: s10, bias: i, preluActivationWeights: a } = t, { transposeA: u, transposeB: l, activation: c, leakyreluAlpha: p } = n;
    return oc({ a: o, b: s10, transposeA: u, transposeB: l, backend: r, bias: i, preluActivationWeights: a, leakyreluAlpha: p, activation: c });
  }
  var IP = { kernelName: pl, backendName: "webgl", kernelFunc: pY };
  var TP = "return abs(x);";
  function mY(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    if (r.shouldExecuteOnCPU([n]) && n.dtype !== "complex64") {
      let s10 = r.texData.get(n.dataId), i = m0(s10.values);
      return r.makeTensorInfo(n.shape, n.dtype, i);
    }
    let o;
    return z().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? o = new Sn(n.shape, TP) : o = new Lr(n.shape, TP), r.runWebGLProgram(o, [n], n.dtype);
  }
  var kP = { kernelName: ka, backendName: "webgl", kernelFunc: mY };
  var fY = gr + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
  var hY = St({ opSnippet: fY });
  var EP = { kernelName: Ys, backendName: "webgl", kernelFunc: hY };
  var dY = gr + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
  var gY = St({ opSnippet: dY });
  var AP = { kernelName: Js, backendName: "webgl", kernelFunc: gY };
  var DP = "return a + b;";
  var yY = le({ opSnippet: DP, packedOpSnippet: DP, supportsComplex: true, cpuKernelImpl: uR });
  var $P = { kernelName: Mo, backendName: "webgl", kernelFunc: yY };
  var v0 = class {
    constructor(t, r) {
      this.outputShape = [], this.outputShape = t, this.variableNames = r.map((s10, i) => `T${i}`);
      let n = [];
      this.variableNames.forEach((s10) => {
        n.push(`float v${s10} = get${s10}AtOutCoords();`);
      });
      let o = this.variableNames.map((s10) => `v${s10}`).join(" + ");
      this.userCode = `
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `;
    }
  };
  var N0 = class {
    constructor(t, r) {
      this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.variableNames = r.map((s10, i) => `T${i}`);
      let n = [];
      this.variableNames.forEach((s10) => {
        n.push(`vec4 v${s10} = get${s10}AtOutCoords();`);
      });
      let o = this.variableNames.map((s10) => `v${s10}`).join(" + ");
      this.userCode = `
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `;
    }
  };
  function C0(e28) {
    let { inputs: t, backend: r } = e28, n = t;
    if (n.length === 1) return Qe({ inputs: { x: n[0] }, backend: r });
    if (n.length > z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      let u = Math.floor(n.length / 2), l = C0({ inputs: n.slice(0, u), backend: r }), c = C0({ inputs: n.slice(u), backend: r });
      return C0({ inputs: [l, c], backend: r });
    }
    let o = n.map((u) => u.dtype).reduce((u, l) => lr(u, l)), s10 = n.map((u) => u.shape), a = z().getBool("WEBGL_PACK") ? new N0(n[0].shape, s10) : new v0(n[0].shape, s10);
    return r.runWebGLProgram(a, n, o);
  }
  var FP = { kernelName: Dc, backendName: "webgl", kernelFunc: C0 };
  function xY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n, a = o.shape.length, u = x.parseAxisParam(s10, o.shape), l = u, c = C.getAxesPermutation(l, a), p = o;
    c != null && (p = Ae({ inputs: { x: o }, backend: r, attrs: { perm: c } }), l = C.getInnerMostAxes(l.length, a)), C.assertAxesAreInnerMostDims("all", l, a);
    let [m, f] = C.computeOutAndReduceShapes(p.shape, l), h = x.sizeFromShape(f), d = rt({ inputs: { x: p }, backend: r, attrs: { shape: [-1, h] } }), g = Wn(d, d.dtype, "all", r), y;
    if (i) {
      let b = C.expandShapeToKeepDim(m, u);
      y = rt({ inputs: { x: g }, backend: r, attrs: { shape: b } });
    } else y = rt({ inputs: { x: g }, backend: r, attrs: { shape: m } });
    return r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(g), c != null && r.disposeIntermediateTensorInfo(p), y;
  }
  var _P = { kernelName: $c, backendName: "webgl", kernelFunc: xY };
  function bY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n, a = o.shape.length, u = x.parseAxisParam(s10, o.shape), l = u, c = C.getAxesPermutation(l, a), p = o;
    c != null && (p = Ae({ inputs: { x: o }, backend: r, attrs: { perm: c } }), l = C.getInnerMostAxes(l.length, a)), C.assertAxesAreInnerMostDims("any", l, a);
    let [m, f] = C.computeOutAndReduceShapes(p.shape, l), h = x.sizeFromShape(f), d = rt({ inputs: { x: p }, backend: r, attrs: { shape: [-1, h] } }), g = Wn(d, d.dtype, "any", r), y;
    if (i) {
      let b = C.expandShapeToKeepDim(m, u);
      y = rt({ inputs: { x: g }, backend: r, attrs: { shape: b } });
    } else y = rt({ inputs: { x: g }, backend: r, attrs: { shape: m } });
    return r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(g), c != null && r.disposeIntermediateTensorInfo(p), y;
  }
  var OP = { kernelName: Fc, backendName: "webgl", kernelFunc: bY };
  var S0 = class {
    constructor(t, r, n) {
      this.variableNames = ["A"];
      let { windowSize: o, batchSize: s10, outSize: i } = t;
      n || this.variableNames.push("bestIndicesA"), this.outputShape = [s10, i];
      let a = r === "max" ? ">" : "<", u = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  };
  var I0 = class {
    constructor(t, r, n, o) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, x.assert(t.length > 2, () => `Packed arg${n.charAt(0).toUpperCase() + n.slice(1)} supports only inputs with rank above 2.`);
      let s10 = t[t.length - 1], i = Math.ceil(s10 / r);
      this.outputShape = t.slice(0, -1), i > 1 && this.outputShape.push(i), o || this.variableNames.push("bestIndicesA");
      let a = this.outputShape, u = a.length, l = Wt(u), c = Ze("coords", u), p, m;
      if (i === 1) {
        m = u + 1;
        let D = Wt(m);
        p = `
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[u - 1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[u - 2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[u - 1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[u - 2]};`;
      } else m = u, p = `
        ${l} sourceLocR = coords;
        ++${c[u - 1]};
        ${l} sourceLocG = coords;
        ++${c[u - 2]};
        ${l} sourceLocA = coords;
        --${c[u - 1]};
        ${l} sourceLocB = coords;
        --${c[u - 2]};`;
      let f = ["x", "y", "z", "w", "u", "v"].slice(0, m), h = "." + f[m - 1], d = f.map((D) => "int " + D), g = Ze("sourceLocR", m - 1).concat("inIdx.r"), y = Ze("sourceLocG", m - 1).concat("inIdx.g"), b = Ze("sourceLocB", m - 1).concat("inIdx.b"), v = Ze("sourceLocA", m - 1).concat("inIdx.a"), w = n === "max" ? "greaterThan" : "lessThan", N = o ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()})));`, E = `vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`, A = o ? "" : `
      float getBestIndicesAChannel(${d.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${d.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u - 1]} < ${a[u - 1] - 1};
        bool hasNextRow = ${c[u - 2]} < ${a[u - 2] - 1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${r};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${r}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  };
  function RP(e28, t, r, n = null) {
    let o = t.shape[0], s10 = t.shape[1];
    n != null && (o = n.shape[0], s10 = n.shape[1]);
    let i = C.computeOptimalWindowSize(s10), a = { windowSize: i, inSize: s10, batchSize: o, outSize: Math.ceil(s10 / i) }, u = new S0(a, r, n == null), l = [t];
    n != null && l.push(n);
    let c = e28.runWebGLProgram(u, l, "int32");
    if (c.shape[1] === 1) return c;
    let p = RP(e28, t, r, c);
    return e28.disposeIntermediateTensorInfo(c), p;
  }
  function PP(e28, t, r, n = null) {
    let o = n != null ? n.shape : t.shape, s10 = o[o.length - 1], i = C.computeOptimalWindowSize(s10), a = new I0(o, i, r, n == null), u = n == null ? [t] : [t, n], l = e28.runWebGLProgram(a, u, "int32");
    if (l.shape.length === t.shape.length) {
      let c = PP(e28, t, r, l);
      return e28.disposeIntermediateTensorInfo(l), c;
    }
    return l;
  }
  function T0(e28, t, r, n) {
    let o = [r];
    if (C.assertAxesAreInnerMostDims("arg" + n.charAt(0).toUpperCase() + n.slice(1), o, t.shape.length), !z().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
      let s10 = [], i = e28.texData.get(t.dataId), a = i !== null && i.isPacked, u = t;
      a && (u = e28.unpackTensor(t), s10.push(u));
      let [l, c] = C.computeOutAndReduceShapes(u.shape, o), p = x.sizeFromShape(c), m = rt({ inputs: { x: u }, backend: e28, attrs: { shape: [-1, p] } });
      s10.push(m);
      let f = RP(e28, m, n);
      s10.push(f);
      let h = rt({ inputs: { x: f }, backend: e28, attrs: { shape: l } });
      return s10.forEach((d) => e28.disposeIntermediateTensorInfo(d)), h;
    }
    return PP(e28, t, n);
  }
  function wY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10 } = n, i = x.parseAxisParam(s10, o.shape), a = C.getAxesPermutation(i, o.shape.length), u = o, l = [];
    a != null && (u = Ae({ inputs: { x: o }, backend: r, attrs: { perm: a } }), l.push(u), i = C.getInnerMostAxes(i.length, u.shape.length)), C.assertAxesAreInnerMostDims("argMax", [i[0]], u.shape.length);
    let c = T0(r, u, i[0], "max");
    return l.forEach((p) => r.disposeIntermediateTensorInfo(p)), c;
  }
  var LP = { kernelName: Ea, backendName: "webgl", kernelFunc: wY };
  function vY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10 } = n, i = x.parseAxisParam(s10, o.shape), a = C.getAxesPermutation(i, o.shape.length), u = o, l = [];
    a != null && (u = Ae({ inputs: { x: o }, backend: r, attrs: { perm: a } }), l.push(u), i = C.getInnerMostAxes(i.length, u.shape.length)), C.assertAxesAreInnerMostDims("argMin", [i[0]], u.shape.length);
    let c = T0(r, u, i[0], "min");
    return l.forEach((p) => r.disposeIntermediateTensorInfo(p)), c;
  }
  var MP = { kernelName: Aa, backendName: "webgl", kernelFunc: vY };
  var NY = gr + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
  var CY = St({ opSnippet: NY });
  var zP = { kernelName: Zs, backendName: "webgl", kernelFunc: CY };
  var SY = gr + "return log(x + sqrt(x * x + 1.0));";
  var IY = St({ opSnippet: SY });
  var BP = { kernelName: Qs, backendName: "webgl", kernelFunc: IY };
  var TY = gr + `
  return atan(x);
`;
  var kY = St({ opSnippet: TY });
  var VP = { kernelName: ti, backendName: "webgl", kernelFunc: kY };
  var EY = Lm + `
  return atan(a, b);
`;
  var AY = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Gn + `
  return result;
`;
  var DY = le({ opSnippet: EY, packedOpSnippet: AY });
  var GP = { kernelName: ri, backendName: "webgl", kernelFunc: DY };
  var $Y = gr + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
  var FY = St({ opSnippet: $Y });
  var WP = { kernelName: ei, backendName: "webgl", kernelFunc: FY };
  var es = class {
    constructor(t, r, n, o = false, s10 = false) {
      if (this.variableNames = ["x"], r === "avg" && n) throw new Error("Cannot compute positions for average pool.");
      let i = t.filterWidth, a = t.strideHeight, u = t.strideWidth, l = t.dilationHeight, c = t.dilationWidth, p = t.effectiveFilterHeight, m = t.effectiveFilterWidth, f = t.padInfo.top, h = t.padInfo.left;
      this.outputShape = t.outShape;
      let d = r === "avg", g = `((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`, y = `(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`, b = "0.0";
      if (d || (b = "-1.0 / 1e-20"), n) {
        let D = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o ? s10 ? g : y : `wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      let v = "max", w = `${r}(${r}(${r}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      r === "avg" && (w = "avgValue / max(count, 1.0)");
      let N = Math.floor(i / 4) * 4, E = i % 4, A = `
      if (${d}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${h});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${N};
          if (${E === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${E === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${E === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${w});
      }
    `;
    }
  };
  var Vu = class {
    constructor(t, r, n, o = false, s10 = false) {
      if (this.variableNames = ["x"], r === "avg" && n) throw new Error("Cannot compute positions for average pool.");
      let i = t.filterWidth, a = t.strideDepth, u = t.strideHeight, l = t.strideWidth, c = t.dilationDepth, p = t.dilationHeight, m = t.dilationWidth, f = t.effectiveFilterDepth, h = t.effectiveFilterHeight, d = t.effectiveFilterWidth, g = t.padInfo.front, y = t.padInfo.top, b = t.padInfo.left;
      this.outputShape = t.outShape;
      let v = r === "avg", w = "0.0";
      if (v || (w = "-1.0 / 1e-20"), n) {
        let L = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${d};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${L} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o ? s10 ? `(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `wD * ${h} * ${d} +
                      wR * ${d} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      let N = "max", E = `${r}(${r}(${r}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      r === "avg" && (E = "avgValue / max(count, 1.0)");
      let A = Math.floor(i / 4) * 4, D = i % 4, R = `
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${A};
            if (${D === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${D === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${D === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${R}
            }
          }
        }
        setOutput(${E});
      }
    `;
    }
  };
  function _Y(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t;
    Os(o, "avgPool");
    let { filterSize: s10, strides: i, pad: a, dimRoundingMode: u } = n, l = 1;
    x.assert(C.eitherStridesOrDilationsAreOne(i, l), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);
    let c = C.computePool2DInfo(o.shape, s10, i, l, a, u);
    if (c.filterWidth === 1 && c.filterHeight === 1 && x.arraysEqual(c.inShape, c.outShape)) return Qe({ inputs: { x: o }, backend: r });
    let p = new es(c, "avg", false);
    return r.runWebGLProgram(p, [o], "float32");
  }
  var UP = { kernelName: Da, backendName: "webgl", kernelFunc: _Y };
  function OY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { filterSize: s10, strides: i, pad: a, dimRoundingMode: u, dataFormat: l } = n, c = [1, 1, 1], p = C.computePool3DInfo(o.shape, s10, i, c, a, u, l), m = new Vu(p, "avg", false);
    return r.runWebGLProgram(m, [o], "float32");
  }
  var jP = { kernelName: $a, backendName: "webgl", kernelFunc: OY };
  var k0 = class {
    constructor(t) {
      this.variableNames = ["dy"], this.outputShape = t.inShape;
      let r = t.filterHeight, n = t.filterWidth, o = t.strideHeight, s10 = t.strideWidth, i = t.dilationHeight, a = t.dilationWidth, u = t.effectiveFilterHeight, l = t.effectiveFilterWidth, c = u - 1 - t.padInfo.top, p = l - 1 - t.padInfo.left, m = 1 / (r * n);
      this.userCode = `
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s10}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var E0 = class {
    constructor(t) {
      this.variableNames = ["dy"], this.outputShape = t.inShape;
      let r = t.filterDepth, n = t.filterHeight, o = t.filterWidth, s10 = t.strideDepth, i = t.strideHeight, a = t.strideWidth, u = t.dilationDepth, l = t.dilationHeight, c = t.dilationWidth, p = t.effectiveFilterDepth, m = t.effectiveFilterHeight, f = t.effectiveFilterWidth, h = p - 1 - t.padInfo.front, d = m - 1 - t.padInfo.top, g = f - 1 - t.padInfo.left, y = 1 / (r * n * o);
      this.userCode = `
      const ivec3 pads = ivec3(${h}, ${d}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s10}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function RY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10 } = t, i = s10, { filterSize: a, strides: u, pad: l, dimRoundingMode: c } = n, p = [1, 1, 1], m = C.computePool3DInfo(i.shape, a, u, p, l, c), f = new E0(m);
    return r.runWebGLProgram(f, [o], i.dtype);
  }
  var HP = { kernelName: Oc, backendName: "webgl", kernelFunc: RY };
  function PY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10 } = t, i = s10;
    Os([o, s10], "avgPoolGrad");
    let { filterSize: a, strides: u, pad: l } = n, c = C.computePool2DInfo(i.shape, a, u, 1, l), p = new k0(c);
    return r.runWebGLProgram(p, [o], i.dtype);
  }
  var KP = { kernelName: _c, backendName: "webgl", kernelFunc: PY };
  function LY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { a: o, b: s10 } = t, { transposeA: i, transposeB: a } = n;
    return oc({ a: o, b: s10, transposeA: i, transposeB: a, backend: r });
  }
  var qP = { kernelName: Fa, backendName: "webgl", kernelFunc: LY };
  var A0 = class {
    constructor(t, r, n, o, s10, i) {
      this.outputShape = [], this.variableNames = ["x", "mean", "variance"], C.assertAndGetBroadcastShape(t, r), C.assertAndGetBroadcastShape(t, n);
      let a = "0.0";
      o != null && (C.assertAndGetBroadcastShape(t, o), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
      let u = "1.0";
      s10 != null && (C.assertAndGetBroadcastShape(t, s10), this.variableNames.push("scale"), u = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  };
  var D0 = class {
    constructor(t, r, n, o, s10, i) {
      this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], C.assertAndGetBroadcastShape(t, r), C.assertAndGetBroadcastShape(t, n);
      let a = "vec4(0.0)";
      o != null && (C.assertAndGetBroadcastShape(t, o), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
      let u = "vec4(1.0)";
      s10 != null && (C.assertAndGetBroadcastShape(t, s10), this.variableNames.push("scale"), u = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  };
  var MY = ({ inputs: e28, backend: t, attrs: r }) => {
    let { x: n, mean: o, variance: s10, offset: i, scale: a } = e28;
    x.assert(o.shape.length === s10.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), x.assert(i == null || o.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), x.assert(a == null || o.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon: u } = r;
    u == null && (u = 1e-3);
    let l = [n, o, s10], c = null;
    i != null && (c = i.shape, l.push(i));
    let p = null;
    a != null && (p = a.shape, l.push(a));
    let m = z().getBool("WEBGL_PACK_NORMALIZATION") ? new D0(n.shape, o.shape, s10.shape, c, p, u) : new A0(n.shape, o.shape, s10.shape, c, p, u);
    return t.runWebGLProgram(m, l, l[0].dtype);
  };
  var XP = { kernelName: Wa, backendName: "webgl", kernelFunc: MY };
  var $0 = class {
    constructor(t) {
      this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;
      let r = Wt(this.rank);
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      let n = zY(this.rank), o, s10 = t.map((i, a) => `sourceLoc.${xS[a]} = start[${a}] + coords.${xS[a]};`);
      o = `
        ${r} sourceLoc;
        ${r} coords = getOutputCoords();
        ${s10.join(`
`)}
      `, this.userCode = `
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `;
    }
  };
  var xS = ["x", "y", "z", "w", "u", "v"];
  function zY(e28) {
    if (e28 === 1) return "sourceLoc";
    if (e28 <= 6) return xS.slice(0, e28).map((t) => "sourceLoc." + t).join(",");
    throw Error(`Slicing for rank ${e28} is not yet supported`);
  }
  var F0 = class {
    constructor(t) {
      this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.rank = t.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      let r = Wt(this.rank), n = Ze("coords", this.rank), o = Ze("sourceLoc", this.rank), s10 = this.rank === 1 ? "sourceLoc" : `vec2(${o.slice(-2).join()})`, i = `getChannel(getSource(${o.join()}), ${s10})`, a = `
      result.x = ${i};
      if (++${n[this.rank - 1]} < ${t[this.rank - 1]}) {
        ++${o[this.rank - 1]};
        result.y = ${i};
        --${o[this.rank - 1]};
      }
    `, u = this.rank === 1 ? "" : `
      --${n[this.rank - 1]};
      if (++${n[this.rank - 2]} < ${t[this.rank - 2]}) {
        ++${o[this.rank - 2]};
        result.z = ${i};
        if (++${n[this.rank - 1]} < ${t[this.rank - 1]}) {
          ++${o[this.rank - 1]};
          result.w = ${i};
        }
      }
    `, l = this.rank <= 4 ? `sourceLoc = coords +
            ${r}(${t.map((c, p) => `start[${p}]`).join()});` : t.map((c, p) => `${o[p]} = ${n[p]} + start[${p}];`).join(`
`);
      this.userCode = `
      void main() {
        ${r} coords = getOutputCoords();
        ${r} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `;
    }
  };
  function BY(e28, t, r, n) {
    let o = n.texData.get(e28.dataId), s10 = n.makeTensorInfo(r, e28.dtype), i = n.texData.get(s10.dataId);
    Object.assign(i, o), i.refCount = 1, i.shape = r, i.dtype = e28.dtype;
    let a = Sr.computeFlatOffset(t, x.computeStrides(e28.shape));
    o.slice && (a += o.slice.flatOffset), i.slice = { flatOffset: a, origDataId: o.slice && o.slice.origDataId || e28.dataId };
    let u = n.dataRefCount.get(i.slice.origDataId) || 1;
    return n.dataRefCount.set(i.slice.origDataId, u + 1), s10;
  }
  function rs(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { begin: s10, size: i } = n, [a, u] = Sr.parseSliceParams(o, s10, i);
    if (Sr.assertParamsValid(o, a, u), x.sizeFromShape(u) === 0) return r.makeTensorInfo(u, o.dtype, []);
    if (r.shouldExecuteOnCPU([o]) || o.dtype === "string") {
      let p = r.texData.get(o.dataId), m = BR(p.values, a, u, o.shape, o.dtype);
      return r.makeTensorInfo(u, o.dtype, m);
    }
    let { isPacked: l } = r.texData.get(o.dataId), c = Sr.isSliceContinous(o.shape, a, u);
    if (l || !c) {
      let p = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new F0(u) : new $0(u), m = [a];
      return r.runWebGLProgram(p, [o], o.dtype, m);
    }
    return r.uploadToGPU(o.dataId), BY(o, a, u, r);
  }
  var YP = { kernelName: pu, backendName: "webgl", kernelFunc: rs };
  var VY = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { blockShape: s10, crops: i } = n;
    x.assert(o.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    let a = s10.reduce((b, v) => b * v), u = C.getReshaped(o.shape, s10, a), l = C.getPermuted(u.length, s10.length), c = C.getReshapedPermuted(o.shape, s10, a), p = C.getSliceBeginCoords(i, s10.length), m = C.getSliceSize(c, i, s10.length), f = [], h = rt({ inputs: { x: o }, backend: r, attrs: { shape: u } }), d = Ae({ inputs: { x: h }, backend: r, attrs: { perm: l } }), g = rt({ inputs: { x: d }, backend: r, attrs: { shape: c } }), y = rs({ inputs: { x: g }, backend: r, attrs: { begin: p, size: m } });
    return f.push(h), f.push(d), f.push(g), f.forEach((b) => r.disposeIntermediateTensorInfo(b)), y;
  };
  var JP = { kernelName: _a, backendName: "webgl", kernelFunc: VY };
  function GY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, weights: s10 } = t, { size: i } = n, a = r.readSync(o.dataId), u = r.readSync(s10.dataId), l = p0(a, u, s10.dtype, s10.shape, i);
    return r.makeTensorInfo([i], s10.dtype, l);
  }
  var ZP = { kernelName: Rc, backendName: "webgl", kernelFunc: GY };
  var WY = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`;
  var UY = `
  return float(int(a.r) & int(b.r));
`;
  function jY(e28) {
    let { inputs: t, backend: r } = e28, { a: n, b: o } = t, s10 = z().getBool("WEBGL_PACK_BINARY_OPERATIONS"), i = z().getNumber("WEBGL_VERSION");
    if (r.shouldExecuteOnCPU([n, o]) || i === 1) {
      let u = r.texData.get(n.dataId).values, l = r.texData.get(o.dataId).values, [c, p] = cR(n.shape, o.shape, u, l, n.dtype), m = r.makeTensorInfo(p, n.dtype), f = r.texData.get(m.dataId);
      return f.values = c, m;
    }
    let a;
    return s10 ? a = new Vn(WY, n.shape, o.shape, false) : a = new In(UY, n.shape, o.shape), r.runWebGLProgram(a, [n, o], n.dtype);
  }
  var QP = { kernelName: Ef, backendName: "webgl", kernelFunc: jY };
  function HY(e28) {
    let { inputs: t, backend: r } = e28, { s0: n, s1: o } = t, s10 = r.readSync(n.dataId), i = r.readSync(o.dataId), a = C.assertAndGetBroadcastShape(Array.from(s10), Array.from(i));
    return r.makeTensorInfo([a.length], "int32", Int32Array.from(a));
  }
  var tL = { kernelName: cy, backendName: "webgl", kernelFunc: HY };
  var KY = "return float(a != b);";
  var bS = le({ opSnippet: KY, cpuKernelImpl: $R, dtype: "bool" });
  var eL = { kernelName: cl, backendName: "webgl", kernelFunc: bS };
  function la(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t, o = r.texData.get(n.dataId);
    return Qe({ inputs: { x: o.complexTensorInfos.real }, backend: r });
  }
  var rL = { kernelName: ip, backendName: "webgl", kernelFunc: la };
  var qY = "return float(int(x));";
  function nL(e28, t) {
    let r = new Lr(e28.shape, qY), n = t.runWebGLProgram(r, [e28], "int32");
    return { dataId: n.dataId, shape: n.shape, dtype: n.dtype };
  }
  function wS(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { dtype: s10 } = n;
    if (s10 === "complex64") {
      if (o.dtype === "complex64") return Qe({ inputs: { x: o }, backend: r });
      let i = Se(o.shape), a = wS({ inputs: { x: o }, backend: r, attrs: { dtype: "float32" } }), u = Tn({ inputs: { real: a, imag: i }, backend: r });
      return i.dispose(), r.disposeIntermediateTensorInfo(a), u;
    }
    if (o.dtype === "complex64") {
      let i = la({ inputs: { input: o }, backend: r }), a = wS({ inputs: { x: i }, backend: r, attrs: { dtype: s10 } });
      return r.disposeIntermediateTensorInfo(i), a;
    }
    if (!x.hasEncodingLoss(o.dtype, s10)) {
      let i = Qe({ inputs: { x: o }, backend: r });
      return { dataId: i.dataId, shape: i.shape, dtype: s10 };
    }
    if (r.shouldExecuteOnCPU([o])) {
      let i = r.texData.get(o.dataId).values, [a, u, l] = pR(i, o.shape, o.dtype, s10);
      return r.makeTensorInfo(a, u, l);
    }
    if (s10 === "int32") return nL(o, r);
    if (s10 === "bool") {
      let i = r.makeTensorInfo([], "bool", x.getTypedArrayFromDType("bool", 1)), u = bS({ inputs: { a: o, b: i }, backend: r });
      return r.disposeIntermediateTensorInfo(i), u;
    }
    throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s10}`);
  }
  var oL = { kernelName: hs, backendName: "webgl", kernelFunc: wS };
  var sL = "return ceil(x);";
  var XY = St({ opSnippet: sL, packedOpSnippet: sL, cpuKernelImpl: mR });
  var iL = { kernelName: ni, backendName: "webgl", kernelFunc: XY };
  var _0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = t, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  };
  var O0 = class {
    constructor(t) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = t, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  };
  function YY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { clipValueMin: s10, clipValueMax: i } = n, a;
    z().getBool("WEBGL_PACK_CLIP") ? a = new O0(o.shape) : a = new _0(o.shape);
    let u = [[s10], [i]];
    return r.runWebGLProgram(a, [o], o.dtype, u);
  }
  var aL = { kernelName: oi, backendName: "webgl", kernelFunc: YY };
  var R0 = class {
    constructor(t) {
      this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  };
  function uL(e28, t) {
    return { dataId: t.dataId, dtype: t.dtype, shape: e28.shape };
  }
  function JY(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t, o = r.texData.get(n.dataId), s10 = new R0(n.shape), i = [uL(n, o.complexTensorInfos.real), uL(n, o.complexTensorInfos.imag)];
    return r.runWebGLProgram(s10, i, i[0].dtype);
  }
  var lL = { kernelName: Oa, backendName: "webgl", kernelFunc: JY };
  var P0 = class {
    constructor(t) {
      this.outputShape = [], this.outputShape = C.computeOutShape(t, 1), this.variableNames = t.map((i, a) => `T${a}`);
      let r = new Array(t.length - 1);
      r[0] = t[0][1];
      for (let i = 1; i < r.length; i++) r[i] = r[i - 1] + t[i][1];
      let n = [`if (yC < ${r[0]}) setOutput(getT0(yR, yC));`];
      for (let i = 1; i < r.length; i++) {
        let a = r[i - 1];
        n.push(`else if (yC < ${r[i]}) setOutput(getT${i}(yR, yC-${a}));`);
      }
      let o = r.length, s10 = r[r.length - 1];
      n.push(`else setOutput(getT${o}(yR, yC-${s10}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `;
    }
  };
  var M0 = class {
    constructor(t, r) {
      this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = C.computeOutShape(t, r);
      let n = this.outputShape, o = n.length, s10 = Wt(o), i = Ze("coords", o), a = ["x", "y", "z", "w", "u", "v"].slice(0, o);
      this.variableNames = t.map((d, g) => `T${g}`);
      let u = new Array(t.length - 1);
      u[0] = t[0][r];
      for (let d = 1; d < u.length; d++) u[d] = u[d - 1] + t[d][r];
      let l = a[r], c = a.slice(-2), p = a.join(), m = `if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;
      for (let d = 1; d < u.length; d++) {
        let g = u[d - 1];
        m += `
        if (${l} < ${u[d]}  && ${l} >= ${u[d - 1]}) {
          return getChannel(
            getT${d}(${L0(a, l, g)}),
            vec2(${L0(c, l, g)}));
        }`;
      }
      let f = u.length, h = u[u.length - 1];
      m += `
        return getChannel(
          getT${f}(${L0(a, l, h)}),
          vec2(${L0(c, l, h)}));`, this.userCode = `
      float getValue(${a.map((d) => "int " + d)}) {
        ${m}
      }

      void main() {
        ${s10} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o - 1]} = ${i[o - 1]} + 1;
        if (${i[o - 1]} < ${n[o - 1]}) {
          result.g = getValue(${i});
        }

        ${i[o - 2]} = ${i[o - 2]} + 1;
        if (${i[o - 2]} < ${n[o - 2]}) {
          result.a = getValue(${i});
        }

        ${i[o - 1]} = ${i[o - 1]} - 1;
        if (${i[o - 2]} < ${n[o - 2]} &&
            ${i[o - 1]} < ${n[o - 1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `;
    }
  };
  function L0(e28, t, r) {
    let n = e28.indexOf(t);
    return e28.map((s10, i) => i === n ? `${s10} - ${r}` : s10).join();
  }
  function sc(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t, o = r.texData.get(n.dataId);
    return Qe({ inputs: { x: o.complexTensorInfos.imag }, backend: r });
  }
  var cL = { kernelName: Zc, backendName: "webgl", kernelFunc: sc };
  function zm(e28, t, r) {
    let n = e28[0].dtype;
    if (n === "complex64") {
      let f = e28.map((b) => la({ inputs: { input: b }, backend: r })), h = e28.map((b) => sc({ inputs: { input: b }, backend: r })), d = zm(f, t, r), g = zm(h, t, r), y = Tn({ inputs: { real: d, imag: g }, backend: r });
      return f.forEach((b) => r.disposeIntermediateTensorInfo(b)), h.forEach((b) => r.disposeIntermediateTensorInfo(b)), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(g), y;
    }
    let o = r.shouldExecuteOnCPU(e28);
    if (n === "string" && (o = true), o) {
      let f = e28.map((w) => {
        let E = [-1, x.sizeFromShape(w.shape.slice(t))];
        return rt({ inputs: { x: w }, backend: r, attrs: { shape: E } });
      }), h = f.map((w) => ({ vals: r.readSync(w.dataId), shape: w.shape })), d = C.computeOutShape(f.map((w) => w.shape), 1), g = f[0].shape[0] === 1, y = fR(h, d, n, g), b = C.computeOutShape(e28.map((w) => w.shape), t), v = r.makeTensorInfo(b, n, y);
      return f.forEach((w) => r.disposeIntermediateTensorInfo(w)), v;
    }
    let s10 = e28.filter((f) => x.sizeFromShape(f.shape) > 0), i = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && s10[0].shape.length > 1;
    if (s10.length === 1) {
      let f = i ? new Lr(e28[0].shape, Rs) : new Sn(e28[0].shape, Rs);
      return r.runWebGLProgram(f, e28, n);
    }
    let a = z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if (s10.length > a) {
      let f = [];
      for (let d = 0; d < s10.length; d += a) {
        let g = s10.slice(d, d + a);
        f.push(zm(g, t, r));
      }
      let h = zm(f, t, r);
      for (let d of f) r.disposeIntermediateTensorInfo(d);
      return h;
    }
    if (i) {
      let f = new M0(s10.map((h) => h.shape), t);
      return r.runWebGLProgram(f, s10, n);
    }
    let { tensors2D: u, outShape: l } = ZY(s10, t, r), c = new P0(u.map((f) => f.shape)), p = r.runWebGLProgram(c, u, n);
    u.forEach((f) => r.disposeIntermediateTensorInfo(f));
    let m = rt({ inputs: { x: p }, attrs: { shape: l }, backend: r });
    return r.disposeIntermediateTensorInfo(p), m;
  }
  function ZY(e28, t, r) {
    let n = C.computeOutShape(e28.map((s10) => s10.shape), t);
    return { tensors2D: e28.map((s10) => rt({ inputs: { x: s10 }, attrs: { shape: [-1, x.sizeFromShape(s10.shape.slice(t))] }, backend: r })), outShape: n };
  }
  function vS(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { axis: o } = n, s10 = x.parseAxisParam(o, t[0].shape)[0], i = t.map((l) => l.shape);
    C.assertParamsConsistent(i, s10);
    let a = C.computeOutShape(t.map((l) => l.shape), s10);
    if (x.sizeFromShape(a) === 0) return r.makeTensorInfo(a, t[0].dtype, []);
    let u = t.filter((l) => x.sizeFromShape(l.shape) > 0);
    return u.length === 1 ? Qe({ inputs: { x: u[0] }, backend: r }) : zm(u, s10, r);
  }
  var pL = { kernelName: Ra, backendName: "webgl", kernelFunc: vS };
  var Bm = class {
    constructor(t, r = false, n = null, o = false, s10 = false) {
      this.variableNames = ["x", "W"], this.outputShape = t.outShape;
      let i = t.padInfo.top, a = t.padInfo.left, u = t.strideHeight, l = t.strideWidth, c = t.dilationHeight, p = t.dilationWidth, m = t.filterHeight, f = t.filterWidth, h = Math.floor(t.inChannels / 4) * 4, d = t.inChannels % 4, g = t.dataFormat === "channelsLast", y = g ? 1 : 2, b = g ? 2 : 3, v = g ? 3 : 1, w = "", N = "";
      n && (o ? w = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }` : s10 ? w = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }` : w = `
          float activation(float x) {
            ${n}
          }
        `, N = "result = activation(result);");
      let E = r ? "result += getBiasAtOutCoords();" : "";
      r && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), s10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${w}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${d === 1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${d === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${d === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${N}
        setOutput(result);
      }
    `;
    }
  };
  var z0 = class {
    constructor(t) {
      this.variableNames = ["x", "W"], this.outputShape = t.outShape;
      let r = t.padInfo.front, n = t.padInfo.top, o = t.padInfo.left, s10 = t.strideDepth, i = t.strideHeight, a = t.strideWidth, u = t.dilationDepth, l = t.dilationHeight, c = t.dilationWidth, p = t.filterDepth, m = t.filterHeight, f = t.filterWidth, h = Math.floor(t.inChannels / 4) * 4, d = t.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${s10}, ${i}, ${a});
      const ivec3 pads = ivec3(${r}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${d === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${d === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${d === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Vm = class {
    constructor(t, r = false, n = null, o = false, s10 = false) {
      this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = t.outShape, this.enableShapeUniforms = fe(this.outputShape.length);
      let i = t.padInfo.left, a = t.strideWidth, u = t.dilationWidth, l = t.filterHeight, c = t.filterWidth, p = c, m = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
      for (let g = 0; g < c; g++) m += `
           vec4 xTexelC${g * 2};
           int xTexelC${g * 2}Ready;
           vec4 xTexelC${g * 2 + 1};
           int xTexelC${g * 2 + 1}Ready;
           vec4 xC${g};`;
      m += `
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;
      for (let g = 0; g < c; g++) m += `
           xTexelC${g * 2} = vec4(0.0);
           xTexelC${g * 2}Ready = 0;
           xTexelC${g * 2 + 1} = vec4(0.0);
           xTexelC${g * 2 + 1}Ready = 0;
           xC${g} = vec4(0.0);`;
      m += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
      for (let g = 0; g < (p + 1) / 2; g++) {
        let y = g * 2;
        if (m += `
           xC = xCCorner + ${y * u};
           `, a === 1) {
          if (y < c && (i % 2 === 1 ? (m += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `, u === 1 && y > 0 ? m += `
                 xC${y} = vec4(xTexelC${y - 2}.zw, xTexelC${y}.xy);
                 ` : m += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `) : m += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `, y + 1 < c)) {
            let b = i % 2 === 0 ? x.nearestLargerEven(u) : u;
            u % 2 === 0 && i % 2 === 1 || u % 2 !== 0 && i % 2 !== 1 ? (m += `
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                     xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y + 1}.zw = vec2(0.0);
                     }
                     xTexelC${y + 1}Ready = 1;
                   }
                   `, u > 1 ? m += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y + 1} = vec4(previous.zw, xTexelC${y + 1}.xy);
                     } else {
                      xC${y + 1} = vec4(0.0, 0.0, xTexelC${y + 1}.xy);
                     }
                     ` : m += `
                     xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.xy);
                     `) : b === 1 ? m += `
                     xC${y + 1} = xTexelC${y};
                     ` : m += `
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                       xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y + 1}.zw = vec2(0.0);
                       }
                       xTexelC${y + 1}Ready = 1;
                     }

                     xC${y + 1} = xTexelC${y + 1};
                     `;
          }
        } else y < c && (i % 2 === 1 ? (m += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y + 1}Ready == 0) {
                   xTexelC${y + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y + 1}.zw = vec2(0.0);
                   }
                   xTexelC${y + 1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
               `, y + 1 < c && (m += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y + 1} = vec4(xTexelC${y + 1}.xy, final.xy);
                 `)) : (m += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                   xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y + 1}.zw = vec2(0.);
                   }
                   xTexelC${y + 1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y + 1}.xy);
               `, y + 1 < c && (m += `
                   xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
                 `)));
        y < c && (m += `
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, y + 1 < c && (m += `
               wTexel = getW(r, ${y + 1}, d1, d2);
               dotProd += xC${y + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
      }
      m += `
     }
   `, m += `
     }
   `, m += `
     }
   `;
      let f = "", h = "";
      n && (o ? f = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }` : s10 ? f = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }` : f = `vec4 activation(vec4 x) {
           ${n}
         }`, h = "result = activation(result);");
      let d = r ? "result += getBiasAtOutCoords();" : "";
      r && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), s10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${d}
         ${h}
         setOutput(result);
       }
     `;
    }
  };
  var B0 = class {
    constructor(t, r) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec4" }, { name: "pad", type: "ivec2" }, { name: "stride", type: "ivec2" }, { name: "dilation", type: "ivec2" }, { name: "inChannels", type: "int" }, { name: "itemsPerBlockRow", type: "int" }, { name: "outWidth", type: "int" }], this.outputShape = t, this.enableShapeUniforms = fe(this.outputShape.length);
      let { dataFormat: n } = r, o = Le(), s10 = n === "channelsLast", i = s10 ? 1 : 2, a = s10 ? 2 : 3, u = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${t[2]} && pos < ${t[1]}) {`, l = "";
      for (let c = 0; c <= 1; c++) for (let p = 0; p <= 1; p++) l += `
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s10}) {
                  innerDims = vec2(d1, ch);
                  result[${c * 2 + p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c * 2 + p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `;
    }
  };
  function V0(e28, t) {
    let r = e28.length;
    return r >= 3 ? t ? [...e28.slice(0, -3), e28[r - 3] * e28[r - 2], e28[r - 1]] : [...e28.slice(0, -3), e28[r - 3], e28[r - 2] * e28[r - 1]] : !t && r === 1 && e28[0] > 1 ? [e28[0], 1] : null;
  }
  function G0({ x: e28, filter: t, convInfo: r, backend: n, bias: o = null, preluActivationWeights: s10 = null, leakyreluAlpha: i = 0, activation: a = null }) {
    let u = e28.shape, l = n.texData.get(e28.dataId), c = r.inChannels, p = u[0] * u[1] * u[2], m = r.outChannels, f = r.dataFormat === "channelsLast", h = false, d = false, g, y = [];
    if (s10 != null) {
      let w = V0(s10.shape, f);
      w != null && (s10 = rt({ inputs: { x: s10 }, backend: n, attrs: { shape: w } }), y.push(s10));
    }
    if (o != null) {
      let w = V0(o.shape, f);
      w != null && (o = rt({ inputs: { x: o }, backend: n, attrs: { shape: w } }), y.push(o));
    }
    if (!((p === 1 || m === 1) && c > yS) && l.isPacked && f && l.texture != null && u[2] % 2 !== 0 && x.arraysEqual(l.shape.slice(-3), u.slice(-3))) {
      let w = u[0] * u[1] * (u[2] + 1), N = { dataId: e28.dataId, shape: [1, w, r.inChannels], dtype: e28.dtype }, E = l.shape;
      l.shape = l.shape.slice(), l.shape[l.shape.length - 2]++, x.assert(Ql(l.shape, N.shape), () => `packed reshape ${l.shape} to ${N.shape} isn't free`);
      let A = rt({ inputs: { x: t }, backend: n, attrs: { shape: [1, r.inChannels, r.outChannels] } });
      y.push(A);
      let D = oc({ a: N, b: A, backend: n, transposeA: h, transposeB: d, bias: o, activation: a, preluActivationWeights: s10, leakyreluAlpha: i }), R = n.texData.get(D.dataId);
      x.assert(R.isPacked, () => "batchMatMul result is expected to be packed"), l.shape = E, R.shape = r.outShape, g = Qe({ inputs: { x: D }, backend: n }), g.shape = r.outShape, y.push(D);
    } else {
      let w = r.outHeight * r.outWidth, N = rt({ inputs: { x: e28 }, backend: n, attrs: { shape: f ? [r.batchSize, w, r.inChannels] : [r.batchSize, r.inChannels, w] } }), E = rt({ inputs: { x: t }, backend: n, attrs: { shape: [1, r.inChannels, r.outChannels] } }), A = oc({ a: f ? N : E, b: f ? E : N, transposeA: !f, transposeB: d, backend: n, bias: o, activation: a, preluActivationWeights: s10, leakyreluAlpha: i });
      g = rt({ inputs: { x: A }, backend: n, attrs: { shape: r.outShape } }), y.push(N), y.push(E), y.push(A);
    }
    for (let w of y) n.disposeIntermediateTensorInfo(w);
    return g;
  }
  function W0({ x: e28, filter: t, convInfo: r, backend: n, bias: o = null, preluActivationWeights: s10 = null, leakyreluAlpha: i = 0, activation: a = null }) {
    let { filterWidth: u, filterHeight: l, inChannels: c, outWidth: p, outHeight: m, dataFormat: f } = r, h = f === "channelsLast", d = u * l * c, g = m * p, y = [r.batchSize, d, g], b = true, v = false, w = [];
    if (s10 != null) {
      let q = V0(s10.shape, h);
      q != null && (s10 = rt({ inputs: { x: s10 }, backend: n, attrs: { shape: q } }), w.push(s10));
    }
    if (o != null) {
      let q = V0(o.shape, h);
      q != null && (o = rt({ inputs: { x: o }, backend: n, attrs: { shape: q } }), w.push(o));
    }
    let N = rt({ inputs: { x: t }, backend: n, attrs: { shape: [1, d, x.sizeFromShape(t.shape) / d] } });
    w.push(N);
    let E = new B0(y, r), A = [e28.shape, [r.padInfo.top, r.padInfo.left], [r.strideHeight, r.strideWidth], [r.dilationHeight, r.dilationWidth], [r.inChannels], [r.filterWidth * r.inChannels], [r.outWidth]], D = n.runWebGLProgram(E, [e28], "float32", A), R = rt({ inputs: { x: D }, backend: n, attrs: { shape: y } });
    w.push(D), w.push(R);
    let L = o != null, G = s10 != null, W = a === "leakyrelu", U = a ? ua(a, true) : null, H = new Mm(h ? R.shape : N.shape, h ? N.shape : R.shape, h ? [r.batchSize, g, r.outChannels] : [r.batchSize, r.outChannels, g], b, v, L, U, G, W), j = h ? [R, N] : [N, R];
    if (o && j.push(o), G && j.push(s10), W) {
      let q = n.makeTensorInfo([], "float32", x.createScalarValue(i, "float32"));
      j.push(q), w.push(q);
    }
    let X = n.runWebGLProgram(H, j, "float32"), Q = rt({ inputs: { x: X }, backend: n, attrs: { shape: r.outShape } });
    w.push(X);
    for (let q of w) n.disposeIntermediateTensorInfo(q);
    return Q;
  }
  function QY(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dataFormat: u, dilations: l, dimRoundingMode: c } = n, p = C.convertConv2DDataFormat(u), m = C.computeConv2DInfo(o.shape, s10.shape, i, l, a, c, false, p), f;
    if (m.filterHeight === 1 && m.filterWidth === 1 && m.dilationHeight === 1 && m.dilationWidth === 1 && m.strideHeight === 1 && m.strideWidth === 1 && (m.padInfo.type === "SAME" || m.padInfo.type === "VALID")) f = G0({ x: o, filter: s10, convInfo: m, backend: r });
    else if (m.strideWidth <= 2 && p === "channelsLast" && z().getBool("WEBGL_EXP_CONV")) {
      let d = new Vm(m), g = [[m.padInfo.top, m.padInfo.left], [m.strideHeight, m.strideWidth], [m.dilationHeight, m.dilationWidth], [m.inHeight, m.inWidth]];
      f = r.runWebGLProgram(d, [o, s10], "float32", g);
    } else if (z().getBool("WEBGL_CONV_IM2COL")) f = W0({ x: o, filter: s10, convInfo: m, backend: r });
    else {
      let d = new Bm(m);
      f = r.runWebGLProgram(d, [o, s10], "float32");
    }
    let h = rt({ inputs: { x: f }, backend: r, attrs: { shape: m.outShape } });
    return r.disposeIntermediateTensorInfo(f), h;
  }
  var mL = { kernelName: Pa, backendName: "webgl", kernelFunc: QY };
  var U0 = class {
    constructor(t) {
      this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
      let r = t.strideHeight, n = t.strideWidth, o = t.padInfo.top, s10 = t.padInfo.left, i = t.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${r} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s10};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var j0 = class {
    constructor(t) {
      this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
      let r = t.filterHeight, n = t.filterWidth, o = t.strideHeight, s10 = t.strideWidth, i = t.dataFormat === "channelsLast", a = r - 1 - t.padInfo.top, u = n - 1 - t.padInfo.left, l = i ? 1 : 2, c = i ? 2 : 3, p = i ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${r} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s10}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var H0 = class {
    constructor(t) {
      this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
      let r = t.strideDepth, n = t.strideHeight, o = t.strideWidth, s10 = t.padInfo.front, i = t.padInfo.top, a = t.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${r} - ${s10};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var K0 = class {
    constructor(t) {
      this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
      let r = t.filterDepth, n = t.filterHeight, o = t.filterWidth, s10 = t.strideDepth, i = t.strideHeight, a = t.strideWidth, u = r - 1 - t.padInfo.front, l = n - 1 - t.padInfo.top, c = o - 1 - t.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${r}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s10}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${r} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function tJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, dy: s10 } = t, { strides: i, pad: a, dataFormat: u, dimRoundingMode: l, filterShape: c } = n, p = C.convertConv2DDataFormat(u), m = C.computeConv2DInfo(o.shape, c, i, 1, a, l, false, p), f = new U0(m);
    return r.runWebGLProgram(f, [o, s10], "float32");
  }
  var fL = { kernelName: Lc, backendName: "webgl", kernelFunc: tJ };
  var q0 = class {
    constructor(t) {
      this.variableNames = ["dy", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "strides", type: "vec2" }], this.outputShape = t.inShape, this.enableShapeUniforms = fe(this.outputShape.length);
      let r = t.filterHeight, n = t.filterWidth, o = r - 1 - t.padInfo.top, s10 = n - 1 - t.padInfo.left;
      this.userCode = `
      const ivec2 pads = ivec2(${o}, ${s10});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${r}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${r} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
    }
  };
  function eJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, filter: s10 } = t, { inputShape: i, strides: a, pad: u, dataFormat: l, dimRoundingMode: c } = n, p = C.convertConv2DDataFormat(l), m = C.computeConv2DInfo(i, s10.shape, a, 1, u, c, false, p);
    if (z().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && p === "channelsLast") {
      let f = [[m.strideHeight, m.strideWidth]], h = new q0(m);
      return r.runWebGLProgram(h, [o, s10], "float32", f);
    } else {
      let f = new j0(m);
      return r.runWebGLProgram(f, [o, s10], "float32");
    }
  }
  var hL = { kernelName: La, backendName: "webgl", kernelFunc: eJ };
  function rJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dilations: u } = n, l = C.computeConv3DInfo(o.shape, s10.shape, i, u, a), c = new z0(l);
    return r.runWebGLProgram(c, [o, s10], "float32");
  }
  var dL = { kernelName: Ma, backendName: "webgl", kernelFunc: rJ };
  function nJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, dy: s10 } = t, { strides: i, pad: a, filterShape: u } = n, l = C.computeConv3DInfo(o.shape, u, i, 1, a), c = new H0(l);
    return r.runWebGLProgram(c, [o, s10], "float32");
  }
  var gL = { kernelName: Mc, backendName: "webgl", kernelFunc: nJ };
  function oJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, filter: s10 } = t, { pad: i, strides: a, inputShape: u } = n, l = C.computeConv3DInfo(u, s10.shape, a, 1, i), c = new K0(l);
    return r.runWebGLProgram(c, [o, s10], "float32");
  }
  var yL = { kernelName: zc, backendName: "webgl", kernelFunc: oJ };
  var sJ = _o + `
  return cos(x);
`;
  var iJ = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Gn}
  return result;
`;
  var aJ = St({ opSnippet: sJ, packedOpSnippet: iJ });
  var xL = { kernelName: si, backendName: "webgl", kernelFunc: aJ };
  var uJ = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
  var lJ = St({ opSnippet: uJ });
  var bL = { kernelName: ii, backendName: "webgl", kernelFunc: lJ };
  var X0 = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
      let [i, a, u, l] = t, [c] = r, [p, m] = n;
      this.outputShape = [c, p, m, l];
      let f = o === "bilinear" ? 1 : 0, [h, d] = [`${a - 1}.0`, `${u - 1}.0`], [g, y, b] = p > 1 ? [`${(a - 1) / (p - 1)}`, "(y2-y1) * height_ratio", `y1*${h} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${h}`], [v, w, N] = m > 1 ? [`${(u - 1) / (m - 1)}`, "(x2-x1) * width_ratio", `x1*${d} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${d}`];
      this.userCode = `
      const float height_ratio = float(${g});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s10}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${d} ) {
          setOutput(float(${s10}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  };
  var cJ = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { image: o, boxes: s10, boxInd: i } = t, { cropSize: a, method: u, extrapolationValue: l } = n, c = new X0(o.shape, s10.shape, a, u, l);
    return r.runWebGLProgram(c, [o, s10, i], "float32");
  };
  var wL = { kernelName: Vc, backendName: "webgl", kernelFunc: cJ };
  var ic;
  (function(e28) {
    e28.Prod = "*", e28.Sum = "+";
  })(ic || (ic = {}));
  var dg = class {
    constructor(t, r, n, o) {
      this.op = t, this.outputShape = r, this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }];
      let s10 = this.outputShape.length, i = this.op === ic.Prod ? "1.0" : "0.0", a = n ? i : `getX(${vL(s10, "coords", this.op)})`, u = this.outputShape[this.outputShape.length - 1], l = "", c = "";
      n ? (l = o ? `end != ${u - 1}` : "end != 0", c = o ? "end + 1" : "end - 1") : (l = o ? `end + pow2 < ${u}` : "end >= pow2", c = o ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${Wt(s10)} coords = getOutputCoords();
        int end = ${NL(s10, "coords", this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${NL(s10, "coords", this.op)} = idx;
          val ${this.op}= getX(${vL(s10, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
  };
  function vL(e28, t, r) {
    if (e28 === 1) return `${t}`;
    if (e28 === 2) return `${t}.x, ${t}.y`;
    if (e28 === 3) return `${t}.x, ${t}.y, ${t}.z`;
    if (e28 === 4) return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
    throw new Error(`Cumulative ${r} for rank ${e28} is not yet supported`);
  }
  function NL(e28, t, r) {
    if (e28 === 1) return `${t}`;
    if (e28 === 2) return `${t}.y`;
    if (e28 === 3) return `${t}.z`;
    if (e28 === 4) return `${t}.w`;
    throw new Error(`Cumulative ${r} for rank ${e28} is not yet supported`);
  }
  function Y0(e28, t, r, n, o, s10) {
    let i = t.shape.length, a = C.getAxesPermutation([n], i), u = t;
    a != null && (u = Ae({ inputs: { x: t }, backend: r, attrs: { perm: a } }));
    let l = C.getInnerMostAxes(1, i)[0];
    if (l !== i - 1) throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${n}`);
    let c = u.shape[l], p = Qe({ inputs: { x: u }, backend: r });
    for (let m = 0; m <= Math.ceil(Math.log2(c)) - 1; m++) {
      let f = new dg(e28, u.shape, false, s10), h = [[m]], d = p;
      p = r.runWebGLProgram(f, [p], p.dtype, h), r.disposeIntermediateTensorInfo(d);
    }
    if (o) {
      let m = new dg(e28, u.shape, o, s10), f = p;
      p = r.runWebGLProgram(m, [p], p.dtype), r.disposeIntermediateTensorInfo(f);
    }
    if (a != null) {
      let m = C.getUndoAxesPermutation(a), f = Ae({ inputs: { x: p }, backend: r, attrs: { perm: m } });
      return r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(u), f;
    }
    return p;
  }
  function pJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, exclusive: i, reverse: a } = n;
    return Y0(ic.Prod, o, r, s10, i, a);
  }
  var CL = { kernelName: Bc, backendName: "webgl", kernelFunc: pJ };
  function mJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, exclusive: i, reverse: a } = n;
    return Y0(ic.Sum, o, r, s10, i, a);
  }
  var SL = { kernelName: za, backendName: "webgl", kernelFunc: mJ };
  function fJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, weights: s10 } = t, { size: i, binaryOutput: a } = n;
    if (o.shape.length === 1) {
      let u = r.readSync(o.dataId), l = r.readSync(s10.dataId), c = p0(u, l, s10.dtype, s10.shape, i);
      return r.makeTensorInfo([i], s10.dtype, c);
    } else if (o.shape.length === 2) {
      let u = r.bufferSync(o), l = r.bufferSync(s10), c = lR(u, l, i, a);
      return r.makeTensorInfo(c.shape, s10.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`);
  }
  var IL = { kernelName: Gc, backendName: "webgl", kernelFunc: fJ };
  var J0 = class {
    constructor(t, r, n) {
      this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = r, this.dataFormat = n, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${r};
      int offset_h = imod(h, ${r});
      int in_w = w / ${r};
      int offset_w = imod(w, ${r});
      int offset_d = (offset_h * ${r} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  };
  function hJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { blockSize: s10, dataFormat: i } = n, a = o.shape[0], u = i === "NHWC" ? o.shape[1] : o.shape[2], l = i === "NHWC" ? o.shape[2] : o.shape[3], c = i === "NHWC" ? o.shape[3] : o.shape[1], p = u * s10, m = l * s10, f = c / (s10 * s10), h = i === "NHWC" ? [a, p, m, f] : [a, f, p, m], d = new J0(h, s10, i);
    return r.runWebGLProgram(d, [o], o.dtype);
  }
  var TL = { kernelName: Wc, backendName: "webgl", kernelFunc: hJ };
  var Gm = class {
    constructor(t, r = false, n = null, o = false, s10 = false) {
      this.variableNames = ["x", "W"], this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = t.outShape, this.enableShapeUniforms = fe(this.outputShape.length);
      let i = t.filterHeight, a = t.filterWidth, u = t.outChannels / t.inChannels, l = "", c = "";
      n && (o ? l = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }` : s10 ? l = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }` : l = `
          float activation(float x) {
            ${n}
          }
        `, c = "result = activation(result);");
      let p = r ? "result += getBiasAtOutCoords();" : "";
      r && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), s10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `;
    }
  };
  var Wm = class {
    constructor(t, r = false, n = null, o = false, s10 = false) {
      this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = t.outShape, this.enableShapeUniforms = fe(this.outputShape.length);
      let i = t.outChannels / t.inChannels, a = t.padInfo.left, u = t.strideWidth, l = t.dilationWidth, c = t.filterHeight, p = t.filterWidth, m = p, f = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let y = 0; y < p; y++) f += `
          vec4 xTexelC${y * 2};
          int xTexelC${y * 2}Ready;
          vec4 xTexelC${y * 2 + 1};
          int xTexelC${y * 2 + 1}Ready;
          vec4 xC${y};`;
      f += `
    for (int r = 0; r < ${c}; r++) {
      `;
      for (let y = 0; y < p; y++) f += `
          xTexelC${y * 2} = vec4(0.0);
          xTexelC${y * 2}Ready = 0;
          xTexelC${y * 2 + 1} = vec4(0.0);
          xTexelC${y * 2 + 1}Ready = 0;
          xC${y} = vec4(0.0);`;
      f += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let y = 0; y < (m + 1) / 2; y++) {
        let b = y * 2;
        if (f += `
          xC = xCCorner + ${b * l};
          `, u === 1) {
          if (b < p && (a % 2 === 1 ? (f += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `, l === 1 && b > 0 ? f += `
                xC${b} = vec4(xTexelC${b - 2}.zw, xTexelC${b}.xy);
                ` : f += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `) : f += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `, b + 1 < p)) {
            let v = a % 2 === 0 ? x.nearestLargerEven(l) : l;
            l % 2 === 0 && a % 2 === 1 || l % 2 !== 0 && a % 2 !== 1 ? (f += `
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {
                    xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b + 1}.zw = vec2(0.0);
                    }
                    xTexelC${b + 1}Ready = 1;
                  }
                  `, l > 1 ? f += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b + 1} = vec4(previous.zw, xTexelC${b + 1}.xy);
                    } else {
                     xC${b + 1} = vec4(0.0, 0.0, xTexelC${b + 1}.xy);
                    }
                    ` : f += `
                    xC${b + 1} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.xy);
                    `) : v === 1 ? f += `
                    xC${b + 1} = xTexelC${b};
                    ` : f += `
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {
                      xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b + 1}.zw = vec2(0.0);
                      }
                      xTexelC${b + 1}Ready = 1;
                    }

                    xC${b + 1} = xTexelC${b + 1};
                    `;
          }
        } else b < p && (a % 2 === 1 ? (f += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b + 1}Ready == 0) {
                  xTexelC${b + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b + 1}.zw = vec2(0.0);
                  }
                  xTexelC${b + 1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.zw);
              `, b + 1 < p && (f += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b + 1} = vec4(xTexelC${b + 1}.xy, final.xy);
                `)) : (f += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {
                  xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b + 1}.zw = vec2(0.);
                  }
                  xTexelC${b + 1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b + 1}.xy);
              `, b + 1 < p && (f += `
                  xC${b + 1} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.zw);
                `)));
        b < p && (f += `
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `, b + 1 < p && (f += `
              wTexel = getW(r, ${b + 1}, d1, q);
              dotProd += xC${b + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
      }
      f += `
    }
  `, f += `
      }
    `;
      let h = "", d = "";
      n && (o ? h = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }` : s10 ? h = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }` : h = `vec4 activation(vec4 x) {
          ${n}
        }`, d = "result = activation(result);");
      let g = r ? "result += getBiasAtOutCoords();" : "";
      r && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), s10 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${d}
        setOutput(result);
      }
    `;
    }
  };
  function dJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dilations: u, dimRoundingMode: l } = n, c = u;
    c == null && (c = [1, 1]), x.assert(C.eitherStridesOrDilationsAreOne(i, c), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);
    let p = C.computeConv2DInfo(o.shape, s10.shape, i, c, a, l, true), m;
    z().getBool("WEBGL_PACK_DEPTHWISECONV") && p.strideWidth <= 2 && p.outChannels / p.inChannels === 1 ? m = new Wm(p) : m = new Gm(p);
    let f = [[p.padInfo.top, p.padInfo.left], [p.strideHeight, p.strideWidth], [p.dilationHeight, p.dilationWidth], [p.inHeight, p.inWidth]];
    return r.runWebGLProgram(m, [o, s10], "float32", f);
  }
  var kL = { kernelName: Ba, backendName: "webgl", kernelFunc: dJ };
  var Z0 = class {
    constructor(t) {
      this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
      let r = t.strideHeight, n = t.strideWidth, o = t.padInfo.top, s10 = t.padInfo.left, i = t.outChannels / t.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${r} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s10};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Q0 = class {
    constructor(t) {
      this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
      let r = t.filterHeight, n = t.filterWidth, o = t.strideHeight, s10 = t.strideWidth, i = r - 1 - t.padInfo.top, a = n - 1 - t.padInfo.left, u = t.outChannels / t.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${r}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${r} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s10}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function gJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, dy: s10 } = t, { strides: i, dilations: a, pad: u, dimRoundingMode: l, filterShape: c } = n, p = C.computeConv2DInfo(o.shape, c, i, a, u, l, true), m = new Z0(p);
    return r.runWebGLProgram(m, [o, s10], "float32");
  }
  var EL = { kernelName: Uc, backendName: "webgl", kernelFunc: gJ };
  function yJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, filter: s10 } = t, { strides: i, dilations: a, pad: u, dimRoundingMode: l, inputShape: c } = n, p = C.computeConv2DInfo(c, s10.shape, i, a, u, l, true), m = new Q0(p);
    return r.runWebGLProgram(m, [o, s10], "float32");
  }
  var AL = { kernelName: jc, backendName: "webgl", kernelFunc: yJ };
  var tw = class {
    constructor(t) {
      this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  };
  function xJ(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t, o = [...n.shape, ...n.shape], s10 = x.sizeFromShape(n.shape), i = rt({ inputs: { x: n }, backend: r, attrs: { shape: [s10] } }), a = new tw(s10), u = r.runWebGLProgram(a, [i], i.dtype), l = rt({ inputs: { x: u }, backend: r, attrs: { shape: o } });
    return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(u), l;
  }
  var DL = { kernelName: py, backendName: "webgl", kernelFunc: xJ };
  var ew = class {
    constructor(t) {
      this.variableNames = ["x", "W"], this.outputShape = t.outShape;
      let { inHeight: r, inWidth: n, padInfo: o, strideHeight: s10, strideWidth: i, filterHeight: a, filterWidth: u, dilationHeight: l, dilationWidth: c } = t, { top: p, left: m } = o;
      this.userCode = `
      const ivec2 strides = ivec2(${s10}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${r}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  };
  function bJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10 } = t, { strides: i, pad: a, dilations: u } = n, l = C.computeDilation2DInfo(o.shape, s10.shape, i, a, "NHWC", u), c, p = new ew(l);
    c = r.runWebGLProgram(p, [o, s10], "float32");
    let m = rt({ inputs: { x: c }, backend: r, attrs: { shape: l.outShape } });
    return r.disposeIntermediateTensorInfo(c), m;
  }
  var $L = { kernelName: Va, backendName: "webgl", kernelFunc: bJ };
  function wJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { equation: o } = n, s10 = t, { allDims: i, summedDims: a, idDims: u } = C.decodeEinsumEquation(o, s10.length);
    C.checkEinsumDimSizes(i.length, u, s10);
    let { path: l, steps: c } = C.getEinsumComputePath(a, u), p = c.length, m = null, f = i.length, h = [];
    for (let d = 0; d < p; ++d) {
      for (let g of c[d]) {
        let { permutationIndices: y, expandDims: b } = C.getEinsumPermutation(f, u[g]), v;
        C.isIdentityPermutation(y) ? v = s10[g] : (v = Ae({ inputs: { x: s10[g] }, backend: r, attrs: { perm: y } }), h.push(v));
        let w = v.shape.slice();
        for (let N = 0; N < b.length; ++N) w.splice(b[N], 0, 1);
        x.arraysEqual(v.shape, w) || (v = rt({ inputs: { x: v }, backend: r, attrs: { shape: w } }), h.push(v)), m === null ? m = v : (m = fg({ inputs: { a: v, b: m }, backend: r }), h.push(m));
      }
      d < p - 1 && (l[d] >= 0 && (m = nc({ inputs: { x: m }, backend: r, attrs: { axis: l[d] - (i.length - f), keepDims: false } }), h.push(m)), f--);
    }
    for (let d of h) d !== m && r.disposeIntermediateTensorInfo(d);
    return m;
  }
  var FL = { kernelName: Hc, backendName: "webgl", kernelFunc: wJ };
  var vJ = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  var NJ = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var CJ = St({ opSnippet: vJ, packedOpSnippet: NJ });
  var _L = { kernelName: ui, backendName: "webgl", kernelFunc: CJ };
  var SJ = "return (b >= 0.0) ? a : a * (b + 1.0);";
  var IJ = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
  var TJ = (e28) => {
    let { inputs: t, backend: r } = e28, { dy: n, y: o } = t, s10 = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Vn(IJ, n.shape, o.shape) : new In(SJ, n.shape, o.shape);
    return r.runWebGLProgram(s10, [n, o], n.dtype);
  };
  var OL = { kernelName: Kc, backendName: "webgl", kernelFunc: TJ };
  var kJ = `
  return vec4(equal(a, b));
`;
  var EJ = "return float(a == b);";
  var AJ = le({ opSnippet: EJ, packedOpSnippet: kJ, dtype: "bool", cpuKernelImpl: hR });
  var RL = { kernelName: nl, backendName: "webgl", kernelFunc: AJ };
  var DJ = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${C.ERF_P};
  float a1 = ${C.ERF_A1};
  float a2 = ${C.ERF_A2};
  float a3 = ${C.ERF_A3};
  float a4 = ${C.ERF_A4};
  float a5 = ${C.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
  var $J = St({ opSnippet: DJ });
  var PL = { kernelName: li, backendName: "webgl", kernelFunc: $J };
  var FJ = _o + `
  return exp(x);
`;
  var _J = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var NS = St({ opSnippet: FJ, packedOpSnippet: _J, cpuKernelImpl: dR, dtype: "float32" });
  var LL = { kernelName: ci, backendName: "webgl", kernelFunc: NS };
  function rw(e28) {
    let { inputs: t, attrs: r, backend: n } = e28, { dim: o } = r, { input: s10 } = t, i = s10.shape.length, a = s10.shape.slice(), u = o;
    return o < 0 && (x.assert(-(i + 1) <= o, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), u = i + o + 1), a.splice(u, 0, 1), rt({ inputs: { x: s10 }, backend: n, attrs: { shape: a } });
  }
  var ML = { kernelName: Ga, backendName: "webgl", kernelFunc: rw };
  var zL = "return exp(x) - 1.0;";
  var OJ = St({ opSnippet: zL, packedOpSnippet: zL, cpuKernelImpl: gR });
  var BL = { kernelName: pi, backendName: "webgl", kernelFunc: OJ };
  var gg = class {
    constructor(t, r, n) {
      this.variableNames = ["real", "imag"];
      let o = r[1];
      this.outputShape = r;
      let s10 = n ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, i = n ? `${o}.0` : "1.0", a;
      if (t === "real") a = "return real * expR - imag * expI;";
      else if (t === "imag") a = "return real * expI + imag * expR;";
      else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);
      this.userCode = `
      const float exponentMultiplier = ${s10};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  };
  function nw(e28, t, r) {
    let n = r.texData.get(e28.dataId), o = x.sizeFromShape(e28.shape), s10 = e28.shape[e28.shape.length - 1], i = o / s10, a = rt({ inputs: { x: e28 }, backend: r, attrs: { shape: [i, s10] } }), u = a.shape, l = new gg("real", u, t), c = new gg("imag", u, t), p = [{ dataId: n.complexTensorInfos.real.dataId, dtype: n.complexTensorInfos.real.dtype, shape: u }, { dataId: n.complexTensorInfos.imag.dataId, dtype: n.complexTensorInfos.imag.dtype, shape: u }], m = r.runWebGLProgram(l, p, "float32"), f = r.runWebGLProgram(c, p, "float32"), h = Tn({ inputs: { real: m, imag: f }, backend: r });
    r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(f);
    let d = rt({ inputs: { x: h }, backend: r, attrs: { shape: e28.shape } });
    return r.disposeIntermediateTensorInfo(a), r.disposeIntermediateTensorInfo(h), d;
  }
  function RJ(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t;
    return nw(n, false, r);
  }
  var VL = { kernelName: qc, backendName: "webgl", kernelFunc: RJ };
  var ow = class {
    constructor(t, r) {
      this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = t, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  };
  function ca(e28) {
    let { backend: t, attrs: r } = e28, { shape: n, value: o } = r, { dtype: s10 } = r;
    if (s10 = s10 || x.inferDtype(o), s10 === "string") {
      let i = x.getArrayFromDType(s10, x.sizeFromShape(n));
      return i.fill(o), t.makeTensorInfo(n, s10, i);
    } else {
      let i = new ow(n, o), a = [[o]];
      return t.runWebGLProgram(i, [], s10, a);
    }
  }
  var GL = { kernelName: Xc, backendName: "webgl", kernelFunc: ca };
  var sw = class {
    constructor(t) {
      this.variableNames = ["Image"], this.outputShape = [];
      let r = t[2];
      this.outputShape = t, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${r} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${r}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };
  var WL = { kernelName: Yc, backendName: "webgl", kernelFunc: ({ inputs: e28, backend: t }) => {
    let { image: r } = e28, n = t, o = new sw(r.shape);
    return n.runWebGLProgram(o, [r], r.dtype);
  } };
  var UL = "return floor(x);";
  var PJ = St({ opSnippet: UL, packedOpSnippet: UL, cpuKernelImpl: yR });
  var jL = { kernelName: mi, backendName: "webgl", kernelFunc: PJ };
  var LJ = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
  var MJ = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
  var zJ = le({ opSnippet: LJ, packedOpSnippet: MJ, dtype: "int32" });
  var HL = { kernelName: fi, backendName: "webgl", kernelFunc: zJ };
  var iw = class {
    constructor(t) {
      this.variableNames = ["A"];
      let r = Le(), [n, o] = t;
      this.outputShape = t, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${r.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  };
  var aw = class {
    constructor(t) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
      let r = Le(), [n, o] = t;
      this.outputShape = t, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${r.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${r.output} = result;
      }
    `;
    }
  };
  var KL = { kernelName: iT, backendName: "webgl", kernelFunc: BJ };
  var Um;
  var CS = z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function BJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { pixels: o } = t, { numChannels: s10 } = n, i = typeof HTMLVideoElement < "u" && o instanceof HTMLVideoElement, a = typeof HTMLImageElement < "u" && o instanceof HTMLImageElement, [u, l] = i ? [o.videoWidth, o.videoHeight] : [o.width, o.height], c = [l, u], p = [l, u, s10];
    if (a || i) {
      let d = z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      (Um == null || d !== CS) && (CS = d, Um = document.createElement("canvas").getContext("2d", { willReadFrequently: CS })), Um.canvas.width = u, Um.canvas.height = l, Um.drawImage(o, 0, 0, u, l), o = Um.canvas;
    }
    let m = r.makeTensorInfo(c, "int32");
    r.texData.get(m.dataId).usage = Kr.PIXELS, r.gpgpu.uploadPixelDataToTexture(r.getTexture(m.dataId), o);
    let f = z().getBool("WEBGL_PACK") ? new aw(p) : new iw(p), h = r.runWebGLProgram(f, [m], "int32");
    return r.disposeData(m.dataId), h;
  }
  function VJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10, bias: i, preluActivationWeights: a } = t, { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: m, activation: f, leakyreluAlpha: h } = n, d = C.convertConv2DDataFormat(c), g = C.computeConv2DInfo(o.shape, s10.shape, u, p, l, m, false, d), y, b = [], v = i != null, w = a != null, N = f === "leakyrelu", E = () => {
      let D = [o, s10], R = (L, G) => {
        if (G === "NCHW" && L.shape.length === 1 && L.shape[0] !== 1) {
          let W = rt({ inputs: { x: L }, backend: r, attrs: { shape: [L.shape[0], 1, 1] } });
          return b.push(W), W;
        }
        return L;
      };
      if (v && D.push(R(i, c)), w && D.push(R(a, c)), N) {
        let L = r.makeTensorInfo([], "float32", x.createScalarValue(h, "float32"));
        D.push(L), b.push(L);
      }
      return D;
    };
    if (g.filterHeight === 1 && g.filterWidth === 1 && g.dilationHeight === 1 && g.dilationWidth === 1 && g.strideHeight === 1 && g.strideWidth === 1 && (g.padInfo.type === "SAME" || g.padInfo.type === "VALID")) y = G0({ x: o, filter: s10, convInfo: g, backend: r, bias: i, activation: f, preluActivationWeights: a, leakyreluAlpha: h });
    else if (g.strideWidth <= 2 && d === "channelsLast" && z().getBool("WEBGL_EXP_CONV")) {
      let D = f ? ua(f, true) : null, R = new Vm(g, v, D, w, N), L = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]], G = E();
      y = r.runWebGLProgram(R, G, "float32", L);
    } else if (z().getBool("WEBGL_CONV_IM2COL")) y = W0({ x: o, filter: s10, convInfo: g, backend: r, bias: i, activation: f, preluActivationWeights: a, leakyreluAlpha: h });
    else {
      let D = f ? ua(f, false) : null, R = new Bm(g, v, D, w, N), L = E();
      y = r.runWebGLProgram(R, L, "float32");
    }
    let A = rt({ inputs: { x: y }, backend: r, attrs: { shape: g.outShape } });
    return b.push(y), b.forEach((D) => r.disposeIntermediateTensorInfo(D)), A;
  }
  var qL = { kernelName: ml, backendName: "webgl", kernelFunc: VJ };
  function GJ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, filter: s10, bias: i, preluActivationWeights: a } = t, { strides: u, pad: l, dilations: c, dimRoundingMode: p, activation: m, leakyreluAlpha: f } = n, h = [], d = c;
    d == null && (d = [1, 1]), x.assert(C.eitherStridesOrDilationsAreOne(u, d), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${d}'`);
    let g = C.computeConv2DInfo(o.shape, s10.shape, u, d, l, p, true), y = z().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels === 1, b = m ? ua(m, y) : null, v = [o, s10], w = i != null, N = a != null, E = m === "leakyrelu";
    if (w && v.push(i), N && v.push(a), E) {
      let L = r.makeTensorInfo([], "float32", x.createScalarValue(f, "float32"));
      v.push(L), h.push(L);
    }
    let A;
    y ? A = new Wm(g, w, b, N, E) : A = new Gm(g, w, b, N, E);
    let D = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]], R = r.runWebGLProgram(A, v, "float32", D);
    return h.forEach((L) => r.disposeIntermediateTensorInfo(L)), R;
  }
  var XL = { kernelName: fl, backendName: "webgl", kernelFunc: GJ };
  var uw = class {
    constructor(t, r, n, o) {
      this.sliceDim = t, this.strides = r, this.paramsShape = o, this.variableNames = ["x", "indices"], this.outputShape = n;
      let s10 = Wt(n.length), i = `
    int index;`;
      for (let a = 0; a < this.sliceDim; a++) i += `
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;
      this.userCode = `
         void main() {
          ${s10} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
  };
  function WJ(e28) {
    let { inputs: t, backend: r } = e28, { params: n, indices: o } = t, s10 = o.shape, i = s10[s10.length - 1], a = x.sizeFromShape(n.shape), [u, l, c, p] = C.prepareAndValidate(n, o), m = rt({ inputs: { x: o }, backend: r, attrs: { shape: [l, i] } }), f = rt({ inputs: { x: n }, backend: r, attrs: { shape: [x.sizeFromShape(n.shape) / c, c] } });
    if (r.shouldExecuteOnCPU([n, o]) || n.dtype === "string") {
      let y = r.readSync(o.dataId), b = r.bufferSync(n), v = xR(y, b, n.dtype, l, i, c, p, n.shape, a);
      return r.makeTensorInfo(u, n.dtype, v.values);
    }
    let h = new uw(i, p, [l, c], n.shape), d = r.runWebGLProgram(h, [f, m], f.dtype), g = rt({ inputs: { x: d }, backend: r, attrs: { shape: u } });
    return r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(d), g;
  }
  var YL = { kernelName: my, backendName: "webgl", kernelFunc: WJ };
  var lw = class {
    constructor(t, r) {
      this.variableNames = ["A", "indices"], this.outputShape = r, this.rank = r.length;
      let n = Wt(this.rank), o = UJ(t, 2);
      this.userCode = `
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `;
    }
  };
  function UJ(e28, t) {
    let r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], n = [];
    for (let o = 0; o < e28.length; o++) o === 2 ? n.push("index") : n.push(`${r[o]}`);
    return n.join();
  }
  function SS(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, indices: s10 } = t, { axis: i, batchDims: a } = n, u = x.parseAxisParam(i, o.shape)[0];
    if (z().get("DEBUG")) {
      let b = r.readSync(s10.dataId), v = o.shape[u];
      for (let w = 0; w < b.length; ++w) {
        let N = b[w];
        x.assert(N <= v - 1 && N >= 0, () => `GatherV2: the index value ${N} is not in [0, ${v - 1}]`);
      }
    }
    let l = C.segment_util.collectGatherOpShapeInfo(o, s10, u, a), c = x.sizeFromShape(s10.shape), p = [], m = rt({ inputs: { x: o }, backend: r, attrs: { shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize] } }), f = rt({ inputs: { x: s10 }, backend: r, attrs: { shape: [l.batchSize, c / l.batchSize] } });
    p.push(m), p.push(f);
    let h = [l.batchSize, l.outerSize, c / l.batchSize, l.sliceSize];
    if (r.shouldExecuteOnCPU([o, s10]) || o.dtype === "string") {
      let b = r.bufferSync(f), v = r.bufferSync(m), w = bR(v, b, h);
      return p.forEach((N) => r.disposeIntermediateTensorInfo(N)), r.makeTensorInfo(l.outputShape, w.dtype, w.values);
    }
    let d = new lw(m.shape, h), g = r.runWebGLProgram(d, [m, f], m.dtype);
    p.push(g);
    let y = rt({ inputs: { x: g }, backend: r, attrs: { shape: l.outputShape } });
    return p.forEach((b) => r.disposeIntermediateTensorInfo(b)), y;
  }
  var JL = { kernelName: Ua, backendName: "webgl", kernelFunc: SS };
  var jJ = "return float(a > b);";
  var HJ = `
  return vec4(greaterThan(a, b));
`;
  var KJ = le({ opSnippet: jJ, packedOpSnippet: HJ, cpuKernelImpl: wR, dtype: "bool" });
  var ZL = { kernelName: ol, backendName: "webgl", kernelFunc: KJ };
  var qJ = "return float(a >= b);";
  var XJ = `
  return vec4(greaterThanEqual(a, b));
`;
  var YJ = le({ opSnippet: qJ, packedOpSnippet: XJ, dtype: "bool", cpuKernelImpl: vR });
  var QL = { kernelName: hi, backendName: "webgl", kernelFunc: YJ };
  function JJ(e28) {
    let { inputs: t, backend: r } = e28, { input: n } = t;
    return nw(n, true, r);
  }
  var t3 = { kernelName: Jc, backendName: "webgl", kernelFunc: JJ };
  var ZJ = "return float(!isnan(x) && !isinf(x));";
  var QJ = St({ opSnippet: ZJ, dtype: "bool" });
  var e32 = { kernelName: di, backendName: "webgl", kernelFunc: QJ };
  var tZ = "return float(isinf(x));";
  var eZ = St({ opSnippet: tZ, dtype: "bool" });
  var r3 = { kernelName: gi, backendName: "webgl", kernelFunc: eZ };
  var rZ = "return float(isnan(x));";
  var nZ = St({ opSnippet: rZ, dtype: "bool" });
  var n3 = { kernelName: yi, backendName: "webgl", kernelFunc: nZ };
  var oZ = "return float(a < b);";
  var sZ = `
  return vec4(lessThan(a, b));
`;
  var iZ = le({ opSnippet: oZ, packedOpSnippet: sZ, cpuKernelImpl: NR, dtype: "bool" });
  var o3 = { kernelName: sl, backendName: "webgl", kernelFunc: iZ };
  var aZ = "return float(a <= b);";
  var uZ = `
  return vec4(lessThanEqual(a, b));
`;
  var lZ = le({ opSnippet: aZ, packedOpSnippet: uZ, cpuKernelImpl: CR, dtype: "bool" });
  var s3 = { kernelName: il, backendName: "webgl", kernelFunc: lZ };
  function cZ(e28) {
    let { backend: t, attrs: r } = e28, { start: n, stop: o, num: s10 } = r, i = SR(n, o, s10);
    return t.makeTensorInfo([i.length], "float32", i);
  }
  var i3 = { kernelName: fy, backendName: "webgl", kernelFunc: cZ };
  var pZ = _o + `
  return x < 0.0 ? 0./0. : log(x);
`;
  var mZ = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`;
  var fZ = St({ opSnippet: pZ, packedOpSnippet: mZ, cpuKernelImpl: IR });
  var a3 = { kernelName: xi, backendName: "webgl", kernelFunc: fZ };
  var hZ = _o + `
  return log(1.0 + x);
`;
  var dZ = St({ opSnippet: hZ });
  var u3 = { kernelName: bi, backendName: "webgl", kernelFunc: dZ };
  var gZ = "return float(a >= 1.0 && b >= 1.0);";
  var yZ = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
  var xZ = le({ opSnippet: gZ, packedOpSnippet: yZ, dtype: "bool" });
  var l3 = { kernelName: al, backendName: "webgl", kernelFunc: xZ };
  var bZ = "return float(!(x >= 1.0));";
  var wZ = St({ opSnippet: bZ });
  var c3 = { kernelName: ul, backendName: "webgl", kernelFunc: wZ };
  var vZ = "return float(a >= 1.0 || b >= 1.0);";
  var NZ = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
  var CZ = le({ opSnippet: vZ, packedOpSnippet: NZ, dtype: "bool" });
  var p3 = { kernelName: ll, backendName: "webgl", kernelFunc: CZ };
  var cw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["x"], this.outputShape = [];
      let i = r, a = t[3] - 1;
      this.outputShape = t;
      let u, l = `float(${n}) + float(${o}) * sum`;
      s10 === 0.5 ? u = `inversesqrt(${l})` : s10 === 1 ? u = `1.0/(${l})` : u = `exp(log(${l}) * float(-${s10}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `;
    }
  };
  var pw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
      let i = r, a = t[3] - 1;
      this.outputShape = t;
      let u, l = `float(${n}) + float(${o}) * sum`;
      s10 === 0.5 ? u = `inversesqrt(${l})` : s10 === 1 ? u = `1.0/(${l})` : u = `exp(log(${l}) * float(-${s10}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `;
    }
  };
  var SZ = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { depthRadius: s10, bias: i, alpha: a, beta: u } = n, l = z().getBool("WEBGL_PACK_NORMALIZATION") ? new pw(o.shape, s10, i, a, u) : new cw(o.shape, s10, i, a, u);
    return r.runWebGLProgram(l, [o], o.dtype);
  };
  var m3 = { kernelName: Ha, backendName: "webgl", kernelFunc: SZ };
  var mw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = r, this.bias = n, this.alpha = o, this.beta = s10, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${r})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${r} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s10})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s10});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  };
  var IZ = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, y: s10, dy: i } = t, { depthRadius: a, bias: u, alpha: l, beta: c } = n, p = new mw(o.shape, a, u, l, c);
    return r.runWebGLProgram(p, [o, s10, i], o.dtype);
  };
  var f3 = { kernelName: Qc, backendName: "webgl", kernelFunc: IZ };
  function h3(e28, t, r, n) {
    let o = x.sizeFromShape(t), i = x.sizeFromShape(e28.shape) / o, a = rt({ inputs: { x: e28 }, attrs: { shape: [i, o] }, backend: n }), u = Wn(a, e28.dtype, "max", n), l = rt({ inputs: { x: u }, attrs: { shape: r }, backend: n });
    return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(u), l;
  }
  function IS(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { reductionIndices: s10, keepDims: i } = n, a = o.shape.length, u = x.parseAxisParam(s10, o.shape), l = u, c = C.getAxesPermutation(l, a), p = c != null, m = r.shouldExecuteOnCPU([o]), f = o;
    if (p) {
      if (m) {
        let v = r.texData.get(f.dataId).values, w = new Array(a);
        for (let A = 0; A < w.length; A++) w[A] = o.shape[c[A]];
        let N = rc(v, o.shape, o.dtype, c, w);
        f = r.makeTensorInfo(w, o.dtype);
        let E = r.texData.get(f.dataId);
        E.values = N;
      } else f = Bu(o, c, r);
      l = C.getInnerMostAxes(l.length, a);
    }
    C.assertAxesAreInnerMostDims("max", l, a);
    let [h, d] = C.computeOutAndReduceShapes(f.shape, l), g = h;
    i && (g = C.expandShapeToKeepDim(h, u));
    let y;
    if (m) {
      let v = r.texData.get(f.dataId).values, w = TR(v, x.sizeFromShape(d), g, o.dtype);
      y = r.makeTensorInfo(g, o.dtype);
      let N = r.texData.get(y.dataId);
      N.values = w;
    } else y = h3(f, d, g, r);
    return p && r.disposeIntermediateTensorInfo(f), y;
  }
  var d3 = { kernelName: Ka, backendName: "webgl", kernelFunc: IS };
  var TZ = Lm + `
  return max(a, b);
`;
  var kZ = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Gn + `
  return result;
`;
  var EZ = le({ opSnippet: TZ, packedOpSnippet: kZ, cpuKernelImpl: kR });
  var g3 = { kernelName: wi, backendName: "webgl", kernelFunc: EZ };
  function AZ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t;
    Os(o, "maxPool");
    let { filterSize: s10, strides: i, pad: a, dimRoundingMode: u } = n, l = 1;
    x.assert(C.eitherStridesOrDilationsAreOne(i, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);
    let c = C.computePool2DInfo(o.shape, s10, i, l, a, u);
    if (c.filterWidth === 1 && c.filterHeight === 1 && x.arraysEqual(c.inShape, c.outShape)) return Qe({ inputs: { x: o }, backend: r });
    let p = new es(c, "max", false);
    return r.runWebGLProgram(p, [o], o.dtype);
  }
  var y3 = { kernelName: qa, backendName: "webgl", kernelFunc: AZ };
  function DZ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { filterSize: s10, strides: i, pad: a, dataFormat: u, dimRoundingMode: l } = n, c = [1, 1, 1], p = C.computePool3DInfo(o.shape, s10, i, c, a, l, u), m = new Vu(p, "max", false);
    return r.runWebGLProgram(m, [o], o.dtype);
  }
  var x3 = { kernelName: Xa, backendName: "webgl", kernelFunc: DZ };
  var fw = class {
    constructor(t) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
      let r = t.strideHeight, n = t.strideWidth, o = t.dilationHeight, s10 = t.effectiveFilterHeight, i = t.effectiveFilterWidth, a = s10 - 1 - t.padInfo.top, u = i - 1 - t.padInfo.left, l = s10 * i - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s10};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var hw = class {
    constructor(t) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
      let r = t.strideDepth, n = t.strideHeight, o = t.strideWidth, s10 = t.dilationDepth, i = t.dilationHeight, a = t.dilationWidth, u = t.effectiveFilterDepth, l = t.effectiveFilterHeight, c = t.effectiveFilterWidth, p = u - 1 - t.padInfo.front, m = l - 1 - t.padInfo.top, f = c - 1 - t.padInfo.left, h = u * l * c - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s10}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function $Z(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10 } = t, i = s10, { filterSize: a, strides: u, pad: l, dimRoundingMode: c } = n, p = [1, 1, 1], m = C.computePool3DInfo(i.shape, a, u, p, l, c), f = new Vu(m, "max", true), h = r.runWebGLProgram(f, [i], i.dtype), d = new hw(m), g = r.runWebGLProgram(d, [o, h], i.dtype);
    return r.disposeIntermediateTensorInfo(h), g;
  }
  var b3 = { kernelName: ep, backendName: "webgl", kernelFunc: $Z };
  function FZ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { dy: o, input: s10, output: i } = t, a = s10;
    Os([s10, i], "maxPoolGrad");
    let { filterSize: u, strides: l, pad: c, dimRoundingMode: p } = n, m = C.computePool2DInfo(a.shape, u, l, 1, c, p), f = true, h = new es(m, "max", f), d = r.runWebGLProgram(h, [a], a.dtype), g = new fw(m), y = r.runWebGLProgram(g, [o, d], a.dtype);
    return r.disposeIntermediateTensorInfo(d), y;
  }
  var w3 = { kernelName: tp, backendName: "webgl", kernelFunc: FZ };
  function v3(e28, t, r, n) {
    let o = new es(r, "max", false), s10 = n.runWebGLProgram(o, [e28], "float32");
    o = new es(r, "max", true, true, t);
    let i = n.runWebGLProgram(o, [e28], "float32");
    return [s10, i];
  }
  var N3 = { kernelName: hy, backendName: "webgl", kernelFunc: ({ inputs: e28, attrs: t, backend: r }) => {
    let { x: n } = e28, { filterSize: o, strides: s10, pad: i, includeBatchInIndex: a } = t, u = r;
    x.assert(n.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);
    let l = [1, 1];
    x.assert(C.eitherStridesOrDilationsAreOne(s10, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s10} and dilations '${l}'`);
    let c = C.computePool2DInfo(n.shape, o, s10, l, i), [p, m] = v3(n, a, c, u);
    return [p, m];
  } };
  function C3(e28, t, r, n) {
    let o = x.sizeFromShape(t), i = x.sizeFromShape(e28.shape) / o, a = rt({ inputs: { x: e28 }, attrs: { shape: [i, o] }, backend: n }), u = Wn(a, "float32", "mean", n), l = rt({ inputs: { x: u }, attrs: { shape: r }, backend: n });
    return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(u), l;
  }
  var S3 = { kernelName: Ya, backendName: "webgl", kernelFunc: ({ inputs: e28, attrs: t, backend: r }) => {
    let { x: n } = e28, { keepDims: o, axis: s10 } = t, i = r, a = n.shape.length, u = x.parseAxisParam(s10, n.shape), l = u, c = C.getAxesPermutation(l, a), p = c != null, m = i.shouldExecuteOnCPU([n]), f = [], h = n;
    if (p) {
      if (m) {
        let w = i.texData.get(h.dataId).values, N = new Array(a);
        for (let D = 0; D < N.length; D++) N[D] = n.shape[c[D]];
        let E = rc(w, n.shape, n.dtype, c, N);
        h = i.makeTensorInfo(N, n.dtype);
        let A = i.texData.get(h.dataId);
        A.values = E;
      } else h = Bu(n, c, i);
      f.push(h), l = C.getInnerMostAxes(l.length, a);
    }
    C.assertAxesAreInnerMostDims("sum", l, a);
    let [d, g] = C.computeOutAndReduceShapes(h.shape, l), y = d;
    o && (y = C.expandShapeToKeepDim(d, u));
    let b = C3(h, g, y, i);
    for (let v of f) i.disposeIntermediateTensorInfo(v);
    return b;
  } };
  function _Z(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n, a = o.shape.length, u = x.parseAxisParam(s10, o.shape), l = u, c = C.getAxesPermutation(l, a), p = o;
    c != null && (p = Ae({ inputs: { x: o }, backend: r, attrs: { perm: c } }), l = C.getInnerMostAxes(l.length, o.shape.length)), C.assertAxesAreInnerMostDims("min", l, a);
    let [m, f] = C.computeOutAndReduceShapes(p.shape, l), h = x.sizeFromShape(f), d = rt({ inputs: { x: p }, backend: r, attrs: { shape: [-1, h] } }), g = Wn(d, d.dtype, "min", r), y;
    if (i) {
      let b = C.expandShapeToKeepDim(m, u);
      y = rt({ inputs: { x: g }, backend: r, attrs: { shape: b } });
    } else y = rt({ inputs: { x: g }, backend: r, attrs: { shape: m } });
    return r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(g), c != null && r.disposeIntermediateTensorInfo(p), y;
  }
  var I3 = { kernelName: Ja, backendName: "webgl", kernelFunc: _Z };
  var OZ = Lm + `
  return min(a, b);
`;
  var RZ = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Gn + `
  return result;
`;
  var PZ = le({ opSnippet: OZ, packedOpSnippet: RZ, cpuKernelImpl: ER });
  var T3 = { kernelName: vi, backendName: "webgl", kernelFunc: PZ };
  var dw = class {
    constructor(t, r, n) {
      this.variableNames = ["x"], this.outputShape = r.map((c, p) => c[0] + t[p] + c[1]);
      let o = t.length, s10 = Wt(o), i = r.map((c) => c[0]).join(","), a = r.map((c, p) => c[0] + t[p]).join(","), u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, o), l = n === "reflect" ? 0 : 1;
      if (o === 1) {
        this.userCode = `
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${s10} start = ${s10}(${i});
      ${s10} end = ${s10}(${a});

      void main() {
        ${s10} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s10} coords = outC - start;
        setOutput(getX(${u}));
      }
    `;
    }
  };
  var gw = class {
    constructor(t, r, n) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = r.map((h, d) => h[0] + t[d] + h[1]);
      let o = t.length, s10 = Wt(o), i = r.map((h) => h[0]).join(","), a = r.map((h, d) => h[0] + t[d]).join(","), u = Ze("rc", o), l = Ze("source", o), c = `${u[o - 1]} < ${this.outputShape[o - 1]}`, p = o === 1 ? "source" : `vec2(${l.slice(-2).join()})`, m = n === "reflect" ? 0 : 1, f = "";
      if (o === 1) {
        let h = `
        ${s10} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;
        f = `
        ${s10} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o - 1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `;
      } else {
        let h = `
        ${s10} source = rc;
        ${s10} lt = ${s10}(lessThan(source, start));
        ${s10} gte = ${s10}(greaterThanEqual(source, end));
        ${s10} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;
        f = `
        ${s10} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o - 1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o - 2]} += 1;
        if(${u[o - 2]} < ${this.outputShape[o - 2]}) {
          ${h}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o - 1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `;
      }
      this.userCode = `
      const ${s10} start = ${s10}(${i});
      const ${s10} end = ${s10}(${a});

      void main() {
        ${s10} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `;
    }
  };
  var LZ = ({ inputs: e28, backend: t, attrs: r }) => {
    let { x: n } = e28, { paddings: o, mode: s10 } = r, i = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gw(n.shape, o, s10) : new dw(n.shape, o, s10);
    return t.runWebGLProgram(i, [n], n.dtype);
  };
  var k3 = { kernelName: Za, backendName: "webgl", kernelFunc: LZ };
  var MZ = `if (b == 0.0) return NAN;
  return mod(a, b);`;
  var zZ = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + Gn + `
  return result;
`;
  var BZ = le({ opSnippet: MZ, packedOpSnippet: zZ });
  var E3 = { kernelName: Ni, backendName: "webgl", kernelFunc: BZ };
  var yw = class {
    constructor(t, r, n) {
      this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [t, n], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${r - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${r - 1}));
      }
    `;
    }
  };
  var VZ = `
if (a == b) {
  return 1.0;
};
return a / b;`;
  var GZ = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
  var TS = le({ opSnippet: VZ, packedOpSnippet: GZ, checkOutOfBounds: true });
  var A3 = { kernelName: ai, backendName: "webgl", kernelFunc: TS };
  var D3 = "return a - b;";
  var kS = le({ opSnippet: D3, packedOpSnippet: D3, supportsComplex: true, cpuKernelImpl: XR });
  var $3 = { kernelName: Mi, backendName: "webgl", kernelFunc: kS };
  function ES(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { logits: o } = t, { dim: s10 } = n, i = x.parseAxisParam([s10], o.shape), a = IS({ inputs: { x: o }, backend: r, attrs: { reductionIndices: i, keepDims: false } }), u = C.expandShapeToKeepDim(a.shape, i), l = rt({ inputs: { x: a }, backend: r, attrs: { shape: u } }), c = kS({ inputs: { a: o, b: l }, backend: r }), p = NS({ inputs: { x: c }, backend: r }), m = nc({ inputs: { x: p }, backend: r, attrs: { axis: i, keepDims: false } }), f = rt({ inputs: { x: m }, backend: r, attrs: { shape: u } }), h = TS({ inputs: { a: p, b: f }, backend: r });
    return r.disposeIntermediateTensorInfo(a), r.disposeIntermediateTensorInfo(l), r.disposeIntermediateTensorInfo(c), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(f), h;
  }
  var F3 = { kernelName: du, backendName: "webgl", kernelFunc: ES };
  function WZ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { logits: o } = t, { numSamples: s10, seed: i, normalized: a } = n, u = a ? o : ES({ inputs: { logits: o }, backend: r, attrs: { dim: o.shape.length - 1 } }), l = u.shape[0], c = u.shape[1], p = new yw(l, c, s10), m = [[i]], f = r.runWebGLProgram(p, [u], "int32", m);
    return a || r.disposeIntermediateTensorInfo(u), f;
  }
  var _3 = { kernelName: dy, backendName: "webgl", kernelFunc: WZ };
  var UZ = gr + `
  return -x;
`;
  var jZ = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  function HZ(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    if (r.shouldExecuteOnCPU([n])) {
      let s10 = r.texData.get(n.dataId), [i, a] = DR(s10.values, n.shape, n.dtype);
      return r.makeTensorInfo(a, n.dtype, i);
    }
    let o;
    return z().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? o = new Sn(n.shape, jZ) : o = new Lr(n.shape, UZ), r.runWebGLProgram(o, [n], n.dtype);
  }
  var O3 = { kernelName: Qa, backendName: "webgl", kernelFunc: HZ };
  var KZ = jr.nonMaxSuppressionV3Impl;
  function qZ(e28) {
    C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: t, backend: r, attrs: n } = e28, { boxes: o, scores: s10 } = t, { maxOutputSize: i, iouThreshold: a, scoreThreshold: u } = n, l = r.readSync(o.dataId), c = r.readSync(s10.dataId), { selectedIndices: p } = KZ(l, c, i, a, u);
    return r.makeTensorInfo([p.length], "int32", new Int32Array(p));
  }
  var R3 = { kernelName: rp, backendName: "webgl", kernelFunc: qZ };
  var XZ = jr.nonMaxSuppressionV4Impl;
  function YZ(e28) {
    C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: t, backend: r, attrs: n } = e28, { boxes: o, scores: s10 } = t, { maxOutputSize: i, iouThreshold: a, scoreThreshold: u, padToMaxOutputSize: l } = n, c = r.readSync(o.dataId), p = r.readSync(s10.dataId), { selectedIndices: m, validOutputs: f } = XZ(c, p, i, a, u, l);
    return [r.makeTensorInfo([m.length], "int32", new Int32Array(m)), r.makeTensorInfo([], "int32", new Int32Array([f]))];
  }
  var P3 = { kernelName: np, backendName: "webgl", kernelFunc: YZ };
  var JZ = jr.nonMaxSuppressionV5Impl;
  function ZZ(e28) {
    C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: t, backend: r, attrs: n } = e28, { boxes: o, scores: s10 } = t, { maxOutputSize: i, iouThreshold: a, scoreThreshold: u, softNmsSigma: l } = n, c = r.readSync(o.dataId), p = r.readSync(s10.dataId), m = i, f = a, h = u, d = l, { selectedIndices: g, selectedScores: y } = JZ(c, p, m, f, h, d);
    return [r.makeTensorInfo([g.length], "int32", new Int32Array(g)), r.makeTensorInfo([y.length], "float32", new Float32Array(y))];
  }
  var L3 = { kernelName: op, backendName: "webgl", kernelFunc: ZZ };
  var xw = class {
    constructor(t, r, n, o) {
      this.variableNames = ["indices"], this.outputShape = [t, r], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `;
    }
  };
  var QZ = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { indices: o } = t, { dtype: s10, depth: i, onValue: a, offValue: u } = n, l = x.sizeFromShape(o.shape), c = new xw(l, i, a, u), p = rt({ inputs: { x: o }, backend: r, attrs: { shape: [l] } }), m = r.runWebGLProgram(c, [p], s10);
    r.disposeIntermediateTensorInfo(p);
    let f = [...o.shape, i], h = rt({ inputs: { x: m }, backend: r, attrs: { shape: f } });
    return r.disposeIntermediateTensorInfo(m), h;
  };
  var M3 = { kernelName: eu, backendName: "webgl", kernelFunc: QZ };
  function yg(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    if (n.dtype === "complex64") {
      let o = la({ inputs: { input: n }, backend: r }), s10 = yg({ inputs: { x: o }, backend: r }), i = sc({ inputs: { input: n }, backend: r }), a = yg({ inputs: { x: i }, backend: r }), u = Tn({ inputs: { real: s10, imag: a }, backend: r });
      return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s10), r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(a), u;
    } else return ca({ attrs: { shape: n.shape, dtype: n.dtype, value: n.dtype === "string" ? "" : 0 }, backend: r });
  }
  var z3 = { kernelName: xu, backendName: "webgl", kernelFunc: yg };
  function B3(e28) {
    let { inputs: t, backend: r } = e28, { x: n } = t;
    if (n.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    if (n.dtype === "complex64") {
      let o = la({ inputs: { input: n }, backend: r }), s10 = B3({ inputs: { x: o }, backend: r }), i = sc({ inputs: { input: n }, backend: r }), a = yg({ inputs: { x: i }, backend: r }), u = Tn({ inputs: { real: s10, imag: a }, backend: r });
      return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s10), r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(a), u;
    } else return ca({ attrs: { shape: n.shape, dtype: n.dtype, value: 1 }, backend: r });
  }
  var V3 = { kernelName: tu, backendName: "webgl", kernelFunc: B3 };
  function tQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { axis: o } = n;
    if (t.length === 1) return rw({ inputs: { input: t[0] }, backend: r, attrs: { dim: o } });
    let s10 = t[0].shape, i = t[0].dtype;
    t.forEach((c) => {
      x.assertShapesMatch(s10, c.shape, "All tensors passed to stack must have matching shapes"), x.assert(i === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let a = [], u = t.map((c) => {
      let p = rw({ inputs: { input: c }, backend: r, attrs: { dim: o } });
      return a.push(p), p;
    }), l = vS({ inputs: u, backend: r, attrs: { axis: o } });
    return a.forEach((c) => r.disposeIntermediateTensorInfo(c)), l;
  }
  var G3 = { kernelName: ru, backendName: "webgl", kernelFunc: tQ };
  var bw = class {
    constructor(t, r, n) {
      this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = r.map((l, c) => l[0] + t[c] + l[1]);
      let o = t.length, s10 = Wt(o), i = r.map((l) => l[0]).join(","), a = r.map((l, c) => l[0] + t[c]).join(","), u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, o);
      if (o === 1) {
        this.userCode = `
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${s10} start = ${s10}(${i});
      ${s10} end = ${s10}(${a});

      void main() {
        ${s10} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s10} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `;
    }
  };
  var ww = class {
    constructor(t, r, n) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = r.map((d, g) => d[0] + t[g] + d[1]);
      let o = t.length, s10 = Wt(o), i = r.map((d) => d[0]).join(","), a = r.map((d, g) => d[0] + t[g]).join(","), u = Ze("rc", o), l = Ze("source", o), c = `${u[o - 1]} < ${this.outputShape[o - 1]}`, p = o === 1 ? "source" : `vec2(${l.slice(-2).join()})`, m = [`${s10} rc = outputLoc;`, `${u[o - 1]} += 1;
       if(${c}) {
      `, o === 1 ? "" : `}
       rc = outputLoc;
       ${u[o - 2]} += 1;
       if(${u[o - 2]} < ${this.outputShape[o - 2]}) {`, o === 1 ? "" : `  ${u[o - 1]} += 1;
         if(${c}) {`], f = o === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", h = "";
      for (let d = 0, g = o === 1 ? 2 : 4; d < g; d++) h += `
        ${m[d]}
        if (${f}) {
          result[${d}] = float(value);
        } else {
          ${s10} source = rc - start;
          result[${d}] = getChannel(getX(${l.join()}), ${p});
        }
      `;
      h += o === 1 ? "} " : "}}", this.userCode = `
      const ${s10} start = ${s10}(${i});
      const ${s10} end = ${s10}(${a});

      void main() {
        ${s10} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `;
    }
  };
  var AS = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { paddings: s10, constantValue: i } = n;
    if (x.sizeFromShape(o.shape) === 0) {
      let l = s10.map((c, p) => c[0] + o.shape[p] + c[1]);
      return ca({ backend: r, attrs: { shape: l, value: i, dtype: o.dtype } });
    }
    let a = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ww(o.shape, s10, i) : new bw(o.shape, s10, i), u = [[i]];
    return r.runWebGLProgram(a, [o], o.dtype, u);
  };
  var W3 = { kernelName: nu, backendName: "webgl", kernelFunc: AS };
  var eQ = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
  var rQ = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + Gn + `
  return result;
`;
  var nQ = le({ opSnippet: eQ, packedOpSnippet: rQ });
  var U3 = { kernelName: Si, backendName: "webgl", kernelFunc: nQ };
  function oQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { axis: s10, keepDims: i } = n, a = o.shape.length, u = [], l = x.parseAxisParam(s10, o.shape), c = l, p = C.getAxesPermutation(c, a), m = o;
    p != null && (m = Ae({ inputs: { x: o }, backend: r, attrs: { perm: p } }), c = C.getInnerMostAxes(c.length, a), u.push(m)), C.assertAxesAreInnerMostDims("prod", c, a);
    let f;
    if (r.shouldExecuteOnCPU([m])) {
      let h = r.texData.get(m.dataId).values, { outVals: d, outShape: g, outDtype: y } = FR(m.shape, m.dtype, h, c);
      f = r.makeTensorInfo(g, y, d);
    } else {
      let [h, d] = C.computeOutAndReduceShapes(m.shape, c), g = x.sizeFromShape(d), y = rt({ inputs: { x: m }, backend: r, attrs: { shape: [-1, g] } }), b = bl(o.dtype), v = Wn(y, b, "prod", r);
      f = rt({ inputs: { x: v }, backend: r, attrs: { shape: h } }), u.push(y), u.push(v);
    }
    if (i) {
      u.push(f);
      let h = C.expandShapeToKeepDim(f.shape, l);
      f = rt({ inputs: { x: f }, backend: r, attrs: { shape: h } });
    }
    return u.forEach((h) => r.disposeIntermediateTensorInfo(h)), f;
  }
  var j3 = { kernelName: su, backendName: "webgl", kernelFunc: oQ };
  function sQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { paramsNestedSplits: o, paramsDenseValues: s10, indices: i } = t, { outputRaggedRank: a } = n, u = o.map((y) => r.readSync(y.dataId)), l = o.map((y) => y.shape), c = r.readSync(s10.dataId), p = r.readSync(i.dataId), [m, f, h] = _R(u, l, c, s10.shape, s10.dtype, p, i.shape, a), d = m.map((y) => r.makeTensorInfo([y.length], "int32", y)), g = r.makeTensorInfo(h, s10.dtype, f);
    return d.concat([g]);
  }
  var H3 = { kernelName: gy, backendName: "webgl", kernelFunc: sQ };
  function iQ(e28) {
    let { inputs: t, backend: r } = e28, { starts: n, limits: o, deltas: s10 } = t, i = r.readSync(n.dataId), a = r.readSync(o.dataId), u = r.readSync(s10.dataId), [l, c] = OR(i, n.shape, n.dtype, a, o.shape, u, s10.shape), p = r.makeTensorInfo([l.length], "int32", l), m = r.makeTensorInfo([c.length], n.dtype, c);
    return [p, m];
  }
  var K3 = { kernelName: yy, backendName: "webgl", kernelFunc: iQ };
  function aQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { shape: o, values: s10, defaultValue: i, rowPartitionTensors: a } = t, { rowPartitionTypes: u } = n, l = r.readSync(o.dataId), c = r.readSync(s10.dataId), p = r.readSync(i.dataId), m = a.map((g) => r.readSync(g.dataId)), f = a.map((g) => g.shape), [h, d] = RR(l, o.shape, c, s10.shape, s10.dtype, p, i.shape, m, f, u);
    return r.makeTensorInfo(h, s10.dtype, d);
  }
  var q3 = { kernelName: xy, backendName: "webgl", kernelFunc: aQ };
  var DS = (e28) => {
    let { backend: t, attrs: r } = e28, { start: n, stop: o, step: s10, dtype: i } = r, a = PR(n, o, s10, i);
    return t.makeTensorInfo([a.length], i, a);
  };
  var X3 = { kernelName: sp, backendName: "webgl", kernelFunc: DS };
  var uQ = "return 1.0 / x;";
  var lQ = St({ opSnippet: uQ });
  var Y3 = { kernelName: Ii, backendName: "webgl", kernelFunc: lQ };
  var cQ = gr + `
  return (x < 0.0) ? 0.0 : x;
`;
  var pQ = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var mQ = St({ opSnippet: cQ, packedOpSnippet: pQ });
  var J3 = { kernelName: Ti, backendName: "webgl", kernelFunc: mQ };
  var fQ = gr + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var hQ = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var dQ = St({ opSnippet: fQ, packedOpSnippet: hQ });
  var Z3 = { kernelName: ki, backendName: "webgl", kernelFunc: dQ };
  var vw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["A"], this.outputShape = [];
      let [i, a, u, l] = t;
      this.outputShape = [i, r, n, l];
      let c = [o && r > 1 ? a - 1 : a, o && n > 1 ? u - 1 : u], p = [o && r > 1 ? r - 1 : r, o && n > 1 ? n - 1 : n], m;
      s10 ? m = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : m = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / p[0]},
          ${c[1] / p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  };
  var Nw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      let [i, a, u, l] = t;
      this.outputShape = [i, r, n, l];
      let c = [o && r > 1 ? a - 1 : a, o && n > 1 ? u - 1 : u], p = [o && r > 1 ? r - 1 : r, o && n > 1 ? n - 1 : n], m;
      s10 ? m = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : m = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / p[0]},
          ${c[1] / p[1]},
          ${c[1] / p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l - 1};
        bool hasNextRow = coords.z < ${n - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  };
  function gQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o } = t, { alignCorners: s10, halfPixelCenters: i, size: a } = n, [u, l] = a, c = z().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Nw(o.shape, u, l, s10, i) : new vw(o.shape, u, l, s10, i);
    return r.runWebGLProgram(c, [o], "float32");
  }
  var Q3 = { kernelName: uu, backendName: "webgl", kernelFunc: gQ };
  var Cw = class {
    constructor(t, r, n) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = r;
      let [, o, s10] = r, [, i, a] = t, u = [n && i > 1 ? o - 1 : o, n && a > 1 ? s10 - 1 : s10], l = [n && i > 1 ? i - 1 : i, n && a > 1 ? a - 1 : a], c = u[0] / l[0], p = u[1] / l[1], m = 1 / c, f = 1 / p, h = Math.ceil(m) * 2 + 2, d = Math.ceil(f) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${d});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s10 - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };
  function yQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o, dy: s10 } = t, { alignCorners: i } = n, a = new Cw(s10.shape, o.shape, i);
    return r.runWebGLProgram(a, [s10], s10.dtype);
  }
  var tM = { kernelName: up, backendName: "webgl", kernelFunc: yQ };
  var Sw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["A"], this.outputShape = [];
      let [i, a, u, l] = t;
      this.outputShape = [i, r, n, l];
      let c = [o && r > 1 ? a - 1 : a, o && n > 1 ? u - 1 : u], p = [o && r > 1 ? r - 1 : r, o && n > 1 ? n - 1 : n], m = o ? "0.5" : "0.0", f;
      s10 ? f = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : f = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / p[0]},
          ${c[1] / p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  };
  var Iw = class {
    constructor(t, r, n, o, s10) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      let [i, a, u, l] = t;
      this.outputShape = [i, r, n, l];
      let c = [o && r > 1 ? a - 1 : a, o && n > 1 ? u - 1 : u], p = [o && r > 1 ? r - 1 : r, o && n > 1 ? n - 1 : n], m = o ? "0.5" : "0.0", f;
      s10 ? f = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : f = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / p[0]},
          ${c[1] / p[1]},
          ${c[1] / p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l - 1};
        bool hasNextRow = coords.z < ${n - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  };
  function xQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o } = t, { alignCorners: s10, halfPixelCenters: i, size: a } = n, [u, l] = a, c = z().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Iw(o.shape, u, l, s10, i) : new Sw(o.shape, u, l, s10, i);
    return r.runWebGLProgram(c, [o], o.dtype);
  }
  var eM = { kernelName: au, backendName: "webgl", kernelFunc: xQ };
  var Tw = class {
    constructor(t, r, n) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = r;
      let [, o, s10] = r, [, i, a] = t, u = [n && i > 1 ? o - 1 : o, n && a > 1 ? s10 - 1 : s10], l = [n && i > 1 ? i - 1 : i, n && a > 1 ? a - 1 : a], c = u[0] / l[0], p = u[1] / l[1], m = 1 / c, f = 1 / p, h = Math.ceil(m) * 2 + 2, d = Math.ceil(f) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${d});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s10}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };
  function bQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { images: o, dy: s10 } = t, { alignCorners: i } = n, a = new Tw(s10.shape, o.shape, i);
    return r.runWebGLProgram(a, [s10], s10.dtype);
  }
  var rM = { kernelName: ap, backendName: "webgl", kernelFunc: bQ };
  var kw = class {
    constructor(t, r) {
      this.variableNames = ["x"];
      let n = t.length;
      if (n > 4) throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);
      if (this.outputShape = t, n === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;
        return;
      }
      let o = (a) => r.indexOf(a) !== -1 && t[a] !== 1 ? `${t[a]} - coords[${a}] - 1` : `coords[${a}]`, s10 = t.map((a, u) => o(u)).join(","), i = Wt(n);
      this.userCode = `
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s10}));
      }
    `;
    }
  };
  var Ew = class {
    constructor(t, r) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
      let n = t.length;
      if (n > 4) throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);
      this.outputShape = t;
      let o = Ze("rc", n), s10 = `${o[n - 1]} + 1 < ${this.outputShape[n - 1]}`, i = `${o[n - 2]} + 1 < ${this.outputShape[n - 2]}`, a = Wt(n);
      n === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s10}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s10}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s10}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;
      function u(h) {
        return m(h);
      }
      function l(h) {
        return h[n - 1] = "(" + h[n - 1] + " + 1)", m(h);
      }
      function c(h) {
        return h[n - 2] = "(" + h[n - 2] + " + 1)", m(h);
      }
      function p(h) {
        return h[n - 1] = "(" + h[n - 1] + " + 1)", h[n - 2] = "(" + h[n - 2] + " + 1)", m(h);
      }
      function m(h) {
        let d = t.map((b, v) => f(v, h)), g = d.join(","), y = d.slice(-2).join(",");
        return `getChannel(getX(${g}), vec2(${y}))`;
      }
      function f(h, d) {
        return r.indexOf(h) !== -1 && t[h] !== 1 ? `${t[h]} - ${d[h]} - 1` : `${d[h]}`;
      }
    }
  };
  function wQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { dims: s10 } = n, i = o.shape.length, a = x.parseAxisParam(s10, o.shape);
    if (i === 0) return Qe({ inputs: { x: o }, backend: r });
    let u = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ew(o.shape, a) : new kw(o.shape, a);
    return r.runWebGLProgram(u, [o], o.dtype);
  }
  var nM = { kernelName: lu, backendName: "webgl", kernelFunc: wQ };
  var Aw = class {
    constructor(t, r) {
      this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
      let n = t[1], o = t[2];
      this.outputShape = t;
      let s10 = "";
      typeof r == "number" ? s10 = `float outputValue = ${r.toFixed(2)};` : s10 = `
        vec3 fill = vec3(${r.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s10}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };
  var oM = { kernelName: hp, backendName: "webgl", kernelFunc: ({ inputs: e28, attrs: t, backend: r }) => {
    let { image: n } = e28, { radians: o, fillValue: s10, center: i } = t, a = r, u = new Aw(n.shape, s10), [l, c] = C.getImageCenter(i, n.shape[1], n.shape[2]), p = [[l, c, Math.sin(o), Math.cos(o)]];
    return a.runWebGLProgram(u, [n], n.dtype, p);
  } };
  var vQ = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
  var NQ = St({ opSnippet: vQ });
  var sM = { kernelName: Ei, backendName: "webgl", kernelFunc: NQ };
  var CQ = "return inversesqrt(x);";
  var SQ = St({ opSnippet: CQ, cpuKernelImpl: LR });
  var iM = { kernelName: Ai, backendName: "webgl", kernelFunc: SQ };
  var Gu = class {
    constructor(t, r, n, o, s10, i, a = true, u = false) {
      this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = i;
      let l = Wt(s10.length), c = Wt(i.length), p = "";
      n === 1 ? p = "i" : n === 2 && (p = "i, j");
      let m = `getIndices(${p})`, f = "";
      o === 1 ? f = "i" : o === 2 && (f = "i, coords[1]");
      let h = `getUpdates(${f})`, d = "";
      u && (d = "coords[0], coords[1]");
      let g = `getDefaultValue(${d})`, y = r > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${l} strides = ${l}(${s10});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${r}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `;
    }
  };
  var Dw = class {
    constructor(t, r, n, o, s10, i, a = true, u = false) {
      this.variableNames = ["updates", "indices", "defaultValue"], this.packedInputs = true, this.packedOutput = true, this.outputShape = i;
      let l = Wt(s10.length), c = Wt(i.length), p = "";
      n === 1 ? p = "i" : n === 2 && (p = "i, j");
      let m = `getIndices(${p})`, f = "";
      o === 1 ? f = "i" : o === 2 && (f = "i, coords[1]");
      let h = `getUpdates(${f})`, d = "";
      u && (d = "coords[0], coords[1]");
      let g = `getDefaultValue(${d})`, y = r > 1 ? "strides[j]" : "strides", b = r > 1 ? "strides[j + 1]" : "strides";
      this.userCode = `
        ${l} strides = ${l}(${s10});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${r}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${r}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `;
    }
  };
  function IQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { indices: o, updates: s10 } = t, { shape: i } = n, { sliceRank: a, numUpdates: u, sliceSize: l, strides: c, outputSize: p } = C.calculateShapes(s10, o, i), m = [p / l, l];
    if (p === 0) return r.makeTensorInfo(i, o.dtype);
    let f = rt({ inputs: { x: o }, backend: r, attrs: { shape: [u, a] } }), h = rt({ inputs: { x: s10 }, backend: r, attrs: { shape: [u, l] } }), d = r.makeTensorInfo([], "float32", new Float32Array([0])), g;
    z().getBool("WEBGL_PACK") ? g = new Dw(u, a, f.shape.length, h.shape.length, c, m) : g = new Gu(u, a, f.shape.length, h.shape.length, c, m);
    let y = r.runWebGLProgram(g, [h, f, d], h.dtype), b = rt({ inputs: { x: y }, backend: r, attrs: { shape: i } });
    return r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(y), r.disposeIntermediateTensorInfo(d), b;
  }
  var aM = { kernelName: by, backendName: "webgl", kernelFunc: IQ };
  var $w = class {
    constructor(t, r, n, o) {
      this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{ name: "numInputs", type: "int" }], this.outputShape = [t, n];
      let s10 = "while (left < right) {", i = `for (int i = 0; i < ${Math.ceil(Math.log2(r + 1))}; ++i) { if (left >= right) break;`, a = z().getNumber("WEBGL_VERSION") === 2 ? s10 : i, u = o === "left" ? "<" : "<=";
      this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
  };
  function TQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { sortedSequence: o, values: s10 } = t, { side: i } = n, a = new $w(o.shape[0], o.shape[1], s10.shape[1], i), u = [[o.shape[1]]];
    return r.runWebGLProgram(a, [o, s10], "int32", u);
  }
  var uM = { kernelName: vy, backendName: "webgl", kernelFunc: TQ };
  var Fw = class {
    constructor(t, r, n) {
      this.variableNames = ["c", "a", "b"], this.outputShape = r;
      let o, s10;
      if (n > 4) throw Error(`Where for rank ${n} is not yet supported`);
      if (n === 1) s10 = "resRC", o = "resRC";
      else {
        let a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], u = [], l = [];
        for (let c = 0; c < r.length; c++) l.push(`${a[c]}`), c < t && u.push(`${a[c]}`);
        o = u.join(), s10 = l.join();
      }
      let i = Wt(n);
      this.userCode = `
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s10}));
        } else {
          setOutput(getB(${s10}));
        }
      }
    `;
    }
  };
  function kQ(e28) {
    let { inputs: t, backend: r } = e28, { condition: n, t: o, e: s10 } = t, i = new Fw(n.shape.length, o.shape, o.shape.length);
    return r.runWebGLProgram(i, [n, o, s10], lr(o.dtype, s10.dtype));
  }
  var lM = { kernelName: cu, backendName: "webgl", kernelFunc: kQ };
  var EQ = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${C.SELU_SCALEALPHA};
  float scale = ${C.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
  var AQ = St({ opSnippet: EQ });
  var cM = { kernelName: Di, backendName: "webgl", kernelFunc: AQ };
  var DQ = _o + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
  var $Q = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var FQ = St({ opSnippet: DQ, packedOpSnippet: $Q, cpuKernelImpl: zR });
  var pM = { kernelName: Oi, backendName: "webgl", kernelFunc: FQ };
  var _Q = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
  var OQ = St({ opSnippet: _Q });
  var mM = { kernelName: _i, backendName: "webgl", kernelFunc: OQ };
  var RQ = _o + `
  return sin(x);
`;
  var PQ = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Gn}
  return result;
`;
  var LQ = St({ opSnippet: RQ, packedOpSnippet: PQ });
  var fM = { kernelName: $i, backendName: "webgl", kernelFunc: LQ };
  var MQ = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
  var zQ = St({ opSnippet: MQ });
  var hM = { kernelName: Fi, backendName: "webgl", kernelFunc: zQ };
  var BQ = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
  var VQ = St({ opSnippet: BQ });
  var dM = { kernelName: Ri, backendName: "webgl", kernelFunc: VQ };
  var GQ = (e28) => {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { blockShape: s10, paddings: i } = n;
    x.assert(o.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    let a = s10.reduce((y, b) => y * b), u = [[0, 0]];
    u.push(...i);
    for (let y = 1 + s10.length; y < o.shape.length; ++y) u.push([0, 0]);
    let l = [], c = AS({ inputs: { x: o }, backend: r, attrs: { paddings: u, constantValue: 0 } }), p = C.getReshaped(c.shape, s10, a, false), m = C.getPermuted(p.length, s10.length, false), f = C.getReshapedPermuted(c.shape, s10, a, false), h = rt({ inputs: { x: c }, backend: r, attrs: { shape: p } }), d = Ae({ inputs: { x: h }, backend: r, attrs: { perm: m } }), g = rt({ inputs: { x: d }, backend: r, attrs: { shape: f } });
    return l.push(c), l.push(h), l.push(d), l.forEach((y) => r.disposeIntermediateTensorInfo(y)), g;
  };
  var gM = { kernelName: fu, backendName: "webgl", kernelFunc: GQ };
  function WQ(e28) {
    let { inputs: t, backend: r } = e28, { indices: n, values: o, denseShape: s10, defaultValue: i } = t;
    if (s10.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
         ${s10.shape}`);
    if (n.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);
    if (o.shape.length !== 1) throw new Error(`Values must be a vector, saw:
         ${o.shape}`);
    if (i.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);
    let a = r.readSync(n.dataId), u = r.readSync(o.dataId), l = r.readSync(s10.dataId), c = r.readSync(i.dataId)[0], [p, m, f, h, d] = VR(a, n.shape, n.dtype, u, o.dtype, l, c);
    return [r.makeTensorInfo(m, n.dtype, p), r.makeTensorInfo([m[0]], o.dtype, f), r.makeTensorInfo([h.length], "bool", new Uint8Array(h.map((g) => Number(g)))), r.makeTensorInfo([d.length], n.dtype, new Int32Array(d))];
  }
  var yM = { kernelName: Ny, backendName: "webgl", kernelFunc: WQ };
  function UQ(e28) {
    let { inputs: t, backend: r } = e28, { inputIndices: n, inputShape: o, newShape: s10 } = t;
    if (n.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);
    if (o.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape ${o.shape}`);
    if (s10.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${s10.shape}`);
    let i = Array.from(r.readSync(o.dataId)), a = r.readSync(n.dataId), u = Array.from(r.readSync(s10.dataId)), [l, c, p] = GR(a, n.shape, n.dtype, i, u);
    return [r.makeTensorInfo(c, n.dtype, l), r.makeTensorInfo([p.length], s10.dtype, new Int32Array(p))];
  }
  var xM = { kernelName: Cy, backendName: "webgl", kernelFunc: UQ };
  function jQ(e28) {
    let { inputs: t, backend: r } = e28, { data: n, indices: o, segmentIds: s10 } = t;
    if (n.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (o.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);
    if (s10.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
              ${s10.shape}`);
    let i = r.readSync(n.dataId), a = r.readSync(o.dataId), u = r.readSync(s10.dataId), [l, c] = f0(i, n.shape, n.dtype, a, u, true);
    return r.makeTensorInfo(c, n.dtype, l);
  }
  var bM = { kernelName: Sy, backendName: "webgl", kernelFunc: jQ };
  function HQ(e28) {
    let { inputs: t, backend: r } = e28, { data: n, indices: o, segmentIds: s10 } = t;
    if (n.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (o.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);
    if (s10.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
             ${s10.shape}`);
    let i = r.readSync(n.dataId), a = r.readSync(o.dataId), u = r.readSync(s10.dataId), [l, c] = f0(i, n.shape, n.dtype, a, u);
    return r.makeTensorInfo(c, n.dtype, l);
  }
  var wM = { kernelName: Iy, backendName: "webgl", kernelFunc: HQ };
  function KQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { sparseIndices: o, sparseValues: s10, defaultValue: i } = t, { outputShape: a } = n, { sliceRank: u, numUpdates: l, sliceSize: c, strides: p, outputSize: m } = C.calculateShapes(s10, o, a), f = false;
    if (s10.dtype === "string") {
      let y = r.bufferSync(o), b = r.bufferSync(s10), v = x.decodeString(r.readSync(i.dataId)[0]), w = MR(y, b, a, m, c, l, u, p, v, f);
      return r.makeTensorInfo(a, w.dtype, w.values);
    }
    let h = new Gu(l, u, o.shape.length, s10.shape.length, p, [m, 1], f), d = r.runWebGLProgram(h, [s10, o, i], s10.dtype), g = rt({ inputs: { x: d }, backend: r, attrs: { shape: a } });
    return r.disposeIntermediateTensorInfo(d), g;
  }
  var vM = { kernelName: Ty, backendName: "webgl", kernelFunc: KQ };
  function qQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { numOrSizeSplits: s10, axis: i } = n, a = x.parseAxisParam(i, o.shape)[0], u = C.prepareSplitSize(o, s10, a), l = o.shape.length, c = new Array(l).fill(0), p = o.shape.slice();
    return u.map((m) => {
      let f = [...p];
      f[a] = m;
      let h = rs({ inputs: { x: o }, backend: r, attrs: { begin: c, size: f } });
      return c[a] += m, h;
    });
  }
  var NM = { kernelName: hu, backendName: "webgl", kernelFunc: qQ };
  var CM = "return sqrt(x);";
  var XQ = St({ opSnippet: CM, packedOpSnippet: CM, cpuKernelImpl: WR });
  var SM = { kernelName: Pi, backendName: "webgl", kernelFunc: XQ };
  var YQ = "return x * x;";
  var JQ = St({ opSnippet: YQ });
  var IM = { kernelName: lp, backendName: "webgl", kernelFunc: JQ };
  var TM = "return (a - b) * (a - b);";
  var ZQ = le({ opSnippet: TM, packedOpSnippet: TM });
  var kM = { kernelName: Li, backendName: "webgl", kernelFunc: ZQ };
  function QQ(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t;
    if (o.dtype !== "string") throw new Error("Input must be of datatype string");
    let s10 = r.readSync(o.dataId), i = C.fromUint8ToStringArray(s10), a = UR(i, "string", n);
    return r.makeTensorInfo(o.shape, "string", a);
  }
  var EM = { kernelName: $f, backendName: "webgl", kernelFunc: QQ };
  function ttt({ inputs: e28, attrs: t, backend: r }) {
    let { x: n } = e28, o = gr + `
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `, s10 = new Lr(n.shape, o);
    return r.runWebGLProgram(s10, [n], n.dtype);
  }
  var AM = { kernelName: Vi, backendName: "webgl", kernelFunc: ttt };
  var _w = class {
    constructor(t, r, n) {
      this.variableNames = ["x"], this.outputShape = n;
      let o = n.length, s10 = Wt(n.length), i = Wt(n.length), a = "";
      if (o === 1) a = "coords * strides + begin";
      else {
        let u = 0;
        a = n.map((l, c) => (u++, n.length === 1 ? `coords * strides[${c}] + begin[${c}]` : `coords[${u - 1}] * strides[${c}] + begin[${c}]`)).join(",");
      }
      this.userCode = `
      ${s10} begin = ${s10}(${t});
      ${s10} strides = ${s10}(${r});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
    }
  };
  function ett(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { begin: s10, end: i, strides: a, beginMask: u, endMask: l, ellipsisMask: c, newAxisMask: p, shrinkAxisMask: m } = n, { finalShapeSparse: f, finalShape: h, isIdentity: d, sliceDim0: g, isSimpleSlice: y, begin: b, end: v, strides: w } = Sr.sliceInfo(o.shape, s10, i, a, u, l, c, p, m), N;
    if (d) N = rt({ inputs: { x: o }, backend: r, attrs: { shape: h } });
    else if (g || y) {
      x.assert(o.shape.length >= 1, () => `Input must have rank at least 1, got: ${o.shape.length}`);
      let A = Sr.computeOutShape(b, v, w), D = rs({ inputs: { x: o }, backend: r, attrs: { begin: b, size: A } });
      N = rt({ inputs: { x: D }, backend: r, attrs: { shape: h } }), r.disposeIntermediateTensorInfo(D);
    } else if (r.shouldExecuteOnCPU([o])) {
      let D = r.readSync(o.dataId), R = kt(o.shape, o.dtype, D), L = jR(f, R, w, b);
      N = r.makeTensorInfo(h, o.dtype, L.values);
    } else {
      let D = new _w(b, w, f);
      N = r.runWebGLProgram(D, [o], o.dtype);
    }
    let E = rt({ inputs: { x: N }, backend: r, attrs: { shape: h } });
    return r.disposeIntermediateTensorInfo(N), E;
  }
  var DM = { kernelName: cp, backendName: "webgl", kernelFunc: ett };
  function rtt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { separator: o, nGramWidths: s10, leftPad: i, rightPad: a, padWidth: u, preserveShortSequences: l } = n, { data: c, dataSplits: p } = t, m = r.readSync(c.dataId), f = r.readSync(p.dataId), [h, d] = HR(m, f, o, s10, i, a, u, l);
    return [r.makeTensorInfo([h.length], "string", h), r.makeTensorInfo(p.shape, "int32", d)];
  }
  var $M = { kernelName: ky, backendName: "webgl", kernelFunc: rtt };
  function ntt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { skipEmpty: o } = n, { input: s10, delimiter: i } = t;
    if (s10.dtype !== "string") throw new Error("Input must be of datatype string");
    if (s10.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${s10.shape}`);
    if (i.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
    let a = r.readSync(s10.dataId), u = r.readSync(i.dataId)[0], [l, c, p] = KR(a, u, o), m = c.length;
    return [r.makeTensorInfo([m, 2], "int32", l), r.makeTensorInfo([m], "string", c), r.makeTensorInfo([2], "int32", new Int32Array(p))];
  }
  var FM = { kernelName: Ey, backendName: "webgl", kernelFunc: ntt };
  function ott(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { numBuckets: o } = n, { input: s10 } = t;
    if (s10.dtype !== "string") throw new Error("Input must be of datatype string");
    if (o <= 0) throw new Error("Number of buckets must be at least 1");
    let i = r.readSync(s10.dataId), a = qR(i, o);
    return r.makeTensorInfo(s10.shape, "int32", a);
  }
  var _M = { kernelName: Ay, backendName: "webgl", kernelFunc: ott };
  var stt = "return tan(x);";
  var itt = St({ opSnippet: stt });
  var OM = { kernelName: zi, backendName: "webgl", kernelFunc: itt };
  var att = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
  var utt = St({ opSnippet: att });
  var RM = { kernelName: Bi, backendName: "webgl", kernelFunc: utt };
  function ltt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { tensor: o, indices: s10, updates: i } = t, {} = n, { sliceRank: a, numUpdates: u, sliceSize: l, strides: c, outputSize: p } = C.calculateShapes(i, s10, o.shape), m = [p / l, l];
    if (p === 0) return r.makeTensorInfo(o.shape, s10.dtype);
    let f = rt({ inputs: { x: s10 }, backend: r, attrs: { shape: [u, a] } }), h = rt({ inputs: { x: i }, backend: r, attrs: { shape: [u, l] } }), d = rt({ inputs: { x: o }, backend: r, attrs: { shape: m } }), g = new Gu(u, a, f.shape.length, h.shape.length, c, m, false, true), y = r.runWebGLProgram(g, [h, f, d], d.dtype), b = rt({ inputs: { x: y }, backend: r, attrs: { shape: o.shape } });
    return r.disposeIntermediateTensorInfo(f), r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(y), b;
  }
  var PM = { kernelName: wy, backendName: "webgl", kernelFunc: ltt };
  var Ow = class {
    constructor(t, r) {
      this.variableNames = ["A"];
      let n = new Array(t.length);
      for (let i = 0; i < n.length; i++) n[i] = t[i] * r[i];
      this.outputShape = n, this.rank = n.length;
      let o = Wt(this.rank), s10 = ctt(t);
      this.userCode = `
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s10}));
      }
    `;
    }
  };
  function ctt(e28) {
    let t = e28.length;
    if (t > 5) throw Error(`Tile for rank ${t} is not yet supported`);
    if (t === 1) return `imod(resRC, ${e28[0]})`;
    let r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], n = [];
    for (let o = 0; o < e28.length; o++) n.push(`imod(${r[o]}, ${e28[o]})`);
    return n.join();
  }
  function $S(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { reps: s10 } = n;
    if (o.dtype === "string" || o.shape.length > 5) {
      let u = r.readSync(o.dataId), l = o.dtype === "string" ? u.map((m) => x.decodeString(m)) : u, c = kt(o.shape, o.dtype, l), p = YR(c, s10);
      return r.makeTensorInfo(p.shape, p.dtype, p.values);
    }
    let i = new Ow(o.shape, s10);
    return r.runWebGLProgram(i, [o], o.dtype);
  }
  var LM = { kernelName: gs, backendName: "webgl", kernelFunc: $S };
  var Rw = class {
    constructor(t) {
      this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "negativeInf", type: "float" }, { name: "dir", type: "int" }, { name: "inc", type: "int" }], this.outputShape = t, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  };
  var Pw = class {
    constructor(t) {
      this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "k", type: "int" }], this.outputShape = t, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  };
  function ac(e28, t) {
    t !== null && e28.disposeIntermediateTensorInfo(t);
  }
  function MM(e28) {
    let t = 1;
    for (; t < e28; ) t *= 2;
    return t;
  }
  function ptt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o } = t, { k: s10, sorted: i } = n, a = z().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), u = z().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), l = o.shape, c = l[l.length - 1];
    if (r.shouldExecuteOnCPU([o]) || c < a || s10 > u) {
      let L = r.readSync(o.dataId), [G, W] = JR(L, l, o.dtype, s10, i);
      return [r.makeTensorInfo(G.shape, G.dtype, G.values), r.makeTensorInfo(W.shape, W.dtype, W.values)];
    }
    if (s10 === 0) return l[l.length - 1] = 0, [r.makeTensorInfo(l, o.dtype, []), r.makeTensorInfo(l, "int32", [])];
    if (c === 1) return [o, ca({ attrs: { shape: l, dtype: "int32", value: 0 }, backend: r })];
    let p = r.texData.get(o.dataId), m = p !== null && p.isPacked, f = m ? r.unpackTensor(o) : o, d = x.sizeFromShape(l) / c, g = rt({ inputs: { x: f }, attrs: { shape: [d, c] }, backend: r });
    m && ac(r, f);
    let y = MM(s10), b = MM(c), v = null, w = () => v === null ? [g, g] : [g, v], N = (L, G, W) => {
      let U = w(), H = new Rw(W), X = [[c], [v === null ? 1 : 0], [Number.NEGATIVE_INFINITY], [L], [G]], Q = v;
      v = r.runWebGLProgram(H, U, "int32", X), ac(r, Q);
    };
    for (let L = 1; L < y; L *= 2) {
      let G = L * 2;
      for (let W = L; W >= 1; W /= 2) N(G, W, [d, b]);
    }
    for (let L = b; L > y; L /= 2) {
      let G = w(), W = new Pw([d, L / 2]), H = [[c], [v === null ? 1 : 0], [y]], j = v;
      v = r.runWebGLProgram(W, G, "int32", H), ac(r, j);
      let X = y / 2, Q = X * 2;
      for (let q = X; q >= 1; q /= 2) N(Q, q, v.shape);
    }
    let E = v;
    v = rs({ inputs: { x: v }, backend: r, attrs: { begin: 0, size: [d, s10] } }), ac(r, E);
    let A = SS({ inputs: { x: g, indices: v }, backend: r, attrs: { axis: 1, batchDims: 1 } });
    ac(r, g);
    let D = l.slice(0, -1);
    D.push(s10), E = v, v = rt({ inputs: { x: v }, attrs: { shape: D }, backend: r }), ac(r, E);
    let R = A;
    return A = rt({ inputs: { x: A }, attrs: { shape: D }, backend: r }), ac(r, R), [A, v];
  }
  var zM = { kernelName: pp, backendName: "webgl", kernelFunc: ptt };
  var Lw = class {
    constructor(t, r, n, o, s10, i) {
      this.variableNames = ["Image", "Transforms"], this.outputShape = i;
      let a = n === "nearest" ? 1 : 2, u;
      switch (o) {
        case "constant":
          u = 1;
          break;
        case "reflect":
          u = 2;
          break;
        case "wrap":
          u = 3;
          break;
        case "nearest":
          u = 4;
          break;
        default:
          u = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${r}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s10});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s10});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${r}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  };
  function mtt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { image: o, transforms: s10 } = t, { interpolation: i, fillMode: a, fillValue: u, outputShape: l } = n, [c, p, m, f] = o.shape, [h, d] = l ?? [p, m], g = [c, h, d, f], y = new Lw(p, m, i, a, u, g);
    return r.runWebGLProgram(y, [o, s10], "float32");
  }
  var BM = { kernelName: mp, backendName: "webgl", kernelFunc: mtt };
  function ftt(e28) {
    let { inputs: t, attrs: r, backend: n } = e28, { axis: o } = r, { x: s10 } = t;
    Os(s10, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    let i = n.readSync(s10.dataId), { outputValues: a, outputShape: u, indices: l } = ZR(i, o, s10.shape, s10.dtype);
    return [n.makeTensorInfo(u, s10.dtype, a), n.makeTensorInfo([l.length], "int32", l)];
  }
  var VM = { kernelName: fp, backendName: "webgl", kernelFunc: ftt };
  function htt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { value: o } = t, { axis: s10 } = n;
    s10 < 0 && (s10 += o.shape.length);
    let i = o, a = i.shape.length, u = o.shape[s10], l = new Array(a - 1), c = 0;
    for (let d = 0; d < a; d++) d !== s10 && (l[c++] = i.shape[d]);
    let p = [], m = new Array(a).fill(0), f = i.shape.slice();
    f[s10] = 1;
    let h = new Array(u);
    for (let d = 0; d < h.length; d++) {
      m[s10] = d;
      let g = rs({ inputs: { x: i }, backend: r, attrs: { begin: m, size: f } }), y = rt({ inputs: { x: g }, backend: r, attrs: { shape: l } });
      h[d] = y, p.push(g);
    }
    return p.forEach((d) => r.disposeIntermediateTensorInfo(d)), h;
  }
  var GM = { kernelName: gu, backendName: "webgl", kernelFunc: htt };
  var Mw = class {
    constructor(t, r) {
      this.variableNames = ["x", "segmentIds"];
      let n = t.windowSize, o = t.batchSize, s10 = t.inSize, i = t.numSegments, a = i * Math.ceil(s10 / n);
      this.outputShape = [o, a];
      let u = "0.0", l = "sumValue", c = Math.floor(n / 4) * 4, p = n % 4, m = `
        sumValue += dot(values, segFilter);
    `, f = "";
      s10 % n > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${s10}) {
          return initializationValue;
        }
      `);
      let h = "";
      s10 % n > 0 && (h = `
        if (inIdx < 0 || inIdx >= ${s10}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `;
    }
  };
  function dtt(e28) {
    let { inputs: t, backend: r, attrs: n } = e28, { x: o, segmentIds: s10 } = t, { numSegments: i } = n, a = o.shape.length, u = [], l = 0, c = C.getAxesPermutation([l], a), p = o;
    c != null && (p = Ae({ inputs: { x: o }, backend: r, attrs: { perm: c } }), u.push(p), l = C.getInnerMostAxes(1, a)[0]);
    let m = C.segment_util.computeOutShape(p.shape, l, i), f = x.sizeFromShape([p.shape[l]]), h = rt({ inputs: { x: p }, backend: r, attrs: { shape: [-1, f] } });
    u.push(h);
    let d = bl(o.dtype), g = (w, N, E, A, D) => {
      let R = w.shape[0], L = w.shape[1], G = C.segment_util.segOpComputeOptimalWindowSize(L, D), W = { windowSize: G, inSize: L, batchSize: R, numSegments: D }, U = new Mw(W, N), H = r.compileAndRun(U, [w, E], A);
      if (u.push(H), H.shape[1] === D) return H;
      let j = DS({ backend: r, attrs: { start: 0, stop: D, step: 1, dtype: "float32" } }), X = $S({ inputs: { x: j }, backend: r, attrs: { reps: [L / G] } });
      return u.push(j), u.push(X), g(H, N, X, A, D);
    }, y = g(h, "unsortedSegmentSum", s10, d, i), b = rt({ inputs: { x: y }, backend: r, attrs: { shape: m } }), v = b;
    if (c != null) {
      u.push(b);
      let w = C.getUndoAxesPermutation(c);
      v = Ae({ inputs: { x: v }, backend: r, attrs: { perm: w } });
    }
    return u.forEach((w) => r.disposeIntermediateTensorInfo(w)), v;
  }
  var WM = { kernelName: yu, backendName: "webgl", kernelFunc: dtt };
  var gtt = [IP, kP, EP, AP, $P, FP, _P, OP, LP, MP, zP, BP, VP, GP, WP, UP, jP, HP, KP, qP, XP, JP, ZP, QP, tL, oL, iL, aL, dP, lL, pL, mL, fL, hL, dL, gL, yL, xL, bL, wL, CL, SL, IL, TL, kL, EL, AL, DL, $L, FL, _L, OL, RL, PL, LL, ML, BL, VL, GL, WL, jL, HL, KL, qL, XL, YL, JL, ZL, QL, hP, t3, cL, e32, r3, n3, gP, o3, s3, i3, a3, u3, l3, c3, p3, m3, f3, d3, g3, y3, x3, b3, w3, N3, S3, I3, T3, k3, E3, _3, bP, O3, R3, P3, L3, eL, M3, V3, G3, W3, U3, yP, j3, H3, K3, q3, X3, rL, A3, Y3, J3, Z3, vP, Q3, tM, eM, rM, nM, oM, sM, iM, aM, uM, lM, cM, pM, mM, fM, hM, YP, F3, dM, gM, yM, xM, bM, wM, vM, NM, SM, IM, kM, EM, AM, DM, $M, FM, _M, $3, CP, OM, RM, PM, LM, zM, BM, SP, VM, GM, WM, z3];
  for (let e28 of gtt) $y(e28);
  function ns(e28) {
    return tr(e28) ? e28.shape.length === 2 : Tt(e28) ? true : it(e28) && Et(e28).length === 2;
  }
  function tr(e28) {
    return e28 instanceof ee;
  }
  function UM(e28) {
    return dt(e28) && Math.floor(Number(e28)) === Number(e28) && e28 >= 0 && e28 < 1 / 0;
  }
  function jM(e28, t) {
    return M(() => {
      tr(e28) && (e28 = e28.arraySync()), tr(t) && (t = t.arraySync());
      let r = [], n = t.slice();
      return e28.forEach((o) => {
        let s10 = xf(n.map((i) => bf(o, i)));
        r.push(n[s10]), n.splice(s10, 1);
      }), r.concat(n);
    });
  }
  function zw(e28) {
    return M(() => ((Tt(e28) || At(e28)) && (e28 = e28.values), tr(e28) || (e28 = me(e28)), e28.div(e28.abs())));
  }
  function uc(e28) {
    return Cc(e28, (t) => Number(t));
  }
  function jm(e28, t, r) {
    tr(e28) && (e28 = e28.arraySync()), (Tt(e28) || At(e28)) && (e28 = e28.values), tr(t) && (t = t.arraySync()), (Tt(t) || At(t)) && (t = t.values), B(on(Et(e28), Et(t)), "`yPred` and `yTrue` must have the same shape!"), r && (e28 = uc(e28), t = uc(t));
    let n = M(() => me(e28).sub(me(t)).pow(2).sum().arraySync());
    return isNaN(n) && !r ? jm(e28, t, true) : n;
  }
  function FS(e28, t, r) {
    tr(e28) && (e28 = e28.arraySync()), (Tt(e28) || At(e28)) && (e28 = e28.values), tr(t) && (t = t.arraySync()), (Tt(t) || At(t)) && (t = t.values), B(on(Et(e28), Et(t)), "`yPred` and `yTrue` must have the same shape!"), r && (e28 = uc(e28), t = uc(t));
    let n = An(e28), o = An(t), s10 = 0;
    n.forEach((a, u) => {
      a === o[u] && s10++;
    });
    let i = s10 / n.length;
    return isNaN(i) && !r ? FS(n, o, true) : i;
  }
  function Bw(e28, t, r, n) {
    return M(() => {
      tr(e28) && (e28 = e28.arraySync()), (Tt(e28) || At(e28)) && (e28 = e28.values), tr(t) && (t = t.arraySync()), (Tt(t) || At(t)) && (t = t.values), It(r) && (r = e28), tr(r) && (r = r.arraySync()), (Tt(r) || At(r)) && (r = r.values), typeof r == "number" && (r = [r]), B(on(Et(e28), Et(t)), "`yTrue` and `yPred` must have the same shape!"), n && (e28 = uc(e28), t = uc(t), r = uc(r));
      let o = e28, s10 = t, i = r;
      e28 = me(e28), t = me(t), r = me(r);
      let a = e28.sub(t).pow(2).sum(), u = e28.sub(r.mean()).pow(2).sum(), l = $t(1).sub(a.div(u)).arraySync();
      return isNaN(l) && !n ? Bw(o, s10, i, true) : l;
    });
  }
  function HM(e28, t, r) {
    return M(() => {
      let n = $t(Bw(e28, t, r));
      return zw(n).mul(n.abs().sqrt()).arraySync();
    });
  }
  var ytt = Object.defineProperty;
  var xtt = (e28, t, r) => t in e28 ? ytt(e28, t, { enumerable: true, configurable: true, writable: true, value: r }) : e28[t] = r;
  var yz = (e28, t, r) => (xtt(e28, typeof t != "symbol" ? t + "" : t, r), r);
  function at(e28) {
    return typeof e28 == "number" && !isNaN(e28) || typeof e28 == "bigint";
  }
  var btt = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var ma = class extends Error {
    constructor(e28) {
      btt() ? super(e28) : super(`

\x1B[31m` + e28 + `
\x1B[0m`);
    }
  };
  function O(e28, t) {
    if (!e28) throw new ma(t);
  }
  var xz = [Array, ArrayBuffer, BigInt64Array, BigUint64Array, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray];
  function pt(e28) {
    return e28 === null || typeof e28 > "u";
  }
  var wtt = xz.map((e28) => e28.name);
  function tt(e28) {
    try {
      return e28 instanceof Array ? true : pt(e28.constructor) ? false : xz.indexOf(e28.constructor) > -1 || wtt.indexOf(e28.constructor.name) > -1;
    } catch {
      return false;
    }
  }
  function ft(e28) {
    try {
      return !!e28._symbol && e28._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch {
      return false;
    }
  }
  function yr(e28) {
    return typeof e28 == "function";
  }
  function Ms(e28) {
    return typeof e28 == "object" && !pt(e28) && !tt(e28);
  }
  function gt(e28) {
    try {
      return !!e28._symbol && e28._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch {
      return false;
    }
  }
  function Qm(e28, t) {
    if (ft(e28)) {
      let s10 = Qm(e28.values, t);
      return s10.length > 0 && at(s10[0]) && s10[0] >= 0 && s10[0] < e28.index.length && (s10[0] = e28.index[s10[0]]), s10.length > 1 && at(s10[1]) && s10[1] >= 0 && s10[1] < e28.columns.length && (s10[1] = e28.columns[s10[1]]), s10;
    }
    if (gt(e28)) {
      let s10 = Qm(e28.values, t);
      return s10.length > 0 && at(s10[0]) && s10[0] >= 0 && s10[0] < e28.index.length && (s10[0] = e28.index[s10[0]]), s10;
    }
    if (O(Ms(e28) || tt(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"), !yr(t)) {
      let s10 = t;
      t = (i) => i === s10;
    }
    function r(s10, i, a) {
      if (a = a || [], a.indexOf(s10) > -1) return null;
      if (Ms(s10)) {
        a.push(s10);
        let u = Object.keys(s10).concat(Object.getOwnPropertySymbols(s10));
        for (let l = 0; l < u.length; l++) {
          let c = u[l], p = s10[c];
          if (i(p)) return [c];
          let m = r(p, i, a);
          if (m && m.length > 0) return [c].concat(m);
        }
      } else if (tt(s10)) {
        a.push(s10);
        for (let u = 0; u < s10.length; u++) {
          let l = s10[u];
          if (i(l)) return [u];
          let c = r(l, i, a);
          if (c && c.length > 0) return [u].concat(c);
        }
      } else if (i(s10)) return [];
      return null;
    }
    function n(s10) {
      try {
        return t(s10);
      } catch {
        return false;
      }
    }
    let o = r(e28, n);
    return o && o.length > 0 ? o : null;
  }
  function Mr(e28) {
    function t(r) {
      if (typeof r == "object") {
        if (r === null) return null;
        if (tt(r)) return r instanceof Array ? r.map((o) => Mr(o)) : r.slice();
        if (gt(r)) {
          let o = r.copy();
          return o.values = Mr(o.values), o;
        }
        if (ft(r)) {
          let o = r.copy();
          return o.values = Mr(r.values), o;
        }
        if (r instanceof Date) return new Date(r.getTime());
        r = tf(r);
        let n = {};
        return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach((o) => {
          n[o] = Mr(r[o]);
        }), n;
      } else return r;
    }
    return t(tf(e28));
  }
  function tf(e28) {
    function t(o, s10, i) {
      if (s10 = s10 || [], i = i || "", s10.indexOf(o) > -1) {
        let a = i.split("/").slice(i.startsWith("/") ? 1 : 0);
        if (a.some((l, c) => {
          let p = a.slice(0, a.length - c - 1), m = r;
          return p.forEach((f) => {
            m = m[f];
          }), m === o;
        })) return `<reference to "${r === o ? "/" : "/" + Qm(r, o).join("/")}">`;
      }
      return typeof o == "object" ? o === null ? null : (s10.push(o), tt(o) ? typeof o.constructor < "u" && o.constructor.name !== "Array" ? o.slice() : o.map((a, u) => t(a, s10, i + "/" + u)) : (Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach((a) => {
        o[a] = t(o[a], s10, i + "/" + a.toString());
      }), o)) : o;
    }
    let r = e28, n = t(r);
    if (ft(e28)) {
      let o = e28.copy();
      o._values = n.values, o._columns = n.columns, o._index = n.index, n = o;
    }
    if (gt(e28)) {
      let o = e28.copy();
      o.name = n.name, o._values = n.values, o._index = n.index, n = o;
    }
    return n;
  }
  function fa(e28) {
    return e28 instanceof Date && e28.toString() !== "Invalid Date";
  }
  var KM = ["number", "int", "float", "bigint"];
  function En(e28, t) {
    function r(n, o) {
      let s10 = typeof n, i = typeof o;
      if (s10 !== i && !KM.includes(s10) && !KM.includes(i)) return false;
      if (s10 === "undefined" && i === "undefined") return true;
      if (s10 === "boolean" || s10 === "symbol") return n === o;
      if (s10 === "number" || s10 === "bigint") try {
        let a = n.toString(), u = o.toString();
        return a === u;
      } catch {
        return false;
      }
      if (s10 === "string" || s10 === "function") return n === o;
      if (s10 === "object") {
        if (n === null || o === null) return n === null && o === null;
        {
          if (fa(n)) return fa(o) ? n.getTime() === o.getTime() : false;
          if (fa(o)) return false;
          if (n instanceof RegExp && o instanceof RegExp) return n.toString() === o.toString();
          if (tt(n) !== tt(o)) return false;
          let a = Object.keys(n).concat(Object.getOwnPropertySymbols(n)), u = Object.keys(o).concat(Object.getOwnPropertySymbols(o));
          if (a.length !== u.length) return false;
          for (let l = 0; l < a.length; l++) {
            let c = a[l];
            if (!r(n[c], o[c])) return false;
          }
          return true;
        }
      }
    }
    try {
      return r(e28, t);
    } catch {
      return r(tf(e28), tf(t));
    }
  }
  function Fg(e28) {
    let t = "abcdefg1234567890", r = "";
    for (; r.length < e28; ) r += t[Math.floor(Math.random() * t.length)];
    return r;
  }
  var vtt = Fg(16);
  var Ntt = Fg(16);
  var Ctt = Fg(16);
  var Stt = Fg(16);
  var Itt = Fg(16);
  var Ttt = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((e28) => this.get(e28));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      return this.countsDict = {}, this.valuesDict = {}, this;
    }
    count(e28) {
      for (let t of e28) tt(t) ? this.count(t) : this.increment(t);
      return this;
    }
    delete(e28) {
      let t = this.getStandardizedKey(e28);
      return delete this.countsDict[t], delete this.valuesDict[t], this;
    }
    get(e28) {
      return this.countsDict[this.getStandardizedKey(e28)] || 0;
    }
    getStandardizedKey(e28) {
      return typeof e28 == "object" && e28 === null ? vtt : pt(e28) ? Ntt : yr(e28) ? e28.toString() : typeof e28 == "symbol" ? e28.toString() + " - " + Itt : e28 === 1 / 0 ? Ctt : e28 === -1 / 0 ? Stt : typeof e28 == "bigint" ? e28.toString() : ft(e28) ? e28.toJSONString() : gt(e28) ? JSON.stringify(e28.toObject()) : JSON.stringify(e28);
    }
    has(e28) {
      return !pt(this.countsDict[this.getStandardizedKey(e28)]);
    }
    increment(e28) {
      return this.set(e28, this.get(e28) + 1);
    }
    set(e28, t) {
      let r = this.getStandardizedKey(e28);
      return this.countsDict[r] = t, this.valuesDict[r] = e28, this;
    }
    toArray() {
      return this.values.map((e28) => ({ value: e28, count: this.get(e28) }));
    }
    toObject() {
      let e28 = {};
      return this.values.forEach((t) => {
        e28[t] = this.get(t);
      }), e28;
    }
  };
  function zr(e28) {
    if (ft(e28) || gt(e28)) return zr(e28.values);
    O(tt(e28), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function t(r) {
      let n = [];
      return r.forEach((o) => {
        tt(o) ? n = n.concat(t(o)) : n.push(o);
      }), n;
    }
    return t(e28);
  }
  function He(e28, t) {
    t = t || {};
    let r = new Ttt(), n = {}, o = zr(e28), s10 = [], i = -1 / 0, a = 1 / 0, u = false, l = 0;
    for (let p of o) {
      if (typeof p == "bigint" && (u = true), !t.shouldDropNaNs || at(p)) try {
        p > i && (i = p), p < a && (a = p), l += Number(p), s10.push(p);
      } catch {
        i = NaN, a = NaN, l = NaN;
      }
      r.increment(p);
    }
    let c = l / s10.length;
    if (n.counts = r, n.max = i, n.mean = c, n.min = a, n.n = o.length, n.sum = l, isNaN(n.mean) && (n.max = NaN, n.min = NaN), t.shouldDropNaNs && (n.nWithoutNaNs = s10.length), t.mode) {
      let p = Array.from(r.values.map((h) => [h, r.get(h)])).toSorted((h, d) => d[1] - h[1]), m = p[0][1], f = [];
      for (let h of p) if (h[1] == m) f.push(h[0]);
      else break;
      n.mode = f.toSorted();
    }
    if (t.median) if (isNaN(c)) n.median = NaN;
    else {
      let p = s10.toSorted((f, h) => Number(f) - Number(h)), m = Math.floor(p.length / 2);
      if (p.length % 2 === 0) {
        let f = p[m - 1], h = p[m];
        if (n.median = (Number(f) + Number(h)) / 2, u && typeof f == "bigint" && typeof h == "bigint") try {
          n.median = BigInt(n.median);
        } catch {
        }
      } else n.median = p[m];
    }
    if (t.stdev || t.variance) {
      let p = 0;
      for (let f of s10) p += Math.pow(Number(f) - c, 2);
      p /= s10.length;
      let m = Math.sqrt(p);
      n.stdev = m, n.variance = p;
    }
    if (u) {
      try {
        n.sum = BigInt(n.sum);
      } catch {
      }
      try {
        n.mean = BigInt(n.mean);
      } catch {
      }
      t.mode && (n.mode = n.mode.map((p) => {
        try {
          return BigInt(p);
        } catch {
          return p;
        }
      }));
    }
    return n;
  }
  function ef(e28, t) {
    let { counts: r } = He(e28);
    return pt(t) || (yr(t) ? r.values.forEach((n) => {
      t(n) || r.delete(n);
    }) : r.values.forEach((n) => {
      En(n, t) || r.delete(n);
    })), r;
  }
  function RS(e28) {
    if (ft(e28) || gt(e28)) return RS(e28.values);
    if (tt(e28)) {
      let t = false, r = false, n = null;
      for (let o of e28) {
        if (RS(o)) return true;
        if (tt(o)) {
          if (n === null) n = o.length;
          else if (o.length !== n) return true;
          t = true;
        } else r = true;
        if (t && r) return true;
      }
    }
    return false;
  }
  function Ro(e28) {
    return RS(tf(e28));
  }
  function iv(e28) {
    if (ft(e28) || gt(e28)) return iv(e28.values);
    O(tt(e28), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let t = 0; t < e28.length; t++) if (tt(e28[t])) return true;
    return false;
  }
  var Hm = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function io(e28) {
    O(!pt(e28), Hm), tt(e28) || (e28 = [e28]), O(!iv(e28), Hm), O(e28.length > 0, Hm);
    let t = e28[0];
    if (typeof t == "bigint" && (t = Number(t)), O(at(t), Hm), O(t >= 0, Hm), O(Math.floor(t) === t, Hm), O(t !== 1 / 0, "We can't create an array containing an infinite number of values!"), e28.length === 1) {
      let r = [];
      for (let n = 0; n < t; n++) r.push(void 0);
      return r;
    } else {
      let r = [];
      for (let n = 0; n < t; n++) r.push(io(e28.slice(1)));
      return r;
    }
  }
  function ss(e28) {
    if (ft(e28) || gt(e28)) {
      let r = e28.copy();
      return r.values = ss(r.values), r.index = ss(r.index), r;
    }
    O(tt(e28), "The `reverse` function only works on arrays, Series, and DataFrames!");
    let t = [];
    for (let r = e28.length - 1; r >= 0; r--) t.push(e28[r]);
    return t;
  }
  function ze(e28, t, r = 1) {
    O(!pt(e28) && !pt(t) && !pt(r), "You must pass two numbers and optionally a step value to the `range` function!"), O(at(e28) && at(t) && at(r), "You must pass two numbers and optionally a step value to the `range` function!"), O(r > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let n = false, o = typeof e28 == "bigint" || typeof t == "bigint" || typeof r == "bigint";
    if (e28 = Number(e28), t = Number(t), r = Number(r), e28 > t) {
      n = true;
      let i = e28;
      e28 = t + r, t = i + r;
    }
    let s10 = [];
    for (let i = e28; i < t; i += r) if (o) try {
      s10.push(BigInt(i));
    } catch {
      s10.push(i);
    }
    else s10.push(i);
    return n && (s10 = ss(s10)), s10;
  }
  function _g(e28) {
    let t = "abcdefg1234567890", r = "";
    for (; r.length < e28; ) r += t[Math.floor(Math.random() * t.length)];
    return r;
  }
  var ktt = _g(256);
  var Ett = _g(256);
  var Att = _g(256);
  var Dtt = _g(256);
  var $tt = _g(256);
  function Un(e28) {
    if (ft(e28) || gt(e28)) return Un(e28.values);
    O(tt(e28), "The `set` function only works on arrays, Series, and DataFrames!");
    let t = [], r = {};
    return zr(e28).forEach((n) => {
      let o = typeof n == "object" && n === null ? ktt : pt(n) ? Ett : yr(n) ? n.toString() : typeof n == "symbol" ? n.toString() + " - " + $tt : n === 1 / 0 ? Att : n === -1 / 0 ? Dtt : typeof n == "bigint" ? n.toString() : ft(n) ? n.toJSONString() : gt(n) ? JSON.stringify(n.toObject()) : JSON.stringify(n);
      r[o] || t.push(n), r[o] = true;
    }), t;
  }
  function bz(e28) {
    if (tt(e28)) {
      let t = bz(e28[0]);
      return [e28.length].concat(t || []);
    } else return;
  }
  function Nt(e28) {
    return ft(e28) || gt(e28) ? Nt(e28.values) : (O(tt(e28), "The `shape` function only works on arrays, Series, and DataFrames!"), bz(e28));
  }
  function wz(e28, t, r) {
    if (pt(r) && (r = 0), O(r === 0 || r === 1 || r === "vertical" || r === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'), tt(t)) {
      O(!Ro(t), "The array of data you're trying to append to this DataFrame is jagged!");
      let n = Nt(t);
      if (n.length === 1) if (r === 0) {
        let o = e28.copy();
        o._values.push(t);
        let s10 = Math.max(e28.shape[1], n[0]);
        for (o._values.forEach((i) => {
          for (; i.length < s10; ) i.push(void 0);
        }); o._index.length < o._values.length; ) o._index.push("row" + o._index.length);
        for (; o._columns.length < s10; ) o._columns.push("col" + o._columns.length);
        return o;
      } else {
        let o = Math.max(e28.shape[0], n[0]), s10 = e28.copy();
        for (ze(0, o).forEach((i) => {
          i >= s10._values.length && s10._values.push(io(e28.shape[1])), s10._values[i].push(t[i]);
        }); s10._index.length < s10._values.length; ) s10._index.push("row" + s10._index.length);
        for (; s10._columns.length < s10._values[0].length; ) s10._columns.push("col" + s10._columns.length);
        return s10;
      }
      else if (n.length === 2) if (r === 0) {
        let o = Math.max(...t.map((i) => i.length).concat([e28.shape[1]])), s10 = e28.copy();
        for (s10._values = s10._values.concat(t).map((i) => {
          for (; i.length < o; ) i.push(void 0);
          return i;
        }); s10._index.length < s10._values.length; ) s10._index.push("row" + s10._index.length);
        for (; s10._columns.length < o; ) s10._columns.push("col" + s10._columns.length);
        return s10;
      } else {
        let o = Math.max(...t.map((a) => a.length)) + e28.shape[1], s10 = Math.max(e28.shape[0], n[0]), i = e28.copy();
        for (ze(0, s10).forEach((a) => {
          for (a >= i._values.length && i._values.push(io(e28.shape[1])), i._values[a] = i._values[a].concat(t[a]); i._values[a].length < o; ) i._values[a].push(void 0);
        }); i._index.length < i._values.length; ) i._index.push("row" + i._index.length);
        for (; i._columns.length < o; ) i._columns.push("col" + i._columns.length);
        return i;
      }
      else throw new ma("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
    } else if (gt(t)) {
      let n = wz(e28, t.values, r);
      return r === 0 ? n.index[n.index.length - 1] = n.index.indexOf(t.name) > -1 ? t.name + " (2)" : t.name : n.columns[n.columns.length - 1] = n.columns.indexOf(t.name) > -1 ? t.name + " (2)" : t.name, n;
    } else if (ft(t)) if (r === 0) {
      let n = e28.copy(), o = Un(n._columns.concat(t._columns)).length;
      for (n._values.forEach((s10) => {
        for (; s10.length < o; ) s10.push(void 0);
      }), t.apply((s10) => {
        let i = s10.copy(), a = [];
        n._columns.forEach((u) => {
          let l = i._index.indexOf(u);
          l > -1 ? (a.push(i._values[l]), i._values.splice(l, 1), i._index.splice(l, 1)) : a.push(void 0);
        }), n._values.push(a.concat(i._values));
      }, 1), n._columns = n._columns.concat(t._columns.filter((s10) => n._columns.indexOf(s10) < 0)); n._index.length < n._values.length; ) {
        let s10 = "row" + n._index.length;
        n._index.push(s10 + (e28._index.indexOf(s10) > -1 ? " (2)" : ""));
      }
      return n;
    } else {
      let n = e28.copy();
      return n._index.forEach((o, s10) => {
        let i = t._index.indexOf(o);
        i > -1 ? n._values[s10] = n._values[s10].concat(t._values[i]) : n._values[s10] = n._values[s10].concat(io(t.shape[1]));
      }), t._index.forEach((o, s10) => {
        n._index.indexOf(o) < 0 && (n._index.push(o), n._values.push(io(n._columns.length).concat(t._values[s10])));
      }), n._columns = n._columns.concat(t._columns.map((o) => o + (n._columns.indexOf(o) > -1 ? " (2)" : ""))), n;
    }
    else throw new ma("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
  }
  function Ftt(e28, t, r, n, o) {
    if (o = o || 0, O(yr(n), "The first parameter to the `apply` method must be a function."), O(o === 0 || o === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1."), o === 0) {
      let s10 = {}, i;
      if (r.columns.forEach((a, u) => {
        let l = new t(r.values.map((p) => p[u]));
        l.name = a, l.index = r.index;
        let c = n(l, u, r);
        c instanceof t ? s10[a] = c.values : s10[a] = c, pt(i) && (i = c instanceof t || tt(c));
      }), i) {
        let a = new e28(s10);
        return a.index = r.index, a;
      } else {
        let a = new t(r.columns.map((u) => s10[u]));
        return a.index = r.columns, a;
      }
    } else if (o === 1) {
      let s10, i = r.values.map((a, u) => {
        let l = new t(a);
        l.name = r.index[u], l.index = r.columns;
        let c = n(l, u, r);
        return pt(s10) && (s10 = c instanceof t || tt(c)), c instanceof t ? c.values : c;
      });
      if (s10) {
        let a = new e28(i);
        return a.index = r.index, a.columns = r.columns, a;
      } else {
        let a = new t(i);
        return a.index = r.index, a;
      }
    }
  }
  function Me(e28) {
    return typeof e28 == "string";
  }
  function _tt(e28, t, r, n, o) {
    let s10 = (a) => a instanceof e28, i = (a) => a instanceof t;
    if (pt(o)) {
      if (s10(n)) return r.append(n, 1);
      if (i(n)) return r.append(n, 1);
      if (Ms(n)) {
        let a = Math.max(...Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map((u) => n[u].length));
        return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach((u) => {
          for (; n[u].length < a; ) n[u].push(void 0);
        }), r.append(new e28(n), 1);
      } else throw new ma("You must pass a DataFrame, Series, or object into the `assign` method!");
    } else {
      O(Me(n), "If passing two arguments into the `assign` method, then the first argument must be a string name!"), O(tt(o) && !Ro(o) && Nt(o).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      let a = r.append(o, 1);
      return a.columns[a.columns.length - 1] = n, a;
    }
  }
  function Ott(e28, t) {
    if (t.isEmpty) return new e28();
    let r = new e28(Mr(t.values));
    return r.columns = t.columns.slice(), r.index = t.index.slice(), r;
  }
  function Rtt(e28, t, r, n, o) {
    pt(n) && (n = []), pt(o) && (o = []), (Me(n) || at(n)) && (n = [n]), (Me(o) || at(o)) && (o = [o]), O(tt(n), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), O(tt(o), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), O(Nt(n).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), O(Nt(o).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let s10, i;
    r.index.forEach((u, l) => {
      n.indexOf(u) < 0 && n.indexOf(l) < 0 && (s10 || (s10 = []), s10.push(u));
    }), r.columns.forEach((u, l) => {
      o.indexOf(u) < 0 && o.indexOf(l) < 0 && (i || (i = []), i.push(u));
    });
    let a = r.get(s10, i);
    if (a instanceof t) {
      let u = new e28();
      u = u.assign(a), r.index.indexOf(a.name) > -1 && (u = u.transpose()), a = u;
    }
    return a;
  }
  function vz(e28) {
    return at(e28) && (e28 >= 0 ? Math.floor(e28) === e28 : Math.ceil(e28) === e28);
  }
  function rf(e28) {
    return vz(e28) && e28 >= 0;
  }
  function Ptt(e28, t, r, n, o, s10) {
    n = n || 0, O(n === 0 || n === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."), s10 = s10 || 0, O(rf(s10), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."), o = s10 > 0 ? "none" : o || "any", O(o === "any" || o === "all" || o === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function i(l) {
      if (s10 > 0) {
        let c = 0;
        for (let p = 0; p < l.length; p++) {
          let m = l[p];
          if (pt(m) && c++, c >= s10) return [];
        }
      } else if (o === "any") for (let c = 0; c < l.length; c++) {
        let p = l[c];
        if (pt(p)) return [];
      }
      else if (o === "all") {
        for (let c = 0; c < l.length; c++) {
          let p = l[c];
          if (!pt(p)) return l;
        }
        return [];
      }
      return l;
    }
    let a = r.copy(), u = Math.random().toString();
    if (n === 0) {
      a = a.assign(u, a.index);
      let l = a.values.map(i).filter((p) => p.length > 0);
      if (Nt(l).length < 2) return new e28();
      a.values = l;
      let c = a.get(null, u);
      if (pt(c)) return new e28();
      Me(c) && (c = [c]), c instanceof t && (c = c.values), a.index = c, a = a.drop(null, u);
    } else if (n === 1) {
      let l = {};
      if (a.columns.forEach((p, m) => {
        let f = a.values.map((d) => d[m]), h = i(f);
        h.length > 0 && (l[p] = h);
      }), Object.keys(l).length + Object.getOwnPropertySymbols(l).length === 0) return new e28();
      let c = new e28(l);
      return c.index = a.index, c;
    }
    return a;
  }
  function Og(e28) {
    if (ft(e28) || gt(e28)) return e28.dropNaN(...Object.values(arguments).slice(1));
    O(tt(e28), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    let t = [];
    return e28.forEach((r) => {
      try {
        return t.push(Og(r));
      } catch {
        if (at(r)) return t.push(r);
      }
    }), t;
  }
  function Ltt(e28, t, r, n, o) {
    r = r || 0, O(r === 0 || r === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."), o = o || 0, O(rf(o), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."), n = o > 0 ? "none" : n || "any", O(n === "any" || n === "all" || n === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function s10(a) {
      let u = Og(a);
      return o > 0 ? a.length - u.length < o : n === "any" ? u.length === a.length : n === "all" ? u.length > 0 : true;
    }
    let i = t.copy();
    if (r === 0) {
      let a = i.index.filter((u) => {
        let l = i.get(u, null).values;
        return s10(l);
      });
      return a.length > 0 ? i.get(a, null) : new e28();
    } else if (r === 1) {
      let a = i.columns.filter((u) => {
        let l = i.get(null, u).values;
        return s10(l);
      });
      return a.length > 0 ? i.get(null, a) : new e28();
    }
    return i;
  }
  function qM(e28) {
    let t = {};
    return zr(e28).forEach((r, n) => {
      t[r] = n;
    }), t;
  }
  function Km(e28) {
    return Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).sort((t, r) => e28[t] - e28[r]);
  }
  function Mtt(e28, t, r, n, o) {
    O(yr(n), "The `filter` method takes a single parameter: a function that is used to filter the values."), pt(o) && (o = 0), O(o === 0 || o === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let s10 = r.copy();
    if (s10.isEmpty) return s10;
    let i = qM(s10.index), a = qM(s10.columns);
    if (o === 0) {
      let u = 0, l = s10.values.filter((c, p) => {
        let m = new t(c);
        m.name = r.index[p], m.index = r.columns;
        let f = n(m, p, r);
        return f ? u++ : delete i[s10.index[p]], f;
      });
      if (u === 0) return new e28();
      if (u === 1) {
        let c = new t(l[0]);
        return c.name = Km(i)[0], c.index = Km(a), c;
      }
      s10.values = l, s10.index = Km(i);
    } else if (o === 1) {
      s10 = s10.transpose();
      let u = 0, l = s10.values.filter((c, p) => {
        let m = new t(c);
        m.name = r.columns[p], m.index = r.index;
        let f = n(m, p, r);
        return f ? u++ : delete a[s10.index[p]], f;
      });
      if (u === 0) return new e28();
      if (u === 1) {
        let c = new t(l[0]);
        return c.name = Km(a)[0], c.index = Km(i), c;
      }
      s10.values = l, s10.index = Km(a), s10 = s10.transpose();
    }
    return s10;
  }
  function ztt(e28, t, r) {
    (Me(t) || at(t)) && (t = [t]), (Me(r) || at(r)) && (r = [r]);
    for (let o in t) typeof t[o] == "bigint" && (t[o] = Number(t[o]));
    for (let o in r) typeof r[o] == "bigint" && (r[o] = Number(r[o]));
    let n = Un((t || []).concat(r || []).map((o) => typeof o));
    return O(n.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!"), n.length === 1 && O(n[0] === "string" || n[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!"), n.length === 2 && (O(n.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!"), O(n.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!")), pt(t) || (t = t.map((o) => {
      if (Me(o)) return O(e28.index.indexOf(o) > -1, `Row "${o}" does not exist!`), o;
      if (at(o)) return O(o >= 0, `Index ${o} is out of bounds!`), O(Math.floor(o) === o, "Row numbers must be integers!"), O(o < e28.index.length, `Index ${o} is out of bounds!`), e28.index[o];
    })), pt(r) || (r = r.map((o) => {
      if (Me(o)) return O(e28.columns.indexOf(o) > -1, `Column "${o}" does not exist!`), o;
      if (at(o)) return O(o >= 0, `Column ${o} is out of bounds!`), O(Math.floor(o) === o, "Column numbers must be integers!"), O(o < e28.columns.length, `Column ${o} is out of bounds!`), e28.columns[o];
    })), e28.getSubsetByNames(t, r);
  }
  function Btt(e28, t) {
    try {
      return e28 < t ? -1 : e28 > t ? 1 : 0;
    } catch {
      return e28 = typeof e28 == "object" && e28 !== null ? JSON.stringify(e28) : e28.toString(), t = typeof t == "object" && t !== null ? JSON.stringify(t) : t.toString(), e28 < t ? -1 : e28 > t ? 1 : 0;
    }
  }
  function zs(e28, t) {
    if (pt(t) && (t = Btt), ft(e28) || gt(e28)) return e28.sort(...Object.values(arguments).slice(1));
    O(tt(e28), "The `sort` function only works on arrays, Series, and DataFrames!"), O(yr(t), "The second parameter of the `sort` function must be a comparison function!");
    let r = e28.slice();
    return r.sort(t), r;
  }
  function Vtt(e28) {
    let t = e28.toLowerCase(), r = "";
    for (let o = 0; o < t.length; o++) {
      let s10 = t[o];
      s10.match(/[a-z0-9]/g) ? r += s10 : r += " ";
    }
    let n = r.split(" ").filter((o) => o.length > 0);
    return n[0] + n.slice(1).map((o) => o[0].toUpperCase() + o.substring(1)).join("");
  }
  function XM(e28, t, r) {
    pt(r) ? r = t.columns : Me(r) && (r = [r]);
    let n = {};
    r.forEach((s10) => {
      O(Me(s10), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      let i = t.columns.indexOf(s10);
      O(i > -1, `The given DataFrame does not have a column called "${s10}"!`);
      let a = t.values.map((l) => l[i]), u = zs(Un(a));
      a.forEach((l) => {
        u.forEach((c) => {
          let p = s10 + "_" + Vtt(c.toString());
          n[p] || (n[p] = []), l === c ? n[p].push(1) : n[p].push(0);
        });
      });
    });
    let o = new e28(n);
    return o.index = t.index, o;
  }
  function Gtt(e28, t, r) {
    let n = e28.shape;
    pt(t) && (t = ze(0, n[0])), pt(r) && (r = ze(0, n[1])), at(t) && (t = [t]), at(r) && (r = [r]), O(tt(t) && tt(r), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), O(Nt(t).length === 1 && Nt(r).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), O(t.length > 0, "The `rowIndices` array must contain at least one index."), O(r.length > 0, "The `colIndices` array must contain at least one index."), t.forEach((i) => {
      O(rf(i), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), O(i < e28.index.length, `The row index ${i} is out of bounds.`);
    }), r.forEach((i) => {
      O(rf(i), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), O(i < e28.columns.length, `The column index ${i} is out of bounds.`);
    });
    let o = t.map((i) => e28.index[i]), s10 = r.map((i) => e28.columns[i]);
    return e28.getSubsetByNames(o, s10);
  }
  function Wtt(e28, t, r, n, o) {
    pt(n) && (n = r.index), pt(o) && (o = r.columns), Me(n) && (n = [n]), Me(o) && (o = [o]), O(tt(n) && tt(o), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), O(Nt(n).length === 1 && Nt(o).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), O(n.length > 0, "The `rows` array must contain at least one row name."), O(o.length > 0, "The `cols` array must contain at least one column name."), n.forEach((a) => {
      O(Me(a), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), O(r.index.indexOf(a) > -1, `The row name "${a}" does not exist in the list of rows.`);
    }), o.forEach((a) => {
      O(Me(a), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), O(r.columns.indexOf(a) > -1, `The column name "${a}" does not exist in the list of columns.`);
    });
    let s10 = n.map((a) => o.map((u) => r.values[r.index.indexOf(a)][r.columns.indexOf(u)]));
    if (n.length === 1 && o.length === 1) return s10[0][0];
    if (n.length === 1) {
      let a = new t(s10[0]);
      return a.name = n[0], a.index = o, a;
    }
    if (o.length === 1) {
      let a = new t(s10.map((u) => u[0]));
      return a.name = o[0], a.index = n, a;
    }
    let i = new e28(s10);
    return i.columns = o, i.index = n, i;
  }
  function Utt(e28, t, r) {
    function n(m, f) {
      return Me(m) && m.length > f ? m.substring(0, f - 3) + "..." : m;
    }
    if (r.isEmpty) return console.table({}), console.log("Shape:", [0, 0], `
`), r;
    let o = typeof window > "u" ? 20 : 10, s10 = Math.floor(o / 2), i = typeof process > "u" ? 10 : Math.floor(process.stdout.columns / 24) - 1, a = Math.floor(i / 2), u = o > r.index.length ? null : ze(0, s10).concat(ze(r.index.length - s10, r.index.length)), l = i > r.columns.length ? null : ze(0, a).concat(ze(r.columns.length - a, r.columns.length)), c = r.get(u, l);
    c instanceof t && (r.shape[0] === 1 ? (c = new e28([c.values]), c.index = r.index, c.columns = new t(r.columns).get(l).values) : r.shape[1] === 1 && (c = new e28([c.values]).transpose(), c.index = new t(r.index).get(u).values, c.columns = r.columns)), o <= r.index.length && (c._index.splice(s10, 0, "..."), c._values.splice(s10, 0, ze(0, c.columns.length).map(() => "..."))), i <= r.columns.length && (c._columns.splice(a, 0, "..."), c._values = c._values.map((m) => (m.splice(a, 0, "..."), m)));
    let p = 28;
    return c instanceof t ? (c.values = c.values.map((m) => n(m, p)), c.name = n(c.name, p), c.index = c.index.map((m) => n(m, p))) : (c.values = c.values.map((m) => m.map((f) => n(f, p))), c.columns = c.columns.map((m) => n(m, p)), c.index = c.index.map((m) => n(m, p))), console.table(c.toDetailedObject()), console.log("Shape:", r.shape, `
`), r;
  }
  function Ym(e28, t) {
    O(at(e28), "The `leftPad` function only works on numbers!");
    let r = e28.toString();
    for (; r.length < t; ) r = "0" + r;
    return r;
  }
  function jtt(e28, t) {
    let r = t ? e28 : e28.copy();
    return r.index = ze(0, e28.shape[0]).map((n) => "row" + Ym(n, (r.index.length - 1).toString().length)), r;
  }
  function Rg(e28, t) {
    if (ft(e28) || gt(e28)) return Rg(e28.values, t);
    O(tt(e28), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (e28.length === 0) return NaN;
      let r = zr(e28), n = false, o = 1;
      for (let s10 of r) {
        if (!at(s10)) if (t) s10 = 1;
        else return NaN;
        typeof s10 == "bigint" && (n = true, s10 = Number(s10)), o *= s10;
      }
      if (n) try {
        return BigInt(o);
      } catch {
      }
      return o;
    } catch {
      return NaN;
    }
  }
  function Htt(e28) {
    return vz(e28) && e28 > 0;
  }
  function kg(e28, t) {
    if (ft(e28) || gt(e28)) return kg(e28.values, t);
    if (O(tt(e28), "The first argument passed into the `reshape` function must be an array!"), at(t) && (t = [t]), O(tt(t), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), O(Nt(t).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), t = t.map((s10) => (typeof s10 == "bigint" && (s10 = Number(s10)), O(Htt(s10), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), Number(s10))), t.length === 0) return zr(e28);
    let r = zr(e28);
    if (t.length === 1 && t[0] === r.length) return r;
    O(Rg(t) === r.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    let n = [], o = Math.floor(r.length / t[0]);
    for (let s10 = 0; s10 < t[0]; s10++) {
      let i = r.slice(s10 * o, (s10 + 1) * o);
      n.push(kg(i, t.slice(1)));
    }
    return n;
  }
  var Nz = Math.pow(2, 64);
  var er = [];
  Cz(Math.floor(Math.random() * Nz));
  function Ktt(e28, t) {
    e28 = gn(e28);
    function r() {
      e28 += gn("0x9e3779b97f4a7c15");
      let o = Mr(e28);
      return o = (o ^ o >> BigInt(30)) * gn("0xbf58476d1ce4e5b9"), o = (o ^ o >> BigInt(27)) * gn("0x94d049bb133111eb"), o ^ o >> BigInt(31);
    }
    let n = [];
    for (let o = 0; o < t; o++) n.push(r());
    return n;
  }
  function gn(e28) {
    return BigInt.asUintN(64, BigInt(e28));
  }
  function YM(e28, t) {
    return e28 = gn(e28), t = BigInt(t), gn(gn(e28 << t) | gn(e28 >> gn(BigInt(64) - t)));
  }
  function Cz(e28) {
    if (typeof e28 == "bigint" && (e28 = Number(e28)), pt(e28)) return Mr(er);
    {
      O(at(e28), "If passing a value into the `seed` function, then that value must be an integer!");
      let t = Ktt(Math.floor(e28), 4);
      er[0] = t[0], er[1] = t[1], er[2] = t[2], er[3] = t[3];
    }
  }
  function JM() {
    let e28 = gn(YM(er[0] + er[3], 23) + er[0]), t = gn(er[1] << BigInt(17));
    return er[2] = gn(er[2] ^ er[0]), er[3] = gn(er[3] ^ er[1]), er[1] = gn(er[1] ^ er[2]), er[0] = gn(er[0] ^ er[3]), er[2] = gn(er[2] ^ t), er[3] = YM(er[3], 45), Math.floor(Number(e28)) / Nz;
  }
  function da(e28) {
    return pt(e28) ? JM() : (tt(e28) || (e28 = [e28]), kg(io(Rg(e28)).map(JM), e28));
  }
  function nf(e28) {
    if (ft(e28) || gt(e28)) return e28.shuffle(...Object.values(arguments).slice(1));
    O(tt(e28), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    let t = [], r = e28.slice();
    for (let n = 0; n < e28.length; n++) {
      let o = Math.floor(da() * r.length);
      t.push(r.splice(o, 1)[0]);
    }
    return t;
  }
  function qtt(e28, t) {
    return pt(t) && (t = 0), O(t === 0 || t === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined."), e28.get(t === 0 ? nf(e28.index) : null, t === 1 ? nf(e28.columns) : null);
  }
  function Ls(e28) {
    return typeof e28 == "boolean";
  }
  function Xtt(e28, t, r) {
    return yr(t) ? Ytt(e28, t, r) : Jtt(e28, t, r);
  }
  function Ytt(e28, t, r) {
    if (r = pt(r) ? 0 : r, O(yr(t), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"), O(at(r), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."), r === 0) {
      let n = zs(e28.index, (o, s10) => t(e28.get(o, null), e28.get(s10, null)));
      return e28.get(n, null);
    } else {
      let n = zs(e28.columns, (o, s10) => t(e28.get(null, o), e28.get(null, s10)));
      return e28.get(null, n);
    }
  }
  function Jtt(e28, t, r) {
    let n = e28.copy(), o = da().toString();
    n = n.assign(o, n.index), pt(t) && (t = [o], r = [true]), (at(t) || Me(t)) && (t = [t], (Ls(r) || Me(r)) && (r = [r])), O(tt(t), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."), O(Nt(t).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."), pt(r) && (r = ze(0, t.length).map(() => true)), O(tt(r), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."), O(Nt(r).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."), O(t.length === r.length, "The arrays passed into the `sort` method must be equal in length."), t = t.map((i) => {
      if (O(Me(i) || at(i), "Column references can either be column names (as strings) or column indices (as whole numbers)."), Me(i)) {
        let a = n.columns.indexOf(i);
        return O(a > -1, `The column "${i}" does not exist!`), a;
      }
      if (at(i)) return O(rf(i), "Column indices must be whole numbers!"), O(i < n.columns.length, `The index ${i} is out of bounds!`), i;
    }), r = r.map((i) => {
      if (O(Me(i) || Ls(i), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."), Me(i)) {
        let a = i.trim().toLowerCase();
        return O(a === "ascending" || a === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."), a === "ascending";
      }
      if (Ls(i)) return i;
    }), n.values = zs(n.values, (i, a) => {
      let u = 0;
      for (; i[t[u]] === a[t[u]] && u < t.length; ) u++;
      let l = r[u];
      if (i[t[u]] === a[t[u]]) return 0;
      if (i[t[u]] < a[t[u]]) return l ? -1 : 1;
      if (i[t[u]] > a[t[u]]) return l ? 1 : -1;
    });
    let s10 = n.columns.indexOf(o);
    return n.index = n.values.map((i) => i[s10]), n = n.dropColumns(o), n;
  }
  function Ztt(e28, t) {
    pt(t) ? t = 0 : O(t === 0 || t === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    let r = {};
    return t === 0 ? e28.index.forEach((n, o) => {
      let s10 = {};
      e28.columns.forEach((i, a) => {
        s10[i] = e28.values[o][a];
      }), r[n] = s10;
    }) : e28.columns.forEach((n, o) => {
      let s10 = {};
      e28.index.forEach((i, a) => {
        s10[i] = e28.values[a][o];
      }), r[n] = s10;
    }), r;
  }
  function Sz(e28, t) {
    return JSON.stringify(e28.toObject(t));
  }
  async function Qtt(e28, t, r) {
    let n = Sz(e28, r), o = false, s10 = false, i, a;
    try {
      let u = t;
      if (t.includes("/")) {
        let c = t.split("/");
        u = c[c.length - 1];
      }
      let l = document.createElement("a");
      l.href = `data:application/json;charset=utf-8,${encodeURIComponent(n)}`, l.download = u, l.dispatchEvent(new MouseEvent("click")), o = true;
    } catch (u) {
      i = u;
    }
    try {
      let u = await import("node:fs"), l = await import("node:path");
      u.writeFileSync(l.resolve(t), n, "utf8"), s10 = true;
    } catch (u) {
      a = u;
    }
    if (!o && !s10) throw typeof window < "u" ? new ma(i) : typeof module < "u" ? new ma(a) : new ma("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
    return e28;
  }
  function tet(e28) {
    let t = {};
    return e28.columns.forEach((r) => {
      t[r] = e28.get(r).values;
    }), t;
  }
  function ao(e28) {
    if (ft(e28) || gt(e28)) return e28.transpose();
    O(tt(e28), "The `transpose` function only works on arrays, Series, and DataFrames!");
    let t = Nt(e28);
    if (O(t.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"), t.length === 1) return ss(e28);
    if (t.length === 2) {
      let r = io(ss(t));
      for (let n = 0; n < t[0]; n++) for (let o = 0; o < t[1]; o++) r[o][n] = e28[n][o];
      return r;
    }
  }
  function Iz(e28, t, r) {
    if (gt(r)) return new e28(t.values.concat(r.values));
    if (tt(r)) {
      let n = Nt(r);
      O(n.length === 1 && !iv(n), "Only vectors can be appended to Series!");
      let o = t.copy();
      return r.forEach((s10, i) => {
        o._values.push(s10), o._index.push("item" + (t.values.length + i));
      }), o;
    }
    return Iz(t, [r]);
  }
  function eet(e28, t) {
    O(yr(t), "The parameter to the `apply` method must be a function.");
    let r = e28.copy();
    return r._values = r._values.map((n, o) => t(n, o)), r;
  }
  function ret(e28) {
    let t = e28.copy(), r = [];
    return t._values = t.values.filter((n, o) => pt(n) ? false : (r.push(t.index[o]), true)), t._index = r, t;
  }
  function net(e28, t) {
    let r = [], n = [];
    t.values.forEach((s10, i) => {
      at(s10) && (n.push(s10), r.push(t.index[i]));
    });
    let o = new e28(n);
    return o.name = t.name, o.index = r, o;
  }
  function oet(e28, t, r) {
    let n = t.copy(), o = Mr(n.index), s10 = [], i = n.values.filter((a, u) => {
      let l = r(a, u, n.values);
      return l || s10.push(n.index[u]), l;
    });
    return s10.forEach((a) => {
      o.splice(o.indexOf(a), 1);
    }), i.length === 0 ? (n = new e28(), n.name = t.name, n) : (n.values = i, n.index = o, n);
  }
  function set3(e28, t) {
    (Me(t) || at(t)) && (t = [t]);
    for (let n in t) typeof t[n] == "bigint" && (t[n] = Number(t[n]));
    let r = Un((t || []).map((n) => typeof n));
    return O(r.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!"), r.length === 1 && O(r[0] === "string" || r[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!"), r.length === 2 && (O(r.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!"), O(r.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!")), pt(t) || (t = t.map((n) => {
      if (typeof n == "string") return O(e28.index.indexOf(n) > -1, `Index "${n}" does not exist!`), n;
      if (typeof n == "number") return O(n >= 0, `Index ${n} is out of bounds!`), O(Math.floor(n) === n, "Indices must be integers!"), O(n < e28.index.length, `Index ${n} is out of bounds!`), e28.index[n];
    })), e28.getSubsetByNames(t);
  }
  function iet(e28, t) {
    let r = e28.shape;
    pt(t) && (t = ze(0, r[0])), O(tt(t), "The `indices` array must be 1-dimensional array of whole numbers."), O(Nt(t).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers."), O(t.length > 0, "The `indices` array must contain at least one index."), t.forEach((o) => {
      O(rf(o), "The `indices` array must be a 1-dimensional array of whole numbers."), O(o < e28.index.length, `The row index ${o} is out of bounds.`);
    });
    let n = t.map((o) => e28.index[o]);
    return e28.getSubsetByNames(n);
  }
  function aet(e28, t, r) {
    pt(r) && (r = t.index), O(tt(r), "The `indices` array must be a 1-dimensional array of strings."), O(Nt(r).length === 1, "The `indices` array must be a 1-dimensional array of strings."), O(r.length > 0, "The `indices` array must contain at least one index name."), r.forEach((s10) => {
      O(Me(s10), "The `indices` array must contain only strings."), O(t.index.indexOf(s10) > -1, `The name "${s10}" does not exist in the index.`);
    });
    let n = r.map((s10) => t.values[t.index.indexOf(s10)]);
    if (n.length === 1) return n[0];
    let o = new e28(n);
    return o.index = r, o.name = t.name, o;
  }
  function uet(e28) {
    let t = e28.copy(), r = typeof window > "u" ? 20 : 10;
    if (t.index.length > r) {
      t = t.get(ze(0, r / 2).concat(ze(t.index.length - r / 2, t.index.length)));
      let o = Mr(t.index);
      o.splice(Math.floor(o.length / 2), 0, "..."), t.values.push("..."), t.index.push("..."), t = t.get(o);
    }
    let n = {};
    return t.values.forEach((o, s10) => {
      let i = {};
      i[t.name] = o, n[t.index[s10]] = i;
    }), console.table(n), console.log("Shape:", e28.shape, `
`), e28;
  }
  function cet(e28) {
    let t = e28.copy();
    return t.get(nf(t.index));
  }
  function pet(e28, t, r) {
    r = r || ((u, l) => u < l ? -1 : 1), O(pt(r) || yr(r), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    let n = ao([t.values, t.index]), o = zs(n, (u, l) => r(u[0], l[0])), s10 = [], i = [];
    o.forEach((u) => {
      s10.push(u[0]), i.push(u[1]);
    });
    let a = new e28();
    return a._values = s10, a._index = i, a.name = t.name, a;
  }
  function met(e28, t) {
    let r = ao([t.values, t.index]);
    r = ao(zs(r, (o, s10) => {
      if (o[1] === s10[1]) return 0;
      if (o[1] < s10[1]) return -1;
      if (o[1] > s10[1]) return 1;
    }));
    let n = new e28(r[0]);
    return n.index = r[1], n.name = t.name, n;
  }
  function fet(e28) {
    let t = {};
    return t[e28.name] = {}, e28.index.forEach((r, n) => {
      t[e28.name][r] = e28.values[n];
    }), t;
  }
  var ZM = Symbol.for("@jrc03c/js-math-tools/series");
  function het(e28) {
    class t {
      static [Symbol.hasInstance](n) {
        try {
          return !!n._symbol && n._symbol === ZM;
        } catch {
          return false;
        }
      }
      constructor(n) {
        if (this.name = "data", Object.defineProperty(this, "_symbol", { configurable: false, enumerable: false, writable: false, value: ZM }), Object.defineProperty(this, "_values", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "values", { configurable: true, enumerable: true, get() {
          return this._values;
        }, set(o) {
          O(tt(o), "The new values must be a 1-dimensional array!");
          let s10 = Nt(o);
          O(s10.length === 1, "The new array of values must be 1-dimensional!"), s10[0] < this._index.length ? this._index = this._index.slice(0, s10[0]) : s10[0] > this._index.length && (this._index = this._index.concat(ze(this._index.length, s10[0]).map((i) => "item" + Ym(i, (o.length - 1).toString().length)))), this._values = o;
        } }), Object.defineProperty(this, "_index", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "index", { configurable: true, enumerable: true, get() {
          return this._index;
        }, set(o) {
          O(tt(o), "The new index must be a 1-dimensional array of strings!"), O(o.length === this.shape[0], "The new index must be the same length as the old index!"), O(Nt(o).length === 1, "The new index must be a 1-dimensional array of strings!"), o.forEach((s10) => {
            O(Me(s10), "All of the row names must be strings!");
          }), this._index = o;
        } }), n) {
          if (n instanceof t) this.name = n.name, this.values = Mr(n.values), this.index = Mr(n.index);
          else if (tt(n)) {
            let o = Nt(n);
            O(o.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!"), this.values = n;
          } else if (n instanceof Object) {
            let o = Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map((a) => a.toString());
            O(o.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            let s10 = o[0], i = n[s10];
            O(Nt(i).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"), this.name = s10, this.values = i.slice();
          }
        }
      }
      get shape() {
        return Nt(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((n) => !pt(n)).length === 0;
      }
      clear() {
        let n = this.copy();
        return n.values.forEach((o, s10) => {
          n.values[s10] = void 0;
        }), n;
      }
      get(n) {
        return set3(this, n);
      }
      getSubsetByNames(n) {
        return aet(t, this, n);
      }
      getSubsetByIndices(n) {
        return iet(this, n);
      }
      loc(n) {
        return this.getSubsetByNames(n);
      }
      iloc(n) {
        return this.getSubsetByIndices(n);
      }
      reverse() {
        let n = new t(ss(this.values));
        return n.index = ss(this.index), n.name = this.name, n;
      }
      resetIndex() {
        let n = this.copy();
        return n.index = ze(0, this.shape[0]).map((o) => "item" + Ym(o, (n.index.length - 1).toString().length)), n;
      }
      copy() {
        let n = new t();
        return n._values = Mr(this.values), n._index = Mr(this.index), n.name = this.name, n;
      }
      append(n) {
        return Iz(t, this, n);
      }
      apply(n) {
        return eet(this, n);
      }
      concat(n) {
        return this.append(n);
      }
      dropMissing(n, o) {
        return ret(this, n, o);
      }
      dropNaN() {
        return net(t, this);
      }
      toObject() {
        return fet(this);
      }
      print() {
        return uet(this);
      }
      shuffle() {
        return cet(this);
      }
      sort(n) {
        return pet(t, this, n);
      }
      sortByIndex() {
        return met(t, this);
      }
      filter(n) {
        return oet(t, this, n);
      }
      toDataFrame() {
        let n = new e28(ao([this.values]));
        return n.columns = [this.name], n.index = this.index, n;
      }
      transpose() {
        let n = this.copy();
        return n.values = ss(n.values), n.index = ss(n.index), n;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return t;
  }
  var QM = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function Vw(e28) {
    let t = "abcdefghijklmnopqrstuvwxyz1234567890", r = "";
    for (let n = 0; n < e28; n++) r += t[Math.floor(da() * t.length)];
    return r;
  }
  var se = class {
    static [Symbol.hasInstance](e28) {
      try {
        return !!e28._symbol && e28._symbol === QM;
      } catch {
        return false;
      }
    }
    constructor(e28) {
      if (Object.defineProperty(this, "_symbol", { configurable: false, enumerable: false, writable: false, value: QM }), Object.defineProperty(this, "_values", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "values", { configurable: true, enumerable: true, get() {
        return this._values.length === 0 || !pt(this._values[0]) && this._values[0].length === 0 ? [[]] : this._values;
      }, set(t) {
        O(tt(t), "The new values must be a 2-dimensional array!");
        let r = Nt(t);
        O(r.length === 2, "The new array of values must be 2-dimensional!"), r[0] < this._index.length ? this._index = this._index.slice(0, r[0]) : r[0] > this._index.length && (this._index = this._index.concat(ze(this._index.length, r[0]).map((n) => "row" + Ym(n, (r[0] - 1).toString().length)))), r[1] < this._columns.length ? this._columns = this._columns.slice(0, r[1]) : r[1] > this._columns.length && (this._columns = this._columns.concat(ze(this._columns.length, r[1]).map((n) => "col" + Ym(n, (r[1] - 1).toString().length)))), this._values = t;
      } }), Object.defineProperty(this, "_columns", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "columns", { configurable: true, enumerable: true, get() {
        return this._columns;
      }, set(t) {
        O(tt(t), "The new columns list must be a 1-dimensional array of strings!"), O(this.isEmpty || t.length === this.shape[1], "The new columns list must be the same length as the old columns list!"), O(Nt(t).length === 1, "The new columns list must be a 1-dimensional array of strings!"), t = t.map((n) => (typeof n != "string" && (n = JSON.stringify(n) || n.toString()), n.trim().length === 0 ? "untitled_" + Vw(8) : n.trim()));
        let r = (() => {
          let n = ef(t), o = {};
          return n.values.forEach((s10) => {
            o[s10] = n.get(s10);
          }), o;
        })();
        t = t.map((n) => r[n] > 1 ? n + "_" + Vw(8) : n), this._columns = t;
      } }), Object.defineProperty(this, "_index", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "index", { configurable: true, enumerable: true, get() {
        return this._index;
      }, set(t) {
        O(tt(t), "The new index must be a 1-dimensional array of strings!"), O(this.isEmpty || t.length === this.shape[0], "The new index must be the same length as the old index!"), O(Nt(t).length === 1, "The new index must be a 1-dimensional array of strings!"), t = t.map((n) => (typeof n != "string" && (n = JSON.stringify(n) || n.toString()), n.trim().length === 0 ? "untitled_" + Vw(8) : n.trim()));
        let r = (() => {
          let n = ef(t), o = {};
          return n.values.forEach((s10) => {
            o[s10] = n.get(s10);
          }), o;
        })();
        t = t.map((n) => r[n] > 1 ? n + "_" + Vw(8) : n), this._index = t;
      } }), O(pt(e28) || Ms(e28) || tt(e28), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."), e28) if (e28 instanceof se) this.values = Mr(e28.values), this.columns = Mr(e28.columns), this.index = Mr(e28.index);
      else if (tt(e28)) {
        let t = Nt(e28);
        O(t.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"), O(!Ro(e28), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"), this.values = e28;
      } else {
        this._columns = Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).map((s10) => s10.toString());
        let t = [], r = null, n = null;
        this._columns.forEach((s10) => {
          pt(n) && (r = s10, n = e28[s10].length), O(e28[s10].length === n, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${r}" points to an array containing ${n} items, and the key "${s10}" points to an array containing ${e28[s10].length} items.`), n = e28[s10].length;
          let i = e28[s10];
          t.push(i);
        }), this._values = ao(t);
        let o = Nt(this.values);
        this._index = ze(0, o[0]).map((s10) => "row" + Ym(s10, (o[0] - 1).toString().length));
      }
    }
    get shape() {
      return Nt(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(e28) {
      this.index = e28;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((e28) => e28.length === 0);
    }
    clear() {
      let e28 = new se(io(this.shape));
      return e28.columns = this.columns.slice(), e28.index = this.index.slice(), e28;
    }
    get(e28, t) {
      if (arguments.length === 0) return this;
      if (arguments.length === 1) try {
        return this.get(null, e28);
      } catch {
        return this.get(e28, null);
      }
      return ztt(this, e28, t);
    }
    getSubsetByNames(e28, t) {
      return Wtt(se, qr, this, e28, t);
    }
    getSubsetByIndices(e28, t) {
      return Gtt(this, e28, t);
    }
    getDummies(e28) {
      return XM(se, this, e28);
    }
    oneHotEncode(e28) {
      return XM(se, this, e28);
    }
    transpose() {
      let e28 = new se(ao(this.values));
      return e28.columns = this.index.slice(), e28.index = this.columns.slice(), e28;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(e28) {
      return jtt(this, e28);
    }
    copy() {
      return Ott(se, this);
    }
    assign(e28, t) {
      return _tt(se, qr, this, e28, t);
    }
    apply(e28, t) {
      return Ftt(se, qr, this, e28, t);
    }
    dropMissing(e28, t, r) {
      return Ptt(se, qr, this, e28, t, r);
    }
    dropNaN(e28, t, r) {
      return Ltt(se, this, e28, t, r);
    }
    drop(e28, t) {
      return Rtt(se, qr, this, e28, t);
    }
    dropColumns(e28) {
      return this.drop(null, e28);
    }
    dropRows(e28) {
      return this.drop(e28, null);
    }
    toDetailedObject(e28) {
      return Ztt(this, e28);
    }
    toObject() {
      return tet(this);
    }
    toJSONString(e28) {
      return Sz(this, e28);
    }
    saveAsJSON(e28, t) {
      return Qtt(this, e28, t);
    }
    print() {
      return Utt(se, qr, this);
    }
    sort(e28, t) {
      return Xtt(this, e28, t);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(e28, t) {
      return Mtt(se, qr, this, e28, t);
    }
    shuffle(e28) {
      return qtt(this, e28);
    }
    append(e28, t) {
      return wz(this, e28, t);
    }
    concat(e28, t) {
      return this.append(e28, t);
    }
    join(e28, t) {
      return this.append(e28, t);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var qr = het(se);
  function Pg(e28, t) {
    return He(e28, { shouldDropNaNs: t }).max;
  }
  function Be(e28) {
    return O(yr(e28), "You must pass a function into the `vectorize` function!"), function t() {
      let r, n, o = [], s10 = [], i = Object.keys(arguments).filter((a) => {
        let u = arguments[a];
        return tt(u) ? true : gt(u) ? (r = true, o.push(u), true) : ft(u) ? (n = true, s10.push(u), true) : false;
      }).map((a) => arguments[a]);
      if (i.slice(0, -1).forEach((a, u) => {
        O(En(tt(a) ? Nt(a) : a.shape, tt(i[u + 1]) ? Nt(i[u + 1]) : i[u + 1].shape), `When passing multiple arrays into the \`${e28.name}\` function, all of the arrays must have the same shape!`);
      }), i.length > 0) {
        let a = Pg(i.map((l) => l.length ? l.length : l.values.length)), u = ze(0, a).map((l) => {
          let c = Object.keys(arguments).map((p) => tt(arguments[p]) ? arguments[p][l] : gt(arguments[p]) || ft(arguments[p]) ? arguments[p].values[l] : arguments[p]);
          return t(...c);
        });
        if (n) try {
          if (s10.length === 1 && En(Nt(s10[0]), Nt(u))) {
            let l = new se(u);
            return l.index = s10[0].index.slice(), l.columns = s10[0].columns.slice(), l;
          } else return new se(u);
        } catch {
          return u;
        }
        if (r) try {
          if (o.length === 1 && o[0].length === u.length) {
            let l = new qr(u);
            return l.name = o[0].name, l.index = o[0].index.slice(), l;
          } else return new qr(u);
        } catch {
          return u;
        }
        return u;
      } else return e28(...arguments);
    };
  }
  function det(e28) {
    try {
      return at(e28) ? typeof e28 == "bigint" ? e28 < 0 ? -e28 : e28 : Math.abs(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var ga = Be(det);
  function get() {
    try {
      let e28 = 0, t = false, r = Object.values(arguments);
      for (let n of r) {
        if (!at(n)) return NaN;
        typeof n == "bigint" && (t = true, n = Number(n)), e28 += n;
      }
      if (t) try {
        return BigInt(e28);
      } catch {
      }
      return e28;
    } catch {
      return NaN;
    }
  }
  var of = Be(get);
  function yet(e28, t) {
    try {
      return t(e28);
    } catch {
      return NaN;
    }
  }
  var pc = Be(yet);
  function xet(e28) {
    try {
      return at(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.acos(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var bet = Be(xet);
  function wet(e28) {
    try {
      return at(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.asin(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var vet = Be(wet);
  function Net(e28) {
    try {
      return at(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.atan(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var Cet = Be(Net);
  function Eg(e28, t) {
    if (ft(e28)) {
      let r = Eg(e28.values, t);
      return [e28.index[r[0]], e28.columns[r[1]]];
    }
    if (gt(e28)) {
      let r = Eg(e28.values, t);
      return e28.index[r];
    }
    O(tt(e28), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      let r = Qm(e28, Pg(e28, t));
      return r ? r.length === 0 ? void 0 : r.length === 1 ? r[0] : r : void 0;
    } catch {
      return;
    }
  }
  function Tz(e28, t) {
    return He(e28, { shouldDropNaNs: t }).min;
  }
  function sf(e28, t) {
    if (ft(e28)) {
      let r = sf(e28.values, t);
      return [e28.index[r[0]], e28.columns[r[1]]];
    }
    if (gt(e28)) {
      let r = sf(e28.values, t);
      return e28.index[r];
    }
    O(tt(e28), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      let r = Qm(e28, Tz(e28, t));
      return r ? r.length === 0 ? void 0 : r.length === 1 ? r[0] : r : void 0;
    } catch {
      return;
    }
  }
  function oo(e28, t) {
    if (ft(e28) || gt(e28)) return e28.apply((r) => oo(r, t));
    if (tt(e28)) return e28.map((r) => oo(r, t));
    if (t === "null") return null;
    if (t === "number") {
      if (pt(e28)) return NaN;
      let r = oo(e28, "boolean");
      if (Ls(r)) return r ? 1 : 0;
      try {
        JSON.parse(e28);
      } catch {
        let s10 = oo(e28, "date");
        if (fa(s10)) return s10.getTime();
      }
      let n = parseFloat(e28);
      return isNaN(n) ? NaN : n;
    }
    if (t === "int") {
      let r = oo(e28, "number");
      return r >= 0 ? Math.floor(r) : Math.ceil(r);
    }
    if (t === "float") return oo(e28, "number");
    if (t === "bigint") return typeof e28 == "bigint" ? e28 : BigInt(oo(e28, "int"));
    if (t === "boolean") {
      if (Ls(e28)) return e28;
      if (at(e28)) return e28 === 0 ? false : e28 === 1 ? true : null;
      try {
        let r = (typeof e28 == "object" ? e28.toString() === "null" ? "false" : JSON.stringify(e28) : e28.toString()).trim().toLowerCase();
        return r === "true" || r === "yes" || r === "y" ? true : r === "false" || r === "no" || r === "n" ? false : null;
      } catch {
        return null;
      }
    }
    if (t === "date") {
      if (fa(e28)) return e28;
      if (pt(e28)) return null;
      let r = parseFloat(e28);
      if (!isNaN(r)) {
        let o = new Date(e28);
        return fa(o) ? o : null;
      }
      let n = Date.parse(e28);
      return isNaN(n) ? null : new Date(n);
    }
    if (t === "object") {
      if (Ms(e28)) return e28;
      let r = oo(e28, "boolean");
      if (Ls(r)) return null;
      try {
        let o = oo(e28, "number");
        if (at(o)) return JSON.parse(e28), null;
      } catch {
      }
      let n = oo(e28, "date");
      if (n) return n;
      try {
        let o = JSON.parse(e28);
        return tt(o) ? o.map((s10) => oo(s10, t)) : o;
      } catch {
        return null;
      }
    }
    if (t === "string") return pt(e28) ? En(e28, void 0) ? "undefined" : "null" : e28 instanceof Date ? e28.toJSON() : typeof e28 == "object" ? e28 === null ? "null" : JSON.stringify(e28) : e28.toString();
  }
  function Iet(e28) {
    try {
      return at(e28) ? typeof e28 == "bigint" ? e28 : Math.ceil(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var Tet = Be(Iet);
  function ket(e28, t) {
    try {
      if (!at(e28)) return NaN;
      if (typeof e28 == "bigint") return e28;
      if (pt(t)) t = 1e-10;
      else if (!at(t)) return NaN;
      return ga(e28) < t ? 0 : e28;
    } catch {
      return NaN;
    }
  }
  var Eet = Be(ket);
  function PS(e28) {
    if (ft(e28) || gt(e28)) {
      let t = e28.copy();
      return t.values = PS(t.values), t;
    }
    if (tt(e28)) return e28.map((t) => PS(t));
    try {
      let t = JSON.parse(e28);
      return at(t) ? typeof t == "bigint" ? Number(t) : t >= 0 ? Math.floor(t) : Math.ceil(t) : NaN;
    } catch {
      return NaN;
    }
  }
  var us = Be(PS);
  function kz(e28, t, r) {
    try {
      return at(e28) ? at(t) ? at(r) ? typeof e28 == "bigint" ? BigInt(kz(us(e28), t, r)) : e28 < t ? t : e28 > r ? r : e28 : NaN : NaN : NaN;
    } catch {
      return NaN;
    }
  }
  var av = Be(kz);
  function Jw(e28, t) {
    function* r(n, o) {
      if (o > n.length) yield n;
      else if (o <= 0) yield [];
      else if (n.length < 2) yield n;
      else for (let s10 = 0; s10 < n.length; s10++) {
        let i = n[s10], a = n.slice(s10 + 1);
        if (!(a.length < o - 1) && o - 1 >= 0) for (let u of Jw(a, o - 1)) yield [i].concat(u);
      }
    }
    return ft(e28) || gt(e28) ? Jw(e28.values, t) : (O(tt(e28), "The `combinations` function only works on arrays, Series, and DataFrames!"), O(at(t) && us(t) === t && t >= 0, "`r` must be a non-negative integer!"), r(zr(e28), t));
  }
  function Ez(e28, t) {
    let r = [];
    for (let n of Jw(e28, t)) r.push(n.slice());
    return r;
  }
  function oI() {
    let e28 = Object.values(arguments).map((r) => ft(r) || gt(r) ? Un(r.values) : (O(tt(r), "The `intersect` function only works on arrays, Series, and DataFrames!"), Un(r)));
    return Un(e28).filter((r) => e28.every((n) => n.findIndex((o) => En(o, r)) > -1));
  }
  var xg = class {
    constructor(e28) {
      O(pt(e28) || e28 === xg.DROP_NAN_MODE || e28 === xg.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"), this.mode = pt(e28) ? xg.DROP_NAN_MODE : e28, this.index = null;
    }
    fit() {
      let e28 = [];
      return Object.values(arguments).forEach((t) => {
        if (tt(t)) {
          let r = Nt(t);
          if (r.length === 1) t = new qr(t);
          else if (r.length === 2) t = new se(t);
          else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        }
        O(ft(t) || gt(t), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"), this.mode === xg.DROP_MISSING_MODE ? e28.push(t.dropMissing().index) : e28.push(t.dropNaN().index);
      }), this.index = oI(...e28), this;
    }
    transform() {
      O(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      let e28 = Object.values(arguments).map((t) => {
        if (tt(t)) {
          let r = Nt(t);
          if (r.length === 1) return new qr(t).get(this.index).values;
          if (r.length === 2) return new se(t).get(this.index, null).values;
          throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        }
        return O(ft(t) || gt(t), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"), t.get(this.index, null);
      });
      return e28.length === 1 ? e28[0] : e28;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var Lg = xg;
  yz(Lg, "DROP_NAN_MODE", "DROP_NAN_MODE");
  yz(Lg, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function Cg(e28, t, r, n) {
    if (gt(e28)) return Cg(e28.values, t, r, n);
    if (gt(t)) return Cg(e28, t.values, r, n);
    if (O(tt(e28) && tt(t) && Nt(e28).length === 1 && Nt(t).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!"), O(e28.length === t.length, "The two arrays or Series passed into the `covariance` function must have the same length!"), r) return Cg(...new Lg().fitAndTransform(e28, t), false, n);
    try {
      let o = He(e28, { stdev: n }), s10 = He(t, { stdev: n }), i = Number(o.mean), a = Number(s10.mean);
      if (!at(i) || !at(a)) return NaN;
      let u = Math.max(e28.length, t.length), l = 0;
      for (let c = 0; c < u; c++) {
        let p = e28[c], m = t[c];
        if (!at(p)) return NaN;
        if (!at(m)) return NaN;
        typeof p == "bigint" && (p = Number(p)), typeof m == "bigint" && (m = Number(m)), l += (p - i) * (m - a);
      }
      return n ? [l / e28.length, o, s10] : l / e28.length;
    } catch {
      return NaN;
    }
  }
  function Hu(e28, t, r) {
    if (gt(e28)) return Hu(e28.values, t, r);
    if (gt(t)) return Hu(e28, t.values, r);
    O(tt(e28) && tt(t) && Nt(e28).length === 1 && Nt(t).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!"), O(e28.length === t.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      let [o, s10, i] = Cg(e28, t, r, true), a = s10.stdev * i.stdev;
      return o / a;
    } catch {
      return NaN;
    }
  }
  function Aet(e28) {
    try {
      return at(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.cos(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var Det = Be(Aet);
  var $et = Object.freeze({ boolean: "boolean", date: "date", null: "null", number: "number", object: "object", string: "string" });
  function LS(e28, t) {
    if (ft(e28) || gt(e28)) return LS(e28.values, t);
    if (ft(t) || gt(t)) return LS(e28, t.values);
    O(tt(e28) && tt(t), "The `diff` function only works on arrays, Series, and DataFrames!");
    let r = Un(e28), n = Un(t), o = [];
    return r.forEach((s10) => {
      n.findIndex((i) => En(i, s10)) < 0 && o.push(s10);
    }), o;
  }
  function Az(e28, t) {
    try {
      if (!at(e28)) return NaN;
      if (!at(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = Az(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return Math.pow(e28, t);
    } catch {
      return NaN;
    }
  }
  var Ku = Be(Az);
  function Dz(e28) {
    try {
      if (!at(e28)) return NaN;
      if (typeof e28 == "bigint") {
        let t = Dz(Number(e28));
        try {
          return BigInt(t);
        } catch {
          return t;
        }
      }
      return Math.sqrt(e28);
    } catch {
      return NaN;
    }
  }
  var Mg = Be(Dz);
  function Fet() {
    try {
      let e28 = Object.values(arguments);
      if (e28.length === 0) return NaN;
      let t = false, r = 1;
      for (let n of e28) {
        if (!at(n)) return NaN;
        typeof n == "bigint" && (t = true, n = Number(n)), r *= n;
      }
      if (t) try {
        return BigInt(r);
      } catch {
      }
      return r;
    } catch {
      return NaN;
    }
  }
  var $z = Be(Fet);
  function qu() {
    return $z(...arguments);
  }
  function Xu(e28, t) {
    return of(e28, qu(t, -1));
  }
  function ya(e28, t) {
    return He(e28, { shouldDropNaNs: t }).sum;
  }
  function MS(e28, t) {
    if (at(e28) && at(t)) return ga(e28 - t);
    if (ft(e28) || gt(e28)) return MS(e28.values, t);
    if (ft(t) || gt(t)) return MS(e28, t.values);
    tt(e28) && tt(t) && O(En(Nt(e28), Nt(t)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    try {
      return Mg(ya(Ku(Xu(e28, t), 2)));
    } catch {
      return NaN;
    }
  }
  function zg(e28, t) {
    return qu(e28, Ku(t, -1));
  }
  function os(e28, t) {
    if (ft(e28)) {
      let o = os(e28.values, t);
      if (Nt(o).length === 1) {
        let s10 = new qr(o);
        return s10.name = gt(t) ? t.name : s10.name, s10.index = e28.index.slice(), s10;
      } else {
        let s10 = new se(o);
        return s10.index = e28.index.slice(), ft(t) && (s10.columns = t.columns.slice()), s10;
      }
    }
    if (ft(t)) {
      let o = os(e28, t.values);
      if (Nt(o).length === 1) {
        let s10 = new qr(o);
        return s10.name = gt(e28) ? e28.name : s10.name, s10.index = t.columns.slice(), s10;
      } else {
        let s10 = new se(o);
        return s10.columns = t.columns.slice(), s10;
      }
    }
    if (gt(e28)) return os(e28.values, t);
    if (gt(t)) return os(e28, t.values);
    O(tt(e28) && tt(t), "The `dot` function only works on arrays, Series, and DataFrames!");
    let r = Nt(e28), n = Nt(t);
    if (O(r.length <= 2 && n.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"), O(r[r.length - 1] === n[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${r[r.length - 1]} !== ${n[0]})`), r.length === 1 && n.length === 1) return ya(qu(e28, t));
    if (r.length === 1 && n.length === 2) return ao(t).map((o) => os(e28, o));
    if (r.length === 2 && n.length === 1) return e28.map((o) => os(o, t));
    if (r.length === 2 && n.length === 2) {
      let o = ao(t), s10 = [];
      for (let i = 0; i < e28.length; i++) {
        let a = [];
        for (let u = 0; u < o.length; u++) a.push(os(e28[i], o[u]));
        s10.push(a);
      }
      return s10;
    }
  }
  function sI(e28) {
    if (ft(e28) || gt(e28)) return e28.dropMissing(...Object.values(arguments).slice(1));
    O(tt(e28), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    let t = [];
    return e28.forEach((r) => {
      try {
        return t.push(sI(r));
      } catch {
        pt(r) || t.push(r);
      }
    }), t;
  }
  function jw(e28, t) {
    if (ft(e28) || gt(e28)) return jw(e28.values, t);
    if (ft(t) || gt(t)) return jw(e28, t.values);
    O(tt(e28) && tt(t), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"), O(En(Nt(e28), Nt(t)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    let r = [], n = [];
    for (let o = 0; o < e28.length; o++) try {
      let [s10, i] = jw(e28[o], t[o]);
      r.push(s10), n.push(i);
    } catch {
      !pt(e28[o]) && !pt(t[o]) && (r.push(e28[o]), n.push(t[o]));
    }
    return [r, n];
  }
  function Uu(e28, t) {
    if (ft(e28) || gt(e28)) return Uu(e28.values, t);
    if (ft(t) || gt(t)) return Uu(e28, t.values);
    O(tt(e28) && tt(t), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"), O(En(Nt(e28), Nt(t)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    let r = [], n = [];
    for (let o = 0; o < e28.length; o++) try {
      let [s10, i] = Uu(e28[o], t[o]);
      r.push(s10), n.push(i);
    } catch {
      at(e28[o]) && at(t[o]) && (r.push(e28[o]), n.push(t[o]));
    }
    return [r, n];
  }
  function _et(e28) {
    return sI(e28);
  }
  function Zw(e28, t) {
    if (ft(e28) || gt(e28)) return Zw(e28.values, t);
    O(tt(e28), "The first argument passed into the `every` function must be an array, Series, or DataFrame!"), O(yr(t), "The second argument passed into the `every` function must be a function!");
    for (let r of e28) if (tt(r)) {
      if (!Zw(r, t)) return false;
    } else if (!t(r)) return false;
    return true;
  }
  function Oet(e28) {
    try {
      if (!at(e28)) return NaN;
      if (typeof e28 == "bigint") {
        if (e28 === 0n) return 1n;
        e28 = Number(e28);
      }
      return Math.exp(e28);
    } catch {
      return NaN;
    }
  }
  var Ret = Be(Oet);
  function zS(e28) {
    try {
      return typeof e28 == "bigint" ? BigInt(zS(us(e28))) : e28 !== us(e28) ? NaN : e28 <= 1 ? 1 : e28 * zS(e28 - 1);
    } catch {
      return NaN;
    }
  }
  var Pet = Be(zS);
  function BS(e28, t) {
    if (ft(e28) || gt(e28)) return BS(e28.values, t);
    if (O(Ms(e28) || tt(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"), !yr(t)) {
      let o = t;
      t = (s10) => s10 === o;
    }
    function r(o, s10, i) {
      if (i = i || [], i.indexOf(o) > -1) return null;
      if (Ms(o)) {
        i.push(o);
        let a = Object.keys(o).concat(Object.getOwnPropertySymbols(o));
        for (let u = 0; u < a.length; u++) {
          let l = a[u], c = o[l];
          if (s10(c)) return c;
          let p = r(c, s10, i);
          if (p) return p;
        }
      } else if (tt(o)) {
        i.push(o);
        for (let a = 0; a < o.length; a++) {
          let u = o[a];
          if (s10(u)) return u;
          let l = r(u, s10, i);
          if (l) return l;
        }
      } else if (s10(o)) return o;
      return null;
    }
    function n(o) {
      try {
        return t(o);
      } catch {
        return false;
      }
    }
    return r(e28, n);
  }
  function VS(e28, t) {
    if (ft(e28) || gt(e28)) return VS(e28.values, t);
    if (O(Ms(e28) || tt(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"), !yr(t)) {
      let s10 = t;
      t = (i) => i === s10;
    }
    function r(s10, i, a) {
      if (a = a || [], a.indexOf(s10) > -1) return null;
      if (Ms(s10)) {
        a.push(s10);
        let u = Object.keys(s10).concat(Object.getOwnPropertySymbols(s10)), l = [];
        for (let c = 0; c < u.length; c++) {
          let p = u[c], m = s10[p], f = false;
          i(m) && (l.push(m), f = true);
          let h = r(m, i, a);
          h && h.length > 0 && h.slice(f ? 1 : 0).forEach((d) => l.push(d));
        }
        return l;
      } else if (tt(s10)) {
        a.push(s10);
        let u = [];
        for (let l = 0; l < s10.length; l++) {
          let c = s10[l], p = false;
          i(c) && (u.push(c), p = true);
          let m = r(c, i, a);
          m && m.length > 0 && m.slice(p ? 1 : 0).forEach((f) => u.push(f));
        }
        return u;
      } else if (i(s10)) return [s10];
      return null;
    }
    function n(s10) {
      try {
        return t(s10);
      } catch {
        return false;
      }
    }
    let o = r(e28, n);
    return o && o.length > 0 ? o : null;
  }
  function Let(e28) {
    try {
      if (e28 === "Infinity") return 1 / 0;
      if (e28 === "-Infinity") return -1 / 0;
      let t = JSON.parse(e28);
      return at(t) ? t : NaN;
    } catch {
      return NaN;
    }
  }
  var Met = Be(Let);
  function zet(e28) {
    try {
      return at(e28) ? typeof e28 == "bigint" ? e28 : Math.floor(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var Bet = Be(zet);
  function af(e28) {
    at(e28) && (e28 = [e28]);
    let t = [], r = Rg(e28);
    for (let n = 0; n < r; n++) t.push(0);
    return kg(t, e28);
  }
  function Vet(e28) {
    typeof e28 == "bigint" && (e28 = us(e28)), O(!pt(e28), "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), O(at(e28), "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), O(us(e28) === e28, "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), O(e28 > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    let t = af([e28, e28]);
    for (let r = 0; r < e28; r++) t[r][r] = 1;
    return t;
  }
  var Get = ["true", "false", "yes", "no"];
  var Wet = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function Gw(e28) {
    return e28.type === "number" && (typeof e28.value < "u" ? e28.isInteger = us(e28.value) === e28.value : e28.isInteger = Zw(e28.values, (t) => at(t) ? us(t) === t : true)), e28;
  }
  function Sg(e28) {
    if (ft(e28)) {
      let s10 = e28.copy(), i = Sg(e28.values);
      return s10.values = i.values, Gw({ type: i.type, values: s10 });
    }
    if (gt(e28)) {
      let s10 = e28.copy(), i = Sg(e28.values);
      return s10.values = i.values, Gw({ type: i.type, values: s10 });
    }
    if (!tt(e28)) {
      let s10 = Sg([e28]);
      return s10.value = s10.values[0], delete s10.values, Gw(s10);
    }
    O(tt(e28), "The `inferType` function only works on arrays, Series, and DataFrames!");
    let t = zr(e28).map((s10) => {
      if (s10 === void 0) return "null";
      try {
        if (typeof s10 == "object") {
          let u = new Date(s10.getTime());
          if (fa(u)) return "date";
        }
      } catch {
      }
      Me(s10) || (typeof s10 == "bigint" ? s10 = s10.toString() + "n" : s10 = JSON.stringify(s10));
      let a = s10.toLowerCase().trim();
      if (Wet.indexOf(a) > -1) return "null";
      if (Get.indexOf(a) > -1) return "boolean";
      try {
        if (s10.match(/^-?\d+n$/g)) return "bigint";
        let u = JSON.parse(s10);
        return at(u) ? "number" : typeof u == "object" ? tt(u) ? "string" : "object" : "string";
      } catch {
        let l = new Date(s10);
        return fa(l) ? "date" : "string";
      }
    }), r = ef(t), o = r.values.toSorted((s10, i) => r.get(i) - r.get(s10))[0];
    return Gw({ type: o, values: pc(e28, (s10) => oo(s10, o)) });
  }
  function Hw(e28) {
    if (ft(e28)) {
      let r = e28.copy();
      return r.values = Hw(r.values), r;
    }
    O(tt(e28), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    let t = Nt(e28);
    if (O(t.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!"), O(t[0] === t[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!"), O(t[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!"), t[0] === 0) return e28;
    if (t[0] === 1) {
      O(e28[0][0] !== 0, "This matrix cannot be inverted!");
      let r = e28[0][0];
      return typeof r == "bigint" && (r = Number(r)), 1 / r;
    } else if (t[0] === 2) {
      let r = e28[0][0], n = e28[0][1], o = e28[1][0], s10 = e28[1][1];
      typeof r == "bigint" && (r = Number(r)), typeof n == "bigint" && (n = Number(n)), typeof o == "bigint" && (o = Number(o)), typeof s10 == "bigint" && (s10 = Number(s10));
      let i = r * s10 - n * o;
      O(i !== 0, "This matrix cannot be inverted!");
      let a = [[s10, -n], [-o, r]];
      return qu(a, 1 / i);
    } else if (t[0] > 1) {
      let r = (n, o) => at(n) || at(o) ? qu(n, o) : os(n, o);
      for (let n = 1; n < t[0] - 1; n++) try {
        let o = e28.slice(0, n).map((d) => d.slice(0, n)), s10 = e28.slice(0, n).map((d) => d.slice(n, t[0])), i = e28.slice(n, t[0]).map((d) => d.slice(0, n)), a = e28.slice(n, t[0]).map((d) => d.slice(n, t[0])), u = Hw(o), l = Hw(of(a, r(-1, r(r(i, u), s10)))), c = of(u, r(r(r(r(u, s10), l), i), u)), p = r(-1, r(r(u, s10), l)), m = r(-1, r(r(l, i), u)), f = l;
        return c.map((d, g) => d.concat(p[g])).concat(m.map((d, g) => d.concat(f[g])));
      } catch {
      }
      O(false, "This matrix cannot be inverted!");
    }
  }
  var Uet = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function Fz(e28, t, r) {
    try {
      if (!at(e28)) return NaN;
      if (!at(t)) return NaN;
      if (!at(r)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let n = Fz(Number(e28), Number(t), r);
        try {
          return BigInt(n);
        } catch {
          return n;
        }
      }
      return r * (t - e28) + e28;
    } catch {
      return NaN;
    }
  }
  var jet = Be(Fz);
  function _z(e28, t) {
    try {
      if (t = pt(t) ? Math.E : t, !at(e28)) return NaN;
      if (!at(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = _z(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return Math.log(e28) / Math.log(t);
    } catch {
      return NaN;
    }
  }
  var Oz = Be(_z);
  function Rz(e28, t) {
    return He(e28, { shouldDropNaNs: t }).mean;
  }
  function Het(e28, t) {
    return He(e28, { shouldDropNaNs: t, median: true }).median;
  }
  function Pz(e28, t) {
    try {
      if (!at(e28)) return NaN;
      if (!at(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = Pz(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return e28 % t;
    } catch {
      return NaN;
    }
  }
  var Ket = Be(Pz);
  function qet(e28, t) {
    return He(e28, { shouldDropNaNs: t, mode: true }).mode;
  }
  function tz() {
    let e28 = da(), t = da();
    return Math.sqrt(-2 * Math.log(e28)) * Math.cos(2 * Math.PI * t);
  }
  function Lz(e28) {
    return pt(e28) ? tz() : pc(io(e28), tz);
  }
  function Xet(e28) {
    return pc(io(e28), () => 1);
  }
  function iI(e28, t) {
    function* r(n, o) {
      if (o = o || n.length, n.length === 1) {
        yield [n];
        return;
      }
      for (let s10 of Ez(n, o)) {
        if (!s10.slice) continue;
        let i = af(s10.length);
        yield s10;
        let a = 1;
        for (; a < s10.length; ) if (i[a] < a) {
          if (a % 2 === 0) {
            let u = s10[0];
            s10[0] = s10[a], s10[a] = u;
          } else {
            let u = s10[i[a]];
            s10[i[a]] = s10[a], s10[a] = u;
          }
          yield s10, i[a] += 1, a = 1;
        } else i[a] = 0, a += 1;
      }
    }
    return ft(e28) || gt(e28) ? iI(e28.values, t) : (O(tt(e28), "The `permutations` function only works on arrays, Series, and DataFrames!"), pt(t) && (t = e28.length), O(at(t) && us(t) === t && t >= 0, "`r` must be a non-negative integer!"), r(zr(e28), t));
  }
  function Yet(e28, t) {
    let r = [];
    for (let n of iI(e28, t)) r.push(n.slice());
    return r;
  }
  function Jet() {
    Object.keys(arguments).forEach((e28) => {
      let t = arguments[e28];
      if (tt(t)) if (Ro(t)) console.log(t);
      else {
        let r = Nt(t);
        r.length === 1 ? new qr(t).print() : r.length == 2 ? new se(t).print() : console.log(t);
      }
      else ft(t) || gt(t) ? t.print() : console.log(t);
    });
  }
  var Zet = Be((e28, t, r, n, o) => {
    try {
      let s10 = false;
      for (let l of [e28, t, r, n, o]) {
        if (!at(l)) return NaN;
        typeof l == "bigint" && (s10 = true);
      }
      s10 && (e28 = Number(e28), t = Number(t), r = Number(r), n = Number(n), o = Number(o));
      let i = (o - n) * (e28 - t), a = r - t;
      if (a === 0) return NaN;
      let u = i / a + n;
      if (s10) try {
        return BigInt(u);
      } catch {
      }
      return u;
    } catch {
      return NaN;
    }
  });
  function Mz(e28, t, r, n, o) {
    if (tt(e28) && pt(n) && pt(o)) {
      n = t, o = r;
      let s10 = He(e28);
      t = s10.min, r = s10.max;
    }
    return Zet(e28, t, r, n, o);
  }
  function Qet(e28) {
    try {
      return at(e28) ? typeof e28 == "bigint" ? e28 : Math.round(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var zz = Be(Qet);
  function Bz(e28) {
    try {
      return at(e28) ? typeof e28 == "bigint" ? BigInt(Bz(Number(e28))) : e28 < 0 ? -1 : e28 > 0 ? 1 : 0 : NaN;
    } catch {
      return NaN;
    }
  }
  var Vz = Be(Bz);
  function trt(e28) {
    try {
      return at(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.sin(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var ert = Be(trt);
  function GS(e28, t) {
    if (ft(e28) || gt(e28)) return GS(e28.values, t);
    O(tt(e28), "The first argument passed into the `some` function must be an array, Series, or DataFrame!"), O(yr(t), "The second argument passed into the `some` function must be a function!");
    for (let r of e28) if (tt(r)) {
      if (GS(r, t)) return true;
    } else if (t(r)) return true;
    return false;
  }
  function Gz(e28, t) {
    return He(e28, { shouldDropNaNs: t, stdev: true }).stdev;
  }
  function rrt(e28) {
    return Gz(e28);
  }
  function nrt(e28) {
    try {
      return at(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.tan(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var ort = Be(nrt);
  function ez(e28, t) {
    O(yr(e28), "`fn` must be a function!");
    let r = /* @__PURE__ */ new Date();
    return t ? e28(...t) : e28(), /* @__PURE__ */ new Date() - r;
  }
  async function srt(e28, t) {
    O(yr(e28), "`fn` must be a function!");
    let r = /* @__PURE__ */ new Date();
    return t ? await e28(...t) : await e28(), /* @__PURE__ */ new Date() - r;
  }
  function irt() {
    return Un([...arguments].map((e28) => tt(e28) ? e28 : ft(e28) || gt(e28) ? e28.values : [e28]));
  }
  function art(e28, t) {
    return He(e28, { shouldDropNaNs: t, variance: true }).variance;
  }
  function urt() {
    let e28 = [], t = Object.values(arguments).map((r) => ((ft(r) || gt(r)) && (r = r.values), O(tt(r), "The `zip` function only works on arrays, Series, and DataFrames!"), r));
    return ze(0, Pg(t.map((r) => r.length))).forEach((r) => {
      let n = [];
      t.forEach((o) => {
        let s10 = o[r];
        n.push(pt(s10) ? void 0 : s10);
      }), e28.push(n);
    }), e28;
  }
  var bg = { abs: ga, add: of, apply: pc, arccos: bet, arcsin: vet, arctan: Cet, argmax: Eg, argmin: sf, assert: O, cast: oo, ceil: Tet, chop: Eet, clamp: av, combinations: Ez, combinationsIterator: Jw, copy: Mr, correl: Hu, cos: Det, count: ef, covariance: Cg, DataFrame: se, dataTypes: $et, decycle: tf, diff: LS, distance: MS, divide: zg, dot: os, dropMissing: sI, dropMissingPairwise: jw, dropNaN: Og, dropNaNPairwise: Uu, dropUndefined: _et, every: Zw, exp: Ret, factorial: Pet, find: BS, findAll: VS, flatten: zr, float: Met, floor: Bet, identity: Vet, IndexMatcher: Lg, indexOf: Qm, inferType: Sg, int: us, intersect: oI, inverse: Hw, isArray: tt, isBoolean: Ls, isBrowser: Uet, isDataFrame: ft, isDate: fa, isEqual: En, isFunction: yr, isJagged: Ro, isNested: iv, isNumber: at, isObject: Ms, isSeries: gt, isString: Me, isUndefined: pt, lerp: jet, log: Oz, MathError: ma, max: Pg, mean: Rz, median: Het, min: Tz, mod: Ket, mode: qet, multiply: $z, ndarray: io, normal: Lz, ones: Xet, permutations: Yet, permutationsIterator: iI, pow: Ku, print: Jet, product: Rg, random: da, range: ze, remap: Mz, reshape: kg, reverse: ss, round: zz, scale: qu, seed: Cz, Series: qr, set: Un, shape: Nt, shuffle: nf, sign: Vz, sin: ert, some: GS, sort: zs, sqrt: Mg, stats: He, std: Gz, stdev: rrt, subtract: Xu, sum: ya, tan: ort, timeAsync: srt, timeSync: ez, time: ez, transpose: ao, union: irt, variance: art, vectorize: Be, zeros: af, zip: urt, dump() {
    let e28 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : void 0;
    if (!e28) throw new bg.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
    Object.keys(bg).forEach((t) => {
      try {
        Object.defineProperty(e28, t, { configurable: false, enumerable: true, writable: false, value: bg[t] });
      } catch {
        e28[t] = bg[t];
      }
    });
  } };
  typeof window < "u" && (window.JSMathTools = bg);
  function WS(e28, t, r) {
    if (gt(e28)) return WS(e28.values, t);
    if (gt(t)) return WS(e28, t.values);
    if (O(tt(e28) && tt(t) && Nt(e28).length === 1 && Nt(t).length === 1, "The `cohensd` function only works on 1-dimensional arrays and Series!"), O(e28.length === t.length, "Two arrays or Series passed into the `cohensd` function must have the same length!"), r) {
      let n = new Lg().fitAndTransform(e28, t);
      e28 = n[0], t = n[1];
    }
    try {
      let n = He(e28, { variance: true }), o = He(t, { variance: true }), s10 = n.mean, i = o.mean;
      return (s10 - i) / Math.sqrt((n.variance + o.variance) / 2);
    } catch {
      return NaN;
    }
  }
  function rz(e28) {
    return typeof e28 == "bigint" ? e28.toString() + "n" : e28;
  }
  function aI() {
    if (arguments.length === 1 && gt(arguments[0])) {
      let { name: o, values: s10 } = arguments[0], i = aI(o, s10), a = new se(i);
      return a.index = arguments[0].index.slice(), a;
    }
    let [e28, t] = arguments;
    O(Me(e28), "When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"), O(tt(t) && Nt(t).length === 1, "When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");
    let r = {};
    return zs(Un(t)).filter((o) => typeof o != "number" || o.toString() !== "NaN").filter((o) => !pt(o)).map((o) => e28 + "_" + rz(o)).slice(0, -1).forEach((o) => {
      r[o] = t.map((s10) => o === e28 + "_" + rz(s10) ? 1 : typeof s10 == "number" && s10.toString() === "NaN" ? NaN : pt(s10) ? NaN : 0);
    }), r;
  }
  function ha(e28) {
    return at(e28) && e28 >= 0 && Math.floor(e28) === e28 && e28 < 1 / 0;
  }
  function Wz(e28) {
    if (typeof e28 != "string") throw new Error("`text` must be a string!");
    e28 = e28.trim();
    let t = "", r = false;
    for (let n = 0; n < e28.length; n++) {
      let o = e28[n];
      o.match(/[A-Za-z0-9]/g) ? (t.length === 0 ? t += o.toLowerCase() : r ? t += o.toUpperCase() : t += o, r = false) : !o.includes("'") && !o.includes("\u2019") && !o.includes("\u275C") && (r = true);
    }
    return t;
  }
  var lrt = Object.defineProperty;
  var crt = (e28, t, r) => t in e28 ? lrt(e28, t, { enumerable: true, configurable: true, writable: true, value: r }) : e28[t] = r;
  var Uz = (e28, t, r) => (crt(e28, typeof t != "symbol" ? t + "" : t, r), r);
  function bt(e28) {
    return typeof e28 == "number" && !isNaN(e28) || typeof e28 == "bigint";
  }
  var prt = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var ju = class extends Error {
    constructor(e28) {
      prt() ? super(e28) : super(`

\x1B[31m` + e28 + `
\x1B[0m`);
    }
  };
  function V(e28, t) {
    if (!e28) throw new ju(t);
  }
  var jz = [Array, ArrayBuffer, BigInt64Array, BigUint64Array, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray];
  function Ot(e28) {
    return e28 === null || typeof e28 > "u";
  }
  var mrt = jz.map((e28) => e28.name);
  function nt(e28) {
    try {
      return e28 instanceof Array ? true : Ot(e28.constructor) ? false : jz.indexOf(e28.constructor) > -1 || mrt.indexOf(e28.constructor.name) > -1;
    } catch {
      return false;
    }
  }
  function Kt(e28) {
    try {
      return !!e28._symbol && e28._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch {
      return false;
    }
  }
  function Br(e28) {
    return typeof e28 == "function";
  }
  function Bs(e28) {
    return typeof e28 == "object" && !Ot(e28) && !nt(e28);
  }
  function Bt(e28) {
    try {
      return !!e28._symbol && e28._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch {
      return false;
    }
  }
  function uf(e28, t) {
    if (Kt(e28)) {
      let s10 = uf(e28.values, t);
      return s10.length > 0 && bt(s10[0]) && s10[0] >= 0 && s10[0] < e28.index.length && (s10[0] = e28.index[s10[0]]), s10.length > 1 && bt(s10[1]) && s10[1] >= 0 && s10[1] < e28.columns.length && (s10[1] = e28.columns[s10[1]]), s10;
    }
    if (Bt(e28)) {
      let s10 = uf(e28.values, t);
      return s10.length > 0 && bt(s10[0]) && s10[0] >= 0 && s10[0] < e28.index.length && (s10[0] = e28.index[s10[0]]), s10;
    }
    if (V(Bs(e28) || nt(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"), !Br(t)) {
      let s10 = t;
      t = (i) => i === s10;
    }
    function r(s10, i, a) {
      if (a = a || [], a.indexOf(s10) > -1) return null;
      if (Bs(s10)) {
        a.push(s10);
        let u = Object.keys(s10).concat(Object.getOwnPropertySymbols(s10));
        for (let l = 0; l < u.length; l++) {
          let c = u[l], p = s10[c];
          if (i(p)) return [c];
          let m = r(p, i, a);
          if (m && m.length > 0) return [c].concat(m);
        }
      } else if (nt(s10)) {
        a.push(s10);
        for (let u = 0; u < s10.length; u++) {
          let l = s10[u];
          if (i(l)) return [u];
          let c = r(l, i, a);
          if (c && c.length > 0) return [u].concat(c);
        }
      } else if (i(s10)) return [];
      return null;
    }
    function n(s10) {
      try {
        return t(s10);
      } catch {
        return false;
      }
    }
    let o = r(e28, n);
    return o && o.length > 0 ? o : null;
  }
  function rn(e28) {
    function t(r) {
      if (typeof r == "object") {
        if (r === null) return null;
        if (nt(r)) return r instanceof Array ? r.map((o) => rn(o)) : r.slice();
        if (Bt(r)) {
          let o = r.copy();
          return o.values = rn(o.values), o;
        }
        if (Kt(r)) {
          let o = r.copy();
          return o.values = rn(r.values), o;
        }
        if (r instanceof Date) return new Date(r.getTime());
        r = mc(r);
        let n = {};
        return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach((o) => {
          n[o] = rn(r[o]);
        }), n;
      } else return r;
    }
    return t(mc(e28));
  }
  function mc(e28) {
    function t(o, s10, i) {
      if (s10 = s10 || [], i = i || "", s10.indexOf(o) > -1) {
        let a = i.split("/").slice(i.startsWith("/") ? 1 : 0);
        if (a.some((l, c) => {
          let p = a.slice(0, a.length - c - 1), m = r;
          return p.forEach((f) => {
            m = m[f];
          }), m === o;
        })) return `<reference to "${r === o ? "/" : "/" + uf(r, o).join("/")}">`;
      }
      return typeof o == "object" ? o === null ? null : (s10.push(o), nt(o) ? typeof o.constructor < "u" && o.constructor.name !== "Array" ? o.slice() : o.map((a, u) => t(a, s10, i + "/" + u)) : (Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach((a) => {
        o[a] = t(o[a], s10, i + "/" + a.toString());
      }), o)) : o;
    }
    let r = e28, n = t(r);
    if (Kt(e28)) {
      let o = e28.copy();
      o._values = n.values, o._columns = n.columns, o._index = n.index, n = o;
    }
    if (Bt(e28)) {
      let o = e28.copy();
      o.name = n.name, o._values = n.values, o._index = n.index, n = o;
    }
    return n;
  }
  function as(e28) {
    return e28 instanceof Date && e28.toString() !== "Invalid Date";
  }
  var nz = ["number", "int", "float", "bigint"];
  function Vs(e28, t) {
    function r(n, o) {
      let s10 = typeof n, i = typeof o;
      if (s10 !== i && !nz.includes(s10) && !nz.includes(i)) return false;
      if (s10 === "undefined" && i === "undefined") return true;
      if (s10 === "boolean" || s10 === "symbol") return n === o;
      if (s10 === "number" || s10 === "bigint") try {
        let a = n.toString(), u = o.toString();
        return a === u;
      } catch {
        return false;
      }
      if (s10 === "string" || s10 === "function") return n === o;
      if (s10 === "object") {
        if (n === null || o === null) return n === null && o === null;
        {
          if (as(n)) return as(o) ? n.getTime() === o.getTime() : false;
          if (as(o)) return false;
          if (n instanceof RegExp && o instanceof RegExp) return n.toString() === o.toString();
          if (nt(n) !== nt(o)) return false;
          let a = Object.keys(n).concat(Object.getOwnPropertySymbols(n)), u = Object.keys(o).concat(Object.getOwnPropertySymbols(o));
          if (a.length !== u.length) return false;
          for (let l = 0; l < a.length; l++) {
            let c = a[l];
            if (!r(n[c], o[c])) return false;
          }
          return true;
        }
      }
    }
    try {
      return r(e28, t);
    } catch {
      return r(mc(e28), mc(t));
    }
  }
  function Bg(e28) {
    let t = "abcdefg1234567890", r = "";
    for (; r.length < e28; ) r += t[Math.floor(Math.random() * t.length)];
    return r;
  }
  var frt = Bg(16);
  var hrt = Bg(16);
  var drt = Bg(16);
  var grt = Bg(16);
  var yrt = Bg(16);
  var xrt = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((e28) => this.get(e28));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      return this.countsDict = {}, this.valuesDict = {}, this;
    }
    count(e28) {
      for (let t of e28) nt(t) ? this.count(t) : this.increment(t);
      return this;
    }
    delete(e28) {
      let t = this.getStandardizedKey(e28);
      return delete this.countsDict[t], delete this.valuesDict[t], this;
    }
    get(e28) {
      return this.countsDict[this.getStandardizedKey(e28)] || 0;
    }
    getStandardizedKey(e28) {
      return typeof e28 == "object" && e28 === null ? frt : Ot(e28) ? hrt : Br(e28) ? e28.toString() : typeof e28 == "symbol" ? e28.toString() + " - " + yrt : e28 === 1 / 0 ? drt : e28 === -1 / 0 ? grt : typeof e28 == "bigint" ? e28.toString() : Kt(e28) ? e28.toJSONString() : Bt(e28) ? JSON.stringify(e28.toObject()) : JSON.stringify(e28);
    }
    has(e28) {
      return !Ot(this.countsDict[this.getStandardizedKey(e28)]);
    }
    increment(e28) {
      return this.set(e28, this.get(e28) + 1);
    }
    set(e28, t) {
      let r = this.getStandardizedKey(e28);
      return this.countsDict[r] = t, this.valuesDict[r] = e28, this;
    }
    toArray() {
      return this.values.map((e28) => ({ value: e28, count: this.get(e28) }));
    }
    toObject() {
      let e28 = {};
      return this.values.forEach((t) => {
        e28[t] = this.get(t);
      }), e28;
    }
  };
  function ls(e28) {
    if (Kt(e28) || Bt(e28)) return ls(e28.values);
    V(nt(e28), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function t(r) {
      let n = [];
      return r.forEach((o) => {
        nt(o) ? n = n.concat(t(o)) : n.push(o);
      }), n;
    }
    return t(e28);
  }
  function uo(e28, t) {
    t = t || {};
    let r = new xrt(), n = {}, o = ls(e28), s10 = [], i = -1 / 0, a = 1 / 0, u = false, l = 0;
    for (let p of o) {
      if (typeof p == "bigint" && (u = true), !t.shouldDropNaNs || bt(p)) try {
        p > i && (i = p), p < a && (a = p), l += Number(p), s10.push(p);
      } catch {
        i = NaN, a = NaN, l = NaN;
      }
      r.increment(p);
    }
    let c = l / s10.length;
    if (n.counts = r, n.max = i, n.mean = c, n.min = a, n.n = o.length, n.sum = l, isNaN(n.mean) && (n.max = NaN, n.min = NaN), t.shouldDropNaNs && (n.nWithoutNaNs = s10.length), t.mode) {
      let p = Array.from(r.values.map((h) => [h, r.get(h)])).toSorted((h, d) => d[1] - h[1]), m = p[0][1], f = [];
      for (let h of p) if (h[1] == m) f.push(h[0]);
      else break;
      n.mode = f.toSorted();
    }
    if (t.median) if (isNaN(c)) n.median = NaN;
    else {
      let p = s10.toSorted((f, h) => Number(f) - Number(h)), m = Math.floor(p.length / 2);
      if (p.length % 2 === 0) {
        let f = p[m - 1], h = p[m];
        if (n.median = (Number(f) + Number(h)) / 2, u && typeof f == "bigint" && typeof h == "bigint") try {
          n.median = BigInt(n.median);
        } catch {
        }
      } else n.median = p[m];
    }
    if (t.stdev || t.variance) {
      let p = 0;
      for (let f of s10) p += Math.pow(Number(f) - c, 2);
      p /= s10.length;
      let m = Math.sqrt(p);
      n.stdev = m, n.variance = p;
    }
    if (u) {
      try {
        n.sum = BigInt(n.sum);
      } catch {
      }
      try {
        n.mean = BigInt(n.mean);
      } catch {
      }
      t.mode && (n.mode = n.mode.map((p) => {
        try {
          return BigInt(p);
        } catch {
          return p;
        }
      }));
    }
    return n;
  }
  function Qw(e28, t) {
    let { counts: r } = uo(e28);
    return Ot(t) || (Br(t) ? r.values.forEach((n) => {
      t(n) || r.delete(n);
    }) : r.values.forEach((n) => {
      Vs(n, t) || r.delete(n);
    })), r;
  }
  function US(e28) {
    if (Kt(e28) || Bt(e28)) return US(e28.values);
    if (nt(e28)) {
      let t = false, r = false, n = null;
      for (let o of e28) {
        if (US(o)) return true;
        if (nt(o)) {
          if (n === null) n = o.length;
          else if (o.length !== n) return true;
          t = true;
        } else r = true;
        if (t && r) return true;
      }
    }
    return false;
  }
  function Vg(e28) {
    return US(mc(e28));
  }
  function uv(e28) {
    if (Kt(e28) || Bt(e28)) return uv(e28.values);
    V(nt(e28), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let t = 0; t < e28.length; t++) if (nt(e28[t])) return true;
    return false;
  }
  var qm = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function is(e28) {
    V(!Ot(e28), qm), nt(e28) || (e28 = [e28]), V(!uv(e28), qm), V(e28.length > 0, qm);
    let t = e28[0];
    if (typeof t == "bigint" && (t = Number(t)), V(bt(t), qm), V(t >= 0, qm), V(Math.floor(t) === t, qm), V(t !== 1 / 0, "We can't create an array containing an infinite number of values!"), e28.length === 1) {
      let r = [];
      for (let n = 0; n < t; n++) r.push(void 0);
      return r;
    } else {
      let r = [];
      for (let n = 0; n < t; n++) r.push(is(e28.slice(1)));
      return r;
    }
  }
  function Ps(e28) {
    if (Kt(e28) || Bt(e28)) {
      let r = e28.copy();
      return r.values = Ps(r.values), r.index = Ps(r.index), r;
    }
    V(nt(e28), "The `reverse` function only works on arrays, Series, and DataFrames!");
    let t = [];
    for (let r = e28.length - 1; r >= 0; r--) t.push(e28[r]);
    return t;
  }
  function fr(e28, t, r = 1) {
    V(!Ot(e28) && !Ot(t) && !Ot(r), "You must pass two numbers and optionally a step value to the `range` function!"), V(bt(e28) && bt(t) && bt(r), "You must pass two numbers and optionally a step value to the `range` function!"), V(r > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let n = false, o = typeof e28 == "bigint" || typeof t == "bigint" || typeof r == "bigint";
    if (e28 = Number(e28), t = Number(t), r = Number(r), e28 > t) {
      n = true;
      let i = e28;
      e28 = t + r, t = i + r;
    }
    let s10 = [];
    for (let i = e28; i < t; i += r) if (o) try {
      s10.push(BigInt(i));
    } catch {
      s10.push(i);
    }
    else s10.push(i);
    return n && (s10 = Ps(s10)), s10;
  }
  function Gg(e28) {
    let t = "abcdefg1234567890", r = "";
    for (; r.length < e28; ) r += t[Math.floor(Math.random() * t.length)];
    return r;
  }
  var brt = Gg(256);
  var wrt = Gg(256);
  var vrt = Gg(256);
  var Nrt = Gg(256);
  var Crt = Gg(256);
  function Oo(e28) {
    if (Kt(e28) || Bt(e28)) return Oo(e28.values);
    V(nt(e28), "The `set` function only works on arrays, Series, and DataFrames!");
    let t = [], r = {};
    return ls(e28).forEach((n) => {
      let o = typeof n == "object" && n === null ? brt : Ot(n) ? wrt : Br(n) ? n.toString() : typeof n == "symbol" ? n.toString() + " - " + Crt : n === 1 / 0 ? vrt : n === -1 / 0 ? Nrt : typeof n == "bigint" ? n.toString() : Kt(n) ? n.toJSONString() : Bt(n) ? JSON.stringify(n.toObject()) : JSON.stringify(n);
      r[o] || t.push(n), r[o] = true;
    }), t;
  }
  function Hz(e28) {
    if (nt(e28)) {
      let t = Hz(e28[0]);
      return [e28.length].concat(t || []);
    } else return;
  }
  function Ht(e28) {
    return Kt(e28) || Bt(e28) ? Ht(e28.values) : (V(nt(e28), "The `shape` function only works on arrays, Series, and DataFrames!"), Hz(e28));
  }
  function Kz(e28, t, r) {
    if (Ot(r) && (r = 0), V(r === 0 || r === 1 || r === "vertical" || r === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'), nt(t)) {
      V(!Vg(t), "The array of data you're trying to append to this DataFrame is jagged!");
      let n = Ht(t);
      if (n.length === 1) if (r === 0) {
        let o = e28.copy();
        o._values.push(t);
        let s10 = Math.max(e28.shape[1], n[0]);
        for (o._values.forEach((i) => {
          for (; i.length < s10; ) i.push(void 0);
        }); o._index.length < o._values.length; ) o._index.push("row" + o._index.length);
        for (; o._columns.length < s10; ) o._columns.push("col" + o._columns.length);
        return o;
      } else {
        let o = Math.max(e28.shape[0], n[0]), s10 = e28.copy();
        for (fr(0, o).forEach((i) => {
          i >= s10._values.length && s10._values.push(is(e28.shape[1])), s10._values[i].push(t[i]);
        }); s10._index.length < s10._values.length; ) s10._index.push("row" + s10._index.length);
        for (; s10._columns.length < s10._values[0].length; ) s10._columns.push("col" + s10._columns.length);
        return s10;
      }
      else if (n.length === 2) if (r === 0) {
        let o = Math.max(...t.map((i) => i.length).concat([e28.shape[1]])), s10 = e28.copy();
        for (s10._values = s10._values.concat(t).map((i) => {
          for (; i.length < o; ) i.push(void 0);
          return i;
        }); s10._index.length < s10._values.length; ) s10._index.push("row" + s10._index.length);
        for (; s10._columns.length < o; ) s10._columns.push("col" + s10._columns.length);
        return s10;
      } else {
        let o = Math.max(...t.map((a) => a.length)) + e28.shape[1], s10 = Math.max(e28.shape[0], n[0]), i = e28.copy();
        for (fr(0, s10).forEach((a) => {
          for (a >= i._values.length && i._values.push(is(e28.shape[1])), i._values[a] = i._values[a].concat(t[a]); i._values[a].length < o; ) i._values[a].push(void 0);
        }); i._index.length < i._values.length; ) i._index.push("row" + i._index.length);
        for (; i._columns.length < o; ) i._columns.push("col" + i._columns.length);
        return i;
      }
      else throw new ju("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
    } else if (Bt(t)) {
      let n = Kz(e28, t.values, r);
      return r === 0 ? n.index[n.index.length - 1] = n.index.indexOf(t.name) > -1 ? t.name + " (2)" : t.name : n.columns[n.columns.length - 1] = n.columns.indexOf(t.name) > -1 ? t.name + " (2)" : t.name, n;
    } else if (Kt(t)) if (r === 0) {
      let n = e28.copy(), o = Oo(n._columns.concat(t._columns)).length;
      for (n._values.forEach((s10) => {
        for (; s10.length < o; ) s10.push(void 0);
      }), t.apply((s10) => {
        let i = s10.copy(), a = [];
        n._columns.forEach((u) => {
          let l = i._index.indexOf(u);
          l > -1 ? (a.push(i._values[l]), i._values.splice(l, 1), i._index.splice(l, 1)) : a.push(void 0);
        }), n._values.push(a.concat(i._values));
      }, 1), n._columns = n._columns.concat(t._columns.filter((s10) => n._columns.indexOf(s10) < 0)); n._index.length < n._values.length; ) {
        let s10 = "row" + n._index.length;
        n._index.push(s10 + (e28._index.indexOf(s10) > -1 ? " (2)" : ""));
      }
      return n;
    } else {
      let n = e28.copy();
      return n._index.forEach((o, s10) => {
        let i = t._index.indexOf(o);
        i > -1 ? n._values[s10] = n._values[s10].concat(t._values[i]) : n._values[s10] = n._values[s10].concat(is(t.shape[1]));
      }), t._index.forEach((o, s10) => {
        n._index.indexOf(o) < 0 && (n._index.push(o), n._values.push(is(n._columns.length).concat(t._values[s10])));
      }), n._columns = n._columns.concat(t._columns.map((o) => o + (n._columns.indexOf(o) > -1 ? " (2)" : ""))), n;
    }
    else throw new ju("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
  }
  function Srt(e28, t, r, n, o) {
    if (o = o || 0, V(Br(n), "The first parameter to the `apply` method must be a function."), V(o === 0 || o === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1."), o === 0) {
      let s10 = {}, i;
      if (r.columns.forEach((a, u) => {
        let l = new t(r.values.map((p) => p[u]));
        l.name = a, l.index = r.index;
        let c = n(l, u, r);
        c instanceof t ? s10[a] = c.values : s10[a] = c, Ot(i) && (i = c instanceof t || nt(c));
      }), i) {
        let a = new e28(s10);
        return a.index = r.index, a;
      } else {
        let a = new t(r.columns.map((u) => s10[u]));
        return a.index = r.columns, a;
      }
    } else if (o === 1) {
      let s10, i = r.values.map((a, u) => {
        let l = new t(a);
        l.name = r.index[u], l.index = r.columns;
        let c = n(l, u, r);
        return Ot(s10) && (s10 = c instanceof t || nt(c)), c instanceof t ? c.values : c;
      });
      if (s10) {
        let a = new e28(i);
        return a.index = r.index, a.columns = r.columns, a;
      } else {
        let a = new t(i);
        return a.index = r.index, a;
      }
    }
  }
  function Te(e28) {
    return typeof e28 == "string";
  }
  function Irt(e28, t, r, n, o) {
    let s10 = (a) => a instanceof e28, i = (a) => a instanceof t;
    if (Ot(o)) {
      if (s10(n)) return r.append(n, 1);
      if (i(n)) return r.append(n, 1);
      if (Bs(n)) {
        let a = Math.max(...Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map((u) => n[u].length));
        return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach((u) => {
          for (; n[u].length < a; ) n[u].push(void 0);
        }), r.append(new e28(n), 1);
      } else throw new ju("You must pass a DataFrame, Series, or object into the `assign` method!");
    } else {
      V(Te(n), "If passing two arguments into the `assign` method, then the first argument must be a string name!"), V(nt(o) && !Vg(o) && Ht(o).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      let a = r.append(o, 1);
      return a.columns[a.columns.length - 1] = n, a;
    }
  }
  function Trt(e28, t) {
    if (t.isEmpty) return new e28();
    let r = new e28(rn(t.values));
    return r.columns = t.columns.slice(), r.index = t.index.slice(), r;
  }
  function krt(e28, t, r, n, o) {
    Ot(n) && (n = []), Ot(o) && (o = []), (Te(n) || bt(n)) && (n = [n]), (Te(o) || bt(o)) && (o = [o]), V(nt(n), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), V(nt(o), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), V(Ht(n).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."), V(Ht(o).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let s10, i;
    r.index.forEach((u, l) => {
      n.indexOf(u) < 0 && n.indexOf(l) < 0 && (s10 || (s10 = []), s10.push(u));
    }), r.columns.forEach((u, l) => {
      o.indexOf(u) < 0 && o.indexOf(l) < 0 && (i || (i = []), i.push(u));
    });
    let a = r.get(s10, i);
    if (a instanceof t) {
      let u = new e28();
      u = u.assign(a), r.index.indexOf(a.name) > -1 && (u = u.transpose()), a = u;
    }
    return a;
  }
  function qz(e28) {
    return bt(e28) && (e28 >= 0 ? Math.floor(e28) === e28 : Math.ceil(e28) === e28);
  }
  function lf(e28) {
    return qz(e28) && e28 >= 0;
  }
  function Ert(e28, t, r, n, o, s10) {
    n = n || 0, V(n === 0 || n === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."), s10 = s10 || 0, V(lf(s10), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."), o = s10 > 0 ? "none" : o || "any", V(o === "any" || o === "all" || o === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function i(l) {
      if (s10 > 0) {
        let c = 0;
        for (let p = 0; p < l.length; p++) {
          let m = l[p];
          if (Ot(m) && c++, c >= s10) return [];
        }
      } else if (o === "any") for (let c = 0; c < l.length; c++) {
        let p = l[c];
        if (Ot(p)) return [];
      }
      else if (o === "all") {
        for (let c = 0; c < l.length; c++) {
          let p = l[c];
          if (!Ot(p)) return l;
        }
        return [];
      }
      return l;
    }
    let a = r.copy(), u = Math.random().toString();
    if (n === 0) {
      a = a.assign(u, a.index);
      let l = a.values.map(i).filter((p) => p.length > 0);
      if (Ht(l).length < 2) return new e28();
      a.values = l;
      let c = a.get(null, u);
      if (Ot(c)) return new e28();
      Te(c) && (c = [c]), c instanceof t && (c = c.values), a.index = c, a = a.drop(null, u);
    } else if (n === 1) {
      let l = {};
      if (a.columns.forEach((p, m) => {
        let f = a.values.map((d) => d[m]), h = i(f);
        h.length > 0 && (l[p] = h);
      }), Object.keys(l).length + Object.getOwnPropertySymbols(l).length === 0) return new e28();
      let c = new e28(l);
      return c.index = a.index, c;
    }
    return a;
  }
  function uI(e28) {
    if (Kt(e28) || Bt(e28)) return e28.dropNaN(...Object.values(arguments).slice(1));
    V(nt(e28), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    let t = [];
    return e28.forEach((r) => {
      try {
        return t.push(uI(r));
      } catch {
        if (bt(r)) return t.push(r);
      }
    }), t;
  }
  function Art(e28, t, r, n, o) {
    r = r || 0, V(r === 0 || r === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."), o = o || 0, V(lf(o), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."), n = o > 0 ? "none" : n || "any", V(n === "any" || n === "all" || n === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function s10(a) {
      let u = uI(a);
      return o > 0 ? a.length - u.length < o : n === "any" ? u.length === a.length : n === "all" ? u.length > 0 : true;
    }
    let i = t.copy();
    if (r === 0) {
      let a = i.index.filter((u) => {
        let l = i.get(u, null).values;
        return s10(l);
      });
      return a.length > 0 ? i.get(a, null) : new e28();
    } else if (r === 1) {
      let a = i.columns.filter((u) => {
        let l = i.get(null, u).values;
        return s10(l);
      });
      return a.length > 0 ? i.get(null, a) : new e28();
    }
    return i;
  }
  function oz(e28) {
    let t = {};
    return ls(e28).forEach((r, n) => {
      t[r] = n;
    }), t;
  }
  function Xm(e28) {
    return Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).sort((t, r) => e28[t] - e28[r]);
  }
  function Drt(e28, t, r, n, o) {
    V(Br(n), "The `filter` method takes a single parameter: a function that is used to filter the values."), Ot(o) && (o = 0), V(o === 0 || o === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let s10 = r.copy();
    if (s10.isEmpty) return s10;
    let i = oz(s10.index), a = oz(s10.columns);
    if (o === 0) {
      let u = 0, l = s10.values.filter((c, p) => {
        let m = new t(c);
        m.name = r.index[p], m.index = r.columns;
        let f = n(m, p, r);
        return f ? u++ : delete i[s10.index[p]], f;
      });
      if (u === 0) return new e28();
      if (u === 1) {
        let c = new t(l[0]);
        return c.name = Xm(i)[0], c.index = Xm(a), c;
      }
      s10.values = l, s10.index = Xm(i);
    } else if (o === 1) {
      s10 = s10.transpose();
      let u = 0, l = s10.values.filter((c, p) => {
        let m = new t(c);
        m.name = r.columns[p], m.index = r.index;
        let f = n(m, p, r);
        return f ? u++ : delete a[s10.index[p]], f;
      });
      if (u === 0) return new e28();
      if (u === 1) {
        let c = new t(l[0]);
        return c.name = Xm(a)[0], c.index = Xm(i), c;
      }
      s10.values = l, s10.index = Xm(a), s10 = s10.transpose();
    }
    return s10;
  }
  function $rt(e28, t, r) {
    (Te(t) || bt(t)) && (t = [t]), (Te(r) || bt(r)) && (r = [r]);
    for (let o in t) typeof t[o] == "bigint" && (t[o] = Number(t[o]));
    for (let o in r) typeof r[o] == "bigint" && (r[o] = Number(r[o]));
    let n = Oo((t || []).concat(r || []).map((o) => typeof o));
    return V(n.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!"), n.length === 1 && V(n[0] === "string" || n[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!"), n.length === 2 && (V(n.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!"), V(n.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!")), Ot(t) || (t = t.map((o) => {
      if (Te(o)) return V(e28.index.indexOf(o) > -1, `Row "${o}" does not exist!`), o;
      if (bt(o)) return V(o >= 0, `Index ${o} is out of bounds!`), V(Math.floor(o) === o, "Row numbers must be integers!"), V(o < e28.index.length, `Index ${o} is out of bounds!`), e28.index[o];
    })), Ot(r) || (r = r.map((o) => {
      if (Te(o)) return V(e28.columns.indexOf(o) > -1, `Column "${o}" does not exist!`), o;
      if (bt(o)) return V(o >= 0, `Column ${o} is out of bounds!`), V(Math.floor(o) === o, "Column numbers must be integers!"), V(o < e28.columns.length, `Column ${o} is out of bounds!`), e28.columns[o];
    })), e28.getSubsetByNames(t, r);
  }
  function Frt(e28, t) {
    try {
      return e28 < t ? -1 : e28 > t ? 1 : 0;
    } catch {
      return e28 = typeof e28 == "object" && e28 !== null ? JSON.stringify(e28) : e28.toString(), t = typeof t == "object" && t !== null ? JSON.stringify(t) : t.toString(), e28 < t ? -1 : e28 > t ? 1 : 0;
    }
  }
  function fc(e28, t) {
    if (Ot(t) && (t = Frt), Kt(e28) || Bt(e28)) return e28.sort(...Object.values(arguments).slice(1));
    V(nt(e28), "The `sort` function only works on arrays, Series, and DataFrames!"), V(Br(t), "The second parameter of the `sort` function must be a comparison function!");
    let r = e28.slice();
    return r.sort(t), r;
  }
  function _rt(e28) {
    let t = e28.toLowerCase(), r = "";
    for (let o = 0; o < t.length; o++) {
      let s10 = t[o];
      s10.match(/[a-z0-9]/g) ? r += s10 : r += " ";
    }
    let n = r.split(" ").filter((o) => o.length > 0);
    return n[0] + n.slice(1).map((o) => o[0].toUpperCase() + o.substring(1)).join("");
  }
  function sz(e28, t, r) {
    Ot(r) ? r = t.columns : Te(r) && (r = [r]);
    let n = {};
    r.forEach((s10) => {
      V(Te(s10), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      let i = t.columns.indexOf(s10);
      V(i > -1, `The given DataFrame does not have a column called "${s10}"!`);
      let a = t.values.map((l) => l[i]), u = fc(Oo(a));
      a.forEach((l) => {
        u.forEach((c) => {
          let p = s10 + "_" + _rt(c.toString());
          n[p] || (n[p] = []), l === c ? n[p].push(1) : n[p].push(0);
        });
      });
    });
    let o = new e28(n);
    return o.index = t.index, o;
  }
  function Ort(e28, t, r) {
    let n = e28.shape;
    Ot(t) && (t = fr(0, n[0])), Ot(r) && (r = fr(0, n[1])), bt(t) && (t = [t]), bt(r) && (r = [r]), V(nt(t) && nt(r), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), V(Ht(t).length === 1 && Ht(r).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), V(t.length > 0, "The `rowIndices` array must contain at least one index."), V(r.length > 0, "The `colIndices` array must contain at least one index."), t.forEach((i) => {
      V(lf(i), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), V(i < e28.index.length, `The row index ${i} is out of bounds.`);
    }), r.forEach((i) => {
      V(lf(i), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."), V(i < e28.columns.length, `The column index ${i} is out of bounds.`);
    });
    let o = t.map((i) => e28.index[i]), s10 = r.map((i) => e28.columns[i]);
    return e28.getSubsetByNames(o, s10);
  }
  function Rrt(e28, t, r, n, o) {
    Ot(n) && (n = r.index), Ot(o) && (o = r.columns), Te(n) && (n = [n]), Te(o) && (o = [o]), V(nt(n) && nt(o), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), V(Ht(n).length === 1 && Ht(o).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), V(n.length > 0, "The `rows` array must contain at least one row name."), V(o.length > 0, "The `cols` array must contain at least one column name."), n.forEach((a) => {
      V(Te(a), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), V(r.index.indexOf(a) > -1, `The row name "${a}" does not exist in the list of rows.`);
    }), o.forEach((a) => {
      V(Te(a), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."), V(r.columns.indexOf(a) > -1, `The column name "${a}" does not exist in the list of columns.`);
    });
    let s10 = n.map((a) => o.map((u) => r.values[r.index.indexOf(a)][r.columns.indexOf(u)]));
    if (n.length === 1 && o.length === 1) return s10[0][0];
    if (n.length === 1) {
      let a = new t(s10[0]);
      return a.name = n[0], a.index = o, a;
    }
    if (o.length === 1) {
      let a = new t(s10.map((u) => u[0]));
      return a.name = o[0], a.index = n, a;
    }
    let i = new e28(s10);
    return i.columns = o, i.index = n, i;
  }
  function Prt(e28, t, r) {
    function n(m, f) {
      return Te(m) && m.length > f ? m.substring(0, f - 3) + "..." : m;
    }
    if (r.isEmpty) return console.table({}), console.log("Shape:", [0, 0], `
`), r;
    let o = typeof window > "u" ? 20 : 10, s10 = Math.floor(o / 2), i = typeof process > "u" ? 10 : Math.floor(process.stdout.columns / 24) - 1, a = Math.floor(i / 2), u = o > r.index.length ? null : fr(0, s10).concat(fr(r.index.length - s10, r.index.length)), l = i > r.columns.length ? null : fr(0, a).concat(fr(r.columns.length - a, r.columns.length)), c = r.get(u, l);
    c instanceof t && (r.shape[0] === 1 ? (c = new e28([c.values]), c.index = r.index, c.columns = new t(r.columns).get(l).values) : r.shape[1] === 1 && (c = new e28([c.values]).transpose(), c.index = new t(r.index).get(u).values, c.columns = r.columns)), o <= r.index.length && (c._index.splice(s10, 0, "..."), c._values.splice(s10, 0, fr(0, c.columns.length).map(() => "..."))), i <= r.columns.length && (c._columns.splice(a, 0, "..."), c._values = c._values.map((m) => (m.splice(a, 0, "..."), m)));
    let p = 28;
    return c instanceof t ? (c.values = c.values.map((m) => n(m, p)), c.name = n(c.name, p), c.index = c.index.map((m) => n(m, p))) : (c.values = c.values.map((m) => m.map((f) => n(f, p))), c.columns = c.columns.map((m) => n(m, p)), c.index = c.index.map((m) => n(m, p))), console.table(c.toDetailedObject()), console.log("Shape:", r.shape, `
`), r;
  }
  function Jm(e28, t) {
    V(bt(e28), "The `leftPad` function only works on numbers!");
    let r = e28.toString();
    for (; r.length < t; ) r = "0" + r;
    return r;
  }
  function Lrt(e28, t) {
    let r = t ? e28 : e28.copy();
    return r.index = fr(0, e28.shape[0]).map((n) => "row" + Jm(n, (r.index.length - 1).toString().length)), r;
  }
  function Wg(e28, t) {
    if (Kt(e28) || Bt(e28)) return Wg(e28.values, t);
    V(nt(e28), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (e28.length === 0) return NaN;
      let r = ls(e28), n = false, o = 1;
      for (let s10 of r) {
        if (!bt(s10)) if (t) s10 = 1;
        else return NaN;
        typeof s10 == "bigint" && (n = true, s10 = Number(s10)), o *= s10;
      }
      if (n) try {
        return BigInt(o);
      } catch {
      }
      return o;
    } catch {
      return NaN;
    }
  }
  function Mrt(e28) {
    return qz(e28) && e28 > 0;
  }
  function Ag(e28, t) {
    if (Kt(e28) || Bt(e28)) return Ag(e28.values, t);
    if (V(nt(e28), "The first argument passed into the `reshape` function must be an array!"), bt(t) && (t = [t]), V(nt(t), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), V(Ht(t).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), t = t.map((s10) => (typeof s10 == "bigint" && (s10 = Number(s10)), V(Mrt(s10), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"), Number(s10))), t.length === 0) return ls(e28);
    let r = ls(e28);
    if (t.length === 1 && t[0] === r.length) return r;
    V(Wg(t) === r.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    let n = [], o = Math.floor(r.length / t[0]);
    for (let s10 = 0; s10 < t[0]; s10++) {
      let i = r.slice(s10 * o, (s10 + 1) * o);
      n.push(Ag(i, t.slice(1)));
    }
    return n;
  }
  var Xz = Math.pow(2, 64);
  var rr = [];
  Yz(Math.floor(Math.random() * Xz));
  function zrt(e28, t) {
    e28 = yn(e28);
    function r() {
      e28 += yn("0x9e3779b97f4a7c15");
      let o = rn(e28);
      return o = (o ^ o >> BigInt(30)) * yn("0xbf58476d1ce4e5b9"), o = (o ^ o >> BigInt(27)) * yn("0x94d049bb133111eb"), o ^ o >> BigInt(31);
    }
    let n = [];
    for (let o = 0; o < t; o++) n.push(r());
    return n;
  }
  function yn(e28) {
    return BigInt.asUintN(64, BigInt(e28));
  }
  function iz(e28, t) {
    return e28 = yn(e28), t = BigInt(t), yn(yn(e28 << t) | yn(e28 >> yn(BigInt(64) - t)));
  }
  function Yz(e28) {
    if (typeof e28 == "bigint" && (e28 = Number(e28)), Ot(e28)) return rn(rr);
    {
      V(bt(e28), "If passing a value into the `seed` function, then that value must be an integer!");
      let t = zrt(Math.floor(e28), 4);
      rr[0] = t[0], rr[1] = t[1], rr[2] = t[2], rr[3] = t[3];
    }
  }
  function az() {
    let e28 = yn(iz(rr[0] + rr[3], 23) + rr[0]), t = yn(rr[1] << BigInt(17));
    return rr[2] = yn(rr[2] ^ rr[0]), rr[3] = yn(rr[3] ^ rr[1]), rr[1] = yn(rr[1] ^ rr[2]), rr[0] = yn(rr[0] ^ rr[3]), rr[2] = yn(rr[2] ^ t), rr[3] = iz(rr[3], 45), Math.floor(Number(e28)) / Xz;
  }
  function cf(e28) {
    return Ot(e28) ? az() : (nt(e28) || (e28 = [e28]), Ag(is(Wg(e28)).map(az), e28));
  }
  function tv(e28) {
    if (Kt(e28) || Bt(e28)) return e28.shuffle(...Object.values(arguments).slice(1));
    V(nt(e28), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    let t = [], r = e28.slice();
    for (let n = 0; n < e28.length; n++) {
      let o = Math.floor(cf() * r.length);
      t.push(r.splice(o, 1)[0]);
    }
    return t;
  }
  function Brt(e28, t) {
    return Ot(t) && (t = 0), V(t === 0 || t === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined."), e28.get(t === 0 ? tv(e28.index) : null, t === 1 ? tv(e28.columns) : null);
  }
  function lc(e28) {
    return typeof e28 == "boolean";
  }
  function Vrt(e28, t, r) {
    return Br(t) ? Grt(e28, t, r) : Wrt(e28, t, r);
  }
  function Grt(e28, t, r) {
    if (r = Ot(r) ? 0 : r, V(Br(t), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"), V(bt(r), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."), r === 0) {
      let n = fc(e28.index, (o, s10) => t(e28.get(o, null), e28.get(s10, null)));
      return e28.get(n, null);
    } else {
      let n = fc(e28.columns, (o, s10) => t(e28.get(null, o), e28.get(null, s10)));
      return e28.get(null, n);
    }
  }
  function Wrt(e28, t, r) {
    let n = e28.copy(), o = cf().toString();
    n = n.assign(o, n.index), Ot(t) && (t = [o], r = [true]), (bt(t) || Te(t)) && (t = [t], (lc(r) || Te(r)) && (r = [r])), V(nt(t), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."), V(Ht(t).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."), Ot(r) && (r = fr(0, t.length).map(() => true)), V(nt(r), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."), V(Ht(r).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."), V(t.length === r.length, "The arrays passed into the `sort` method must be equal in length."), t = t.map((i) => {
      if (V(Te(i) || bt(i), "Column references can either be column names (as strings) or column indices (as whole numbers)."), Te(i)) {
        let a = n.columns.indexOf(i);
        return V(a > -1, `The column "${i}" does not exist!`), a;
      }
      if (bt(i)) return V(lf(i), "Column indices must be whole numbers!"), V(i < n.columns.length, `The index ${i} is out of bounds!`), i;
    }), r = r.map((i) => {
      if (V(Te(i) || lc(i), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."), Te(i)) {
        let a = i.trim().toLowerCase();
        return V(a === "ascending" || a === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."), a === "ascending";
      }
      if (lc(i)) return i;
    }), n.values = fc(n.values, (i, a) => {
      let u = 0;
      for (; i[t[u]] === a[t[u]] && u < t.length; ) u++;
      let l = r[u];
      if (i[t[u]] === a[t[u]]) return 0;
      if (i[t[u]] < a[t[u]]) return l ? -1 : 1;
      if (i[t[u]] > a[t[u]]) return l ? 1 : -1;
    });
    let s10 = n.columns.indexOf(o);
    return n.index = n.values.map((i) => i[s10]), n = n.dropColumns(o), n;
  }
  function Urt(e28, t) {
    Ot(t) ? t = 0 : V(t === 0 || t === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    let r = {};
    return t === 0 ? e28.index.forEach((n, o) => {
      let s10 = {};
      e28.columns.forEach((i, a) => {
        s10[i] = e28.values[o][a];
      }), r[n] = s10;
    }) : e28.columns.forEach((n, o) => {
      let s10 = {};
      e28.index.forEach((i, a) => {
        s10[i] = e28.values[a][o];
      }), r[n] = s10;
    }), r;
  }
  function Jz(e28, t) {
    return JSON.stringify(e28.toObject(t));
  }
  async function jrt(e28, t, r) {
    let n = Jz(e28, r), o = false, s10 = false, i, a;
    try {
      let u = t;
      if (t.includes("/")) {
        let c = t.split("/");
        u = c[c.length - 1];
      }
      let l = document.createElement("a");
      l.href = `data:application/json;charset=utf-8,${encodeURIComponent(n)}`, l.download = u, l.dispatchEvent(new MouseEvent("click")), o = true;
    } catch (u) {
      i = u;
    }
    try {
      let u = await import("node:fs"), l = await import("node:path");
      u.writeFileSync(l.resolve(t), n, "utf8"), s10 = true;
    } catch (u) {
      a = u;
    }
    if (!o && !s10) throw typeof window < "u" ? new ju(i) : typeof module < "u" ? new ju(a) : new ju("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
    return e28;
  }
  function Hrt(e28) {
    let t = {};
    return e28.columns.forEach((r) => {
      t[r] = e28.get(r).values;
    }), t;
  }
  function xa(e28) {
    if (Kt(e28) || Bt(e28)) return e28.transpose();
    V(nt(e28), "The `transpose` function only works on arrays, Series, and DataFrames!");
    let t = Ht(e28);
    if (V(t.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"), t.length === 1) return Ps(e28);
    if (t.length === 2) {
      let r = is(Ps(t));
      for (let n = 0; n < t[0]; n++) for (let o = 0; o < t[1]; o++) r[o][n] = e28[n][o];
      return r;
    }
  }
  function Zz(e28, t, r) {
    if (Bt(r)) return new e28(t.values.concat(r.values));
    if (nt(r)) {
      let n = Ht(r);
      V(n.length === 1 && !uv(n), "Only vectors can be appended to Series!");
      let o = t.copy();
      return r.forEach((s10, i) => {
        o._values.push(s10), o._index.push("item" + (t.values.length + i));
      }), o;
    }
    return Zz(t, [r]);
  }
  function Krt(e28, t) {
    V(Br(t), "The parameter to the `apply` method must be a function.");
    let r = e28.copy();
    return r._values = r._values.map((n, o) => t(n, o)), r;
  }
  function qrt(e28) {
    let t = e28.copy(), r = [];
    return t._values = t.values.filter((n, o) => Ot(n) ? false : (r.push(t.index[o]), true)), t._index = r, t;
  }
  function Xrt(e28, t) {
    let r = [], n = [];
    t.values.forEach((s10, i) => {
      bt(s10) && (n.push(s10), r.push(t.index[i]));
    });
    let o = new e28(n);
    return o.name = t.name, o.index = r, o;
  }
  function Yrt(e28, t, r) {
    let n = t.copy(), o = rn(n.index), s10 = [], i = n.values.filter((a, u) => {
      let l = r(a, u, n.values);
      return l || s10.push(n.index[u]), l;
    });
    return s10.forEach((a) => {
      o.splice(o.indexOf(a), 1);
    }), i.length === 0 ? (n = new e28(), n.name = t.name, n) : (n.values = i, n.index = o, n);
  }
  function Jrt(e28, t) {
    (Te(t) || bt(t)) && (t = [t]);
    for (let n in t) typeof t[n] == "bigint" && (t[n] = Number(t[n]));
    let r = Oo((t || []).map((n) => typeof n));
    return V(r.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!"), r.length === 1 && V(r[0] === "string" || r[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!"), r.length === 2 && (V(r.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!"), V(r.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!")), Ot(t) || (t = t.map((n) => {
      if (typeof n == "string") return V(e28.index.indexOf(n) > -1, `Index "${n}" does not exist!`), n;
      if (typeof n == "number") return V(n >= 0, `Index ${n} is out of bounds!`), V(Math.floor(n) === n, "Indices must be integers!"), V(n < e28.index.length, `Index ${n} is out of bounds!`), e28.index[n];
    })), e28.getSubsetByNames(t);
  }
  function Zrt(e28, t) {
    let r = e28.shape;
    Ot(t) && (t = fr(0, r[0])), V(nt(t), "The `indices` array must be 1-dimensional array of whole numbers."), V(Ht(t).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers."), V(t.length > 0, "The `indices` array must contain at least one index."), t.forEach((o) => {
      V(lf(o), "The `indices` array must be a 1-dimensional array of whole numbers."), V(o < e28.index.length, `The row index ${o} is out of bounds.`);
    });
    let n = t.map((o) => e28.index[o]);
    return e28.getSubsetByNames(n);
  }
  function Qrt(e28, t, r) {
    Ot(r) && (r = t.index), V(nt(r), "The `indices` array must be a 1-dimensional array of strings."), V(Ht(r).length === 1, "The `indices` array must be a 1-dimensional array of strings."), V(r.length > 0, "The `indices` array must contain at least one index name."), r.forEach((s10) => {
      V(Te(s10), "The `indices` array must contain only strings."), V(t.index.indexOf(s10) > -1, `The name "${s10}" does not exist in the index.`);
    });
    let n = r.map((s10) => t.values[t.index.indexOf(s10)]);
    if (n.length === 1) return n[0];
    let o = new e28(n);
    return o.index = r, o.name = t.name, o;
  }
  function tnt(e28) {
    let t = e28.copy(), r = typeof window > "u" ? 20 : 10;
    if (t.index.length > r) {
      t = t.get(fr(0, r / 2).concat(fr(t.index.length - r / 2, t.index.length)));
      let o = rn(t.index);
      o.splice(Math.floor(o.length / 2), 0, "..."), t.values.push("..."), t.index.push("..."), t = t.get(o);
    }
    let n = {};
    return t.values.forEach((o, s10) => {
      let i = {};
      i[t.name] = o, n[t.index[s10]] = i;
    }), console.table(n), console.log("Shape:", e28.shape, `
`), e28;
  }
  function ent(e28) {
    let t = e28.copy();
    return t.get(tv(t.index));
  }
  function rnt(e28, t, r) {
    r = r || ((u, l) => u < l ? -1 : 1), V(Ot(r) || Br(r), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    let n = xa([t.values, t.index]), o = fc(n, (u, l) => r(u[0], l[0])), s10 = [], i = [];
    o.forEach((u) => {
      s10.push(u[0]), i.push(u[1]);
    });
    let a = new e28();
    return a._values = s10, a._index = i, a.name = t.name, a;
  }
  function nnt(e28, t) {
    let r = xa([t.values, t.index]);
    r = xa(fc(r, (o, s10) => {
      if (o[1] === s10[1]) return 0;
      if (o[1] < s10[1]) return -1;
      if (o[1] > s10[1]) return 1;
    }));
    let n = new e28(r[0]);
    return n.index = r[1], n.name = t.name, n;
  }
  function ont(e28) {
    let t = {};
    return t[e28.name] = {}, e28.index.forEach((r, n) => {
      t[e28.name][r] = e28.values[n];
    }), t;
  }
  var uz = Symbol.for("@jrc03c/js-math-tools/series");
  function snt(e28) {
    class t {
      static [Symbol.hasInstance](n) {
        try {
          return !!n._symbol && n._symbol === uz;
        } catch {
          return false;
        }
      }
      constructor(n) {
        if (this.name = "data", Object.defineProperty(this, "_symbol", { configurable: false, enumerable: false, writable: false, value: uz }), Object.defineProperty(this, "_values", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "values", { configurable: true, enumerable: true, get() {
          return this._values;
        }, set(o) {
          V(nt(o), "The new values must be a 1-dimensional array!");
          let s10 = Ht(o);
          V(s10.length === 1, "The new array of values must be 1-dimensional!"), s10[0] < this._index.length ? this._index = this._index.slice(0, s10[0]) : s10[0] > this._index.length && (this._index = this._index.concat(fr(this._index.length, s10[0]).map((i) => "item" + Jm(i, (o.length - 1).toString().length)))), this._values = o;
        } }), Object.defineProperty(this, "_index", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "index", { configurable: true, enumerable: true, get() {
          return this._index;
        }, set(o) {
          V(nt(o), "The new index must be a 1-dimensional array of strings!"), V(o.length === this.shape[0], "The new index must be the same length as the old index!"), V(Ht(o).length === 1, "The new index must be a 1-dimensional array of strings!"), o.forEach((s10) => {
            V(Te(s10), "All of the row names must be strings!");
          }), this._index = o;
        } }), n) {
          if (n instanceof t) this.name = n.name, this.values = rn(n.values), this.index = rn(n.index);
          else if (nt(n)) {
            let o = Ht(n);
            V(o.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!"), this.values = n;
          } else if (n instanceof Object) {
            let o = Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map((a) => a.toString());
            V(o.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            let s10 = o[0], i = n[s10];
            V(Ht(i).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"), this.name = s10, this.values = i.slice();
          }
        }
      }
      get shape() {
        return Ht(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((n) => !Ot(n)).length === 0;
      }
      clear() {
        let n = this.copy();
        return n.values.forEach((o, s10) => {
          n.values[s10] = void 0;
        }), n;
      }
      get(n) {
        return Jrt(this, n);
      }
      getSubsetByNames(n) {
        return Qrt(t, this, n);
      }
      getSubsetByIndices(n) {
        return Zrt(this, n);
      }
      loc(n) {
        return this.getSubsetByNames(n);
      }
      iloc(n) {
        return this.getSubsetByIndices(n);
      }
      reverse() {
        let n = new t(Ps(this.values));
        return n.index = Ps(this.index), n.name = this.name, n;
      }
      resetIndex() {
        let n = this.copy();
        return n.index = fr(0, this.shape[0]).map((o) => "item" + Jm(o, (n.index.length - 1).toString().length)), n;
      }
      copy() {
        let n = new t();
        return n._values = rn(this.values), n._index = rn(this.index), n.name = this.name, n;
      }
      append(n) {
        return Zz(t, this, n);
      }
      apply(n) {
        return Krt(this, n);
      }
      concat(n) {
        return this.append(n);
      }
      dropMissing(n, o) {
        return qrt(this, n, o);
      }
      dropNaN() {
        return Xrt(t, this);
      }
      toObject() {
        return ont(this);
      }
      print() {
        return tnt(this);
      }
      shuffle() {
        return ent(this);
      }
      sort(n) {
        return rnt(t, this, n);
      }
      sortByIndex() {
        return nnt(t, this);
      }
      filter(n) {
        return Yrt(t, this, n);
      }
      toDataFrame() {
        let n = new e28(xa([this.values]));
        return n.columns = [this.name], n.index = this.index, n;
      }
      transpose() {
        let n = this.copy();
        return n.values = Ps(n.values), n.index = Ps(n.index), n;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return t;
  }
  var lz = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function Ww(e28) {
    let t = "abcdefghijklmnopqrstuvwxyz1234567890", r = "";
    for (let n = 0; n < e28; n++) r += t[Math.floor(cf() * t.length)];
    return r;
  }
  var mr = class {
    static [Symbol.hasInstance](e28) {
      try {
        return !!e28._symbol && e28._symbol === lz;
      } catch {
        return false;
      }
    }
    constructor(e28) {
      if (Object.defineProperty(this, "_symbol", { configurable: false, enumerable: false, writable: false, value: lz }), Object.defineProperty(this, "_values", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "values", { configurable: true, enumerable: true, get() {
        return this._values.length === 0 || !Ot(this._values[0]) && this._values[0].length === 0 ? [[]] : this._values;
      }, set(t) {
        V(nt(t), "The new values must be a 2-dimensional array!");
        let r = Ht(t);
        V(r.length === 2, "The new array of values must be 2-dimensional!"), r[0] < this._index.length ? this._index = this._index.slice(0, r[0]) : r[0] > this._index.length && (this._index = this._index.concat(fr(this._index.length, r[0]).map((n) => "row" + Jm(n, (r[0] - 1).toString().length)))), r[1] < this._columns.length ? this._columns = this._columns.slice(0, r[1]) : r[1] > this._columns.length && (this._columns = this._columns.concat(fr(this._columns.length, r[1]).map((n) => "col" + Jm(n, (r[1] - 1).toString().length)))), this._values = t;
      } }), Object.defineProperty(this, "_columns", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "columns", { configurable: true, enumerable: true, get() {
        return this._columns;
      }, set(t) {
        V(nt(t), "The new columns list must be a 1-dimensional array of strings!"), V(this.isEmpty || t.length === this.shape[1], "The new columns list must be the same length as the old columns list!"), V(Ht(t).length === 1, "The new columns list must be a 1-dimensional array of strings!"), t = t.map((n) => (typeof n != "string" && (n = JSON.stringify(n) || n.toString()), n.trim().length === 0 ? "untitled_" + Ww(8) : n.trim()));
        let r = (() => {
          let n = Qw(t), o = {};
          return n.values.forEach((s10) => {
            o[s10] = n.get(s10);
          }), o;
        })();
        t = t.map((n) => r[n] > 1 ? n + "_" + Ww(8) : n), this._columns = t;
      } }), Object.defineProperty(this, "_index", { value: [], configurable: true, enumerable: false, writable: true }), Object.defineProperty(this, "index", { configurable: true, enumerable: true, get() {
        return this._index;
      }, set(t) {
        V(nt(t), "The new index must be a 1-dimensional array of strings!"), V(this.isEmpty || t.length === this.shape[0], "The new index must be the same length as the old index!"), V(Ht(t).length === 1, "The new index must be a 1-dimensional array of strings!"), t = t.map((n) => (typeof n != "string" && (n = JSON.stringify(n) || n.toString()), n.trim().length === 0 ? "untitled_" + Ww(8) : n.trim()));
        let r = (() => {
          let n = Qw(t), o = {};
          return n.values.forEach((s10) => {
            o[s10] = n.get(s10);
          }), o;
        })();
        t = t.map((n) => r[n] > 1 ? n + "_" + Ww(8) : n), this._index = t;
      } }), V(Ot(e28) || Bs(e28) || nt(e28), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."), e28) if (e28 instanceof mr) this.values = rn(e28.values), this.columns = rn(e28.columns), this.index = rn(e28.index);
      else if (nt(e28)) {
        let t = Ht(e28);
        V(t.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"), V(!Vg(e28), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"), this.values = e28;
      } else {
        this._columns = Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).map((s10) => s10.toString());
        let t = [], r = null, n = null;
        this._columns.forEach((s10) => {
          Ot(n) && (r = s10, n = e28[s10].length), V(e28[s10].length === n, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${r}" points to an array containing ${n} items, and the key "${s10}" points to an array containing ${e28[s10].length} items.`), n = e28[s10].length;
          let i = e28[s10];
          t.push(i);
        }), this._values = xa(t);
        let o = Ht(this.values);
        this._index = fr(0, o[0]).map((s10) => "row" + Jm(s10, (o[0] - 1).toString().length));
      }
    }
    get shape() {
      return Ht(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(e28) {
      this.index = e28;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((e28) => e28.length === 0);
    }
    clear() {
      let e28 = new mr(is(this.shape));
      return e28.columns = this.columns.slice(), e28.index = this.index.slice(), e28;
    }
    get(e28, t) {
      if (arguments.length === 0) return this;
      if (arguments.length === 1) try {
        return this.get(null, e28);
      } catch {
        return this.get(e28, null);
      }
      return $rt(this, e28, t);
    }
    getSubsetByNames(e28, t) {
      return Rrt(mr, kn, this, e28, t);
    }
    getSubsetByIndices(e28, t) {
      return Ort(this, e28, t);
    }
    getDummies(e28) {
      return sz(mr, this, e28);
    }
    oneHotEncode(e28) {
      return sz(mr, this, e28);
    }
    transpose() {
      let e28 = new mr(xa(this.values));
      return e28.columns = this.index.slice(), e28.index = this.columns.slice(), e28;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(e28) {
      return Lrt(this, e28);
    }
    copy() {
      return Trt(mr, this);
    }
    assign(e28, t) {
      return Irt(mr, kn, this, e28, t);
    }
    apply(e28, t) {
      return Srt(mr, kn, this, e28, t);
    }
    dropMissing(e28, t, r) {
      return Ert(mr, kn, this, e28, t, r);
    }
    dropNaN(e28, t, r) {
      return Art(mr, this, e28, t, r);
    }
    drop(e28, t) {
      return krt(mr, kn, this, e28, t);
    }
    dropColumns(e28) {
      return this.drop(null, e28);
    }
    dropRows(e28) {
      return this.drop(e28, null);
    }
    toDetailedObject(e28) {
      return Urt(this, e28);
    }
    toObject() {
      return Hrt(this);
    }
    toJSONString(e28) {
      return Jz(this, e28);
    }
    saveAsJSON(e28, t) {
      return jrt(this, e28, t);
    }
    print() {
      return Prt(mr, kn, this);
    }
    sort(e28, t) {
      return Vrt(this, e28, t);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(e28, t) {
      return Drt(mr, kn, this, e28, t);
    }
    shuffle(e28) {
      return Brt(this, e28);
    }
    append(e28, t) {
      return Kz(this, e28, t);
    }
    concat(e28, t) {
      return this.append(e28, t);
    }
    join(e28, t) {
      return this.append(e28, t);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var kn = snt(mr);
  function lv(e28, t) {
    return uo(e28, { shouldDropNaNs: t }).max;
  }
  function Ve(e28) {
    return V(Br(e28), "You must pass a function into the `vectorize` function!"), function t() {
      let r, n, o = [], s10 = [], i = Object.keys(arguments).filter((a) => {
        let u = arguments[a];
        return nt(u) ? true : Bt(u) ? (r = true, o.push(u), true) : Kt(u) ? (n = true, s10.push(u), true) : false;
      }).map((a) => arguments[a]);
      if (i.slice(0, -1).forEach((a, u) => {
        V(Vs(nt(a) ? Ht(a) : a.shape, nt(i[u + 1]) ? Ht(i[u + 1]) : i[u + 1].shape), `When passing multiple arrays into the \`${e28.name}\` function, all of the arrays must have the same shape!`);
      }), i.length > 0) {
        let a = lv(i.map((l) => l.length ? l.length : l.values.length)), u = fr(0, a).map((l) => {
          let c = Object.keys(arguments).map((p) => nt(arguments[p]) ? arguments[p][l] : Bt(arguments[p]) || Kt(arguments[p]) ? arguments[p].values[l] : arguments[p]);
          return t(...c);
        });
        if (n) try {
          if (s10.length === 1 && Vs(Ht(s10[0]), Ht(u))) {
            let l = new mr(u);
            return l.index = s10[0].index.slice(), l.columns = s10[0].columns.slice(), l;
          } else return new mr(u);
        } catch {
          return u;
        }
        if (r) try {
          if (o.length === 1 && o[0].length === u.length) {
            let l = new kn(u);
            return l.name = o[0].name, l.index = o[0].index.slice(), l;
          } else return new kn(u);
        } catch {
          return u;
        }
        return u;
      } else return e28(...arguments);
    };
  }
  function int3(e28) {
    try {
      return bt(e28) ? typeof e28 == "bigint" ? e28 < 0 ? -e28 : e28 : Math.abs(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var lI = Ve(int3);
  function ant() {
    try {
      let e28 = 0, t = false, r = Object.values(arguments);
      for (let n of r) {
        if (!bt(n)) return NaN;
        typeof n == "bigint" && (t = true, n = Number(n)), e28 += n;
      }
      if (t) try {
        return BigInt(e28);
      } catch {
      }
      return e28;
    } catch {
      return NaN;
    }
  }
  var ev = Ve(ant);
  function unt(e28, t) {
    try {
      return t(e28);
    } catch {
      return NaN;
    }
  }
  var cv = Ve(unt);
  function lnt(e28) {
    try {
      return bt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.acos(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var cnt = Ve(lnt);
  function pnt(e28) {
    try {
      return bt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.asin(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var mnt = Ve(pnt);
  function fnt(e28) {
    try {
      return bt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.atan(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var hnt = Ve(fnt);
  function jS(e28, t) {
    if (Kt(e28)) {
      let r = jS(e28.values, t);
      return [e28.index[r[0]], e28.columns[r[1]]];
    }
    if (Bt(e28)) {
      let r = jS(e28.values, t);
      return e28.index[r];
    }
    V(nt(e28), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      let r = uf(e28, lv(e28, t));
      return r ? r.length === 0 ? void 0 : r.length === 1 ? r[0] : r : void 0;
    } catch {
      return;
    }
  }
  function Qz(e28, t) {
    return uo(e28, { shouldDropNaNs: t }).min;
  }
  function HS(e28, t) {
    if (Kt(e28)) {
      let r = HS(e28.values, t);
      return [e28.index[r[0]], e28.columns[r[1]]];
    }
    if (Bt(e28)) {
      let r = HS(e28.values, t);
      return e28.index[r];
    }
    V(nt(e28), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      let r = uf(e28, Qz(e28, t));
      return r ? r.length === 0 ? void 0 : r.length === 1 ? r[0] : r : void 0;
    } catch {
      return;
    }
  }
  function so(e28, t) {
    if (Kt(e28) || Bt(e28)) return e28.apply((r) => so(r, t));
    if (nt(e28)) return e28.map((r) => so(r, t));
    if (t === "null") return null;
    if (t === "number") {
      if (Ot(e28)) return NaN;
      let r = so(e28, "boolean");
      if (lc(r)) return r ? 1 : 0;
      try {
        JSON.parse(e28);
      } catch {
        let s10 = so(e28, "date");
        if (as(s10)) return s10.getTime();
      }
      let n = parseFloat(e28);
      return isNaN(n) ? NaN : n;
    }
    if (t === "int") {
      let r = so(e28, "number");
      return r >= 0 ? Math.floor(r) : Math.ceil(r);
    }
    if (t === "float") return so(e28, "number");
    if (t === "bigint") return typeof e28 == "bigint" ? e28 : BigInt(so(e28, "int"));
    if (t === "boolean") {
      if (lc(e28)) return e28;
      if (bt(e28)) return e28 === 0 ? false : e28 === 1 ? true : null;
      try {
        let r = (typeof e28 == "object" ? e28.toString() === "null" ? "false" : JSON.stringify(e28) : e28.toString()).trim().toLowerCase();
        return r === "true" || r === "yes" || r === "y" ? true : r === "false" || r === "no" || r === "n" ? false : null;
      } catch {
        return null;
      }
    }
    if (t === "date") {
      if (as(e28)) return e28;
      if (Ot(e28)) return null;
      let r = parseFloat(e28);
      if (!isNaN(r)) {
        let o = new Date(e28);
        return as(o) ? o : null;
      }
      let n = Date.parse(e28);
      return isNaN(n) ? null : new Date(n);
    }
    if (t === "object") {
      if (Bs(e28)) return e28;
      let r = so(e28, "boolean");
      if (lc(r)) return null;
      try {
        let o = so(e28, "number");
        if (bt(o)) return JSON.parse(e28), null;
      } catch {
      }
      let n = so(e28, "date");
      if (n) return n;
      try {
        let o = JSON.parse(e28);
        return nt(o) ? o.map((s10) => so(s10, t)) : o;
      } catch {
        return null;
      }
    }
    if (t === "string") return Ot(e28) ? Vs(e28, void 0) ? "undefined" : "null" : e28 instanceof Date ? e28.toJSON() : typeof e28 == "object" ? e28 === null ? "null" : JSON.stringify(e28) : e28.toString();
  }
  function dnt(e28) {
    try {
      return bt(e28) ? typeof e28 == "bigint" ? e28 : Math.ceil(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var gnt = Ve(dnt);
  function ynt(e28, t) {
    try {
      if (!bt(e28)) return NaN;
      if (typeof e28 == "bigint") return e28;
      if (Ot(t)) t = 1e-10;
      else if (!bt(t)) return NaN;
      return lI(e28) < t ? 0 : e28;
    } catch {
      return NaN;
    }
  }
  var xnt = Ve(ynt);
  function KS(e28) {
    if (Kt(e28) || Bt(e28)) {
      let t = e28.copy();
      return t.values = KS(t.values), t;
    }
    if (nt(e28)) return e28.map((t) => KS(t));
    try {
      let t = JSON.parse(e28);
      return bt(t) ? typeof t == "bigint" ? Number(t) : t >= 0 ? Math.floor(t) : Math.ceil(t) : NaN;
    } catch {
      return NaN;
    }
  }
  var Gs = Ve(KS);
  function tB(e28, t, r) {
    try {
      return bt(e28) ? bt(t) ? bt(r) ? typeof e28 == "bigint" ? BigInt(tB(Gs(e28), t, r)) : e28 < t ? t : e28 > r ? r : e28 : NaN : NaN : NaN;
    } catch {
      return NaN;
    }
  }
  var bnt = Ve(tB);
  function rv(e28, t) {
    function* r(n, o) {
      if (o > n.length) yield n;
      else if (o <= 0) yield [];
      else if (n.length < 2) yield n;
      else for (let s10 = 0; s10 < n.length; s10++) {
        let i = n[s10], a = n.slice(s10 + 1);
        if (!(a.length < o - 1) && o - 1 >= 0) for (let u of rv(a, o - 1)) yield [i].concat(u);
      }
    }
    return Kt(e28) || Bt(e28) ? rv(e28.values, t) : (V(nt(e28), "The `combinations` function only works on arrays, Series, and DataFrames!"), V(bt(t) && Gs(t) === t && t >= 0, "`r` must be a non-negative integer!"), r(ls(e28), t));
  }
  function eB(e28, t) {
    let r = [];
    for (let n of rv(e28, t)) r.push(n.slice());
    return r;
  }
  function rB() {
    let e28 = Object.values(arguments).map((r) => Kt(r) || Bt(r) ? Oo(r.values) : (V(nt(r), "The `intersect` function only works on arrays, Series, and DataFrames!"), Oo(r)));
    return Oo(e28).filter((r) => e28.every((n) => n.findIndex((o) => Vs(o, r)) > -1));
  }
  var wg = class {
    constructor(e28) {
      V(Ot(e28) || e28 === wg.DROP_NAN_MODE || e28 === wg.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"), this.mode = Ot(e28) ? wg.DROP_NAN_MODE : e28, this.index = null;
    }
    fit() {
      let e28 = [];
      return Object.values(arguments).forEach((t) => {
        if (nt(t)) {
          let r = Ht(t);
          if (r.length === 1) t = new kn(t);
          else if (r.length === 2) t = new mr(t);
          else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        }
        V(Kt(t) || Bt(t), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"), this.mode === wg.DROP_MISSING_MODE ? e28.push(t.dropMissing().index) : e28.push(t.dropNaN().index);
      }), this.index = rB(...e28), this;
    }
    transform() {
      V(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      let e28 = Object.values(arguments).map((t) => {
        if (nt(t)) {
          let r = Ht(t);
          if (r.length === 1) return new kn(t).get(this.index).values;
          if (r.length === 2) return new mr(t).get(this.index, null).values;
          throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        }
        return V(Kt(t) || Bt(t), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"), t.get(this.index, null);
      });
      return e28.length === 1 ? e28[0] : e28;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var pv = wg;
  Uz(pv, "DROP_NAN_MODE", "DROP_NAN_MODE");
  Uz(pv, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function Ig(e28, t, r, n) {
    if (Bt(e28)) return Ig(e28.values, t, r, n);
    if (Bt(t)) return Ig(e28, t.values, r, n);
    if (V(nt(e28) && nt(t) && Ht(e28).length === 1 && Ht(t).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!"), V(e28.length === t.length, "The two arrays or Series passed into the `covariance` function must have the same length!"), r) return Ig(...new pv().fitAndTransform(e28, t), false, n);
    try {
      let o = uo(e28, { stdev: n }), s10 = uo(t, { stdev: n }), i = Number(o.mean), a = Number(s10.mean);
      if (!bt(i) || !bt(a)) return NaN;
      let u = Math.max(e28.length, t.length), l = 0;
      for (let c = 0; c < u; c++) {
        let p = e28[c], m = t[c];
        if (!bt(p)) return NaN;
        if (!bt(m)) return NaN;
        typeof p == "bigint" && (p = Number(p)), typeof m == "bigint" && (m = Number(m)), l += (p - i) * (m - a);
      }
      return n ? [l / e28.length, o, s10] : l / e28.length;
    } catch {
      return NaN;
    }
  }
  function qS(e28, t, r) {
    if (Bt(e28)) return qS(e28.values, t, r);
    if (Bt(t)) return qS(e28, t.values, r);
    V(nt(e28) && nt(t) && Ht(e28).length === 1 && Ht(t).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!"), V(e28.length === t.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      let [o, s10, i] = Ig(e28, t, r, true), a = s10.stdev * i.stdev;
      return o / a;
    } catch {
      return NaN;
    }
  }
  function wnt(e28) {
    try {
      return bt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.cos(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var vnt = Ve(wnt);
  var Nnt = Object.freeze({ boolean: "boolean", date: "date", null: "null", number: "number", object: "object", string: "string" });
  function XS(e28, t) {
    if (Kt(e28) || Bt(e28)) return XS(e28.values, t);
    if (Kt(t) || Bt(t)) return XS(e28, t.values);
    V(nt(e28) && nt(t), "The `diff` function only works on arrays, Series, and DataFrames!");
    let r = Oo(e28), n = Oo(t), o = [];
    return r.forEach((s10) => {
      n.findIndex((i) => Vs(i, s10)) < 0 && o.push(s10);
    }), o;
  }
  function nB(e28, t) {
    try {
      if (!bt(e28)) return NaN;
      if (!bt(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = nB(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return Math.pow(e28, t);
    } catch {
      return NaN;
    }
  }
  var cI = Ve(nB);
  function oB(e28) {
    try {
      if (!bt(e28)) return NaN;
      if (typeof e28 == "bigint") {
        let t = oB(Number(e28));
        try {
          return BigInt(t);
        } catch {
          return t;
        }
      }
      return Math.sqrt(e28);
    } catch {
      return NaN;
    }
  }
  var sB = Ve(oB);
  function Cnt() {
    try {
      let e28 = Object.values(arguments);
      if (e28.length === 0) return NaN;
      let t = false, r = 1;
      for (let n of e28) {
        if (!bt(n)) return NaN;
        typeof n == "bigint" && (t = true, n = Number(n)), r *= n;
      }
      if (t) try {
        return BigInt(r);
      } catch {
      }
      return r;
    } catch {
      return NaN;
    }
  }
  var iB = Ve(Cnt);
  function pf() {
    return iB(...arguments);
  }
  function aB(e28, t) {
    return ev(e28, pf(t, -1));
  }
  function pI(e28, t) {
    return uo(e28, { shouldDropNaNs: t }).sum;
  }
  function YS(e28, t) {
    if (bt(e28) && bt(t)) return lI(e28 - t);
    if (Kt(e28) || Bt(e28)) return YS(e28.values, t);
    if (Kt(t) || Bt(t)) return YS(e28, t.values);
    nt(e28) && nt(t) && V(Vs(Ht(e28), Ht(t)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    try {
      return sB(pI(cI(aB(e28, t), 2)));
    } catch {
      return NaN;
    }
  }
  function Snt(e28, t) {
    return pf(e28, cI(t, -1));
  }
  function pa(e28, t) {
    if (Kt(e28)) {
      let o = pa(e28.values, t);
      if (Ht(o).length === 1) {
        let s10 = new kn(o);
        return s10.name = Bt(t) ? t.name : s10.name, s10.index = e28.index.slice(), s10;
      } else {
        let s10 = new mr(o);
        return s10.index = e28.index.slice(), Kt(t) && (s10.columns = t.columns.slice()), s10;
      }
    }
    if (Kt(t)) {
      let o = pa(e28, t.values);
      if (Ht(o).length === 1) {
        let s10 = new kn(o);
        return s10.name = Bt(e28) ? e28.name : s10.name, s10.index = t.columns.slice(), s10;
      } else {
        let s10 = new mr(o);
        return s10.columns = t.columns.slice(), s10;
      }
    }
    if (Bt(e28)) return pa(e28.values, t);
    if (Bt(t)) return pa(e28, t.values);
    V(nt(e28) && nt(t), "The `dot` function only works on arrays, Series, and DataFrames!");
    let r = Ht(e28), n = Ht(t);
    if (V(r.length <= 2 && n.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"), V(r[r.length - 1] === n[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${r[r.length - 1]} !== ${n[0]})`), r.length === 1 && n.length === 1) return pI(pf(e28, t));
    if (r.length === 1 && n.length === 2) return xa(t).map((o) => pa(e28, o));
    if (r.length === 2 && n.length === 1) return e28.map((o) => pa(o, t));
    if (r.length === 2 && n.length === 2) {
      let o = xa(t), s10 = [];
      for (let i = 0; i < e28.length; i++) {
        let a = [];
        for (let u = 0; u < o.length; u++) a.push(pa(e28[i], o[u]));
        s10.push(a);
      }
      return s10;
    }
  }
  function mI(e28) {
    if (Kt(e28) || Bt(e28)) return e28.dropMissing(...Object.values(arguments).slice(1));
    V(nt(e28), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    let t = [];
    return e28.forEach((r) => {
      try {
        return t.push(mI(r));
      } catch {
        Ot(r) || t.push(r);
      }
    }), t;
  }
  function Kw(e28, t) {
    if (Kt(e28) || Bt(e28)) return Kw(e28.values, t);
    if (Kt(t) || Bt(t)) return Kw(e28, t.values);
    V(nt(e28) && nt(t), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"), V(Vs(Ht(e28), Ht(t)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    let r = [], n = [];
    for (let o = 0; o < e28.length; o++) try {
      let [s10, i] = Kw(e28[o], t[o]);
      r.push(s10), n.push(i);
    } catch {
      !Ot(e28[o]) && !Ot(t[o]) && (r.push(e28[o]), n.push(t[o]));
    }
    return [r, n];
  }
  function qw(e28, t) {
    if (Kt(e28) || Bt(e28)) return qw(e28.values, t);
    if (Kt(t) || Bt(t)) return qw(e28, t.values);
    V(nt(e28) && nt(t), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"), V(Vs(Ht(e28), Ht(t)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    let r = [], n = [];
    for (let o = 0; o < e28.length; o++) try {
      let [s10, i] = qw(e28[o], t[o]);
      r.push(s10), n.push(i);
    } catch {
      bt(e28[o]) && bt(t[o]) && (r.push(e28[o]), n.push(t[o]));
    }
    return [r, n];
  }
  function Int(e28) {
    return mI(e28);
  }
  function nv(e28, t) {
    if (Kt(e28) || Bt(e28)) return nv(e28.values, t);
    V(nt(e28), "The first argument passed into the `every` function must be an array, Series, or DataFrame!"), V(Br(t), "The second argument passed into the `every` function must be a function!");
    for (let r of e28) if (nt(r)) {
      if (!nv(r, t)) return false;
    } else if (!t(r)) return false;
    return true;
  }
  function Tnt(e28) {
    try {
      if (!bt(e28)) return NaN;
      if (typeof e28 == "bigint") {
        if (e28 === 0n) return 1n;
        e28 = Number(e28);
      }
      return Math.exp(e28);
    } catch {
      return NaN;
    }
  }
  var knt = Ve(Tnt);
  function JS(e28) {
    try {
      return typeof e28 == "bigint" ? BigInt(JS(Gs(e28))) : e28 !== Gs(e28) ? NaN : e28 <= 1 ? 1 : e28 * JS(e28 - 1);
    } catch {
      return NaN;
    }
  }
  var Ent = Ve(JS);
  function ZS(e28, t) {
    if (Kt(e28) || Bt(e28)) return ZS(e28.values, t);
    if (V(Bs(e28) || nt(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"), !Br(t)) {
      let o = t;
      t = (s10) => s10 === o;
    }
    function r(o, s10, i) {
      if (i = i || [], i.indexOf(o) > -1) return null;
      if (Bs(o)) {
        i.push(o);
        let a = Object.keys(o).concat(Object.getOwnPropertySymbols(o));
        for (let u = 0; u < a.length; u++) {
          let l = a[u], c = o[l];
          if (s10(c)) return c;
          let p = r(c, s10, i);
          if (p) return p;
        }
      } else if (nt(o)) {
        i.push(o);
        for (let a = 0; a < o.length; a++) {
          let u = o[a];
          if (s10(u)) return u;
          let l = r(u, s10, i);
          if (l) return l;
        }
      } else if (s10(o)) return o;
      return null;
    }
    function n(o) {
      try {
        return t(o);
      } catch {
        return false;
      }
    }
    return r(e28, n);
  }
  function QS(e28, t) {
    if (Kt(e28) || Bt(e28)) return QS(e28.values, t);
    if (V(Bs(e28) || nt(e28), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"), !Br(t)) {
      let s10 = t;
      t = (i) => i === s10;
    }
    function r(s10, i, a) {
      if (a = a || [], a.indexOf(s10) > -1) return null;
      if (Bs(s10)) {
        a.push(s10);
        let u = Object.keys(s10).concat(Object.getOwnPropertySymbols(s10)), l = [];
        for (let c = 0; c < u.length; c++) {
          let p = u[c], m = s10[p], f = false;
          i(m) && (l.push(m), f = true);
          let h = r(m, i, a);
          h && h.length > 0 && h.slice(f ? 1 : 0).forEach((d) => l.push(d));
        }
        return l;
      } else if (nt(s10)) {
        a.push(s10);
        let u = [];
        for (let l = 0; l < s10.length; l++) {
          let c = s10[l], p = false;
          i(c) && (u.push(c), p = true);
          let m = r(c, i, a);
          m && m.length > 0 && m.slice(p ? 1 : 0).forEach((f) => u.push(f));
        }
        return u;
      } else if (i(s10)) return [s10];
      return null;
    }
    function n(s10) {
      try {
        return t(s10);
      } catch {
        return false;
      }
    }
    let o = r(e28, n);
    return o && o.length > 0 ? o : null;
  }
  function Ant(e28) {
    try {
      if (e28 === "Infinity") return 1 / 0;
      if (e28 === "-Infinity") return -1 / 0;
      let t = JSON.parse(e28);
      return bt(t) ? t : NaN;
    } catch {
      return NaN;
    }
  }
  var Dnt = Ve(Ant);
  function $nt(e28) {
    try {
      return bt(e28) ? typeof e28 == "bigint" ? e28 : Math.floor(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var Fnt = Ve($nt);
  function fI(e28) {
    bt(e28) && (e28 = [e28]);
    let t = [], r = Wg(e28);
    for (let n = 0; n < r; n++) t.push(0);
    return Ag(t, e28);
  }
  function _nt(e28) {
    typeof e28 == "bigint" && (e28 = Gs(e28)), V(!Ot(e28), "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), V(bt(e28), "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), V(Gs(e28) === e28, "You must pass an integer greater than 0 (representing the size) into the `identity` function!"), V(e28 > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    let t = fI([e28, e28]);
    for (let r = 0; r < e28; r++) t[r][r] = 1;
    return t;
  }
  var Ont = ["true", "false", "yes", "no"];
  var Rnt = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function Uw(e28) {
    return e28.type === "number" && (typeof e28.value < "u" ? e28.isInteger = Gs(e28.value) === e28.value : e28.isInteger = nv(e28.values, (t) => bt(t) ? Gs(t) === t : true)), e28;
  }
  function Xw(e28) {
    if (Kt(e28)) {
      let s10 = e28.copy(), i = Xw(e28.values);
      return s10.values = i.values, Uw({ type: i.type, values: s10 });
    }
    if (Bt(e28)) {
      let s10 = e28.copy(), i = Xw(e28.values);
      return s10.values = i.values, Uw({ type: i.type, values: s10 });
    }
    if (!nt(e28)) {
      let s10 = Xw([e28]);
      return s10.value = s10.values[0], delete s10.values, Uw(s10);
    }
    V(nt(e28), "The `inferType` function only works on arrays, Series, and DataFrames!");
    let t = ls(e28).map((s10) => {
      if (s10 === void 0) return "null";
      try {
        if (typeof s10 == "object") {
          let u = new Date(s10.getTime());
          if (as(u)) return "date";
        }
      } catch {
      }
      Te(s10) || (typeof s10 == "bigint" ? s10 = s10.toString() + "n" : s10 = JSON.stringify(s10));
      let a = s10.toLowerCase().trim();
      if (Rnt.indexOf(a) > -1) return "null";
      if (Ont.indexOf(a) > -1) return "boolean";
      try {
        if (s10.match(/^-?\d+n$/g)) return "bigint";
        let u = JSON.parse(s10);
        return bt(u) ? "number" : typeof u == "object" ? nt(u) ? "string" : "object" : "string";
      } catch {
        let l = new Date(s10);
        return as(l) ? "date" : "string";
      }
    }), r = Qw(t), o = r.values.toSorted((s10, i) => r.get(i) - r.get(s10))[0];
    return Uw({ type: o, values: cv(e28, (s10) => so(s10, o)) });
  }
  function Yw(e28) {
    if (Kt(e28)) {
      let r = e28.copy();
      return r.values = Yw(r.values), r;
    }
    V(nt(e28), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    let t = Ht(e28);
    if (V(t.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!"), V(t[0] === t[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!"), V(t[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!"), t[0] === 0) return e28;
    if (t[0] === 1) {
      V(e28[0][0] !== 0, "This matrix cannot be inverted!");
      let r = e28[0][0];
      return typeof r == "bigint" && (r = Number(r)), 1 / r;
    } else if (t[0] === 2) {
      let r = e28[0][0], n = e28[0][1], o = e28[1][0], s10 = e28[1][1];
      typeof r == "bigint" && (r = Number(r)), typeof n == "bigint" && (n = Number(n)), typeof o == "bigint" && (o = Number(o)), typeof s10 == "bigint" && (s10 = Number(s10));
      let i = r * s10 - n * o;
      V(i !== 0, "This matrix cannot be inverted!");
      let a = [[s10, -n], [-o, r]];
      return pf(a, 1 / i);
    } else if (t[0] > 1) {
      let r = (n, o) => bt(n) || bt(o) ? pf(n, o) : pa(n, o);
      for (let n = 1; n < t[0] - 1; n++) try {
        let o = e28.slice(0, n).map((d) => d.slice(0, n)), s10 = e28.slice(0, n).map((d) => d.slice(n, t[0])), i = e28.slice(n, t[0]).map((d) => d.slice(0, n)), a = e28.slice(n, t[0]).map((d) => d.slice(n, t[0])), u = Yw(o), l = Yw(ev(a, r(-1, r(r(i, u), s10)))), c = ev(u, r(r(r(r(u, s10), l), i), u)), p = r(-1, r(r(u, s10), l)), m = r(-1, r(r(l, i), u)), f = l;
        return c.map((d, g) => d.concat(p[g])).concat(m.map((d, g) => d.concat(f[g])));
      } catch {
      }
      V(false, "This matrix cannot be inverted!");
    }
  }
  var Pnt = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function uB(e28, t, r) {
    try {
      if (!bt(e28)) return NaN;
      if (!bt(t)) return NaN;
      if (!bt(r)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let n = uB(Number(e28), Number(t), r);
        try {
          return BigInt(n);
        } catch {
          return n;
        }
      }
      return r * (t - e28) + e28;
    } catch {
      return NaN;
    }
  }
  var Lnt = Ve(uB);
  function lB(e28, t) {
    try {
      if (t = Ot(t) ? Math.E : t, !bt(e28)) return NaN;
      if (!bt(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = lB(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return Math.log(e28) / Math.log(t);
    } catch {
      return NaN;
    }
  }
  var Mnt = Ve(lB);
  function znt(e28, t) {
    return uo(e28, { shouldDropNaNs: t }).mean;
  }
  function Bnt(e28, t) {
    return uo(e28, { shouldDropNaNs: t, median: true }).median;
  }
  function cB(e28, t) {
    try {
      if (!bt(e28)) return NaN;
      if (!bt(t)) return NaN;
      if (typeof e28 == "bigint" || typeof t == "bigint") {
        let r = cB(Number(e28), Number(t));
        try {
          return BigInt(r);
        } catch {
          return r;
        }
      }
      return e28 % t;
    } catch {
      return NaN;
    }
  }
  var Vnt = Ve(cB);
  function Gnt(e28, t) {
    return uo(e28, { shouldDropNaNs: t, mode: true }).mode;
  }
  function cz() {
    let e28 = cf(), t = cf();
    return Math.sqrt(-2 * Math.log(e28)) * Math.cos(2 * Math.PI * t);
  }
  function Wnt(e28) {
    return Ot(e28) ? cz() : cv(is(e28), cz);
  }
  function Unt(e28) {
    return cv(is(e28), () => 1);
  }
  function hI(e28, t) {
    function* r(n, o) {
      if (o = o || n.length, n.length === 1) {
        yield [n];
        return;
      }
      for (let s10 of eB(n, o)) {
        if (!s10.slice) continue;
        let i = fI(s10.length);
        yield s10;
        let a = 1;
        for (; a < s10.length; ) if (i[a] < a) {
          if (a % 2 === 0) {
            let u = s10[0];
            s10[0] = s10[a], s10[a] = u;
          } else {
            let u = s10[i[a]];
            s10[i[a]] = s10[a], s10[a] = u;
          }
          yield s10, i[a] += 1, a = 1;
        } else i[a] = 0, a += 1;
      }
    }
    return Kt(e28) || Bt(e28) ? hI(e28.values, t) : (V(nt(e28), "The `permutations` function only works on arrays, Series, and DataFrames!"), Ot(t) && (t = e28.length), V(bt(t) && Gs(t) === t && t >= 0, "`r` must be a non-negative integer!"), r(ls(e28), t));
  }
  function jnt(e28, t) {
    let r = [];
    for (let n of hI(e28, t)) r.push(n.slice());
    return r;
  }
  function Hnt() {
    Object.keys(arguments).forEach((e28) => {
      let t = arguments[e28];
      if (nt(t)) if (Vg(t)) console.log(t);
      else {
        let r = Ht(t);
        r.length === 1 ? new kn(t).print() : r.length == 2 ? new mr(t).print() : console.log(t);
      }
      else Kt(t) || Bt(t) ? t.print() : console.log(t);
    });
  }
  var Knt = Ve((e28, t, r, n, o) => {
    try {
      let s10 = false;
      for (let l of [e28, t, r, n, o]) {
        if (!bt(l)) return NaN;
        typeof l == "bigint" && (s10 = true);
      }
      s10 && (e28 = Number(e28), t = Number(t), r = Number(r), n = Number(n), o = Number(o));
      let i = (o - n) * (e28 - t), a = r - t;
      if (a === 0) return NaN;
      let u = i / a + n;
      if (s10) try {
        return BigInt(u);
      } catch {
      }
      return u;
    } catch {
      return NaN;
    }
  });
  function qnt(e28, t, r, n, o) {
    if (nt(e28) && Ot(n) && Ot(o)) {
      n = t, o = r;
      let s10 = uo(e28);
      t = s10.min, r = s10.max;
    }
    return Knt(e28, t, r, n, o);
  }
  function Xnt(e28) {
    try {
      return bt(e28) ? typeof e28 == "bigint" ? e28 : Math.round(e28) : NaN;
    } catch {
      return NaN;
    }
  }
  var Ynt = Ve(Xnt);
  function pB(e28) {
    try {
      return bt(e28) ? typeof e28 == "bigint" ? BigInt(pB(Number(e28))) : e28 < 0 ? -1 : e28 > 0 ? 1 : 0 : NaN;
    } catch {
      return NaN;
    }
  }
  var Jnt = Ve(pB);
  function Znt(e28) {
    try {
      return bt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.sin(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var Qnt = Ve(Znt);
  function tI(e28, t) {
    if (Kt(e28) || Bt(e28)) return tI(e28.values, t);
    V(nt(e28), "The first argument passed into the `some` function must be an array, Series, or DataFrame!"), V(Br(t), "The second argument passed into the `some` function must be a function!");
    for (let r of e28) if (nt(r)) {
      if (tI(r, t)) return true;
    } else if (t(r)) return true;
    return false;
  }
  function mB(e28, t) {
    return uo(e28, { shouldDropNaNs: t, stdev: true }).stdev;
  }
  function tot(e28) {
    return mB(e28);
  }
  function eot(e28) {
    try {
      return bt(e28) ? (typeof e28 == "bigint" && (e28 = Number(e28)), Math.tan(e28)) : NaN;
    } catch {
      return NaN;
    }
  }
  var rot = Ve(eot);
  function pz(e28, t) {
    V(Br(e28), "`fn` must be a function!");
    let r = /* @__PURE__ */ new Date();
    return t ? e28(...t) : e28(), /* @__PURE__ */ new Date() - r;
  }
  async function not(e28, t) {
    V(Br(e28), "`fn` must be a function!");
    let r = /* @__PURE__ */ new Date();
    return t ? await e28(...t) : await e28(), /* @__PURE__ */ new Date() - r;
  }
  function oot() {
    return Oo([...arguments].map((e28) => nt(e28) ? e28 : Kt(e28) || Bt(e28) ? e28.values : [e28]));
  }
  function sot(e28, t) {
    return uo(e28, { shouldDropNaNs: t, variance: true }).variance;
  }
  function iot() {
    let e28 = [], t = Object.values(arguments).map((r) => ((Kt(r) || Bt(r)) && (r = r.values), V(nt(r), "The `zip` function only works on arrays, Series, and DataFrames!"), r));
    return fr(0, lv(t.map((r) => r.length))).forEach((r) => {
      let n = [];
      t.forEach((o) => {
        let s10 = o[r];
        n.push(Ot(s10) ? void 0 : s10);
      }), e28.push(n);
    }), e28;
  }
  var vg = { abs: lI, add: ev, apply: cv, arccos: cnt, arcsin: mnt, arctan: hnt, argmax: jS, argmin: HS, assert: V, cast: so, ceil: gnt, chop: xnt, clamp: bnt, combinations: eB, combinationsIterator: rv, copy: rn, correl: qS, cos: vnt, count: Qw, covariance: Ig, DataFrame: mr, dataTypes: Nnt, decycle: mc, diff: XS, distance: YS, divide: Snt, dot: pa, dropMissing: mI, dropMissingPairwise: Kw, dropNaN: uI, dropNaNPairwise: qw, dropUndefined: Int, every: nv, exp: knt, factorial: Ent, find: ZS, findAll: QS, flatten: ls, float: Dnt, floor: Fnt, identity: _nt, IndexMatcher: pv, indexOf: uf, inferType: Xw, int: Gs, intersect: rB, inverse: Yw, isArray: nt, isBoolean: lc, isBrowser: Pnt, isDataFrame: Kt, isDate: as, isEqual: Vs, isFunction: Br, isJagged: Vg, isNested: uv, isNumber: bt, isObject: Bs, isSeries: Bt, isString: Te, isUndefined: Ot, lerp: Lnt, log: Mnt, MathError: ju, max: lv, mean: znt, median: Bnt, min: Qz, mod: Vnt, mode: Gnt, multiply: iB, ndarray: is, normal: Wnt, ones: Unt, permutations: jnt, permutationsIterator: hI, pow: cI, print: Hnt, product: Wg, random: cf, range: fr, remap: qnt, reshape: Ag, reverse: Ps, round: Ynt, scale: pf, seed: Yz, Series: kn, set: Oo, shape: Ht, shuffle: tv, sign: Jnt, sin: Qnt, some: tI, sort: fc, sqrt: sB, stats: uo, std: mB, stdev: tot, subtract: aB, sum: pI, tan: rot, timeAsync: not, timeSync: pz, time: pz, transpose: xa, union: oot, variance: sot, vectorize: Ve, zeros: fI, zip: iot, dump() {
    let e28 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : void 0;
    if (!e28) throw new vg.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
    Object.keys(vg).forEach((t) => {
      try {
        Object.defineProperty(e28, t, { configurable: false, enumerable: true, writable: false, value: vg[t] });
      } catch {
        e28[t] = vg[t];
      }
    });
  } };
  typeof window < "u" && (window.JSMathTools = vg);
  var aot = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : void 0;
  function eI(e28) {
    let t = Symbol.for("@TypedArrayConstructor"), r = "Symbol(@TypedArrayConstructor)", n = t in e28 ? t : r in e28 ? r : void 0;
    if (n) {
      if (!("values" in e28)) throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");
      return e28[n] === "ArrayBuffer" ? new Uint8Array(e28.values).buffer : new aot[e28[n]](e28.values);
    }
    if (nt(e28) && e28.constructor.name === "Array") return e28;
    throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!");
  }
  function Zm(e28) {
    if (e28 instanceof ArrayBuffer || e28 instanceof BigInt64Array || e28 instanceof BigUint64Array || e28 instanceof Float32Array || e28 instanceof Float64Array || e28 instanceof Int16Array || e28 instanceof Int32Array || e28 instanceof Int8Array || e28 instanceof Uint16Array || e28 instanceof Uint32Array || e28 instanceof Uint8Array || e28 instanceof Uint8ClampedArray) return { [Symbol.for("@TypedArrayConstructor")]: e28.constructor.name, values: e28 instanceof ArrayBuffer ? Array.from(new Uint8Array(e28)) : Array.from(e28) };
    if (nt(e28)) return e28.map((t) => {
      try {
        return Zm(t);
      } catch {
        return t;
      }
    });
    if (typeof e28 == "object" & e28 !== null) {
      if (as(e28)) return new Date(e28.getTime());
      let t = {};
      return Object.keys(e28).forEach((r) => {
        try {
          t[r] = Zm(e28[r]);
        } catch {
          t[r] = e28[r];
        }
      }), t;
    }
    throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.");
  }
  function fB(e28) {
    return e28 = e28.trim(), !!(e28.match(/^-?\d+(\.\d+)?$/g) || e28.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g) || e28.match(/^-?\.\d+$/g) || e28 === "NaN");
  }
  var hB = "!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";
  function dB(e28, t, r) {
    if (typeof e28 != "string") throw new Error("`text` must be a string!");
    if (typeof t != "string") throw new Error("`a` must be a string!");
    if (typeof r != "string") throw new Error("`b` must be a string!");
    return e28.split(t).join(r);
  }
  var mz = "  ";
  var fz = " ";
  function dI(e28) {
    if (typeof e28 != "string") throw new Error("`text` must be a string!");
    let t = "";
    for (let r = 0; r < e28.length; r++) {
      let n = e28[r].toLowerCase();
      hB.includes(n) ? t += fz : t += n;
    }
    for (; t.includes(mz); ) t = dB(t, mz, fz);
    return t.trim();
  }
  function uot(e28, t) {
    return t = t || "", e28.split(`
`).map((r) => r.trim().length > 0 ? t + r : r).join(`
`);
  }
  function lot(e28) {
    if (typeof e28 != "string") throw new Error("`text` must be a string!");
    let t = dI(e28).split(" ");
    return t.length === 0 ? "" : t.length === 1 ? t[0] : t.join("-");
  }
  var hz = { "@Infinity": 1 / 0, "@NegativeInfinity": -1 / 0, "@NaN": NaN, "@undefined": void 0 };
  function Dg(e28) {
    if (typeof e28 == "object") {
      if (e28 === null) return e28;
      if (nt(e28)) for (let t = 0; t < e28.length; t++) e28[t] = Dg(e28[t]);
      else Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).forEach((t) => {
        e28[t] = Dg(e28[t]);
      });
      return e28;
    } else return typeof e28 > "u" || e28 === "Symbol(@undefined)" ? void 0 : e28;
  }
  function cot(e28) {
    if (typeof e28 == "bigint") return e28;
    if (typeof e28 == "string") if (e28.match(/^\s*?-?\d+n\s*?$/g)) try {
      return BigInt(e28.split("n")[0]);
    } catch {
      return NaN;
    }
    else return NaN;
    else return NaN;
  }
  function pot(e28) {
    if (typeof e28 != "string") return typeof e28 == "number" ? e28 : void 0;
    if (fB(e28)) return parseFloat(e28);
  }
  function mot(e28) {
    if (typeof e28 != "string") return;
    let t = "@jrc03c/js-text-tools/newline-replacer";
    if (e28 = e28.replaceAll(`
`, t), e28.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)) {
      let r = e28.replace("Symbol(@String):", "");
      if (r.match(/^".*?"$/g)) try {
        return JSON.parse(r);
      } catch {
        r = r.substring(1, r.length - 1);
      }
      return r = r.replaceAll(t, `
`), r;
    }
  }
  function fot(e28) {
    if (typeof e28 != "string") return typeof e28 == "symbol" ? { out: e28, isASymbol: true } : void 0;
    if (e28.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)) {
      let t = e28.replace(/^.*?Symbol\(/g, "").replace(/\).*?$/g, "");
      return t in hz ? { out: hz[t], isASymbol: true } : { out: Symbol.for(t), isASymbol: true };
    }
  }
  function hot(e28) {
    if (typeof e28 != "string") return e28 instanceof RegExp ? e28 : void 0;
    let t = e28.trim();
    if (t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g)) try {
      let r = t.replace(/^\//g, "").replace(/\/(d|g|i|m|s|u|v|y)*?$/g, ""), n = t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);
      return new RegExp(r, n);
    } catch {
    }
  }
  function dot3(e28) {
    if (typeof e28 != "string") return typeof e28 == "object" ? e28 : "Symbol(@undefined)";
    try {
      let t = JSON.parse(e28, (r, n) => {
        try {
          let o = ov(n);
          return typeof o > "u" ? "Symbol(@undefined)" : o;
        } catch {
          return typeof n > "u" ? "Symbol(@undefined)" : n;
        }
      });
      return nt(t) && (t = Dg(t)), t;
    } catch {
      return e28;
    }
  }
  function got(e28) {
    if (typeof e28 != "string") return e28 instanceof Date && e28.toString() !== "Invalid Date" ? e28 : void 0;
    try {
      let t = new Date(Date.parse(e28));
      if (t.toString() !== "Invalid Date") return t;
    } catch {
    }
  }
  function yot(e28) {
    return typeof e28 == "object" ? e28 !== null ? Dg(e28) : void 0 : (Object.keys(e28).concat(Object.getOwnPropertySymbols(e28)).forEach((t) => {
      try {
        let r = t;
        try {
          t = ov(t);
        } catch {
        }
        e28[t] = ov(e28[r]), t !== r && delete e28[r];
      } catch {
      }
    }), Dg(e28));
  }
  function ov(e28) {
    function t(r) {
      if (typeof r == "string") {
        let n = mot(r);
        if (typeof n == "string") return n;
        let o = fot(r);
        return n = o ? o.out : void 0, o && o.isASymbol || (n = hot(r), n instanceof RegExp) || (n = cot(r), typeof n == "bigint") || (n = pot(r), typeof n == "number") || (n = got(r), n instanceof Date) ? n : (n = dot3(r), typeof n < "u" ? n === "Symbol(@undefined)" ? void 0 : n : r);
      }
      if (typeof r == "object") {
        if (r === null) return null;
        let n;
        try {
          if (n = eI(r), nt(n)) return n;
        } catch {
        }
        if (n = yot(r), n) try {
          return eI(n);
        } catch {
          return n;
        }
        return r;
      }
      return r;
    }
    return t(e28);
  }
  function xot(e28) {
    let t = Wz(e28);
    return t[0].toUpperCase() + t.slice(1);
  }
  function bot(e28) {
    if (typeof e28 != "string") throw new Error("`text` must be a string!");
    let t = dI(e28).split(" ");
    return t.length === 0 ? "" : t.length === 1 ? t[0] : t.join("_");
  }
  function Wu(e28, t) {
    return !e28 || t <= 0 ? "" : fr(0, t).map(() => e28).join("");
  }
  function gB(e28, t) {
    V(Te(t) || Ot(t), "The second parameter to the `stringify` function must be undefined or a string!");
    let r = t ? `
` : "";
    function n(o, s10, i) {
      return i = i || 0, typeof o == "bigint" ? JSON.stringify(o.toString() + "n") : typeof o == "number" ? o === 1 / 0 ? '"Symbol(@Infinity)"' : o === -1 / 0 ? '"Symbol(@NegativeInfinity)"' : isNaN(o) ? '"Symbol(@NaN)"' : o.toString() : typeof o == "string" ? JSON.stringify("Symbol(@String):" + o) : typeof o == "boolean" ? o.toString() : typeof o > "u" ? '"Symbol(@undefined)"' : typeof o == "symbol" || typeof o == "function" ? JSON.stringify(o.toString()) : o instanceof RegExp ? o.toString() : typeof o == "object" ? o === null ? "null" : as(o) ? JSON.stringify(o.toJSON()) : nt(o) ? o.length === 0 ? Wu(s10, i - 1) + "[]" : o instanceof Array ? Wu(s10, i - 1) + "[" + r + o.map((a) => {
        let u = (() => {
          try {
            return n(Zm(a), s10, i + 1);
          } catch {
            return n(a, s10, i + 1);
          }
        })();
        return Te(u) && (u = u.trim()), Wu(s10, i + 1) + u;
      }).join("," + r) + r + Wu(s10, i) + "]" : n(Zm(o), null, s10) : Object.keys(o).length + Object.getOwnPropertySymbols(o).length === 0 ? Wu(s10, i - 1) + "{}" : Wu(s10, i - 1) + "{" + r + Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map((a) => {
        let u = (() => {
          try {
            return n(Zm(o[a]), s10, i + 1);
          } catch {
            return n(o[a], s10, i + 1);
          }
        })();
        Te(u) && (u = u.trim());
        let l = typeof a == "symbol" ? n(a) : JSON.stringify(a);
        return Wu(s10, i + 1) + l + ":" + (s10 ? " " : "") + u;
      }).join("," + r) + r + Wu(s10, i) + "}" : "undefined";
    }
    return n(mc(e28), t);
  }
  function wot(e28) {
    let t = e28.split(`
`), r = t.filter((o) => o.trim().length > 0).map((o) => o.split("").findIndex((s10) => !s10.match(/\s/g))), n = Math.min(...r);
    return t.map((o) => o.substring(n)).join(`
`);
  }
  function vot(e28, t) {
    if (typeof e28 != "string") throw new Error("The first argument to the `wrap` function must be a string!");
    if ((typeof t > "u" || t === null) && (typeof process < "u" && typeof process.stdout < "u" && typeof process.stdout.columns == "number" ? t = process.stdout.columns > 80 ? 80 : process.stdout.columns : t = 80), isNaN(t) || typeof t != "number") throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");
    let r = [];
    return e28.split(`
`).forEach((n) => {
      if (n.trim().length === 0) return r.push("");
      let o = n.split(/[^\s]/g)[0], s10 = n.replace(o, "").split(" "), i = o;
      s10.forEach((a) => {
        let u = i + (i.trim().length > 0 ? " " : "") + a;
        u.length > t ? (r.push(i), i = o + a) : i = u;
      }), i.length > 0 && r.push(i);
    }), r.join(`
`);
  }
  typeof window < "u" && (window.JSTextTools = { camelify: Wz, convertObjectToTypedArray: eI, convertTypedArrayToObject: Zm, indent: uot, isANumberString: fB, kebabify: lot, parse: ov, pascalify: xot, punctuation: hB, replaceAll: dB, snakeify: bot, stringify: gB, strip: dI, unindent: wot, wrap: vot });
  function yB(e28, t) {
    t = t || {};
    let r = at(t.maxUniqueValues) ? t.maxUniqueValues : 7, n = at(t.minNonMissingValues) ? t.minNonMissingValues : 15, o = at(t.maxCorrelationThreshold) ? t.maxCorrelationThreshold : 1 - 1e-5, s10 = t.progress || null;
    if (tt(e28)) return O(Nt(e28).length === 2 && !Ro(e28), "The `convertToNumerical` function only works on non-jagged 2-dimensional arrays and DataFrames!"), yB(new se(e28));
    O(ft(e28), "You must pass a DataFrame into the `convertToNumerical` function!"), O(ha(r), "`maxUniqueValues` must be a whole number!"), O(ha(n), "`minNonMissingValues` must be a whole number!"), O(at(o), "`maxCorrelationThreshold` must be a number!"), pt(s10) || O(yr(s10), "If defined, `progress` must be a function!");
    let i = {}, a = true;
    return e28.apply((u, l) => {
      s10 && s10(l / e28.columns.length);
      let c = Sg(u.values);
      if (c.type === "boolean" && (c.values = c.values.map((m) => m ? 1 : 0)), c.type === "date" && (c.values = c.values.map((m) => {
        try {
          return m.getTime();
        } catch {
          return NaN;
        }
      })), c.type === "null") return;
      c.type === "number" || c.type, c.type === "object" && (c.values = c.values.map((m) => gB(m))), c.type;
      let p = c.values.filter((m) => !pt(m));
      if (!(c.values.length - p.length > n.length)) {
        if (c.type !== "boolean") {
          let m = zs(ef(p).toArray().filter((h) => !pt(h.value) && at(h.count)), (h, d) => d.count - h.count);
          if (ya(m.slice(0, r).map((h) => h.count), a) / p.length >= 0.9) {
            if (m.length < 2) return;
            let h = aI(u.name, c.values);
            for (; Object.keys(h).length > 0; ) {
              let d = Object.keys(h)[0], g = h[d];
              delete h[d];
              let y = Object.keys(i);
              for (let b = 0; b < y.length; b++) {
                let v = i[y[b]];
                if (Hu(g, v, a) > o) return;
              }
              i[d] = g;
            }
            return;
          }
          if (c.type === "object" || c.type === "string") return;
        }
        if (c.type === "boolean" || c.type === "date" || c.type === "number" || c.type === "bigint") {
          let m = Object.keys(i);
          for (let f = 0; f < m.length; f++) {
            let h = i[m[f]];
            if (Hu(c.values, h, a) > o) return;
          }
          i[u.name] = c.values;
        }
      }
    }), new se(i);
  }
  function xB(e28) {
    if (gt(e28)) {
      let o = new se(xB(e28.values));
      return o.index = e28.index.slice(), o.columns = e28.index.slice(), o;
    }
    O(tt(e28), "The `diagonalize` function only works on 1-dimensional arrays and Series!");
    let t = Nt(e28);
    O(t.length === 1, "The `diagonalize` function only works on 1-dimensional arrays and Series!");
    let r = e28.every((o) => typeof o == "bigint"), n = af([t[0], t[0]]);
    if (e28.forEach((o, s10) => n[s10][s10] = o), r) for (let o = 0; o < n.length; o++) for (let s10 = 0; s10 < n[o].length; s10++) try {
      n[o][s10] = BigInt(n[o][s10]);
    } catch {
    }
    return n;
  }
  function _S(e28) {
    let t = "@jrc03c/js-data-science-helpers/get-correlation-matrix";
    return Object.defineProperty(e28, t, { configurable: false, enumerable: false, writable: false, value: Symbol.for(t) }), e28;
  }
  function rI(e28, t, r) {
    if (pt(t) && (t = e28), ft(e28)) {
      let o = new se(rI(e28.values, t));
      return o.index = e28.columns.slice(), o.columns = ft(t) ? t.columns.slice() : new se(t).columns.slice(), _S(o);
    }
    if (ft(t)) {
      let o = new se(rI(e28, t.values));
      return o.index = ft(e28) ? e28.columns.slice() : new se(e28).columns.slice(), o.columns = t.columns.slice(), _S(o);
    }
    O(tt(e28) && tt(t), "The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"), O(!Ro(e28) && !Ro(t), "The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"), O(e28.length === t.length, 'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');
    let n = io([e28[0].length, t[0].length]);
    for (let o = 0; o < e28[0].length; o++) {
      let s10 = e28.map((i) => i[o]);
      for (let i = 0; i < t[0].length; i++) {
        let a = t.map((u) => u[i]);
        r ? n[o][i] = Hu(...Uu(s10, a)) : n[o][i] = Hu(s10, a);
      }
    }
    return _S(av(n, -1, 1));
  }
  function Not(e28, t, r) {
    t = pt(t) ? 1 - 1e-5 : t, ft(e28) || (e28 = new se(e28));
    let n = Nt(e28);
    O((tt(e28) || ft(e28)) && n.length === 2, "The first argument passed into the `getHighlyCorrelatedColumns` function must be a 2-dimensional array or DataFrame!"), O(at(t) && t >= -1 && t <= 1, "The second argument passed into the `getHighlyCorrelatedColumns` must be a number in the range [-1, 1] representing the threshold above which two columns will be considered to be highly correlated!");
    let o = {};
    r && (e28 = e28.dropNaN());
    for (let s10 = 0; s10 < n[1] - 1; s10++) for (let i = s10 + 1; i < n[1]; i++) {
      let a = e28.columns[s10], u = e28.columns[i], l = Hu(e28.get(a), e28.get(u));
      l > t && (o[a] || (o[a] = []), o[a].push({ column: u, correlation: l }), o[u] || (o[u] = []), o[u].push({ column: a, correlation: l }));
    }
    return Object.keys(o).forEach((s10) => {
      o[s10] = zs(o[s10], (i, a) => i.column < a.column ? -1 : 1);
    }), o;
  }
  function gI(e28, t) {
    return ft(e28) || gt(e28) ? gI(e28.values) : at(e28) ? ga(e28) : tt(e28) ? (t && (e28 = Og(e28)), Mg(ya(Ku(e28, 2)))) : NaN;
  }
  function Cot(e28, t) {
    let r = He(e28, { shouldDropNaNs: t }), n = t ? r.nWithoutNaNs : r.n;
    return r.counts.values.filter((o) => at(o) || !t).map((o) => {
      let s10 = r.counts.get(o);
      return { value: o, count: s10, percentage: s10 / n };
    });
  }
  var dz = [0.5, 0.49601, 0.49202, 0.48803, 0.48405, 0.48006, 0.47608, 0.4721, 0.46812, 0.46414, 0.46017, 0.4562, 0.45224, 0.44828, 0.44433, 0.44038, 0.4364, 0.43251, 0.42858, 0.42465, 0.42074, 0.41683, 0.41294, 0.40905, 0.40517, 0.40129, 0.39743, 0.39358, 0.38974, 0.38591, 0.38209, 0.37828, 0.37448, 0.3707, 0.36693, 0.36317, 0.35942, 0.35569, 0.35197, 0.34827, 0.34458, 0.3409, 0.33724, 0.3336, 0.32997, 0.32636, 0.32276, 0.31918, 0.31561, 0.31207, 0.30854, 0.30503, 0.30153, 0.29806, 0.2946, 0.29116, 0.28774, 0.28434, 0.28096, 0.2776, 0.27425, 0.27093, 0.26763, 0.26435, 0.26109, 0.25785, 0.25463, 0.25143, 0.24825, 0.2451, 0.24196, 0.23885, 0.23576, 0.2327, 0.22965, 0.22663, 0.22363, 0.22065, 0.2177, 0.21476, 0.21186, 0.20897, 0.20611, 0.20327, 0.20045, 0.19766, 0.19489, 0.19215, 0.18943, 0.18673, 0.18406, 0.18141, 0.17879, 0.17619, 0.17361, 0.17106, 0.16853, 0.16602, 0.16354, 0.16109, 0.15866, 0.15625, 0.15386, 0.15151, 0.14917, 0.14686, 0.14457, 0.14231, 0.14007, 0.13786, 0.13567, 0.1335, 0.13136, 0.12924, 0.12714, 0.12507, 0.12302, 0.121, 0.119, 0.11702, 0.11507, 0.11314, 0.11123, 0.10935, 0.10749, 0.10565, 0.10383, 0.10204, 0.10027, 0.09853, 0.0968, 0.0951, 0.09342, 0.09176, 0.09012, 0.08851, 0.08692, 0.08534, 0.08379, 0.08226, 0.08076, 0.07927, 0.0778, 0.07636, 0.07493, 0.07353, 0.07215, 0.07078, 0.06944, 0.06811, 0.06681, 0.06552, 0.06426, 0.06301, 0.06178, 0.06057, 0.05938, 0.05821, 0.05705, 0.05592, 0.0548, 0.0537, 0.05262, 0.05155, 0.0505, 0.04947, 0.04846, 0.04746, 0.04648, 0.04551, 0.04457, 0.04363, 0.04272, 0.04182, 0.04093, 0.04006, 0.0392, 0.03836, 0.03754, 0.03673, 0.03593, 0.03515, 0.03438, 0.03362, 0.03288, 0.03216, 0.03144, 0.03074, 0.03005, 0.02938, 0.02872, 0.02807, 0.02743, 0.0268, 0.02619, 0.02559, 0.025, 0.02442, 0.02385, 0.0233, 0.02275, 0.02222, 0.02169, 0.02118, 0.02068, 0.02018, 0.0197, 0.01923, 0.01876, 0.01831, 0.01786, 0.01743, 0.017, 0.01659, 0.01618, 0.01578, 0.01539, 0.015, 0.01463, 0.01426, 0.0139, 0.01355, 0.01321, 0.01287, 0.01255, 0.01222, 0.01191, 0.0116, 0.0113, 0.01101, 0.01072, 0.01044, 0.01017, 99e-4, 964e-5, 939e-5, 914e-5, 889e-5, 866e-5, 842e-5, 82e-4, 798e-5, 776e-5, 755e-5, 734e-5, 714e-5, 695e-5, 676e-5, 657e-5, 639e-5, 621e-5, 604e-5, 587e-5, 57e-4, 554e-5, 539e-5, 523e-5, 508e-5, 494e-5, 48e-4, 466e-5, 453e-5, 44e-4, 427e-5, 415e-5, 402e-5, 391e-5, 379e-5, 368e-5, 357e-5, 347e-5, 336e-5, 326e-5, 317e-5, 307e-5, 298e-5, 289e-5, 28e-4, 272e-5, 264e-5, 256e-5, 248e-5, 24e-4, 233e-5, 226e-5, 219e-5, 212e-5, 205e-5, 199e-5, 193e-5, 187e-5, 181e-5, 175e-5, 169e-5, 164e-5, 159e-5, 154e-5, 149e-5, 144e-5, 139e-5, 135e-5, 131e-5, 126e-5, 122e-5, 118e-5, 114e-5, 111e-5, 107e-5, 104e-5, 1e-3, 97e-5, 94e-5, 9e-4, 87e-5, 84e-5, 82e-5, 79e-5, 76e-5, 74e-5, 71e-5, 69e-5, 66e-5, 64e-5, 62e-5, 6e-4, 58e-5, 56e-5, 54e-5, 52e-5, 5e-4, 48e-5, 47e-5, 45e-5, 43e-5, 42e-5, 4e-4, 39e-5, 38e-5, 36e-5, 35e-5, 34e-5, 32e-5, 31e-5, 3e-4, 29e-5, 28e-5, 27e-5, 26e-5, 25e-5, 24e-5, 23e-5, 22e-5, 22e-5, 21e-5, 2e-4, 19e-5, 19e-5, 18e-5, 17e-5, 17e-5, 16e-5, 15e-5, 15e-5, 14e-5, 14e-5, 13e-5, 13e-5, 12e-5, 12e-5, 11e-5, 11e-5, 1e-4, 1e-4, 1e-4, 9e-5, 9e-5, 8e-5, 8e-5, 8e-5, 8e-5, 7e-5, 7e-5, 7e-5, 6e-5, 6e-5, 6e-5, 6e-5, 5e-5, 5e-5, 5e-5, 5e-5, 5e-5, 4e-5, 4e-5, 4e-5, 4e-5, 4e-5, 4e-5, 3e-5, 3e-5, 3e-5, 3e-5, 3e-5, 3e-5, 3e-5, 3e-5, 2e-5, 2e-5, 2e-5, 2e-5];
  function Sot(e28) {
    return ga(e28) > 4.1 ? 0 : dz[zz(Mz(ga(e28), 0, 4.1, 0, dz.length))];
  }
  function $g(e28, t, r) {
    if (ft(e28) || gt(e28)) return $g(e28.values, t);
    if (ft(t) || gt(t)) return $g(e28, t.values);
    O(tt(e28) && tt(t) && En(Nt(e28), Nt(t)), "You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");
    let [n, o] = r ? Uu(zr(e28), zr(t)) : [zr(e28), zr(t)];
    if (n.length === 0 || o.length === 0) return NaN;
    let s10 = He(n, { stdev: true }), i = He(o, { stdev: true }), a = s10.mean, u = i.mean, l = s10.stdev, c = i.stdev, p = n.length, m = o.length, f = (a - u) / Mg(l * l / p + c * c / m);
    return 2 * Sot(f);
  }
  function OS(e28) {
    let t = "@jrc03c/js-data-science-helpers/get-p-value-matrix";
    return Object.defineProperty(e28, t, { configurable: false, enumerable: false, writable: false, value: Symbol.for(t) }), e28;
  }
  function nI(e28, t, r) {
    if (pt(t) && (t = e28), ft(e28)) {
      let o = new se(nI(e28.values, t));
      return o.index = e28.columns.slice(), o.columns = ft(t) ? t.columns.slice() : new se(t).columns.slice(), OS(o);
    }
    if (ft(t)) {
      let o = new se(nI(e28, t.values));
      return o.index = ft(e28) ? e28.columns.slice() : new se(e28).columns.slice(), o.columns = t.columns.slice(), OS(o);
    }
    O(tt(e28) && tt(t), "The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"), O(!Ro(e28) && !Ro(t), "The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"), O(e28.length === t.length, 'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');
    let n = io([e28[0].length, t[0].length]);
    for (let o = 0; o < e28[0].length; o++) {
      let s10 = e28.map((i) => i[o]);
      for (let i = 0; i < t[0].length; i++) {
        let a = t.map((u) => u[i]);
        r ? n[o][i] = $g(...Uu(s10, a)) : n[o][i] = $g(s10, a);
      }
    }
    return OS(av(n, 0, 1));
  }
  function bB(e28) {
    if (tt(e28)) {
      O(Nt(e28).length === 2 && !Ro(e28), "The `hunterChainSort` function only works on non-jagged 2-dimensional arrays and DataFrames!");
      let i = new se(e28);
      return i.index = i.columns.slice(), bB(i).values;
    }
    O(ft(e28), "You must pass a 2-dimensional array or DataFrame into the `hunterChainSort` function!");
    let t = true, r = e28.index.slice(), n = [];
    for (; r.length > 1; ) if (n.length === 0) {
      let i = r[Eg(r.map((a) => ya(Ku(e28.values[e28.index.indexOf(a)], 2), t)), t)];
      r.splice(r.indexOf(i), 1), n.push(i);
    } else {
      let i = n.at(-1), a = e28.values[e28.index.indexOf(i)].filter((l, c) => r.includes(e28.index[c])), u = r[Eg(a, t)];
      r.splice(r.indexOf(u), 1), n.push(u);
    }
    n.push(r[0]);
    let o = ss(n);
    return e28.get(o, null);
  }
  var Iot = class Ng {
    static DROP_NAN_MODE = "DROP_NAN_MODE";
    static DROP_MISSING_MODE = "DROP_MISSING_MODE";
    constructor(t) {
      let r = this;
      O(pt(t) || t === Ng.DROP_NAN_MODE || t === Ng.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"), r.mode = pt(t) ? Ng.DROP_MISSING_MODE : t, r.index = null;
    }
    fit() {
      let t = this, r = [];
      return Object.values(arguments).forEach((n) => {
        O(ft(n) || gt(n), "The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."), t.mode === Ng.DROP_MISSING_MODE ? r.push(n.dropMissing().index) : r.push(n.dropNaN().index);
      }), t.index = oI(...r), t;
    }
    transform() {
      let t = this;
      O(!!t.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      let r = Object.values(arguments).map((n) => (O(ft(n) || gt(n), "The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."), n.get(t.index, null)));
      return r.length === 1 ? r[0] : r;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  function wB(e28, t) {
    if (typeof e28 == "number") return e28 === 0 || e28 === 1;
    if (typeof e28 == "bigint") return e28 === 0n || e28 === 1n;
    if (ft(e28) || gt(e28)) return wB(e28.values, t);
    if (tt(e28)) {
      t && (e28 = Og(e28));
      let n = ef(e28).values.toSorted();
      return n.length === 2 && Number(n[0]) === 0 && Number(n[1]) === 1 || n.length === 1 && (Number(n[0]) === 0 || Number(n[0]) === 1);
    }
    return false;
  }
  function Tot(e28) {
    try {
      let t = "@jrc03c/js-data-science-helpers/get-correlation-matrix";
      if (e28[t] === Symbol.for(t)) return true;
      let r = He(e28, { shouldDropNaNs: true });
      return r.min >= -1 && r.max <= 1;
    } catch {
      return false;
    }
  }
  function kot(e28, t) {
    (ft(e28) || gt(e28)) && (e28 = e28.values), (ft(t) || gt(t)) && (t = t.values), O(En(Nt(e28), Nt(t)), "`yPred` and `yTrue` must have the same shape!");
    let r = zr(e28), n = zr(t), o = 0;
    return r.forEach((s10, i) => {
      s10 === n[i] && o++;
    }), o / r.length;
  }
  function yI(e28) {
    return tt(e28) && Nt(e28).length === 2;
  }
  function Eot(e28, t) {
    return e28.map((r) => t[sf(t.map((n) => cc(r, n)))]);
  }
  function cc(e28, t) {
    return ya(Ku(Xu(e28, t), 2), true);
  }
  var vB = class {
    constructor(e28) {
      O(typeof e28 == "object", "`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."), O(ha(e28.k), "`k` must be a whole number!"), O(ha(e28.maxIterations) || pt(e28.maxIterations), "`maxIterations` must be a whole number or undefined!"), O(ha(e28.maxRestarts) || pt(e28.maxRestarts), "`maxRestarts` must be a whole number or undefined!"), O(typeof e28.tolerance == "number" || pt(e28.tolerance), "`tolerance` must be a number or undefined!"), this.k = e28.k, this.maxRestarts = e28.maxRestarts || 25, this.maxIterations = e28.maxIterations || 100, this.tolerance = e28.tolerance || 1e-4, this.centroids = null;
    }
    initializeCentroids(e28) {
      return nf(e28).slice(0, this.k);
    }
    getFitStepFunction(e28, t) {
      O(yI(e28), "`x` must be a matrix!"), ft(e28) && (e28 = e28.values), pt(t) || O(yr(t), "If defined, `progress` must be a function!");
      let r = this.initializeCentroids(e28), n = { currentRestart: 0, currentIteration: 0, currentCentroids: r, bestCentroids: r, bestScore: -1 / 0, isFinished: false };
      return () => {
        let o = this.predict(e28, n.currentCentroids), s10 = [], i = af(this.k);
        e28.forEach((u, l) => {
          let c = o[l];
          s10[c] || (s10[c] = af(u.length)), s10[c] = of(s10[c], u), i[c]++;
        });
        let a = ze(0, this.k).map((u) => i[u] === 0 ? of(n.currentCentroids[Math.floor(da() * n.currentCentroids.length)], qu(1e-3, Lz(n.currentCentroids[0].length))) : zg(s10[u], i[u]));
        if (cc(n.currentCentroids, a) < this.tolerance ? n.currentIteration = this.maxIterations - 1 : n.currentCentroids = a, t && t((n.currentRestart + n.currentIteration / this.maxIterations) / this.maxRestarts, this), n.currentIteration++, n.currentIteration >= this.maxIterations) {
          let u = this.score(e28, n.currentCentroids);
          if (u > n.bestScore && (n.bestScore = u, n.bestCentroids = Mr(n.currentCentroids)), n.currentIteration = 0, n.currentRestart++, n.currentRestart >= this.maxRestarts) n.isFinished = true, this.centroids = n.bestCentroids, t && t(1, this);
          else {
            let l = this.initializeCentroids(e28);
            n.currentCentroids = l;
          }
        }
        return n;
      };
    }
    fit(e28, t) {
      let r = this.getFitStepFunction(e28, t), n;
      for (; !n || !n.isFinished; ) n = r();
      return this;
    }
    predict(e28, t) {
      if (t = t || this.centroids, !t) throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");
      return e28.map((r) => sf(t.map((n) => cc(r, n))));
    }
    score(e28, t) {
      if (t = t || this.centroids, !t) throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");
      let n = this.predict(e28, t).map((o) => t[o]);
      return -cc(e28, n);
    }
  };
  var NB = class extends vB {
    initializeCentroids(e28) {
      let r = [e28[Math.floor(da() * e28.length)]];
      for (; r.length < this.k; ) {
        let n = e28.map((s10) => cc(s10, r[sf(r.map((i) => cc(s10, i)), true)])), o = zg(n, Pg(n, true));
        r.push(e28[o.findIndex((s10) => da() < s10)]);
      }
      return r;
    }
  };
  var Aot = class {
    constructor(e28) {
      pt(e28) && (e28 = {}), O(typeof e28 == "object", "`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."), pt(e28.ks) && (e28.ks = ze(1, 16)), O(tt(e28.ks), "`ks` must be an array of whole numbers!"), e28.ks.forEach((t) => {
        O(ha(t), "`ks` must be an array of whole numbers!");
      }), O(ha(e28.maxIterations) || pt(e28.maxIterations), "`maxIterations` must be a whole number or undefined!"), O(ha(e28.maxRestarts) || pt(e28.maxRestarts), "`maxRestarts` must be a whole number or undefined!"), O(typeof e28.tolerance == "number" || pt(e28.tolerance), "`tolerance` must be a number or undefined!"), this.ks = e28.ks, this.maxRestarts = e28.maxRestarts || 25, this.maxIterations = e28.maxIterations || 100, this.tolerance = e28.tolerance || 1e-4, this.scoreStopRatio = e28.scoreStopRatio || 0.85, this.modelClass = e28.modelClass || NB, this.fittedModel = null;
    }
    getFitStepFunction(e28, t) {
      O(yI(e28), "`x` must be a matrix!"), ft(e28) && (e28 = e28.values), pt(t) || O(yr(t), "If defined, `progress` must be a function!");
      let r = { isFinished: false, lastScore: -1 / 0, currentIndex: 0 };
      return () => {
        let n = this.ks[r.currentIndex], o = new this.modelClass({ k: n, maxRestarts: 10, maxIterations: 20 });
        o.fit(e28, (i) => t ? t((r.currentIndex + i) / (this.ks.length + 1)) : null);
        let s10 = o.score(e28);
        return s10 / r.lastScore > this.scoreStopRatio ? (r.isFinished = true, r.currentIndex--) : (r.lastScore = s10, r.currentIndex + 1 >= this.ks.length ? r.isFinished = true : r.currentIndex++), r.isFinished && (this.fittedModel = new this.modelClass({ k: this.ks[r.currentIndex], maxRestarts: this.maxRestarts, maxIterations: this.maxIterations }), this.fittedModel.fit(e28, (i) => t ? t((this.ks.length + i) / (this.ks.length + 1)) : null), t && t(1)), r;
      };
    }
    fit(e28, t) {
      let r = this.getFitStepFunction(e28, t), n;
      for (; !n || !n.isFinished; ) n = r();
      return this;
    }
    predict(e28, t) {
      return this.fittedModel.predict(e28, t);
    }
    score(e28, t) {
      return this.fittedModel.score(e28, t);
    }
    get k() {
      return this.fittedModel.k;
    }
    set k(e28) {
      throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.");
    }
    get centroids() {
      return this.fittedModel.centroids;
    }
    set centroids(e28) {
      O(En(Nt(e28), Nt(this.fittedModel.centroids)), "When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"), this.fittedModel.centroids = e28;
    }
  };
  var Dot = { accuracy: kot, isMatrix: yI, orderCentroids: Eot, sse: cc };
  var Ug = { helpers: Dot, KMeansMeta: Aot, KMeansNaive: vB, KMeansPlusPlus: NB };
  function xI(e28, t) {
    if (ft(e28) || gt(e28)) {
      let s10 = e28.copy();
      return s10.values = xI(s10.values), s10;
    }
    O(tt(e28), "The `normalize` function only works on arrays, Series, and DataFrames!");
    let r = He(e28, { shouldDropNaNs: t, stdev: true }), n = r.mean, o = r.stdev;
    return pc(e28, (s10) => (Number(s10) - n) / o);
  }
  function Tg(e28, t) {
    if (gt(e28)) {
      if (gt(t)) return new qr(Tg(e28.values, t.values));
      {
        let r = e28.copy();
        return r.values = Tg(e28.values, t), r;
      }
    }
    if (gt(t)) {
      let r = t.copy();
      return r.values = Tg(e28, t.values), r;
    }
    return O(tt(e28), "`project` only works on vectors!"), O(tt(t), "`project` only works on vectors!"), O(Nt(e28).length === 1, "`project` only works on vectors!"), O(Nt(t).length === 1, "`project` only works on vectors!"), qu(Number(os(t, e28)) / Number(os(t, t)), t);
  }
  function CB(e28) {
    if (ft(e28)) {
      let s10 = new se(CB(e28.values));
      return s10.index = e28.index.slice(), s10.columns = e28.columns.slice(), s10;
    }
    O(tt(e28) && !Ro(e28) && Nt(e28).length === 2, "`orthonormalize` only works on matrices!");
    let t = ao(e28), r = [];
    t.forEach((s10) => {
      let i = s10;
      r.forEach((a) => {
        i = Xu(i, Tg(i, a));
      }), r.push(i);
    });
    let n = true, o = r.map((s10) => zg(s10, gI(s10, n)));
    return ao(o);
  }
  function $ot(e28) {
    let t = e28.counts.values;
    return t.length < 3 && (t.length === 2 && En(t.toSorted(), [0, 1]) || t.length === 1 && (t[0] === 0 || t[0] === 1));
  }
  function gz(e28) {
    let t = [];
    return e28.counts.values.forEach((r) => {
      if (at(r)) {
        let n = e28.counts.get(r);
        for (let o = 0; o < n; o++) t.push(r);
      }
    }), t;
  }
  var Fot = class {
    constructor(e28) {
      e28 = e28 || {}, this.isAllowedToClip = pt(e28.isAllowedToClip) ? true : e28.isAllowedToClip, this.isAllowedToTakeTheLog = pt(e28.isAllowedToTakeTheLog) ? false : e28.isAllowedToTakeTheLog, this.maxScore = e28.maxScore || 5, O(Ls(this.isAllowedToClip), "The `isAllowedToClip` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"), O(Ls(this.isAllowedToTakeTheLog), "The `isAllowedToTakeTheLog` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"), O(at(this.maxScore) && this.maxScore >= 0, "The `maxScore` property on the options object passed into the `OutlierMitigator` constructor must have a non-negative number value!"), this.mad = 0, this.median = 0;
    }
    fit(e28) {
      if (ft(e28) || gt(e28)) return this.fit(e28.values);
      if (O(tt(e28), "The `OutlierMitigator.fit` method only works on arrays, Series, and DataFrames!"), e28.length === 0) return;
      let t = He(e28, { shouldDropNaNs: true, median: true });
      if ($ot(t)) return this;
      let r = gz(t);
      return this.median = Number(t.median), this.mad = Number(He(ga(Xu(r, this.median)), { median: true }).median), this;
    }
    fitAndTransform() {
      return this.fit(arguments[0]).transform(...arguments);
    }
    transform() {
      if (arguments.length > 1) return Array.from(arguments).map((s10) => this.transform(s10));
      let e28 = arguments[0];
      if (ft(e28) || gt(e28)) return this.transform(e28.values);
      O(tt(e28), "The `OutlierMitigator.transform` method only works on arrays, Series, and DataFrames!");
      let t = He(e28, { shouldDropNaNs: true }), r = gz(t), n = false;
      if (this.mad === 0) {
        let s10 = [], i = [], a = -1 / 0, u = 1 / 0;
        r.forEach((p) => {
          p < this.median ? (s10.push(p), p > a && (a = p)) : p > this.median && (i.push(p), p < u && (u = p));
        });
        let l = this.median, c = this.median;
        if (s10.length > 0 && (l = a), i.length > 0 && (c = u), this.mad = (c - l) / 2, this.mad === 0) return e28;
        n = (this.median - l) / this.mad > this.maxScore || (c - this.median) / this.mad > this.maxScore;
      }
      if (He(zg(ga(Xu(r, this.median)), this.mad)).max > this.maxScore || n) {
        let s10 = null, i = Mr(e28);
        return this.isAllowedToClip && (i = pc(i, (a) => (a = at(a) ? av(a, this.median - this.maxScore * this.mad, this.median + this.maxScore * this.mad) : a, this.isAllowedToTakeTheLog && at(a) && (s10 === null || a < s10) && (s10 = a), a))), this.isAllowedToTakeTheLog && (s10 === null && (s10 = He(i).min), i = pc(i, (a) => at(a) ? Oz(a - s10 + 1) : a)), i;
      } else return e28;
    }
  };
  function sv(e28, t, r) {
    if (ft(e28) || gt(e28)) return sv(e28.values, t);
    if (ft(t) || gt(t)) return sv(e28, t.values);
    if (O(tt(e28), "You must pass two same-shaped numerical arrays into the `rSquared` function!"), O(tt(t), "You must pass two same-shaped numerical arrays into the `rSquared` function!"), O(En(Nt(e28), Nt(t)), "You must pass two same-shaped numerical arrays into the `rSquared` function!"), r) {
      let s10 = Uu(e28, t);
      e28 = s10[0], t = s10[1];
    }
    let n = Number(ya(Ku(Xu(e28, t), 2))), o = Number(ya(Ku(Xu(e28, Rz(e28)), 2)));
    return o === 0 ? NaN : 1 - n / o;
  }
  function _ot(e28, t, r) {
    let n = sv(e28, t, r);
    return Vz(n) * Mg(ga(n));
  }
  function Oot() {
    return xI(...arguments);
  }
  var Rot = class {
    constructor(e28) {
      e28 = e28 || {}, this.means = [], this.stdevs = [], this.wasFittedOnAVector = false, this.hasBeenFitted = false, this.shouldIgnoreNaNs = typeof e28.shouldIgnoreNaNs > "u" ? false : e28.shouldIgnoreNaNs;
    }
    _getDataArrayAndShape(e28) {
      if (ft(e28)) return [e28.values, e28.shape];
      if (gt(e28)) {
        let r = ao([e28.values]);
        return [r, Nt(r)];
      }
      O(tt(e28), "`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");
      let t = Nt(e28);
      return O(t.length < 3, "`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"), t.length === 1 && (t.push(1), e28 = ao([e28])), [e28, t];
    }
    fit(e28) {
      let t = this._getDataArrayAndShape(e28);
      e28 = t[0];
      let r = t[1];
      return this.wasFittedOnAVector = r.indexOf(1) > -1, this.means = [], this.stdevs = [], ze(0, r[1]).forEach((n) => {
        let o = e28.map((i) => i[n]), s10 = He(o, { shouldDropNaNs: this.shouldIgnoreNaNs, stdev: true });
        this.means.push(s10.mean), this.stdevs.push(s10.stdev);
      }), this.hasBeenFitted = true, this;
    }
    fitAndTransform() {
      return this.fit(arguments[0]).transform(...arguments);
    }
    transform() {
      let e28 = Array.from(arguments);
      if (e28.length > 1) return e28.map((s10) => this.transform(s10));
      let t = e28[0];
      if (!this.hasBeenFitted) throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");
      if (ft(t)) {
        let s10 = new se(this.transform(t.values));
        return s10.columns = t.columns, s10.index = t.index, s10;
      }
      if (gt(t)) {
        let s10 = new qr(this.transform(t.values));
        return s10.name = t.name, s10.index = t.index, s10;
      }
      let r = this._getDataArrayAndShape(t);
      t = r[0];
      let n = r[1];
      O(n[1] === this.means.length, "The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");
      let o = t.map((s10) => s10.map((i, a) => (Number(i) - Number(this.means[a])) / Number(this.stdevs[a])));
      return this.wasFittedOnAVector ? zr(o) : o;
    }
    untransform(e28) {
      if (!this.hasBeenFitted) throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");
      if (ft(e28)) {
        let o = new se(this.untransform(e28.values));
        return o.columns = e28.columns, o.index = e28.index, o;
      }
      if (gt(e28)) {
        let o = new qr(this.untransform(e28.values));
        return o.name = e28.name, o.index = e28.index, o;
      }
      let t = this._getDataArrayAndShape(e28);
      e28 = t[0];
      let r = t[1];
      O(r[1] === this.means.length, "The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");
      let n = e28.map((o) => o.map((s10, i) => s10 * this.stdevs[i] + this.means[i]));
      return this.wasFittedOnAVector ? zr(n) : n;
    }
  };
  function Pot() {
    let e28 = Array.from(arguments), t = e28.filter((p) => tt(p) || ft(p) || gt(p)), r = e28.find((p) => !t.includes(p) && typeof p == "object") || {}, n = pt(r.shouldShuffle) ? true : r.shouldShuffle, o = pt(r.testSize) ? 0.1 : r.testSize;
    O(Ls(n), "If passing an options object to the `trainTestSplit` function and including a `shouldShuffle` property on that object, then the value of that property must be a boolean!"), O(at(o) && o > 0 && o < 1, "If passing an options object to the `trainTestSplit` function and including a `testSize` property on that object, then the value of that property must be a number between 0 and 1 (exclusive on both ends)!"), O(t.length > 0, "You must pass at least one dataset into the `trainTestSplit` function!");
    let s10 = t.map((p) => Nt(p)[0]);
    O(Un(s10).length === 1, `All datasets passed into the \`trainTestSplit\` function must have the same length at their shallowest dimension! The lengths of the datasets you provided, though, are: ${s10.join(", ")}`);
    let i = [], a = n ? nf(ze(0, s10[0])) : ze(0, s10[0]), u = us((1 - o) * a.length), l = a.slice(0, u), c = a.slice(u);
    return t.forEach((p) => {
      if (ft(p)) i.push(p.get(l, null)), i.push(p.get(c, null));
      else if (gt(p)) i.push(p.get(l)), i.push(p.get(c));
      else {
        let m = [], f = [];
        p.forEach((h, d) => {
          l.includes(d) ? m.push(h) : f.push(h);
        }), i.push(m), i.push(f);
      }
    }), i;
  }
  typeof window < "u" && (window.JSDataScienceHelpers = { cohensd: WS, convertToNumerical: yB, diagonalize: xB, getCorrelationMatrix: rI, getHighlyCorrelatedColumns: Not, getMagnitude: gI, getOneHotEncodings: aI, getPercentages: Cot, getPValueMatrix: nI, hunterChainSort: bB, IndexMatcher: Iot, isBinary: wB, isCorrelationMatrix: Tot, isWholeNumber: ha, KMeans: Ug, MathError: ma, normalize: xI, orthonormalize: CB, OutlierMitigator: Fot, project: Tg, pValue: $g, rScore: _ot, rSquared: sv, standardize: Oot, StandardScaler: Rot, trainTestSplit: Pot });
  function jg(e28) {
    return new Promise((t, r) => {
      try {
        let n = /* @__PURE__ */ new Date();
        return setTimeout(() => t(/* @__PURE__ */ new Date() - n), e28);
      } catch (n) {
        return r(n);
      }
    });
  }
  function Lot(e28) {
    let t = /* @__PURE__ */ new Date(), r = /* @__PURE__ */ new Date();
    for (; r - t < e28; ) r = /* @__PURE__ */ new Date();
    return /* @__PURE__ */ new Date() - t;
  }
  typeof window < "u" && (window.pause = jg, window.pauseAsync = jg, window.pauseSync = Lot);
  var { KMeansNaive: Mot } = Ug;
  var hc = class extends Mot {
    initializeCentroids(t) {
      return Tt(t) && (t = t.values), tr(t) && (t = t.arraySync()), me(super.initializeCentroids(ms(t)));
    }
    getFitStepFunction(t, r) {
      Tt(t) && (t = t.values), tr(t) && (t = t.arraySync()), t = ms(t), B(ns(t), "`x` must be a matrix!"), It(r) || B(ur(r), "If defined, `progress` must be a function!");
      let n = [], o = (u) => (n.push(u), u), s10 = o(me(t)), i = o(this.initializeCentroids(t)), a = { currentRestart: 0, currentIteration: 0, currentCentroids: i, bestCentroids: i, bestScore: -1 / 0, isFinished: false };
      return async () => {
        try {
          let u = this.predict(s10, a.currentCentroids), l = a.currentCentroids.arraySync(), c = [];
          for (let m = 0; m < this.k; m++) {
            let f = [];
            if (u.forEach((h, d) => {
              h === m && f.push(d);
            }), f.length === 0) c.push(Nc(l[Math.floor(po() * l.length)], Sa(0.01, Dv(t[0].length))));
            else {
              let h = o(s10.gather(f));
              c.push(o(h.mean(0)));
            }
          }
          if (c = o(Xe(c)), jm(a.currentCentroids, c) < this.tolerance && (a.currentIteration = this.maxIterations - 1), a.currentIteration++, a.currentIteration >= this.maxIterations) {
            a.currentRestart++;
            let m = this.score(s10, c);
            m > a.bestScore && (a.bestScore = m, a.bestCentroids = o(c.clone())), a.currentIteration = 0, a.currentRestart >= this.maxRestarts ? a.isFinished = true : a.currentCentroids = o(this.initializeCentroids(t));
          } else a.currentCentroids = o(c.clone());
          return a.isFinished ? (this.centroids = a.bestCentroids.arraySync(), a = { isFinished: true }, n.forEach((m) => {
            try {
              m.dispose();
            } catch {
            }
          }), r && (r(1, this), await jg(0))) : (this.centroids = a.currentCentroids.arraySync(), r && (r((a.currentRestart + a.currentIteration / this.maxIterations) / this.maxRestarts, this), await jg(0))), a;
        } catch (u) {
          throw n.forEach((l) => {
            try {
              l.dispose();
            } catch {
            }
          }), u;
        }
      };
    }
    async fit(t, r) {
      let n = this.getFitStepFunction(t, r), o;
      for (; !o || !o.isFinished; ) o = await n();
      return this;
    }
    predict(t, r) {
      return M(() => {
        tr(t) && (t = t.arraySync()), Tt(t) && (t = t.values), t = ms(t), B(ns(t), "`x` must be a matrix!"), r = r || this.centroids, tr(r) || (r = me(r)), B(Et(t)[1] === r.shape[1], "`x` and `centroids` must have the same number of columns!");
        let n = me(t).expandDims(1), o = r.expandDims(0);
        return n.sub(o).pow(2).sum(2).argMin(1).arraySync();
      });
    }
    score(t, r) {
      return M(() => {
        tr(t) && (t = t.arraySync()), Tt(t) && (t = t.values), t = ms(t), B(ns(t), "`x` must be a matrix!"), r = r || this.centroids, tr(r) || (r = me(r)), B(ns(r) || It(r), "`centroids` must be a matrix or undefined!"), B(Et(t)[1] === r.shape[1], "`x` and `centroids` must have the same number of columns!");
        let n = me(t), o = this.predict(n, r), s10 = r.gather(o).arraySync();
        return -jm(n, s10);
      });
    }
  };
  var dc = class extends hc {
    initializeCentroids(t) {
      return tr(t) || (t = ms(t)), B(ns(t), "`x` must be a matrix!"), M(() => {
        let r = me(t), n = [Xn(po() * t.length)];
        for (; n.length < this.k; ) {
          let o = n.map((l) => t[l]), s10 = me(this.predict(t, o), null, "int32"), i = M(() => me(o).gather(s10).sub(r).pow(2).sum(1)), a = i.div(i.max()).arraySync(), u = 0;
          for (let l = 0; l < 1e4; l++) {
            u = Xn(po() * a.length);
            let c = a[u];
            if (po() < c) break;
          }
          n.push(u);
        }
        return me(n.map((o) => t[o]));
      });
    }
  };
  var { KMeansMeta: zot } = Ug;
  var Hg = class extends zot {
    constructor(t) {
      super(t), t = t || {}, this.modelClass = t.modelClass || dc;
    }
    get centroids() {
      return this.fittedModel.centroids;
    }
    set centroids(t) {
      tr(t) && (t = t.arraySync());
      let r = Et(t);
      if (this.centroids) {
        let n = this.centroids, o = Et(n);
        B(on(r, o), `The new centroids must have the same shape as the old centroids! (expected: [${o.join(", ")}], received: [${r.join(", ")}])`);
      }
      this.fittedModel || (this.fittedModel = new this.modelClass({ k: r[0], maxIterations: this.maxIterations, maxRestarts: this.maxRestarts, tolerance: this.tolerance })), this.fittedModel.centroids = t;
    }
    async fit(t, r) {
      let n = this.getFitStepFunction(t, r), o;
      for (; !o || !o.isFinished; ) o = await n();
      return this;
    }
    getFitStepFunction(t, r) {
      t = ms(t), B(ns(t), "`x` must be a matrix!"), Tt(t) && (t = t.values), It(r) || B(ur(r), "If defined, `progress` must be a function!");
      let n = { isFinished: false, lastScore: -1 / 0, currentIndex: 0 };
      return async () => {
        let o = this.ks[n.currentIndex], s10 = new this.modelClass({ k: o, maxRestarts: 10, maxIterations: 20 });
        await s10.fit(t, (a) => r ? r((n.currentIndex + a) / (this.ks.length + 1)) : null);
        let i = s10.score(t);
        return i / n.lastScore > this.scoreStopRatio ? (n.isFinished = true, n.currentIndex--) : (n.lastScore = i, n.currentIndex + 1 >= this.ks.length ? n.isFinished = true : n.currentIndex++), n.isFinished && (this.fittedModel = new this.modelClass({ k: this.ks[n.currentIndex], maxRestarts: this.maxRestarts, maxIterations: this.maxIterations }), await this.fittedModel.fit(t, (a) => r ? r((this.ks.length + a) / (this.ks.length + 1)) : null), r && r(1)), n;
      };
    }
  };
  var Bot = { isMatrix: ns, isTFTensor: tr, isWholeNumber: UM, orderCentroids: jM, sign: zw };
  var Vot = { sse: jm, accuracy: FS, rSquared: Bw, rScore: HM };
  var Got = { TFKMeansMeta: Hg, TFKMeansNaive: hc, TFKMeansPlusPlus: dc };
  var Wot = { helpers: Bot, metrics: Vot, models: Got };
  typeof window < "u" && (window.TFKMeans = Wot);

  // node_modules/@jrc03c/js-data-science-helpers/dist/js-data-science-helpers.import.mjs
  var __defProp4 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber3(x6) {
    return typeof x6 === "number" && !isNaN(x6) || typeof x6 === "bigint";
  }
  var isBrowser4 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError3 = class extends Error {
    constructor(message) {
      if (isBrowser4()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert3(isTrue, message) {
    if (!isTrue)
      throw new MathError3(message);
  }
  var arrayTypes3 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined3(x6) {
    return x6 === null || typeof x6 === "undefined";
  }
  var typeStrings3 = arrayTypes3.map((s222) => s222.name);
  function isArray3(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined3(obj.constructor)) {
        return arrayTypes3.indexOf(obj.constructor) > -1 || typeStrings3.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e28) {
      return false;
    }
  }
  function isDataFrame3(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e28) {
      return false;
    }
  }
  function isFunction3(fn2) {
    return typeof fn2 === "function";
  }
  function isObject3(x6) {
    return typeof x6 === "object" && !isUndefined3(x6) && !isArray3(x6);
  }
  function isSeries3(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e28) {
      return false;
    }
  }
  function indexOf3(x6, fn2) {
    if (isDataFrame3(x6)) {
      const index = indexOf3(x6.values, fn2);
      if (index.length > 0 && isNumber3(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      if (index.length > 1 && isNumber3(index[1]) && index[1] >= 0 && index[1] < x6.columns.length) {
        index[1] = x6.columns[index[1]];
      }
      return index;
    }
    if (isSeries3(x6)) {
      const index = indexOf3(x6.values, fn2);
      if (index.length > 0 && isNumber3(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      return index;
    }
    assert3(isObject3(x6) || isArray3(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction3(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject3(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return [key];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray3(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return [i];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn22(x22)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const paths = helper522(x6, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy3(x6) {
    function helper522(x22) {
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        if (isArray3(x22)) {
          if (!(x22 instanceof Array)) {
            return x22.slice();
          }
          return x22.map((v) => copy3(v));
        }
        if (isSeries3(x22)) {
          const out32 = x22.copy();
          out32.values = copy3(out32.values);
          return out32;
        }
        if (isDataFrame3(x22)) {
          const out32 = x22.copy();
          out32.values = copy3(x22.values);
          return out32;
        }
        if (x22 instanceof Date) {
          return new Date(x22.getTime());
        }
        x22 = decycle3(x22);
        const out222 = {};
        Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
          out222[key] = copy3(x22[key]);
        });
        return out222;
      } else {
        return x22;
      }
    }
    return helper522(decycle3(x6));
  }
  function decycle3(x6) {
    function helper522(x22, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x22) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x22;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x22 ? "/" : "/" + indexOf3(orig, x22).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x22 === "object") {
        if (x22 === null)
          return null;
        checked.push(x22);
        if (isArray3(x22)) {
          if (typeof x22.constructor !== "undefined" && x22.constructor.name !== "Array") {
            return x22.slice();
          }
          return x22.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
            x22[key] = helper522(x22[key], checked, currentPath + "/" + key.toString());
          });
          return x22;
        }
      } else {
        return x22;
      }
    }
    const orig = x6;
    let out222 = helper522(orig);
    if (isDataFrame3(x6)) {
      const temp = x6.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries3(x6)) {
      const temp = x6.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate3(x6) {
    return x6 instanceof Date && x6.toString() !== "Invalid Date";
  }
  var numberTypes3 = ["number", "int", "float", "bigint"];
  function isEqual3(a, b) {
    function helper522(a22, b22) {
      const aType = typeof a22;
      const bType = typeof b22;
      if (aType !== bType && !numberTypes3.includes(aType) && !numberTypes3.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a22 === b22;
      if (aType === "symbol")
        return a22 === b22;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a22.toString();
          const bString = b22.toString();
          return aString === bString;
        } catch (e28) {
          return false;
        }
      }
      if (aType === "string")
        return a22 === b22;
      if (aType === "function")
        return a22 === b22;
      if (aType === "object") {
        if (a22 === null || b22 === null) {
          return a22 === null && b22 === null;
        } else {
          if (isDate3(a22)) {
            if (isDate3(b22)) {
              return a22.getTime() === b22.getTime();
            } else {
              return false;
            }
          } else if (isDate3(b22)) {
            return false;
          }
          if (a22 instanceof RegExp && b22 instanceof RegExp) {
            return a22.toString() === b22.toString();
          }
          if (isArray3(a22) !== isArray3(b22)) {
            return false;
          }
          const aKeys = Object.keys(a22).concat(Object.getOwnPropertySymbols(a22));
          const bKeys = Object.keys(b22).concat(Object.getOwnPropertySymbols(b22));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a22[key], b22[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e28) {
      return helper522(decycle3(a), decycle3(b));
    }
  }
  function makeKey6(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY4 = makeKey6(16);
  var UNDEFINED_KEY4 = makeKey6(16);
  var INFINITY_KEY4 = makeKey6(16);
  var MINUS_INFINITY_KEY4 = makeKey6(16);
  var SYMBOL_KEY4 = makeKey6(16);
  var Counter3 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x6) {
      for (const v of x6) {
        if (isArray3(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY4 : isUndefined3(value) ? UNDEFINED_KEY4 : isFunction3(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY4 : value === Infinity ? INFINITY_KEY4 : value === -Infinity ? MINUS_INFINITY_KEY4 : typeof value === "bigint" ? value.toString() : isDataFrame3(value) ? value.toJSONString() : isSeries3(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined3(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return flatten3(arr.values);
    }
    assert3(isArray3(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray3(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats3(x6, options) {
    options = options || {};
    const counts = new Counter3();
    const out222 = {};
    const xflat = flatten3(x6);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber3(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e28) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e28) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e28) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e28) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e28) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count3(arr, matcher) {
    const { counts } = stats3(arr);
    if (!isUndefined3(matcher)) {
      if (isFunction3(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual3(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper6(x6) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return helper6(x6.values);
    }
    if (isArray3(x6)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x6) {
        if (helper6(v)) {
          return true;
        }
        if (isArray3(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged3(x6) {
    return helper6(decycle3(x6));
  }
  function isNested3(x6) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return isNested3(x6.values);
    }
    assert3(isArray3(x6), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x6.length; i++) {
      if (isArray3(x6[i])) {
        return true;
      }
    }
    return false;
  }
  var error3 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray3(shape222) {
    assert3(!isUndefined3(shape222), error3);
    if (!isArray3(shape222))
      shape222 = [shape222];
    assert3(!isNested3(shape222), error3);
    assert3(shape222.length > 0, error3);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert3(isNumber3(s222), error3);
    assert3(s222 >= 0, error3);
    assert3(Math.floor(s222) === s222, error3);
    assert3(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray3(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      const out32 = arr.copy();
      out32.values = reverse3(out32.values);
      out32.index = reverse3(out32.index);
      return out32;
    }
    assert3(isArray3(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range3(a, b, step = 1) {
    assert3(!isUndefined3(a) && !isUndefined3(b) && !isUndefined3(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert3(isNumber3(a) && isNumber3(b) && isNumber3(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert3(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e28) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse3(out222);
    return out222;
  }
  function makeKey23(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY23 = makeKey23(256);
  var UNDEFINED_KEY23 = makeKey23(256);
  var INFINITY_KEY23 = makeKey23(256);
  var MINUS_INFINITY_KEY23 = makeKey23(256);
  var SYMBOL_KEY23 = makeKey23(256);
  function set4(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return set4(arr.values);
    }
    assert3(isArray3(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten3(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY23 : isUndefined3(item) ? UNDEFINED_KEY23 : isFunction3(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY23 : item === Infinity ? INFINITY_KEY23 : item === -Infinity ? MINUS_INFINITY_KEY23 : typeof item === "bigint" ? item.toString() : isDataFrame3(item) ? item.toJSONString() : isSeries3(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper23(x6) {
    if (isArray3(x6)) {
      const childShapes = helper23(x6[0]);
      return [x6.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape3(x6) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return shape3(x6.values);
    }
    assert3(isArray3(x6), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper23(x6);
  }
  function dfAppend3(df2, x6, axis) {
    if (isUndefined3(axis)) {
      axis = 0;
    }
    assert3(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray3(x6)) {
      assert3(!isJagged3(x6), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape3(x6);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df2.copy();
          out222._values.push(x6);
          const maxRowLength = Math.max(df2.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range3(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray3(df2.shape[1]));
            }
            out222._values[i].push(x6[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x6.map((row) => row.length).concat([df2.shape[1]]));
          const out222 = df2.copy();
          out222._values = out222._values.concat(x6).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x6.map((row) => row.length)) + df2.shape[1];
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range3(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray3(df2.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x6[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError3("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries3(x6)) {
      const out222 = dfAppend3(df2, x6.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      }
      return out222;
    } else if (isDataFrame3(x6)) {
      if (axis === 0) {
        const out222 = df2.copy();
        const maxRowLength = set4(out222._columns.concat(x6._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x6.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x6._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df2._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df2.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x6._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x6._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray3(x6.shape[1]));
          }
        });
        x6._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray3(out222._columns.length).concat(x6._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x6._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError3("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply3(DataFrame222, Series222, df2, fn2, axis) {
    axis = axis || 0;
    assert3(isFunction3(fn2), "The first parameter to the `apply` method must be a function.");
    assert3(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df2.columns.forEach((colName, i) => {
        const series = new Series222(df2.values.map((row) => row[i]));
        series.name = colName;
        series.index = df2.index;
        const value = fn2(series, i, df2);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined3(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray3(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        return out222;
      } else {
        const out222 = new Series222(df2.columns.map((colName) => temp[colName]));
        out222.index = df2.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df2.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const value = fn2(series, i, df2);
        if (isUndefined3(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray3(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        out222.columns = df2.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df2.index;
        return out222;
      }
    }
  }
  function isString3(s222) {
    return typeof s222 === "string";
  }
  function dfAssign3(DataFrame222, Series222, df2, p12, p22) {
    const isDataFrame222 = (x6) => x6 instanceof DataFrame222;
    const isSeries222 = (x6) => x6 instanceof Series222;
    if (!isUndefined3(p22)) {
      assert3(isString3(p12), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert3(isArray3(p22) && !isJagged3(p22) && shape3(p22).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df2.append(p22, 1);
      out222.columns[out222.columns.length - 1] = p12;
      return out222;
    } else {
      if (isDataFrame222(p12)) {
        return df2.append(p12, 1);
      } else if (isSeries222(p12)) {
        return df2.append(p12, 1);
      } else if (isObject3(p12)) {
        const maxColumnLength = Math.max(...Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).map((key) => p12[key].length));
        Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).forEach((key) => {
          while (p12[key].length < maxColumnLength) {
            p12[key].push(void 0);
          }
        });
        return df2.append(new DataFrame222(p12), 1);
      } else {
        throw new MathError3("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy3(DataFrame222, df2) {
    if (df2.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy3(df2.values));
    out222.columns = df2.columns.slice();
    out222.index = df2.index.slice();
    return out222;
  }
  function dfDrop3(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined3(rows))
      rows = [];
    if (isUndefined3(cols))
      cols = [];
    if (isString3(rows) || isNumber3(rows))
      rows = [rows];
    if (isString3(cols) || isNumber3(cols))
      cols = [cols];
    assert3(isArray3(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert3(isArray3(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert3(shape3(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert3(shape3(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df2.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df2.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df2.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df2.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger3(x6) {
    return isNumber3(x6) && (x6 >= 0 ? Math.floor(x6) === x6 : Math.ceil(x6) === x6);
  }
  function isWholeNumber3(x6) {
    return isInteger3(x6) && x6 >= 0;
  }
  function dfDropMissing3(DataFrame222, Series222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert3(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert3(isWholeNumber3(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert3(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined3(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined3(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined3(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df2.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape3(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined3(newIndex))
        return new DataFrame222();
      if (isString3(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN3(x6) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return x6.dropNaN(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(x6), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropNaN3(v));
      } catch (e28) {
        if (isNumber3(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN3(DataFrame222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert3(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert3(isWholeNumber3(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert3(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN3(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df2.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject3(x6) {
    const out222 = {};
    flatten3(x6).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject3(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter3(DataFrame222, Series222, df2, fn2, axis) {
    assert3(isFunction3(fn2), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined3(axis))
      axis = 0;
    assert3(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df2.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject3(out222.index);
    const columns = arrayToObject3(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject3(index)[0];
        temp.index = undoArrayToObject3(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject3(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.columns[i];
        series.index = df2.index;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject3(columns)[0];
        temp.index = undoArrayToObject3(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject3(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet3(df2, rows, cols) {
    if (isString3(rows) || isNumber3(rows))
      rows = [rows];
    if (isString3(cols) || isNumber3(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set4((rows || []).concat(cols || []).map((v) => typeof v));
    assert3(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert3(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert3(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert3(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined3(rows)) {
      rows = rows.map((r) => {
        if (isString3(r)) {
          assert3(df2.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber3(r)) {
          assert3(r >= 0, `Index ${r} is out of bounds!`);
          assert3(Math.floor(r) === r, `Row numbers must be integers!`);
          assert3(r < df2.index.length, `Index ${r} is out of bounds!`);
          return df2.index[r];
        }
      });
    }
    if (!isUndefined3(cols)) {
      cols = cols.map((c) => {
        if (isString3(c)) {
          assert3(df2.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber3(c)) {
          assert3(c >= 0, `Column ${c} is out of bounds!`);
          assert3(Math.floor(c) === c, `Column numbers must be integers!`);
          assert3(c < df2.columns.length, `Column ${c} is out of bounds!`);
          return df2.columns[c];
        }
      });
    }
    return df2.getSubsetByNames(rows, cols);
  }
  function alphaSort3(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e28) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort3(arr, fn2) {
    if (isUndefined3(fn2))
      fn2 = alphaSort3;
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert3(isFunction3(fn2), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn2);
    return out222;
  }
  function camelify3(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies3(DataFrame222, df2, columns) {
    if (isUndefined3(columns)) {
      columns = df2.columns;
    } else if (isString3(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert3(isString3(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df2.columns.indexOf(col);
      assert3(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df2.values.map((row) => row[colIndex]);
      const valuesSet = sort3(set4(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify3(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df2.index;
    return out222;
  }
  function dfGetSubsetByIndices3(df2, rowIndices, colIndices) {
    const dataShape = df2.shape;
    if (isUndefined3(rowIndices))
      rowIndices = range3(0, dataShape[0]);
    if (isUndefined3(colIndices))
      colIndices = range3(0, dataShape[1]);
    if (isNumber3(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber3(colIndices))
      colIndices = [colIndices];
    assert3(isArray3(rowIndices) && isArray3(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert3(shape3(rowIndices).length === 1 && shape3(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert3(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert3(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert3(isWholeNumber3(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert3(rowIndex < df2.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert3(isWholeNumber3(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert3(colIndex < df2.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df2.index[i]);
    const cols = colIndices.map((i) => df2.columns[i]);
    return df2.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames3(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined3(rows))
      rows = df2.index;
    if (isUndefined3(cols))
      cols = df2.columns;
    if (isString3(rows))
      rows = [rows];
    if (isString3(cols))
      cols = [cols];
    assert3(isArray3(rows) && isArray3(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert3(shape3(rows).length === 1 && shape3(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert3(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert3(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert3(isString3(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert3(df2.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert3(isString3(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert3(df2.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df2.values[df2.index.indexOf(row)][df2.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint3(DataFrame222, Series222, df2) {
    function truncate(s222, maxLength2) {
      if (isString3(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df2.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df2;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df2.index.length ? null : range3(0, halfMaxRows).concat(range3(df2.index.length - halfMaxRows, df2.index.length));
    const tempColumns = maxColumns > df2.columns.length ? null : range3(0, halfMaxColumns).concat(range3(df2.columns.length - halfMaxColumns, df2.columns.length));
    let temp = df2.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df2.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df2.index;
        temp.columns = new Series222(df2.columns).get(tempColumns).values;
      } else if (df2.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df2.index).get(tempRows).values;
        temp.columns = df2.columns;
      }
    }
    if (maxRows <= df2.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range3(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df2.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df2.shape, "\n");
    return df2;
  }
  function leftPad3(x6, maxLength) {
    assert3(isNumber3(x6), "The `leftPad` function only works on numbers!");
    let out222 = x6.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex3(df2, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df2 : df2.copy();
    out222.index = range3(0, df2.shape[0]).map((i) => {
      return "row" + leftPad3(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product3(arr, shouldDropNaNs) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return product3(arr.values, shouldDropNaNs);
    }
    assert3(isArray3(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten3(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber3(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  function isNaturalNumber3(x6) {
    return isInteger3(x6) && x6 > 0;
  }
  function reshape3(x6, newShape) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return reshape3(x6.values, newShape);
    }
    assert3(isArray3(x6), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber3(newShape))
      newShape = [newShape];
    assert3(isArray3(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert3(shape3(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert3(isNaturalNumber3(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten3(x6);
    }
    const temp = flatten3(x6);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert3(product3(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape3(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX3 = Math.pow(2, 64);
  var s6 = [];
  seed3(Math.floor(Math.random() * MAX3));
  function splitmix643(state, n) {
    state = uint3(state);
    function helper522() {
      state += uint3("0x9e3779b97f4a7c15");
      let z10 = copy3(state);
      z10 = (z10 ^ z10 >> BigInt(30)) * uint3("0xbf58476d1ce4e5b9");
      z10 = (z10 ^ z10 >> BigInt(27)) * uint3("0x94d049bb133111eb");
      return z10 ^ z10 >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint3(x6) {
    return BigInt.asUintN(64, BigInt(x6));
  }
  function rotl3(x6, k6) {
    x6 = uint3(x6);
    k6 = BigInt(k6);
    return uint3(uint3(x6 << k6) | uint3(x6 >> uint3(BigInt(64) - k6)));
  }
  function seed3(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined3(val)) {
      assert3(isNumber3(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix643(Math.floor(val), 4);
      s6[0] = temp[0];
      s6[1] = temp[1];
      s6[2] = temp[2];
      s6[3] = temp[3];
    } else {
      return copy3(s6);
    }
  }
  function next3() {
    const result = uint3(rotl3(s6[0] + s6[3], 23) + s6[0]);
    const t = uint3(s6[1] << BigInt(17));
    s6[2] = uint3(s6[2] ^ s6[0]);
    s6[3] = uint3(s6[3] ^ s6[1]);
    s6[1] = uint3(s6[1] ^ s6[2]);
    s6[0] = uint3(s6[0] ^ s6[3]);
    s6[2] = uint3(s6[2] ^ t);
    s6[3] = rotl3(s6[3], 45);
    return Math.floor(Number(result)) / MAX3;
  }
  function random3(shape222) {
    if (isUndefined3(shape222))
      return next3();
    if (!isArray3(shape222))
      shape222 = [shape222];
    return reshape3(ndarray3(product3(shape222)).map(next3), shape222);
  }
  function shuffle3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random3() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle3(df2, axis) {
    if (isUndefined3(axis))
      axis = 0;
    assert3(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df2.get(axis === 0 ? shuffle3(df2.index) : null, axis === 1 ? shuffle3(df2.columns) : null);
  }
  function isBoolean3(x6) {
    return typeof x6 === "boolean";
  }
  function dfSort3(df2, a, b) {
    if (isFunction3(a)) {
      return dfSortByFunction3(df2, a, b);
    } else {
      return dfSortByColumns3(df2, a, b);
    }
  }
  function dfSortByFunction3(df2, fn2, axis) {
    axis = isUndefined3(axis) ? 0 : axis;
    assert3(isFunction3(fn2), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert3(isNumber3(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort3(df2.index, (a, b) => {
        return fn2(df2.get(a, null), df2.get(b, null));
      });
      return df2.get(index, null);
    } else {
      const columns = sort3(df2.columns, (a, b) => {
        return fn2(df2.get(null, a), df2.get(null, b));
      });
      return df2.get(null, columns);
    }
  }
  function dfSortByColumns3(df2, cols, directions) {
    let out222 = df2.copy();
    const indexID = random3().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined3(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber3(cols) || isString3(cols)) {
      cols = [cols];
      if (isBoolean3(directions) || isString3(directions))
        directions = [directions];
    }
    assert3(isArray3(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert3(shape3(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined3(directions))
      directions = range3(0, cols.length).map(() => true);
    assert3(isArray3(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert3(shape3(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert3(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert3(isString3(col) || isNumber3(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString3(col)) {
        const index = out222.columns.indexOf(col);
        assert3(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber3(col)) {
        assert3(isWholeNumber3(col), "Column indices must be whole numbers!");
        assert3(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert3(isString3(dir) || isBoolean3(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString3(dir)) {
        const value = dir.trim().toLowerCase();
        assert3(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean3(dir)) {
        return dir;
      }
    });
    out222.values = sort3(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject3(df2, axis) {
    if (isUndefined3(axis)) {
      axis = 0;
    } else {
      assert3(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df2.index.forEach((rowName, i) => {
        const temp = {};
        df2.columns.forEach((colName, j) => {
          temp[colName] = df2.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df2.columns.forEach((colName, j) => {
        const temp = {};
        df2.index.forEach((rowName, i) => {
          temp[rowName] = df2.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString3(df2, axis) {
    return JSON.stringify(df2.toObject(axis));
  }
  async function dfToJSON3(df2, filename, axis) {
    const out222 = dfToJSONString3(df2, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e28) {
      browserError = e28;
    }
    try {
      const fs2 = await import("node:fs");
      const path = await import("node:path");
      fs2.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e28) {
      nodeError = e28;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError3(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError3(nodeError);
      } else {
        throw new MathError3("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df2;
  }
  function dfToObject3(df2) {
    const out222 = {};
    df2.columns.forEach((col) => {
      out222[col] = df2.get(col).values;
    });
    return out222;
  }
  function transpose3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return arr.transpose();
    }
    assert3(isArray3(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape3(arr);
    assert3(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse3(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray3(reverse3(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend3(Series222, series, x6) {
    if (isSeries3(x6)) {
      return new Series222(series.values.concat(x6.values));
    }
    if (isArray3(x6)) {
      const xShape = shape3(x6);
      assert3(xShape.length === 1 && !isNested3(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x6.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend3(series, [x6]);
  }
  function seriesApply3(series, fn2) {
    assert3(isFunction3(fn2), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn2(v, i));
    return out222;
  }
  function seriesDropMissing3(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined3(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN3(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber3(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter3(Series222, series, fn2) {
    let out222 = series.copy();
    const index = copy3(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn2(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet3(series, indices) {
    if (isString3(indices) || isNumber3(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set4((indices || []).map((v) => typeof v));
    assert3(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert3(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert3(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert3(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined3(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert3(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert3(i >= 0, `Index ${i} is out of bounds!`);
          assert3(Math.floor(i) === i, `Indices must be integers!`);
          assert3(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices3(series, indices) {
    const dataShape = series.shape;
    if (isUndefined3(indices))
      indices = range3(0, dataShape[0]);
    assert3(isArray3(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert3(shape3(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert3(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert3(isWholeNumber3(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert3(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames3(Series222, series, indices) {
    if (isUndefined3(indices))
      indices = series.index;
    assert3(isArray3(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert3(shape3(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert3(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert3(isString3(name), "The `indices` array must contain only strings.");
      assert3(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint3(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range3(0, maxRows / 2).concat(range3(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy3(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle3(series) {
    const out222 = series.copy();
    return out222.get(shuffle3(out222.index));
  }
  function seriesSort3(Series222, series, fn2) {
    fn2 = fn2 || ((a, b) => a < b ? -1 : 1);
    assert3(isUndefined3(fn2) || isFunction3(fn2), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose3([series.values, series.index]);
    const temp = sort3(pairs, (aPair, bPair) => {
      return fn2(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex3(Series222, series) {
    let temp = transpose3([series.values, series.index]);
    temp = transpose3(sort3(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject3(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL3 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass3(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x6) {
        try {
          return !!x6._symbol && x6._symbol === SERIES_SYMBOL3;
        } catch (e28) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL3
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x6) {
            assert3(isArray3(x6), "The new values must be a 1-dimensional array!");
            const dataShape = shape3(x6);
            assert3(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range3(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad3(i, (x6.length - 1).toString().length);
              }));
            }
            this._values = x6;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x6) {
            assert3(isArray3(x6), "The new index must be a 1-dimensional array of strings!");
            assert3(x6.length === this.shape[0], "The new index must be the same length as the old index!");
            assert3(shape3(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
            x6.forEach((value) => {
              assert3(isString3(value), "All of the row names must be strings!");
            });
            this._index = x6;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy3(data.values);
            this.index = copy3(data.index);
          } else if (isArray3(data)) {
            const dataShape = shape3(data);
            assert3(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert3(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert3(shape3(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape3(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined3(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet3(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames3(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices3(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse3(this.values));
        out222.index = reverse3(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range3(0, this.shape[0]).map((i) => {
          return "item" + leftPad3(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy3(this.values);
        out222._index = copy3(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x6) {
        return seriesAppend3(Series222, this, x6);
      }
      apply(fn2) {
        return seriesApply3(this, fn2);
      }
      concat(x6) {
        return this.append(x6);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing3(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN3(Series222, this);
      }
      toObject() {
        return seriesToObject3(this);
      }
      print() {
        return seriesPrint3(this);
      }
      shuffle() {
        return seriesShuffle3(this);
      }
      sort(direction) {
        return seriesSort3(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex3(Series222, this);
      }
      filter(fn2) {
        return seriesFilter3(Series222, this, fn2);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose3([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse3(out222.values);
        out222.index = reverse3(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL3 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey33(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random3() * alpha.length)];
    return out222;
  }
  var DataFrame3 = class {
    static [Symbol.hasInstance](x6) {
      try {
        return !!x6._symbol && x6._symbol === DATAFRAME_SYMBOL3;
      } catch (e28) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL3
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined3(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x6) {
          assert3(isArray3(x6), "The new values must be a 2-dimensional array!");
          const dataShape = shape3(x6);
          assert3(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range3(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad3(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range3(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad3(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x6;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x6) {
          assert3(isArray3(x6), "The new columns list must be a 1-dimensional array of strings!");
          assert3(this.isEmpty || x6.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert3(shape3(x6).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey33(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count3(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey33(8);
            }
            return v;
          });
          this._columns = x6;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x6) {
          assert3(isArray3(x6), "The new index must be a 1-dimensional array of strings!");
          assert3(this.isEmpty || x6.length === this.shape[0], "The new index must be the same length as the old index!");
          assert3(shape3(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey33(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count3(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey33(8);
            }
            return v;
          });
          this._index = x6;
        }
      });
      assert3(isUndefined3(data) || isObject3(data) || isArray3(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame3) {
          this.values = copy3(data.values);
          this.columns = copy3(data.columns);
          this.index = copy3(data.index);
        } else if (isArray3(data)) {
          const dataShape = shape3(data);
          assert3(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert3(!isJagged3(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined3(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert3(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose3(temp);
          const dataShape = shape3(this.values);
          this._index = range3(0, dataShape[0]).map((i) => {
            return "row" + leftPad3(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape3(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame3(ndarray3(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e28) {
          return this.get(rows, null);
        }
      }
      return dfGet3(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames3(DataFrame3, Series3, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices3(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies3(DataFrame3, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies3(DataFrame3, this, columns);
    }
    transpose() {
      const out222 = new DataFrame3(transpose3(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex3(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy3(DataFrame3, this);
    }
    assign(p12, p22) {
      return dfAssign3(DataFrame3, Series3, this, p12, p22);
    }
    apply(fn2, axis) {
      return dfApply3(DataFrame3, Series3, this, fn2, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing3(DataFrame3, Series3, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN3(DataFrame3, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop3(DataFrame3, Series3, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject3(this, axis);
    }
    toObject() {
      return dfToObject3(this);
    }
    toJSONString(axis) {
      return dfToJSONString3(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON3(this, filename, axis);
    }
    print() {
      return dfPrint3(DataFrame3, Series3, this);
    }
    sort(cols, directions) {
      return dfSort3(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn2, axis) {
      return dfFilter3(DataFrame3, Series3, this, fn2, axis);
    }
    shuffle(axis) {
      return dfShuffle3(this, axis);
    }
    append(x6, axis) {
      return dfAppend3(this, x6, axis);
    }
    concat(x6, axis) {
      return this.append(x6, axis);
    }
    join(x6, axis) {
      return this.append(x6, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series3 = createSeriesClass3(DataFrame3);
  function max3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).max;
  }
  function vectorize3(fn2) {
    assert3(isFunction3(fn2), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray3(arg)) {
          return true;
        } else if (isSeries3(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame3(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert3(isEqual3(isArray3(s222) ? shape3(s222) : s222.shape, isArray3(childArrays[i + 1]) ? shape3(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn2.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max3(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range3(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray3(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries3(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame3(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual3(shape3(dataframes[0]), shape3(out222))) {
              const temp = new DataFrame3(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame3(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series3(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series3(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn2(...arguments);
      }
    };
  }
  function abs3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6 < 0 ? -x6 : x6;
      } else {
        return Math.abs(x6);
      }
    } catch (e28) {
      return NaN;
    }
  }
  var vabs3 = vectorize3(abs3);
  function add3() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x6 = Object.values(arguments);
      for (let v of x6) {
        if (!isNumber3(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vadd3 = vectorize3(add3);
  function apply3(x6, fn2) {
    try {
      return fn2(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vapply3 = vectorize3(apply3);
  function arccos3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.acos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varccos3 = vectorize3(arccos3);
  function arcsin3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.asin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varcsin3 = vectorize3(arcsin3);
  function arctan3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.atan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varctan3 = vectorize3(arctan3);
  function argmax3(x6, shouldDropNaNs) {
    if (isDataFrame3(x6)) {
      const index = argmax3(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries3(x6)) {
      const index = argmax3(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert3(isArray3(x6), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf3(x6, max3(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function min3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).min;
  }
  function argmin3(x6, shouldDropNaNs) {
    if (isDataFrame3(x6)) {
      const index = argmin3(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries3(x6)) {
      const index = argmin3(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert3(isArray3(x6), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf3(x6, min3(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function cast3(value, type) {
    if (isDataFrame3(value) || isSeries3(value)) {
      return value.apply((item) => cast3(item, type));
    }
    if (isArray3(value)) {
      return value.map((v) => cast3(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined3(value)) {
        return NaN;
      }
      const booleanValue = cast3(value, "boolean");
      if (isBoolean3(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e28) {
        const dateValue = cast3(value, "date");
        if (isDate3(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast3(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast3(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast3(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean3(value)) {
        return value;
      }
      if (isNumber3(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e28) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate3(value)) {
        return value;
      }
      if (isUndefined3(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate3(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject3(value)) {
        return value;
      }
      const booleanValue = cast3(value, "boolean");
      if (isBoolean3(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast3(value, "number");
        if (isNumber3(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e28) {
      }
      const dateValue = cast3(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray3(out222)) {
          return out222.map((v) => cast3(v, type));
        } else {
          return out222;
        }
      } catch (e28) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined3(value)) {
        if (isEqual3(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.ceil(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vceil3 = vectorize3(ceil3);
  function chop3(x6, threshold) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      if (isUndefined3(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber3(threshold)) {
        return NaN;
      }
      return vabs3(x6) < threshold ? 0 : x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vchop3 = vectorize3(chop3);
  function int4(x6) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      const out222 = x6.copy();
      out222.values = int4(out222.values);
      return out222;
    }
    if (isArray3(x6)) {
      return x6.map((v) => int4(v));
    } else {
      try {
        const out222 = JSON.parse(x6);
        if (isNumber3(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e28) {
        return NaN;
      }
    }
  }
  var vint3 = vectorize3(int4);
  function clamp3(x6, a, b) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (!isNumber3(a))
        return NaN;
      if (!isNumber3(b))
        return NaN;
      if (typeof x6 === "bigint") {
        return BigInt(clamp3(vint3(x6), a, b));
      }
      if (x6 < a)
        return a;
      if (x6 > b)
        return b;
      return x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vclamp3 = vectorize3(clamp3);
  function combinationsIterator3(x6, r) {
    function* helper522(x22, r22) {
      if (r22 > x22.length) {
        yield x22;
      } else if (r22 <= 0) {
        yield [];
      } else if (x22.length < 2) {
        yield x22;
      } else {
        for (let i = 0; i < x22.length; i++) {
          const item = x22[i];
          const after = x22.slice(i + 1);
          if (after.length < r22 - 1) {
            continue;
          }
          if (r22 - 1 >= 0) {
            for (const child of combinationsIterator3(after, r22 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return combinationsIterator3(x6.values, r);
    }
    assert3(isArray3(x6), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert3(isNumber3(r) && vint3(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten3(x6), r);
  }
  function combinations3(x6, r) {
    const out222 = [];
    for (const combo of combinationsIterator3(x6, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect3() {
    const arrays = Object.values(arguments).map((x6) => {
      if (isDataFrame3(x6) || isSeries3(x6)) {
        return set4(x6.values);
      }
      assert3(isArray3(x6), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set4(x6);
    });
    const all = set4(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual3(other, v)) > -1);
    });
  }
  var _IndexMatcher3 = class {
    constructor(mode222) {
      assert3(isUndefined3(mode222) || mode222 === _IndexMatcher3.DROP_NAN_MODE || mode222 === _IndexMatcher3.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined3(mode222) ? mode222 : _IndexMatcher3.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x6) => {
        if (isArray3(x6)) {
          const xshape = shape3(x6);
          if (xshape.length === 1) {
            x6 = new Series3(x6);
          } else if (xshape.length === 2) {
            x6 = new DataFrame3(x6);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert3(isDataFrame3(x6) || isSeries3(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher3.DROP_MISSING_MODE) {
          indices.push(x6.dropMissing().index);
        } else {
          indices.push(x6.dropNaN().index);
        }
      });
      this.index = intersect3(...indices);
      return this;
    }
    transform() {
      assert3(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x6) => {
        if (isArray3(x6)) {
          const xshape = shape3(x6);
          if (xshape.length === 1) {
            return new Series3(x6).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame3(x6).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert3(isDataFrame3(x6) || isSeries3(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x6.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher3 = _IndexMatcher3;
  __publicField3(IndexMatcher3, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField3(IndexMatcher3, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance3(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries3(x6)) {
      return covariance3(x6.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries3(y)) {
      return covariance3(x6, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert3(isArray3(x6) && isArray3(y) && shape3(x6).length === 1 && shape3(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert3(x6.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance3(...new IndexMatcher3().fitAndTransform(x6, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats3(x6, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats3(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx2 = Number(xstats.mean);
      const my2 = Number(ystats.mean);
      if (!isNumber3(mx2) || !isNumber3(my2)) {
        return NaN;
      }
      const n = Math.max(x6.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx2 = x6[i];
        let vy2 = y[i];
        if (!isNumber3(vx2))
          return NaN;
        if (!isNumber3(vy2))
          return NaN;
        if (typeof vx2 === "bigint") {
          vx2 = Number(vx2);
        }
        if (typeof vy2 === "bigint") {
          vy2 = Number(vy2);
        }
        out222 += (vx2 - mx2) * (vy2 - my2);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x6.length, xstats, ystats];
      } else {
        return out222 / x6.length;
      }
    } catch (e28) {
      return NaN;
    }
  }
  function correl3(x6, y, shouldDropNaNs) {
    if (isSeries3(x6)) {
      return correl3(x6.values, y, shouldDropNaNs);
    }
    if (isSeries3(y)) {
      return correl3(x6, y.values, shouldDropNaNs);
    }
    assert3(isArray3(x6) && isArray3(y) && shape3(x6).length === 1 && shape3(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert3(x6.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance3(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e28) {
      return NaN;
    }
  }
  function cos3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.cos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vcos3 = vectorize3(cos3);
  var dataTypes3 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff3(a, b) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return diff3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return diff3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set4(a);
    const bTemp = set4(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual3(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow3(x6, p) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (!isNumber3(p))
        return NaN;
      if (typeof x6 === "bigint" || typeof p === "bigint") {
        const out222 = pow3(Number(x6), Number(p));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.pow(x6, p);
    } catch (e28) {
      return NaN;
    }
  }
  var vpow3 = vectorize3(pow3);
  function sqrt3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        const out222 = sqrt3(Number(x6));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.sqrt(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsqrt3 = vectorize3(sqrt3);
  function multiply3() {
    try {
      const x6 = Object.values(arguments);
      if (x6.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x6) {
        if (!isNumber3(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vmultiply3 = vectorize3(multiply3);
  function scale3() {
    return vmultiply3(...arguments);
  }
  function subtract3(a, b) {
    return vadd3(a, scale3(b, -1));
  }
  function sum3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).sum;
  }
  function distance3(a, b) {
    if (isNumber3(a) && isNumber3(b)) {
      return vabs3(a - b);
    }
    if (isDataFrame3(a) || isSeries3(a)) {
      return distance3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return distance3(a, b.values);
    }
    if (isArray3(a) && isArray3(b)) {
      assert3(isEqual3(shape3(a), shape3(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt3(sum3(vpow3(subtract3(a, b), 2)));
    } catch (e28) {
      return NaN;
    }
  }
  function divide3(a, b) {
    return scale3(a, vpow3(b, -1));
  }
  function dot4(a, b) {
    if (isDataFrame3(a)) {
      const temp = dot4(a.values, b);
      if (shape3(temp).length === 1) {
        const out222 = new Series3(temp);
        out222.name = isSeries3(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame3(temp);
        out222.index = a.index.slice();
        if (isDataFrame3(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame3(b)) {
      const temp = dot4(a, b.values);
      if (shape3(temp).length === 1) {
        const out222 = new Series3(temp);
        out222.name = isSeries3(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame3(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries3(a)) {
      return dot4(a.values, b);
    }
    if (isSeries3(b)) {
      return dot4(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape3(a);
    const bShape = shape3(b);
    assert3(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert3(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum3(scale3(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose3(b).map((col) => dot4(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot4(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose3(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot4(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing3(x6) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return x6.dropMissing(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(x6), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropMissing3(v));
      } catch (e28) {
        if (!isUndefined3(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise3(a, b) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return dropMissingPairwise3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return dropMissingPairwise3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert3(isEqual3(shape3(a), shape3(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise3(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (!isUndefined3(a[i]) && !isUndefined3(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise3(a, b) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return dropNaNPairwise3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return dropNaNPairwise3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert3(isEqual3(shape3(a), shape3(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise3(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (isNumber3(a[i]) && isNumber3(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined3(x6) {
    return dropMissing3(x6);
  }
  function every3(x6, fn2) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return every3(x6.values, fn2);
    }
    assert3(isArray3(x6), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert3(isFunction3(fn2), "The second argument passed into the `every` function must be a function!");
    for (const v of x6) {
      if (isArray3(v)) {
        if (!every3(v, fn2)) {
          return false;
        }
      } else {
        if (!fn2(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        if (x6 === 0n) {
          return 1n;
        } else {
          x6 = Number(x6);
        }
      }
      return Math.exp(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vexp3 = vectorize3(exp3);
  function factorial3(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial3(vint3(n)));
      }
      if (n !== vint3(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial3(n - 1);
    } catch (e28) {
      return NaN;
    }
  }
  var vfactorial3 = vectorize3(factorial3);
  function find3(x6, fn2) {
    if (isDataFrame3(x6)) {
      return find3(x6.values, fn2);
    }
    if (isSeries3(x6)) {
      return find3(x6.values, fn2);
    }
    assert3(isObject3(x6) || isArray3(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction3(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject3(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray3(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn22(x22)) {
          return x22;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    return helper522(x6, safeFn);
  }
  function findAll3(x6, fn2) {
    if (isDataFrame3(x6)) {
      return findAll3(x6.values, fn2);
    }
    if (isSeries3(x6)) {
      return findAll3(x6.values, fn2);
    }
    assert3(isObject3(x6) || isArray3(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction3(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject3(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray3(x22)) {
        checked.push(x22);
        const out222 = [];
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn22(x22)) {
          return [x22];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const results = helper522(x6, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float3(x6) {
    try {
      if (x6 === "Infinity") {
        return Infinity;
      }
      if (x6 === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x6);
      if (isNumber3(out222))
        return out222;
      return NaN;
    } catch (e28) {
      return NaN;
    }
  }
  var vfloat3 = vectorize3(float3);
  function floor3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6;
      }
      return Math.floor(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vfloor3 = vectorize3(floor3);
  function zeros3(shape222) {
    if (isNumber3(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product3(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape3(out222, shape222);
  }
  function identity3(size) {
    if (typeof size === "bigint") {
      size = vint3(size);
    }
    assert3(!isUndefined3(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert3(isNumber3(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert3(vint3(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert3(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros3([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues3 = ["true", "false", "yes", "no"];
  var nullValues3 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger3(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint3(results.value) === results.value;
      } else {
        results.isInteger = every3(results.values, (v) => isNumber3(v) ? vint3(v) === v : true);
      }
    }
    return results;
  }
  function inferType3(arr) {
    if (isDataFrame3(arr)) {
      const out222 = arr.copy();
      const results = inferType3(arr.values);
      out222.values = results.values;
      return checkIfInteger3({ type: results.type, values: out222 });
    }
    if (isSeries3(arr)) {
      const out222 = arr.copy();
      const results = inferType3(arr.values);
      out222.values = results.values;
      return checkIfInteger3({ type: results.type, values: out222 });
    }
    if (!isArray3(arr)) {
      const out222 = inferType3([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger3(out222);
    }
    assert3(isArray3(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten3(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate3(temp)) {
            return "date";
          }
        }
      } catch (e28) {
      }
      if (!isString3(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues3.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues3.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber3(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray3(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e28) {
        const vDate = new Date(v);
        if (isDate3(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count3(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger3({
      type: primaryType,
      values: vapply3(arr, (v) => cast3(v, primaryType))
    });
  }
  function inverse3(x6) {
    if (isDataFrame3(x6)) {
      const out222 = x6.copy();
      out222.values = inverse3(out222.values);
      return out222;
    }
    assert3(isArray3(x6), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape3(x6);
    assert3(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert3(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert3(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x6;
    } else if (xShape[0] === 1) {
      assert3(x6[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x6[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x6[0][0];
      let b = x6[0][1];
      let c = x6[1][0];
      let d = x6[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det2 = a * d - b * c;
      assert3(det2 !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale3(out222, 1 / det2);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber3(a) || isNumber3(b) ? scale3(a, b) : dot4(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x6.slice(0, divider).map((row) => row.slice(0, divider));
          const B10 = x6.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C5 = x6.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x6.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse3(A);
          const CompInv = inverse3(vadd3(D, times(-1, times(times(C5, AInv), B10))));
          const topLeft = vadd3(AInv, times(times(times(times(AInv, B10), CompInv), C5), AInv));
          const topRight = times(-1, times(times(AInv, B10), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C5), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e28) {
        }
      }
      assert3(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser23 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp3(a, b, f) {
    try {
      if (!isNumber3(a))
        return NaN;
      if (!isNumber3(b))
        return NaN;
      if (!isNumber3(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp3(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e28) {
      return NaN;
    }
  }
  var vlerp3 = vectorize3(lerp3);
  function log3(x6, base) {
    try {
      base = isUndefined3(base) ? Math.E : base;
      if (!isNumber3(x6))
        return NaN;
      if (!isNumber3(base))
        return NaN;
      if (typeof x6 === "bigint" || typeof base === "bigint") {
        const out222 = log3(Number(x6), Number(base));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.log(x6) / Math.log(base);
    } catch (e28) {
      return NaN;
    }
  }
  var vlog3 = vectorize3(log3);
  function mean3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).mean;
  }
  function median3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod3(a, b) {
    try {
      if (!isNumber3(a))
        return NaN;
      if (!isNumber3(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod3(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return a % b;
    } catch (e28) {
      return NaN;
    }
  }
  var vmod3 = vectorize3(mod3);
  function mode3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper33() {
    const u12 = random3();
    const u22 = random3();
    return Math.sqrt(-2 * Math.log(u12)) * Math.cos(2 * Math.PI * u22);
  }
  function normal3(shape222) {
    if (isUndefined3(shape222))
      return helper33();
    return vapply3(ndarray3(shape222), helper33);
  }
  function ones3(shape222) {
    return vapply3(ndarray3(shape222), () => 1);
  }
  function permutationsIterator3(x6, r) {
    function* helper522(x22, r22) {
      r22 = r22 || x22.length;
      if (x22.length === 1) {
        yield [x22];
        return;
      }
      for (const c of combinations3(x22, r22)) {
        if (!c.slice)
          continue;
        const state = zeros3(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return permutationsIterator3(x6.values, r);
    }
    assert3(isArray3(x6), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined3(r)) {
      r = x6.length;
    }
    assert3(isNumber3(r) && vint3(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten3(x6), r);
  }
  function permutations3(x6, r) {
    const out222 = [];
    for (const perm of permutationsIterator3(x6, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print3() {
    Object.keys(arguments).forEach((key) => {
      const x6 = arguments[key];
      if (isArray3(x6)) {
        if (!isJagged3(x6)) {
          const xShape = shape3(x6);
          if (xShape.length === 1) {
            new Series3(x6).print();
          } else if (xShape.length == 2) {
            new DataFrame3(x6).print();
          } else {
            console.log(x6);
          }
        } else {
          console.log(x6);
        }
      } else if (isDataFrame3(x6) || isSeries3(x6)) {
        x6.print();
      } else {
        console.log(x6);
      }
    });
  }
  var helper43 = vectorize3((x6, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x6, a, b, c, d]) {
        if (!isNumber3(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x6 = Number(x6);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x6 - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  });
  function remap3(x6, a, b, c, d) {
    if (isArray3(x6) && isUndefined3(c) && isUndefined3(d)) {
      c = a;
      d = b;
      const results = stats3(x6);
      a = results.min;
      b = results.max;
    }
    return helper43(x6, a, b, c, d);
  }
  function round3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.round(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vround3 = vectorize3(round3);
  function sign3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return BigInt(sign3(Number(x6)));
      if (x6 < 0)
        return -1;
      if (x6 > 0)
        return 1;
      return 0;
    } catch (e28) {
      return NaN;
    }
  }
  var vsign3 = vectorize3(sign3);
  function sin3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.sin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsin3 = vectorize3(sin3);
  function some3(x6, fn2) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return some3(x6.values, fn2);
    }
    assert3(isArray3(x6), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert3(isFunction3(fn2), "The second argument passed into the `some` function must be a function!");
    for (const v of x6) {
      if (isArray3(v)) {
        if (some3(v, fn2)) {
          return true;
        }
      } else {
        if (fn2(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev3(x6) {
    return std3(x6);
  }
  function tan3(x6) {
    try {
      if (!isNumber3(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.tan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vtan3 = vectorize3(tan3);
  function timeSync3(fn2, args) {
    assert3(isFunction3(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn2(...args);
    } else {
      fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync3(fn2, args) {
    assert3(isFunction3(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn2(...args);
    } else {
      await fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union3() {
    return set4([...arguments].map((v) => {
      if (isArray3(v))
        return v;
      if (isDataFrame3(v))
        return v.values;
      if (isSeries3(v))
        return v.values;
      return [v];
    }));
  }
  function variance3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip3() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame3(arr) || isSeries3(arr)) {
        arr = arr.values;
      }
      assert3(isArray3(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range3(0, max3(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined3(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out3 = {
    abs: vabs3,
    add: vadd3,
    apply: vapply3,
    arccos: varccos3,
    arcsin: varcsin3,
    arctan: varctan3,
    argmax: argmax3,
    argmin: argmin3,
    assert: assert3,
    cast: cast3,
    ceil: vceil3,
    chop: vchop3,
    clamp: vclamp3,
    combinations: combinations3,
    combinationsIterator: combinationsIterator3,
    copy: copy3,
    correl: correl3,
    cos: vcos3,
    count: count3,
    covariance: covariance3,
    DataFrame: DataFrame3,
    dataTypes: dataTypes3,
    decycle: decycle3,
    diff: diff3,
    distance: distance3,
    divide: divide3,
    dot: dot4,
    dropMissing: dropMissing3,
    dropMissingPairwise: dropMissingPairwise3,
    dropNaN: dropNaN3,
    dropNaNPairwise: dropNaNPairwise3,
    dropUndefined: dropUndefined3,
    every: every3,
    exp: vexp3,
    factorial: vfactorial3,
    find: find3,
    findAll: findAll3,
    flatten: flatten3,
    float: vfloat3,
    floor: vfloor3,
    identity: identity3,
    IndexMatcher: IndexMatcher3,
    indexOf: indexOf3,
    inferType: inferType3,
    int: vint3,
    intersect: intersect3,
    inverse: inverse3,
    isArray: isArray3,
    isBoolean: isBoolean3,
    isBrowser: isBrowser23,
    isDataFrame: isDataFrame3,
    isDate: isDate3,
    isEqual: isEqual3,
    isFunction: isFunction3,
    isJagged: isJagged3,
    isNested: isNested3,
    isNumber: isNumber3,
    isObject: isObject3,
    isSeries: isSeries3,
    isString: isString3,
    isUndefined: isUndefined3,
    lerp: vlerp3,
    log: vlog3,
    MathError: MathError3,
    max: max3,
    mean: mean3,
    median: median3,
    min: min3,
    mod: vmod3,
    mode: mode3,
    multiply: vmultiply3,
    ndarray: ndarray3,
    normal: normal3,
    ones: ones3,
    permutations: permutations3,
    permutationsIterator: permutationsIterator3,
    pow: vpow3,
    print: print3,
    product: product3,
    random: random3,
    range: range3,
    remap: remap3,
    reshape: reshape3,
    reverse: reverse3,
    round: vround3,
    scale: scale3,
    seed: seed3,
    Series: Series3,
    set: set4,
    shape: shape3,
    shuffle: shuffle3,
    sign: vsign3,
    sin: vsin3,
    some: some3,
    sort: sort3,
    sqrt: vsqrt3,
    stats: stats3,
    std: std3,
    stdev: stdev3,
    subtract: subtract3,
    sum: sum3,
    tan: vtan3,
    timeAsync: timeAsync3,
    timeSync: timeSync3,
    time: timeSync3,
    transpose: transpose3,
    union: union3,
    variance: variance3,
    vectorize: vectorize3,
    zeros: zeros3,
    zip: zip3,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out3.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out3).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out3[key]
          });
        } catch (e28) {
          context22[key] = out3[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out3;
  }
  function cohensd(arr1, arr2, shouldIgnoreNaNs) {
    if (isSeries3(arr1)) {
      return cohensd(arr1.values, arr2);
    }
    if (isSeries3(arr2)) {
      return cohensd(arr1, arr2.values);
    }
    assert3(
      isArray3(arr1) && isArray3(arr2) && shape3(arr1).length === 1 && shape3(arr2).length === 1,
      "The `cohensd` function only works on 1-dimensional arrays and Series!"
    );
    assert3(
      arr1.length === arr2.length,
      "Two arrays or Series passed into the `cohensd` function must have the same length!"
    );
    if (shouldIgnoreNaNs) {
      const results = new IndexMatcher3().fitAndTransform(arr1, arr2);
      arr1 = results[0];
      arr2 = results[1];
    }
    try {
      const stats1 = stats3(arr1, { variance: true });
      const stats222 = stats3(arr2, { variance: true });
      const m12 = stats1.mean;
      const m22 = stats222.mean;
      return (m12 - m22) / Math.sqrt((stats1.variance + stats222.variance) / 2);
    } catch (e28) {
      return NaN;
    }
  }
  function simpleStringify(x6) {
    if (typeof x6 === "bigint") {
      return x6.toString() + "n";
    } else {
      return x6;
    }
  }
  function getOneHotEncodings() {
    if (arguments.length === 1 && isSeries3(arguments[0])) {
      const { name: name2, values: values2 } = arguments[0];
      const encodings = getOneHotEncodings(name2, values2);
      const out4 = new DataFrame3(encodings);
      out4.index = arguments[0].index.slice();
      return out4;
    }
    const [name, values] = arguments;
    assert3(
      isString3(name),
      "When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"
    );
    assert3(
      isArray3(values) && shape3(values).length === 1,
      "When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!"
    );
    const out32 = {};
    const colNames = sort3(set4(values)).filter((v) => typeof v !== "number" || v.toString() !== "NaN").filter((v) => !isUndefined3(v)).map((v) => name + "_" + simpleStringify(v)).slice(0, -1);
    colNames.forEach((colName) => {
      out32[colName] = values.map((v) => {
        if (colName === name + "_" + simpleStringify(v)) {
          return 1;
        }
        if (typeof v === "number" && v.toString() === "NaN") {
          return NaN;
        }
        if (isUndefined3(v)) {
          return NaN;
        }
        return 0;
      });
    });
    return out32;
  }
  function isWholeNumber23(x6) {
    return isNumber3(x6) && x6 >= 0 && Math.floor(x6) === x6 && x6 < Infinity;
  }
  function camelify23(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    text = text.trim();
    let out222 = "";
    let shouldCapitalizeNextCharacter = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char.match(/[A-Za-z0-9]/g)) {
        if (out222.length === 0) {
          out222 += char.toLowerCase();
        } else if (shouldCapitalizeNextCharacter) {
          out222 += char.toUpperCase();
        } else {
          out222 += char;
        }
        shouldCapitalizeNextCharacter = false;
      } else if (!char.includes("'") && !char.includes("\u2019") && !char.includes("\u275C")) {
        shouldCapitalizeNextCharacter = true;
      }
    }
    return out222;
  }
  var __defProp23 = Object.defineProperty;
  var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField23 = (obj, key, value) => {
    __defNormalProp23(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber23(x6) {
    return typeof x6 === "number" && !isNaN(x6) || typeof x6 === "bigint";
  }
  var isBrowser33 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError23 = class extends Error {
    constructor(message) {
      if (isBrowser33()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert23(isTrue, message) {
    if (!isTrue)
      throw new MathError23(message);
  }
  var arrayTypes23 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined23(x6) {
    return x6 === null || typeof x6 === "undefined";
  }
  var typeStrings23 = arrayTypes23.map((s222) => s222.name);
  function isArray23(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined23(obj.constructor)) {
        return arrayTypes23.indexOf(obj.constructor) > -1 || typeStrings23.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e28) {
      return false;
    }
  }
  function isDataFrame23(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e28) {
      return false;
    }
  }
  function isFunction23(fn2) {
    return typeof fn2 === "function";
  }
  function isObject23(x6) {
    return typeof x6 === "object" && !isUndefined23(x6) && !isArray23(x6);
  }
  function isSeries23(x6) {
    try {
      return !!x6._symbol && x6._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e28) {
      return false;
    }
  }
  function indexOf23(x6, fn2) {
    if (isDataFrame23(x6)) {
      const index = indexOf23(x6.values, fn2);
      if (index.length > 0 && isNumber23(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      if (index.length > 1 && isNumber23(index[1]) && index[1] >= 0 && index[1] < x6.columns.length) {
        index[1] = x6.columns[index[1]];
      }
      return index;
    }
    if (isSeries23(x6)) {
      const index = indexOf23(x6.values, fn2);
      if (index.length > 0 && isNumber23(index[0]) && index[0] >= 0 && index[0] < x6.index.length) {
        index[0] = x6.index[index[0]];
      }
      return index;
    }
    assert23(isObject23(x6) || isArray23(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction23(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject23(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return [key];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray23(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return [i];
          }
          const results = helper522(value, fn22, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn22(x22)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const paths = helper522(x6, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy23(x6) {
    function helper522(x22) {
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        if (isArray23(x22)) {
          if (!(x22 instanceof Array)) {
            return x22.slice();
          }
          return x22.map((v) => copy23(v));
        }
        if (isSeries23(x22)) {
          const out32 = x22.copy();
          out32.values = copy23(out32.values);
          return out32;
        }
        if (isDataFrame23(x22)) {
          const out32 = x22.copy();
          out32.values = copy23(x22.values);
          return out32;
        }
        if (x22 instanceof Date) {
          return new Date(x22.getTime());
        }
        x22 = decycle23(x22);
        const out222 = {};
        Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
          out222[key] = copy23(x22[key]);
        });
        return out222;
      } else {
        return x22;
      }
    }
    return helper522(decycle23(x6));
  }
  function decycle23(x6) {
    function helper522(x22, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x22) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x22;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x22 ? "/" : "/" + indexOf23(orig, x22).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x22 === "object") {
        if (x22 === null)
          return null;
        checked.push(x22);
        if (isArray23(x22)) {
          if (typeof x22.constructor !== "undefined" && x22.constructor.name !== "Array") {
            return x22.slice();
          }
          return x22.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).forEach((key) => {
            x22[key] = helper522(x22[key], checked, currentPath + "/" + key.toString());
          });
          return x22;
        }
      } else {
        return x22;
      }
    }
    const orig = x6;
    let out222 = helper522(orig);
    if (isDataFrame23(x6)) {
      const temp = x6.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries23(x6)) {
      const temp = x6.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate23(x6) {
    return x6 instanceof Date && x6.toString() !== "Invalid Date";
  }
  var numberTypes23 = ["number", "int", "float", "bigint"];
  function isEqual23(a, b) {
    function helper522(a22, b22) {
      const aType = typeof a22;
      const bType = typeof b22;
      if (aType !== bType && !numberTypes23.includes(aType) && !numberTypes23.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a22 === b22;
      if (aType === "symbol")
        return a22 === b22;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a22.toString();
          const bString = b22.toString();
          return aString === bString;
        } catch (e28) {
          return false;
        }
      }
      if (aType === "string")
        return a22 === b22;
      if (aType === "function")
        return a22 === b22;
      if (aType === "object") {
        if (a22 === null || b22 === null) {
          return a22 === null && b22 === null;
        } else {
          if (isDate23(a22)) {
            if (isDate23(b22)) {
              return a22.getTime() === b22.getTime();
            } else {
              return false;
            }
          } else if (isDate23(b22)) {
            return false;
          }
          if (a22 instanceof RegExp && b22 instanceof RegExp) {
            return a22.toString() === b22.toString();
          }
          if (isArray23(a22) !== isArray23(b22)) {
            return false;
          }
          const aKeys = Object.keys(a22).concat(Object.getOwnPropertySymbols(a22));
          const bKeys = Object.keys(b22).concat(Object.getOwnPropertySymbols(b22));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a22[key], b22[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e28) {
      return helper522(decycle23(a), decycle23(b));
    }
  }
  function makeKey43(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY33 = makeKey43(16);
  var UNDEFINED_KEY33 = makeKey43(16);
  var INFINITY_KEY33 = makeKey43(16);
  var MINUS_INFINITY_KEY33 = makeKey43(16);
  var SYMBOL_KEY33 = makeKey43(16);
  var Counter23 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x6) {
      for (const v of x6) {
        if (isArray23(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY33 : isUndefined23(value) ? UNDEFINED_KEY33 : isFunction23(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY33 : value === Infinity ? INFINITY_KEY33 : value === -Infinity ? MINUS_INFINITY_KEY33 : typeof value === "bigint" ? value.toString() : isDataFrame23(value) ? value.toJSONString() : isSeries23(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined23(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return flatten23(arr.values);
    }
    assert23(isArray23(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray23(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats23(x6, options) {
    options = options || {};
    const counts = new Counter23();
    const out222 = {};
    const xflat = flatten23(x6);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber23(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e28) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e28) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e28) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e28) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e28) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count23(arr, matcher) {
    const { counts } = stats23(arr);
    if (!isUndefined23(matcher)) {
      if (isFunction23(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual23(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper53(x6) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return helper53(x6.values);
    }
    if (isArray23(x6)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x6) {
        if (helper53(v)) {
          return true;
        }
        if (isArray23(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged23(x6) {
    return helper53(decycle23(x6));
  }
  function isNested23(x6) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return isNested23(x6.values);
    }
    assert23(isArray23(x6), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x6.length; i++) {
      if (isArray23(x6[i])) {
        return true;
      }
    }
    return false;
  }
  var error23 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray23(shape222) {
    assert23(!isUndefined23(shape222), error23);
    if (!isArray23(shape222))
      shape222 = [shape222];
    assert23(!isNested23(shape222), error23);
    assert23(shape222.length > 0, error23);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert23(isNumber23(s222), error23);
    assert23(s222 >= 0, error23);
    assert23(Math.floor(s222) === s222, error23);
    assert23(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray23(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      const out32 = arr.copy();
      out32.values = reverse23(out32.values);
      out32.index = reverse23(out32.index);
      return out32;
    }
    assert23(isArray23(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range23(a, b, step = 1) {
    assert23(!isUndefined23(a) && !isUndefined23(b) && !isUndefined23(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert23(isNumber23(a) && isNumber23(b) && isNumber23(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert23(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e28) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse23(out222);
    return out222;
  }
  function makeKey223(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY223 = makeKey223(256);
  var UNDEFINED_KEY223 = makeKey223(256);
  var INFINITY_KEY223 = makeKey223(256);
  var MINUS_INFINITY_KEY223 = makeKey223(256);
  var SYMBOL_KEY223 = makeKey223(256);
  function set23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return set23(arr.values);
    }
    assert23(isArray23(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten23(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY223 : isUndefined23(item) ? UNDEFINED_KEY223 : isFunction23(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY223 : item === Infinity ? INFINITY_KEY223 : item === -Infinity ? MINUS_INFINITY_KEY223 : typeof item === "bigint" ? item.toString() : isDataFrame23(item) ? item.toJSONString() : isSeries23(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper223(x6) {
    if (isArray23(x6)) {
      const childShapes = helper223(x6[0]);
      return [x6.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape23(x6) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return shape23(x6.values);
    }
    assert23(isArray23(x6), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper223(x6);
  }
  function dfAppend23(df2, x6, axis) {
    if (isUndefined23(axis)) {
      axis = 0;
    }
    assert23(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray23(x6)) {
      assert23(!isJagged23(x6), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape23(x6);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df2.copy();
          out222._values.push(x6);
          const maxRowLength = Math.max(df2.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range23(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray23(df2.shape[1]));
            }
            out222._values[i].push(x6[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x6.map((row) => row.length).concat([df2.shape[1]]));
          const out222 = df2.copy();
          out222._values = out222._values.concat(x6).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x6.map((row) => row.length)) + df2.shape[1];
          const maxColLength = Math.max(df2.shape[0], xShape[0]);
          const out222 = df2.copy();
          range23(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray23(df2.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x6[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError23("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries23(x6)) {
      const out222 = dfAppend23(df2, x6.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x6.name) > -1 ? x6.name + " (2)" : x6.name;
      }
      return out222;
    } else if (isDataFrame23(x6)) {
      if (axis === 0) {
        const out222 = df2.copy();
        const maxRowLength = set23(out222._columns.concat(x6._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x6.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x6._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df2._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df2.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x6._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x6._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray23(x6.shape[1]));
          }
        });
        x6._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray23(out222._columns.length).concat(x6._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x6._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError23("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply23(DataFrame222, Series222, df2, fn2, axis) {
    axis = axis || 0;
    assert23(isFunction23(fn2), "The first parameter to the `apply` method must be a function.");
    assert23(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df2.columns.forEach((colName, i) => {
        const series = new Series222(df2.values.map((row) => row[i]));
        series.name = colName;
        series.index = df2.index;
        const value = fn2(series, i, df2);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined23(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray23(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        return out222;
      } else {
        const out222 = new Series222(df2.columns.map((colName) => temp[colName]));
        out222.index = df2.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df2.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const value = fn2(series, i, df2);
        if (isUndefined23(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray23(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df2.index;
        out222.columns = df2.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df2.index;
        return out222;
      }
    }
  }
  function isString23(s222) {
    return typeof s222 === "string";
  }
  function dfAssign23(DataFrame222, Series222, df2, p12, p22) {
    const isDataFrame222 = (x6) => x6 instanceof DataFrame222;
    const isSeries222 = (x6) => x6 instanceof Series222;
    if (!isUndefined23(p22)) {
      assert23(isString23(p12), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert23(isArray23(p22) && !isJagged23(p22) && shape23(p22).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df2.append(p22, 1);
      out222.columns[out222.columns.length - 1] = p12;
      return out222;
    } else {
      if (isDataFrame222(p12)) {
        return df2.append(p12, 1);
      } else if (isSeries222(p12)) {
        return df2.append(p12, 1);
      } else if (isObject23(p12)) {
        const maxColumnLength = Math.max(...Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).map((key) => p12[key].length));
        Object.keys(p12).concat(Object.getOwnPropertySymbols(p12)).forEach((key) => {
          while (p12[key].length < maxColumnLength) {
            p12[key].push(void 0);
          }
        });
        return df2.append(new DataFrame222(p12), 1);
      } else {
        throw new MathError23("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy23(DataFrame222, df2) {
    if (df2.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy23(df2.values));
    out222.columns = df2.columns.slice();
    out222.index = df2.index.slice();
    return out222;
  }
  function dfDrop23(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined23(rows))
      rows = [];
    if (isUndefined23(cols))
      cols = [];
    if (isString23(rows) || isNumber23(rows))
      rows = [rows];
    if (isString23(cols) || isNumber23(cols))
      cols = [cols];
    assert23(isArray23(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert23(isArray23(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert23(shape23(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert23(shape23(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df2.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df2.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df2.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df2.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger23(x6) {
    return isNumber23(x6) && (x6 >= 0 ? Math.floor(x6) === x6 : Math.ceil(x6) === x6);
  }
  function isWholeNumber32(x6) {
    return isInteger23(x6) && x6 >= 0;
  }
  function dfDropMissing23(DataFrame222, Series222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert23(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert23(isWholeNumber32(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert23(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined23(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined23(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined23(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df2.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape23(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined23(newIndex))
        return new DataFrame222();
      if (isString23(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN23(x6) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return x6.dropNaN(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(x6), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropNaN23(v));
      } catch (e28) {
        if (isNumber23(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN23(DataFrame222, df2, axis, condition, threshold) {
    axis = axis || 0;
    assert23(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert23(isWholeNumber32(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert23(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN23(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df2.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject23(x6) {
    const out222 = {};
    flatten23(x6).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject23(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter23(DataFrame222, Series222, df2, fn2, axis) {
    assert23(isFunction23(fn2), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined23(axis))
      axis = 0;
    assert23(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df2.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject23(out222.index);
    const columns = arrayToObject23(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.index[i];
        series.index = df2.columns;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject23(index)[0];
        temp.index = undoArrayToObject23(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject23(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df2.columns[i];
        series.index = df2.index;
        const shouldKeep = fn2(series, i, df2);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject23(columns)[0];
        temp.index = undoArrayToObject23(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject23(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet23(df2, rows, cols) {
    if (isString23(rows) || isNumber23(rows))
      rows = [rows];
    if (isString23(cols) || isNumber23(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set23((rows || []).concat(cols || []).map((v) => typeof v));
    assert23(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert23(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert23(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert23(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined23(rows)) {
      rows = rows.map((r) => {
        if (isString23(r)) {
          assert23(df2.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber23(r)) {
          assert23(r >= 0, `Index ${r} is out of bounds!`);
          assert23(Math.floor(r) === r, `Row numbers must be integers!`);
          assert23(r < df2.index.length, `Index ${r} is out of bounds!`);
          return df2.index[r];
        }
      });
    }
    if (!isUndefined23(cols)) {
      cols = cols.map((c) => {
        if (isString23(c)) {
          assert23(df2.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber23(c)) {
          assert23(c >= 0, `Column ${c} is out of bounds!`);
          assert23(Math.floor(c) === c, `Column numbers must be integers!`);
          assert23(c < df2.columns.length, `Column ${c} is out of bounds!`);
          return df2.columns[c];
        }
      });
    }
    return df2.getSubsetByNames(rows, cols);
  }
  function alphaSort23(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e28) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort23(arr, fn2) {
    if (isUndefined23(fn2))
      fn2 = alphaSort23;
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert23(isFunction23(fn2), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn2);
    return out222;
  }
  function camelify223(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies23(DataFrame222, df2, columns) {
    if (isUndefined23(columns)) {
      columns = df2.columns;
    } else if (isString23(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert23(isString23(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df2.columns.indexOf(col);
      assert23(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df2.values.map((row) => row[colIndex]);
      const valuesSet = sort23(set23(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify223(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df2.index;
    return out222;
  }
  function dfGetSubsetByIndices23(df2, rowIndices, colIndices) {
    const dataShape = df2.shape;
    if (isUndefined23(rowIndices))
      rowIndices = range23(0, dataShape[0]);
    if (isUndefined23(colIndices))
      colIndices = range23(0, dataShape[1]);
    if (isNumber23(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber23(colIndices))
      colIndices = [colIndices];
    assert23(isArray23(rowIndices) && isArray23(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert23(shape23(rowIndices).length === 1 && shape23(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert23(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert23(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert23(isWholeNumber32(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert23(rowIndex < df2.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert23(isWholeNumber32(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert23(colIndex < df2.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df2.index[i]);
    const cols = colIndices.map((i) => df2.columns[i]);
    return df2.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames23(DataFrame222, Series222, df2, rows, cols) {
    if (isUndefined23(rows))
      rows = df2.index;
    if (isUndefined23(cols))
      cols = df2.columns;
    if (isString23(rows))
      rows = [rows];
    if (isString23(cols))
      cols = [cols];
    assert23(isArray23(rows) && isArray23(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert23(shape23(rows).length === 1 && shape23(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert23(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert23(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert23(isString23(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert23(df2.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert23(isString23(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert23(df2.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df2.values[df2.index.indexOf(row)][df2.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint23(DataFrame222, Series222, df2) {
    function truncate(s222, maxLength2) {
      if (isString23(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df2.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df2;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df2.index.length ? null : range23(0, halfMaxRows).concat(range23(df2.index.length - halfMaxRows, df2.index.length));
    const tempColumns = maxColumns > df2.columns.length ? null : range23(0, halfMaxColumns).concat(range23(df2.columns.length - halfMaxColumns, df2.columns.length));
    let temp = df2.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df2.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df2.index;
        temp.columns = new Series222(df2.columns).get(tempColumns).values;
      } else if (df2.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df2.index).get(tempRows).values;
        temp.columns = df2.columns;
      }
    }
    if (maxRows <= df2.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range23(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df2.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df2.shape, "\n");
    return df2;
  }
  function leftPad23(x6, maxLength) {
    assert23(isNumber23(x6), "The `leftPad` function only works on numbers!");
    let out222 = x6.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex23(df2, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df2 : df2.copy();
    out222.index = range23(0, df2.shape[0]).map((i) => {
      return "row" + leftPad23(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product23(arr, shouldDropNaNs) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return product23(arr.values, shouldDropNaNs);
    }
    assert23(isArray23(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten23(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber23(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  function isNaturalNumber23(x6) {
    return isInteger23(x6) && x6 > 0;
  }
  function reshape23(x6, newShape) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return reshape23(x6.values, newShape);
    }
    assert23(isArray23(x6), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber23(newShape))
      newShape = [newShape];
    assert23(isArray23(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert23(shape23(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert23(isNaturalNumber23(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten23(x6);
    }
    const temp = flatten23(x6);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert23(product23(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape23(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX23 = Math.pow(2, 64);
  var s24 = [];
  seed23(Math.floor(Math.random() * MAX23));
  function splitmix6423(state, n) {
    state = uint23(state);
    function helper522() {
      state += uint23("0x9e3779b97f4a7c15");
      let z10 = copy23(state);
      z10 = (z10 ^ z10 >> BigInt(30)) * uint23("0xbf58476d1ce4e5b9");
      z10 = (z10 ^ z10 >> BigInt(27)) * uint23("0x94d049bb133111eb");
      return z10 ^ z10 >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint23(x6) {
    return BigInt.asUintN(64, BigInt(x6));
  }
  function rotl23(x6, k6) {
    x6 = uint23(x6);
    k6 = BigInt(k6);
    return uint23(uint23(x6 << k6) | uint23(x6 >> uint23(BigInt(64) - k6)));
  }
  function seed23(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined23(val)) {
      assert23(isNumber23(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix6423(Math.floor(val), 4);
      s24[0] = temp[0];
      s24[1] = temp[1];
      s24[2] = temp[2];
      s24[3] = temp[3];
    } else {
      return copy23(s24);
    }
  }
  function next23() {
    const result = uint23(rotl23(s24[0] + s24[3], 23) + s24[0]);
    const t = uint23(s24[1] << BigInt(17));
    s24[2] = uint23(s24[2] ^ s24[0]);
    s24[3] = uint23(s24[3] ^ s24[1]);
    s24[1] = uint23(s24[1] ^ s24[2]);
    s24[0] = uint23(s24[0] ^ s24[3]);
    s24[2] = uint23(s24[2] ^ t);
    s24[3] = rotl23(s24[3], 45);
    return Math.floor(Number(result)) / MAX23;
  }
  function random23(shape222) {
    if (isUndefined23(shape222))
      return next23();
    if (!isArray23(shape222))
      shape222 = [shape222];
    return reshape23(ndarray23(product23(shape222)).map(next23), shape222);
  }
  function shuffle23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random23() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle23(df2, axis) {
    if (isUndefined23(axis))
      axis = 0;
    assert23(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df2.get(axis === 0 ? shuffle23(df2.index) : null, axis === 1 ? shuffle23(df2.columns) : null);
  }
  function isBoolean23(x6) {
    return typeof x6 === "boolean";
  }
  function dfSort23(df2, a, b) {
    if (isFunction23(a)) {
      return dfSortByFunction23(df2, a, b);
    } else {
      return dfSortByColumns23(df2, a, b);
    }
  }
  function dfSortByFunction23(df2, fn2, axis) {
    axis = isUndefined23(axis) ? 0 : axis;
    assert23(isFunction23(fn2), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert23(isNumber23(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort23(df2.index, (a, b) => {
        return fn2(df2.get(a, null), df2.get(b, null));
      });
      return df2.get(index, null);
    } else {
      const columns = sort23(df2.columns, (a, b) => {
        return fn2(df2.get(null, a), df2.get(null, b));
      });
      return df2.get(null, columns);
    }
  }
  function dfSortByColumns23(df2, cols, directions) {
    let out222 = df2.copy();
    const indexID = random23().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined23(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber23(cols) || isString23(cols)) {
      cols = [cols];
      if (isBoolean23(directions) || isString23(directions))
        directions = [directions];
    }
    assert23(isArray23(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert23(shape23(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined23(directions))
      directions = range23(0, cols.length).map(() => true);
    assert23(isArray23(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert23(shape23(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert23(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert23(isString23(col) || isNumber23(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString23(col)) {
        const index = out222.columns.indexOf(col);
        assert23(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber23(col)) {
        assert23(isWholeNumber32(col), "Column indices must be whole numbers!");
        assert23(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert23(isString23(dir) || isBoolean23(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString23(dir)) {
        const value = dir.trim().toLowerCase();
        assert23(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean23(dir)) {
        return dir;
      }
    });
    out222.values = sort23(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject23(df2, axis) {
    if (isUndefined23(axis)) {
      axis = 0;
    } else {
      assert23(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df2.index.forEach((rowName, i) => {
        const temp = {};
        df2.columns.forEach((colName, j) => {
          temp[colName] = df2.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df2.columns.forEach((colName, j) => {
        const temp = {};
        df2.index.forEach((rowName, i) => {
          temp[rowName] = df2.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString23(df2, axis) {
    return JSON.stringify(df2.toObject(axis));
  }
  async function dfToJSON23(df2, filename, axis) {
    const out222 = dfToJSONString23(df2, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e28) {
      browserError = e28;
    }
    try {
      const fs2 = await import("node:fs");
      const path = await import("node:path");
      fs2.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e28) {
      nodeError = e28;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError23(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError23(nodeError);
      } else {
        throw new MathError23("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df2;
  }
  function dfToObject23(df2) {
    const out222 = {};
    df2.columns.forEach((col) => {
      out222[col] = df2.get(col).values;
    });
    return out222;
  }
  function transpose23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return arr.transpose();
    }
    assert23(isArray23(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape23(arr);
    assert23(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse23(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray23(reverse23(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend23(Series222, series, x6) {
    if (isSeries23(x6)) {
      return new Series222(series.values.concat(x6.values));
    }
    if (isArray23(x6)) {
      const xShape = shape23(x6);
      assert23(xShape.length === 1 && !isNested23(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x6.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend23(series, [x6]);
  }
  function seriesApply23(series, fn2) {
    assert23(isFunction23(fn2), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn2(v, i));
    return out222;
  }
  function seriesDropMissing23(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined23(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN23(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber23(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter23(Series222, series, fn2) {
    let out222 = series.copy();
    const index = copy23(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn2(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet23(series, indices) {
    if (isString23(indices) || isNumber23(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set23((indices || []).map((v) => typeof v));
    assert23(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert23(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert23(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert23(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined23(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert23(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert23(i >= 0, `Index ${i} is out of bounds!`);
          assert23(Math.floor(i) === i, `Indices must be integers!`);
          assert23(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices23(series, indices) {
    const dataShape = series.shape;
    if (isUndefined23(indices))
      indices = range23(0, dataShape[0]);
    assert23(isArray23(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert23(shape23(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert23(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert23(isWholeNumber32(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert23(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames23(Series222, series, indices) {
    if (isUndefined23(indices))
      indices = series.index;
    assert23(isArray23(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert23(shape23(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert23(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert23(isString23(name), "The `indices` array must contain only strings.");
      assert23(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint23(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range23(0, maxRows / 2).concat(range23(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy23(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle23(series) {
    const out222 = series.copy();
    return out222.get(shuffle23(out222.index));
  }
  function seriesSort23(Series222, series, fn2) {
    fn2 = fn2 || ((a, b) => a < b ? -1 : 1);
    assert23(isUndefined23(fn2) || isFunction23(fn2), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose23([series.values, series.index]);
    const temp = sort23(pairs, (aPair, bPair) => {
      return fn2(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex23(Series222, series) {
    let temp = transpose23([series.values, series.index]);
    temp = transpose23(sort23(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject23(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL23 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass23(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x6) {
        try {
          return !!x6._symbol && x6._symbol === SERIES_SYMBOL23;
        } catch (e28) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL23
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x6) {
            assert23(isArray23(x6), "The new values must be a 1-dimensional array!");
            const dataShape = shape23(x6);
            assert23(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range23(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad23(i, (x6.length - 1).toString().length);
              }));
            }
            this._values = x6;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x6) {
            assert23(isArray23(x6), "The new index must be a 1-dimensional array of strings!");
            assert23(x6.length === this.shape[0], "The new index must be the same length as the old index!");
            assert23(shape23(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
            x6.forEach((value) => {
              assert23(isString23(value), "All of the row names must be strings!");
            });
            this._index = x6;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy23(data.values);
            this.index = copy23(data.index);
          } else if (isArray23(data)) {
            const dataShape = shape23(data);
            assert23(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert23(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert23(shape23(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape23(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined23(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet23(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames23(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices23(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse23(this.values));
        out222.index = reverse23(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range23(0, this.shape[0]).map((i) => {
          return "item" + leftPad23(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy23(this.values);
        out222._index = copy23(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x6) {
        return seriesAppend23(Series222, this, x6);
      }
      apply(fn2) {
        return seriesApply23(this, fn2);
      }
      concat(x6) {
        return this.append(x6);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing23(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN23(Series222, this);
      }
      toObject() {
        return seriesToObject23(this);
      }
      print() {
        return seriesPrint23(this);
      }
      shuffle() {
        return seriesShuffle23(this);
      }
      sort(direction) {
        return seriesSort23(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex23(Series222, this);
      }
      filter(fn2) {
        return seriesFilter23(Series222, this, fn2);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose23([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse23(out222.values);
        out222.index = reverse23(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL23 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey323(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random23() * alpha.length)];
    return out222;
  }
  var DataFrame23 = class {
    static [Symbol.hasInstance](x6) {
      try {
        return !!x6._symbol && x6._symbol === DATAFRAME_SYMBOL23;
      } catch (e28) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL23
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined23(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x6) {
          assert23(isArray23(x6), "The new values must be a 2-dimensional array!");
          const dataShape = shape23(x6);
          assert23(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range23(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad23(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range23(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad23(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x6;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x6) {
          assert23(isArray23(x6), "The new columns list must be a 1-dimensional array of strings!");
          assert23(this.isEmpty || x6.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert23(shape23(x6).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey323(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count23(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey323(8);
            }
            return v;
          });
          this._columns = x6;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x6) {
          assert23(isArray23(x6), "The new index must be a 1-dimensional array of strings!");
          assert23(this.isEmpty || x6.length === this.shape[0], "The new index must be the same length as the old index!");
          assert23(shape23(x6).length === 1, "The new index must be a 1-dimensional array of strings!");
          x6 = x6.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey323(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count23(x6);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x6 = x6.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey323(8);
            }
            return v;
          });
          this._index = x6;
        }
      });
      assert23(isUndefined23(data) || isObject23(data) || isArray23(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame23) {
          this.values = copy23(data.values);
          this.columns = copy23(data.columns);
          this.index = copy23(data.index);
        } else if (isArray23(data)) {
          const dataShape = shape23(data);
          assert23(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert23(!isJagged23(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined23(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert23(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose23(temp);
          const dataShape = shape23(this.values);
          this._index = range23(0, dataShape[0]).map((i) => {
            return "row" + leftPad23(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape23(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame23(ndarray23(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e28) {
          return this.get(rows, null);
        }
      }
      return dfGet23(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames23(DataFrame23, Series23, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices23(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies23(DataFrame23, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies23(DataFrame23, this, columns);
    }
    transpose() {
      const out222 = new DataFrame23(transpose23(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex23(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy23(DataFrame23, this);
    }
    assign(p12, p22) {
      return dfAssign23(DataFrame23, Series23, this, p12, p22);
    }
    apply(fn2, axis) {
      return dfApply23(DataFrame23, Series23, this, fn2, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing23(DataFrame23, Series23, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN23(DataFrame23, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop23(DataFrame23, Series23, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject23(this, axis);
    }
    toObject() {
      return dfToObject23(this);
    }
    toJSONString(axis) {
      return dfToJSONString23(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON23(this, filename, axis);
    }
    print() {
      return dfPrint23(DataFrame23, Series23, this);
    }
    sort(cols, directions) {
      return dfSort23(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn2, axis) {
      return dfFilter23(DataFrame23, Series23, this, fn2, axis);
    }
    shuffle(axis) {
      return dfShuffle23(this, axis);
    }
    append(x6, axis) {
      return dfAppend23(this, x6, axis);
    }
    concat(x6, axis) {
      return this.append(x6, axis);
    }
    join(x6, axis) {
      return this.append(x6, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series23 = createSeriesClass23(DataFrame23);
  function max23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).max;
  }
  function vectorize23(fn2) {
    assert23(isFunction23(fn2), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray23(arg)) {
          return true;
        } else if (isSeries23(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame23(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert23(isEqual23(isArray23(s222) ? shape23(s222) : s222.shape, isArray23(childArrays[i + 1]) ? shape23(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn2.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max23(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range23(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray23(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries23(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame23(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual23(shape23(dataframes[0]), shape23(out222))) {
              const temp = new DataFrame23(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame23(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series23(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series23(out222);
            }
          } catch (e28) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn2(...arguments);
      }
    };
  }
  function abs23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6 < 0 ? -x6 : x6;
      } else {
        return Math.abs(x6);
      }
    } catch (e28) {
      return NaN;
    }
  }
  var vabs23 = vectorize23(abs23);
  function add23() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x6 = Object.values(arguments);
      for (let v of x6) {
        if (!isNumber23(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vadd23 = vectorize23(add23);
  function apply23(x6, fn2) {
    try {
      return fn2(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vapply23 = vectorize23(apply23);
  function arccos23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.acos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varccos23 = vectorize23(arccos23);
  function arcsin23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.asin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varcsin23 = vectorize23(arcsin23);
  function arctan23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.atan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var varctan23 = vectorize23(arctan23);
  function argmax23(x6, shouldDropNaNs) {
    if (isDataFrame23(x6)) {
      const index = argmax23(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries23(x6)) {
      const index = argmax23(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert23(isArray23(x6), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf23(x6, max23(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function min23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).min;
  }
  function argmin23(x6, shouldDropNaNs) {
    if (isDataFrame23(x6)) {
      const index = argmin23(x6.values, shouldDropNaNs);
      return [x6.index[index[0]], x6.columns[index[1]]];
    }
    if (isSeries23(x6)) {
      const index = argmin23(x6.values, shouldDropNaNs);
      return x6.index[index];
    }
    assert23(isArray23(x6), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf23(x6, min23(x6, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e28) {
      return void 0;
    }
  }
  function cast23(value, type) {
    if (isDataFrame23(value) || isSeries23(value)) {
      return value.apply((item) => cast23(item, type));
    }
    if (isArray23(value)) {
      return value.map((v) => cast23(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined23(value)) {
        return NaN;
      }
      const booleanValue = cast23(value, "boolean");
      if (isBoolean23(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e28) {
        const dateValue = cast23(value, "date");
        if (isDate23(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast23(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast23(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast23(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean23(value)) {
        return value;
      }
      if (isNumber23(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e28) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate23(value)) {
        return value;
      }
      if (isUndefined23(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate23(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject23(value)) {
        return value;
      }
      const booleanValue = cast23(value, "boolean");
      if (isBoolean23(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast23(value, "number");
        if (isNumber23(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e28) {
      }
      const dateValue = cast23(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray23(out222)) {
          return out222.map((v) => cast23(v, type));
        } else {
          return out222;
        }
      } catch (e28) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined23(value)) {
        if (isEqual23(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.ceil(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vceil23 = vectorize23(ceil23);
  function chop23(x6, threshold) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      if (isUndefined23(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber23(threshold)) {
        return NaN;
      }
      return vabs23(x6) < threshold ? 0 : x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vchop23 = vectorize23(chop23);
  function int23(x6) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      const out222 = x6.copy();
      out222.values = int23(out222.values);
      return out222;
    }
    if (isArray23(x6)) {
      return x6.map((v) => int23(v));
    } else {
      try {
        const out222 = JSON.parse(x6);
        if (isNumber23(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e28) {
        return NaN;
      }
    }
  }
  var vint23 = vectorize23(int23);
  function clamp23(x6, a, b) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (!isNumber23(a))
        return NaN;
      if (!isNumber23(b))
        return NaN;
      if (typeof x6 === "bigint") {
        return BigInt(clamp23(vint23(x6), a, b));
      }
      if (x6 < a)
        return a;
      if (x6 > b)
        return b;
      return x6;
    } catch (e28) {
      return NaN;
    }
  }
  var vclamp23 = vectorize23(clamp23);
  function combinationsIterator23(x6, r) {
    function* helper522(x22, r22) {
      if (r22 > x22.length) {
        yield x22;
      } else if (r22 <= 0) {
        yield [];
      } else if (x22.length < 2) {
        yield x22;
      } else {
        for (let i = 0; i < x22.length; i++) {
          const item = x22[i];
          const after = x22.slice(i + 1);
          if (after.length < r22 - 1) {
            continue;
          }
          if (r22 - 1 >= 0) {
            for (const child of combinationsIterator23(after, r22 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return combinationsIterator23(x6.values, r);
    }
    assert23(isArray23(x6), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert23(isNumber23(r) && vint23(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten23(x6), r);
  }
  function combinations23(x6, r) {
    const out222 = [];
    for (const combo of combinationsIterator23(x6, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect23() {
    const arrays = Object.values(arguments).map((x6) => {
      if (isDataFrame23(x6) || isSeries23(x6)) {
        return set23(x6.values);
      }
      assert23(isArray23(x6), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set23(x6);
    });
    const all = set23(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual23(other, v)) > -1);
    });
  }
  var _IndexMatcher23 = class {
    constructor(mode222) {
      assert23(isUndefined23(mode222) || mode222 === _IndexMatcher23.DROP_NAN_MODE || mode222 === _IndexMatcher23.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined23(mode222) ? mode222 : _IndexMatcher23.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x6) => {
        if (isArray23(x6)) {
          const xshape = shape23(x6);
          if (xshape.length === 1) {
            x6 = new Series23(x6);
          } else if (xshape.length === 2) {
            x6 = new DataFrame23(x6);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert23(isDataFrame23(x6) || isSeries23(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher23.DROP_MISSING_MODE) {
          indices.push(x6.dropMissing().index);
        } else {
          indices.push(x6.dropNaN().index);
        }
      });
      this.index = intersect23(...indices);
      return this;
    }
    transform() {
      assert23(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x6) => {
        if (isArray23(x6)) {
          const xshape = shape23(x6);
          if (xshape.length === 1) {
            return new Series23(x6).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame23(x6).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert23(isDataFrame23(x6) || isSeries23(x6), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x6.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher23 = _IndexMatcher23;
  __publicField23(IndexMatcher23, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField23(IndexMatcher23, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance23(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries23(x6)) {
      return covariance23(x6.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries23(y)) {
      return covariance23(x6, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert23(isArray23(x6) && isArray23(y) && shape23(x6).length === 1 && shape23(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert23(x6.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance23(...new IndexMatcher23().fitAndTransform(x6, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats23(x6, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats23(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx2 = Number(xstats.mean);
      const my2 = Number(ystats.mean);
      if (!isNumber23(mx2) || !isNumber23(my2)) {
        return NaN;
      }
      const n = Math.max(x6.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx2 = x6[i];
        let vy2 = y[i];
        if (!isNumber23(vx2))
          return NaN;
        if (!isNumber23(vy2))
          return NaN;
        if (typeof vx2 === "bigint") {
          vx2 = Number(vx2);
        }
        if (typeof vy2 === "bigint") {
          vy2 = Number(vy2);
        }
        out222 += (vx2 - mx2) * (vy2 - my2);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x6.length, xstats, ystats];
      } else {
        return out222 / x6.length;
      }
    } catch (e28) {
      return NaN;
    }
  }
  function correl23(x6, y, shouldDropNaNs) {
    if (isSeries23(x6)) {
      return correl23(x6.values, y, shouldDropNaNs);
    }
    if (isSeries23(y)) {
      return correl23(x6, y.values, shouldDropNaNs);
    }
    assert23(isArray23(x6) && isArray23(y) && shape23(x6).length === 1 && shape23(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert23(x6.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance23(x6, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e28) {
      return NaN;
    }
  }
  function cos23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.cos(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vcos23 = vectorize23(cos23);
  var dataTypes23 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff23(a, b) {
    if (isDataFrame23(a) || isSeries23(a)) {
      return diff23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return diff23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set23(a);
    const bTemp = set23(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual23(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow23(x6, p) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (!isNumber23(p))
        return NaN;
      if (typeof x6 === "bigint" || typeof p === "bigint") {
        const out222 = pow23(Number(x6), Number(p));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.pow(x6, p);
    } catch (e28) {
      return NaN;
    }
  }
  var vpow23 = vectorize23(pow23);
  function sqrt23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        const out222 = sqrt23(Number(x6));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.sqrt(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsqrt23 = vectorize23(sqrt23);
  function multiply23() {
    try {
      const x6 = Object.values(arguments);
      if (x6.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x6) {
        if (!isNumber23(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  }
  var vmultiply23 = vectorize23(multiply23);
  function scale23() {
    return vmultiply23(...arguments);
  }
  function subtract23(a, b) {
    return vadd23(a, scale23(b, -1));
  }
  function sum23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).sum;
  }
  function distance23(a, b) {
    if (isNumber23(a) && isNumber23(b)) {
      return vabs23(a - b);
    }
    if (isDataFrame23(a) || isSeries23(a)) {
      return distance23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return distance23(a, b.values);
    }
    if (isArray23(a) && isArray23(b)) {
      assert23(isEqual23(shape23(a), shape23(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt23(sum23(vpow23(subtract23(a, b), 2)));
    } catch (e28) {
      return NaN;
    }
  }
  function divide23(a, b) {
    return scale23(a, vpow23(b, -1));
  }
  function dot23(a, b) {
    if (isDataFrame23(a)) {
      const temp = dot23(a.values, b);
      if (shape23(temp).length === 1) {
        const out222 = new Series23(temp);
        out222.name = isSeries23(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame23(temp);
        out222.index = a.index.slice();
        if (isDataFrame23(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame23(b)) {
      const temp = dot23(a, b.values);
      if (shape23(temp).length === 1) {
        const out222 = new Series23(temp);
        out222.name = isSeries23(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame23(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries23(a)) {
      return dot23(a.values, b);
    }
    if (isSeries23(b)) {
      return dot23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape23(a);
    const bShape = shape23(b);
    assert23(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert23(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum23(scale23(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose23(b).map((col) => dot23(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot23(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose23(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot23(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing23(x6) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return x6.dropMissing(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(x6), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x6.forEach((v) => {
      try {
        return out222.push(dropMissing23(v));
      } catch (e28) {
        if (!isUndefined23(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise23(a, b) {
    if (isDataFrame23(a) || isSeries23(a)) {
      return dropMissingPairwise23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return dropMissingPairwise23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert23(isEqual23(shape23(a), shape23(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise23(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (!isUndefined23(a[i]) && !isUndefined23(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise23(a, b) {
    if (isDataFrame23(a) || isSeries23(a)) {
      return dropNaNPairwise23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return dropNaNPairwise23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert23(isEqual23(shape23(a), shape23(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise23(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e28) {
        if (isNumber23(a[i]) && isNumber23(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined23(x6) {
    return dropMissing23(x6);
  }
  function every23(x6, fn2) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return every23(x6.values, fn2);
    }
    assert23(isArray23(x6), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert23(isFunction23(fn2), "The second argument passed into the `every` function must be a function!");
    for (const v of x6) {
      if (isArray23(v)) {
        if (!every23(v, fn2)) {
          return false;
        }
      } else {
        if (!fn2(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        if (x6 === 0n) {
          return 1n;
        } else {
          x6 = Number(x6);
        }
      }
      return Math.exp(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vexp23 = vectorize23(exp23);
  function factorial23(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial23(vint23(n)));
      }
      if (n !== vint23(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial23(n - 1);
    } catch (e28) {
      return NaN;
    }
  }
  var vfactorial23 = vectorize23(factorial23);
  function find23(x6, fn2) {
    if (isDataFrame23(x6)) {
      return find23(x6.values, fn2);
    }
    if (isSeries23(x6)) {
      return find23(x6.values, fn2);
    }
    assert23(isObject23(x6) || isArray23(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction23(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject23(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray23(x22)) {
        checked.push(x22);
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          if (fn22(value)) {
            return value;
          }
          const result = helper522(value, fn22, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn22(x22)) {
          return x22;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    return helper522(x6, safeFn);
  }
  function findAll23(x6, fn2) {
    if (isDataFrame23(x6)) {
      return findAll23(x6.values, fn2);
    }
    if (isSeries23(x6)) {
      return findAll23(x6.values, fn2);
    }
    assert23(isObject23(x6) || isArray23(x6), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction23(fn2)) {
      const value = fn2;
      fn2 = (v) => v === value;
    }
    function helper522(x22, fn22, checked) {
      checked = checked || [];
      if (checked.indexOf(x22) > -1) {
        return null;
      }
      if (isObject23(x22)) {
        checked.push(x22);
        const keys = Object.keys(x22).concat(Object.getOwnPropertySymbols(x22));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x22[key];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray23(x22)) {
        checked.push(x22);
        const out222 = [];
        for (let i = 0; i < x22.length; i++) {
          const value = x22[i];
          let alreadyStoredThisValue = false;
          if (fn22(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn22, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn22(x22)) {
          return [x22];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn2(v);
      } catch (e28) {
        return false;
      }
    }
    const results = helper522(x6, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float23(x6) {
    try {
      if (x6 === "Infinity") {
        return Infinity;
      }
      if (x6 === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x6);
      if (isNumber23(out222))
        return out222;
      return NaN;
    } catch (e28) {
      return NaN;
    }
  }
  var vfloat23 = vectorize23(float23);
  function floor23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        return x6;
      }
      return Math.floor(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vfloor23 = vectorize23(floor23);
  function zeros23(shape222) {
    if (isNumber23(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product23(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape23(out222, shape222);
  }
  function identity23(size) {
    if (typeof size === "bigint") {
      size = vint23(size);
    }
    assert23(!isUndefined23(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert23(isNumber23(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert23(vint23(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert23(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros23([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues23 = ["true", "false", "yes", "no"];
  var nullValues23 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger23(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint23(results.value) === results.value;
      } else {
        results.isInteger = every23(results.values, (v) => isNumber23(v) ? vint23(v) === v : true);
      }
    }
    return results;
  }
  function inferType23(arr) {
    if (isDataFrame23(arr)) {
      const out222 = arr.copy();
      const results = inferType23(arr.values);
      out222.values = results.values;
      return checkIfInteger23({ type: results.type, values: out222 });
    }
    if (isSeries23(arr)) {
      const out222 = arr.copy();
      const results = inferType23(arr.values);
      out222.values = results.values;
      return checkIfInteger23({ type: results.type, values: out222 });
    }
    if (!isArray23(arr)) {
      const out222 = inferType23([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger23(out222);
    }
    assert23(isArray23(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten23(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate23(temp)) {
            return "date";
          }
        }
      } catch (e28) {
      }
      if (!isString23(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues23.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues23.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber23(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray23(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e28) {
        const vDate = new Date(v);
        if (isDate23(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count23(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger23({
      type: primaryType,
      values: vapply23(arr, (v) => cast23(v, primaryType))
    });
  }
  function inverse23(x6) {
    if (isDataFrame23(x6)) {
      const out222 = x6.copy();
      out222.values = inverse23(out222.values);
      return out222;
    }
    assert23(isArray23(x6), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape23(x6);
    assert23(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert23(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert23(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x6;
    } else if (xShape[0] === 1) {
      assert23(x6[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x6[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x6[0][0];
      let b = x6[0][1];
      let c = x6[1][0];
      let d = x6[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det2 = a * d - b * c;
      assert23(det2 !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale23(out222, 1 / det2);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber23(a) || isNumber23(b) ? scale23(a, b) : dot23(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x6.slice(0, divider).map((row) => row.slice(0, divider));
          const B10 = x6.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C5 = x6.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x6.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse23(A);
          const CompInv = inverse23(vadd23(D, times(-1, times(times(C5, AInv), B10))));
          const topLeft = vadd23(AInv, times(times(times(times(AInv, B10), CompInv), C5), AInv));
          const topRight = times(-1, times(times(AInv, B10), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C5), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e28) {
        }
      }
      assert23(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser223 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp23(a, b, f) {
    try {
      if (!isNumber23(a))
        return NaN;
      if (!isNumber23(b))
        return NaN;
      if (!isNumber23(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp23(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e28) {
      return NaN;
    }
  }
  var vlerp23 = vectorize23(lerp23);
  function log23(x6, base) {
    try {
      base = isUndefined23(base) ? Math.E : base;
      if (!isNumber23(x6))
        return NaN;
      if (!isNumber23(base))
        return NaN;
      if (typeof x6 === "bigint" || typeof base === "bigint") {
        const out222 = log23(Number(x6), Number(base));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return Math.log(x6) / Math.log(base);
    } catch (e28) {
      return NaN;
    }
  }
  var vlog23 = vectorize23(log23);
  function mean23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).mean;
  }
  function median23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod23(a, b) {
    try {
      if (!isNumber23(a))
        return NaN;
      if (!isNumber23(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod23(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e28) {
          return out222;
        }
      }
      return a % b;
    } catch (e28) {
      return NaN;
    }
  }
  var vmod23 = vectorize23(mod23);
  function mode23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper323() {
    const u12 = random23();
    const u22 = random23();
    return Math.sqrt(-2 * Math.log(u12)) * Math.cos(2 * Math.PI * u22);
  }
  function normal23(shape222) {
    if (isUndefined23(shape222))
      return helper323();
    return vapply23(ndarray23(shape222), helper323);
  }
  function ones23(shape222) {
    return vapply23(ndarray23(shape222), () => 1);
  }
  function permutationsIterator23(x6, r) {
    function* helper522(x22, r22) {
      r22 = r22 || x22.length;
      if (x22.length === 1) {
        yield [x22];
        return;
      }
      for (const c of combinations23(x22, r22)) {
        if (!c.slice)
          continue;
        const state = zeros23(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return permutationsIterator23(x6.values, r);
    }
    assert23(isArray23(x6), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined23(r)) {
      r = x6.length;
    }
    assert23(isNumber23(r) && vint23(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten23(x6), r);
  }
  function permutations23(x6, r) {
    const out222 = [];
    for (const perm of permutationsIterator23(x6, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print23() {
    Object.keys(arguments).forEach((key) => {
      const x6 = arguments[key];
      if (isArray23(x6)) {
        if (!isJagged23(x6)) {
          const xShape = shape23(x6);
          if (xShape.length === 1) {
            new Series23(x6).print();
          } else if (xShape.length == 2) {
            new DataFrame23(x6).print();
          } else {
            console.log(x6);
          }
        } else {
          console.log(x6);
        }
      } else if (isDataFrame23(x6) || isSeries23(x6)) {
        x6.print();
      } else {
        console.log(x6);
      }
    });
  }
  var helper423 = vectorize23((x6, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x6, a, b, c, d]) {
        if (!isNumber23(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x6 = Number(x6);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x6 - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e28) {
        }
      }
      return out222;
    } catch (e28) {
      return NaN;
    }
  });
  function remap23(x6, a, b, c, d) {
    if (isArray23(x6) && isUndefined23(c) && isUndefined23(d)) {
      c = a;
      d = b;
      const results = stats23(x6);
      a = results.min;
      b = results.max;
    }
    return helper423(x6, a, b, c, d);
  }
  function round23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return x6;
      return Math.round(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vround23 = vectorize23(round23);
  function sign23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint")
        return BigInt(sign23(Number(x6)));
      if (x6 < 0)
        return -1;
      if (x6 > 0)
        return 1;
      return 0;
    } catch (e28) {
      return NaN;
    }
  }
  var vsign23 = vectorize23(sign23);
  function sin23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.sin(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vsin23 = vectorize23(sin23);
  function some23(x6, fn2) {
    if (isDataFrame23(x6) || isSeries23(x6)) {
      return some23(x6.values, fn2);
    }
    assert23(isArray23(x6), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert23(isFunction23(fn2), "The second argument passed into the `some` function must be a function!");
    for (const v of x6) {
      if (isArray23(v)) {
        if (some23(v, fn2)) {
          return true;
        }
      } else {
        if (fn2(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev23(x6) {
    return std23(x6);
  }
  function tan23(x6) {
    try {
      if (!isNumber23(x6))
        return NaN;
      if (typeof x6 === "bigint") {
        x6 = Number(x6);
      }
      return Math.tan(x6);
    } catch (e28) {
      return NaN;
    }
  }
  var vtan23 = vectorize23(tan23);
  function timeSync23(fn2, args) {
    assert23(isFunction23(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn2(...args);
    } else {
      fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync23(fn2, args) {
    assert23(isFunction23(fn2), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn2(...args);
    } else {
      await fn2();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union23() {
    return set23([...arguments].map((v) => {
      if (isArray23(v))
        return v;
      if (isDataFrame23(v))
        return v.values;
      if (isSeries23(v))
        return v.values;
      return [v];
    }));
  }
  function variance23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip23() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame23(arr) || isSeries23(arr)) {
        arr = arr.values;
      }
      assert23(isArray23(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range23(0, max23(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined23(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out23 = {
    abs: vabs23,
    add: vadd23,
    apply: vapply23,
    arccos: varccos23,
    arcsin: varcsin23,
    arctan: varctan23,
    argmax: argmax23,
    argmin: argmin23,
    assert: assert23,
    cast: cast23,
    ceil: vceil23,
    chop: vchop23,
    clamp: vclamp23,
    combinations: combinations23,
    combinationsIterator: combinationsIterator23,
    copy: copy23,
    correl: correl23,
    cos: vcos23,
    count: count23,
    covariance: covariance23,
    DataFrame: DataFrame23,
    dataTypes: dataTypes23,
    decycle: decycle23,
    diff: diff23,
    distance: distance23,
    divide: divide23,
    dot: dot23,
    dropMissing: dropMissing23,
    dropMissingPairwise: dropMissingPairwise23,
    dropNaN: dropNaN23,
    dropNaNPairwise: dropNaNPairwise23,
    dropUndefined: dropUndefined23,
    every: every23,
    exp: vexp23,
    factorial: vfactorial23,
    find: find23,
    findAll: findAll23,
    flatten: flatten23,
    float: vfloat23,
    floor: vfloor23,
    identity: identity23,
    IndexMatcher: IndexMatcher23,
    indexOf: indexOf23,
    inferType: inferType23,
    int: vint23,
    intersect: intersect23,
    inverse: inverse23,
    isArray: isArray23,
    isBoolean: isBoolean23,
    isBrowser: isBrowser223,
    isDataFrame: isDataFrame23,
    isDate: isDate23,
    isEqual: isEqual23,
    isFunction: isFunction23,
    isJagged: isJagged23,
    isNested: isNested23,
    isNumber: isNumber23,
    isObject: isObject23,
    isSeries: isSeries23,
    isString: isString23,
    isUndefined: isUndefined23,
    lerp: vlerp23,
    log: vlog23,
    MathError: MathError23,
    max: max23,
    mean: mean23,
    median: median23,
    min: min23,
    mod: vmod23,
    mode: mode23,
    multiply: vmultiply23,
    ndarray: ndarray23,
    normal: normal23,
    ones: ones23,
    permutations: permutations23,
    permutationsIterator: permutationsIterator23,
    pow: vpow23,
    print: print23,
    product: product23,
    random: random23,
    range: range23,
    remap: remap23,
    reshape: reshape23,
    reverse: reverse23,
    round: vround23,
    scale: scale23,
    seed: seed23,
    Series: Series23,
    set: set23,
    shape: shape23,
    shuffle: shuffle23,
    sign: vsign23,
    sin: vsin23,
    some: some23,
    sort: sort23,
    sqrt: vsqrt23,
    stats: stats23,
    std: std23,
    stdev: stdev23,
    subtract: subtract23,
    sum: sum23,
    tan: vtan23,
    timeAsync: timeAsync23,
    timeSync: timeSync23,
    time: timeSync23,
    transpose: transpose23,
    union: union23,
    variance: variance23,
    vectorize: vectorize23,
    zeros: zeros23,
    zip: zip23,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out23.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out23).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out23[key]
          });
        } catch (e28) {
          context22[key] = out23[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out23;
  }
  var context2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : void 0;
  function convertObjectToTypedArray2(x6) {
    const typedArrayConstructorSymbol = Symbol.for("@TypedArrayConstructor");
    const typedArrayConstructorString = "Symbol(@TypedArrayConstructor)";
    const typedArrayConstructorKey = typedArrayConstructorSymbol in x6 ? typedArrayConstructorSymbol : typedArrayConstructorString in x6 ? typedArrayConstructorString : void 0;
    if (typedArrayConstructorKey) {
      if (!("values" in x6)) {
        throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");
      }
      if (x6[typedArrayConstructorKey] === "ArrayBuffer") {
        return new Uint8Array(x6.values).buffer;
      }
      return new context2[x6[typedArrayConstructorKey]](x6.values);
    }
    if (isArray23(x6) && x6.constructor.name === "Array") {
      return x6;
    }
    throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!");
  }
  function convertTypedArrayToObject2(x6) {
    if (x6 instanceof ArrayBuffer || x6 instanceof BigInt64Array || x6 instanceof BigUint64Array || x6 instanceof Float32Array || x6 instanceof Float64Array || x6 instanceof Int16Array || x6 instanceof Int32Array || x6 instanceof Int8Array || x6 instanceof Uint16Array || x6 instanceof Uint32Array || x6 instanceof Uint8Array || x6 instanceof Uint8ClampedArray) {
      return {
        [Symbol.for("@TypedArrayConstructor")]: x6.constructor.name,
        values: x6 instanceof ArrayBuffer ? Array.from(new Uint8Array(x6)) : Array.from(x6)
      };
    }
    if (isArray23(x6)) {
      return x6.map((v) => {
        try {
          return convertTypedArrayToObject2(v);
        } catch (e28) {
          return v;
        }
      });
    }
    if (typeof x6 === "object" & x6 !== null) {
      if (isDate23(x6)) {
        return new Date(x6.getTime());
      }
      const out222 = {};
      Object.keys(x6).forEach((key) => {
        try {
          out222[key] = convertTypedArrayToObject2(x6[key]);
        } catch (e28) {
          out222[key] = x6[key];
        }
      });
      return out222;
    }
    throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.");
  }
  function isANumberString2(x6) {
    x6 = x6.trim();
    return !!(x6.match(/^-?\d+(\.\d+)?$/g) || x6.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g) || x6.match(/^-?\.\d+$/g) || x6 === "NaN");
  }
  var punctuation2 = "!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";
  function replaceAll2(text, a, b) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    if (typeof a !== "string") {
      throw new Error("`a` must be a string!");
    }
    if (typeof b !== "string") {
      throw new Error("`b` must be a string!");
    }
    return text.split(a).join(b);
  }
  var doubleSpace2 = "  ";
  var singleSpace2 = " ";
  function strip2(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    let out222 = "";
    for (let i = 0; i < text.length; i++) {
      const char = text[i].toLowerCase();
      if (punctuation2.includes(char)) {
        out222 += singleSpace2;
      } else {
        out222 += char;
      }
    }
    while (out222.includes(doubleSpace2)) {
      out222 = replaceAll2(out222, doubleSpace2, singleSpace2);
    }
    return out222.trim();
  }
  function indent2(text, chars) {
    chars = chars || "";
    return text.split("\n").map((line) => {
      if (line.trim().length > 0) {
        return chars + line;
      } else {
        return line;
      }
    }).join("\n");
  }
  function kebabify2(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip2(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("-");
  }
  var specials2 = {
    "@Infinity": Infinity,
    "@NegativeInfinity": -Infinity,
    "@NaN": NaN,
    "@undefined": void 0
  };
  function fixUndefineds2(x6) {
    if (typeof x6 === "object") {
      if (x6 === null) {
        return x6;
      }
      if (isArray23(x6)) {
        for (let i = 0; i < x6.length; i++) {
          x6[i] = fixUndefineds2(x6[i]);
        }
      } else {
        Object.keys(x6).concat(Object.getOwnPropertySymbols(x6)).forEach((key) => {
          x6[key] = fixUndefineds2(x6[key]);
        });
      }
      return x6;
    } else {
      if (typeof x6 === "undefined") {
        return void 0;
      }
      if (x6 === "Symbol(@undefined)") {
        return void 0;
      }
      return x6;
    }
  }
  function parseAsBigInt2(x6) {
    if (typeof x6 === "bigint") {
      return x6;
    } else if (typeof x6 === "string") {
      if (x6.match(/^\s*?-?\d+n\s*?$/g)) {
        try {
          return BigInt(x6.split("n")[0]);
        } catch (e28) {
          return NaN;
        }
      } else {
        return NaN;
      }
    } else {
      return NaN;
    }
  }
  function parseAsNumber2(x6) {
    if (typeof x6 !== "string") {
      if (typeof x6 === "number") {
        return x6;
      } else {
        return;
      }
    }
    if (isANumberString2(x6)) {
      return parseFloat(x6);
    }
  }
  function parseAsString2(x6) {
    if (typeof x6 !== "string") {
      return;
    }
    const replacement = "@jrc03c/js-text-tools/newline-replacer";
    x6 = x6.replaceAll("\n", replacement);
    if (x6.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)) {
      let out222 = x6.replace("Symbol(@String):", "");
      if (out222.match(/^".*?"$/g)) {
        try {
          return JSON.parse(out222);
        } catch (e28) {
          out222 = out222.substring(1, out222.length - 1);
        }
      }
      out222 = out222.replaceAll(replacement, "\n");
      return out222;
    }
  }
  function parseAsSymbol2(x6) {
    if (typeof x6 !== "string") {
      if (typeof x6 === "symbol") {
        return { out: x6, isASymbol: true };
      } else {
        return;
      }
    }
    if (x6.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)) {
      const xTemp = x6.replace(/^.*?Symbol\(/g, "").replace(/\).*?$/g, "");
      if (xTemp in specials2) {
        return { out: specials2[xTemp], isASymbol: true };
      }
      return { out: Symbol.for(xTemp), isASymbol: true };
    }
  }
  function parseAsRegex2(x6) {
    if (typeof x6 !== "string") {
      if (x6 instanceof RegExp) {
        return x6;
      } else {
        return;
      }
    }
    const xTrimmed = x6.trim();
    if (xTrimmed.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g)) {
      try {
        const pattern = xTrimmed.replace(/^\//g, "").replace(/\/(d|g|i|m|s|u|v|y)*?$/g, "");
        const flags = xTrimmed.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);
        return new RegExp(pattern, flags);
      } catch (e28) {
      }
    }
  }
  function parseWithJSONParse2(x6) {
    if (typeof x6 !== "string") {
      if (typeof x6 === "object") {
        return x6;
      } else {
        return "Symbol(@undefined)";
      }
    }
    try {
      let out222 = JSON.parse(x6, (key, value) => {
        try {
          const out32 = parse2(value);
          return typeof out32 === "undefined" ? "Symbol(@undefined)" : out32;
        } catch (e28) {
          return typeof value === "undefined" ? "Symbol(@undefined)" : value;
        }
      });
      if (isArray23(out222)) {
        out222 = fixUndefineds2(out222);
      }
      return out222;
    } catch (e28) {
      return x6;
    }
  }
  function parseAsDate2(x6) {
    if (typeof x6 !== "string") {
      if (x6 instanceof Date && x6.toString() !== "Invalid Date") {
        return x6;
      } else {
        return;
      }
    }
    try {
      const d = new Date(Date.parse(x6));
      if (d.toString() !== "Invalid Date") {
        return d;
      }
    } catch (e28) {
    }
  }
  function parseObjectKeysAndValues2(x6) {
    if (typeof x6 === "object") {
      if (x6 !== null) {
        return fixUndefineds2(x6);
      }
      return;
    }
    Object.keys(x6).concat(Object.getOwnPropertySymbols(x6)).forEach((key) => {
      try {
        let origKey = key;
        try {
          key = parse2(key);
        } catch (e28) {
        }
        x6[key] = parse2(x6[origKey]);
        if (key !== origKey) {
          delete x6[origKey];
        }
      } catch (e28) {
      }
    });
    return fixUndefineds2(x6);
  }
  function parse2(x6) {
    function helper522(x22) {
      if (typeof x22 === "string") {
        let out222 = parseAsString2(x22);
        if (typeof out222 === "string") {
          return out222;
        }
        const results = parseAsSymbol2(x22);
        out222 = results ? results.out : void 0;
        if (results && results.isASymbol) {
          return out222;
        }
        out222 = parseAsRegex2(x22);
        if (out222 instanceof RegExp) {
          return out222;
        }
        out222 = parseAsBigInt2(x22);
        if (typeof out222 === "bigint") {
          return out222;
        }
        out222 = parseAsNumber2(x22);
        if (typeof out222 === "number") {
          return out222;
        }
        out222 = parseAsDate2(x22);
        if (out222 instanceof Date) {
          return out222;
        }
        out222 = parseWithJSONParse2(x22);
        if (typeof out222 !== "undefined") {
          if (out222 === "Symbol(@undefined)") {
            return void 0;
          } else {
            return out222;
          }
        }
        return x22;
      }
      if (typeof x22 === "object") {
        if (x22 === null) {
          return null;
        }
        let out222;
        try {
          out222 = convertObjectToTypedArray2(x22);
          if (isArray23(out222))
            return out222;
        } catch (e28) {
        }
        out222 = parseObjectKeysAndValues2(x22);
        if (out222) {
          try {
            return convertObjectToTypedArray2(out222);
          } catch (e28) {
            return out222;
          }
        }
        return x22;
      }
      return x22;
    }
    return helper522(x6);
  }
  function pascalify2(text) {
    const out222 = camelify23(text);
    return out222[0].toUpperCase() + out222.slice(1);
  }
  function snakeify2(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip2(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("_");
  }
  function prefix2(s222, n) {
    if (!s222 || n <= 0)
      return "";
    return range23(0, n).map(() => s222).join("");
  }
  function stringify2(x6, indent22) {
    assert23(isString23(indent22) || isUndefined23(indent22), "The second parameter to the `stringify` function must be undefined or a string!");
    const newline = indent22 ? "\n" : "";
    function helper522(x22, indent3, depth) {
      depth = depth || 0;
      if (typeof x22 === "bigint") {
        return JSON.stringify(x22.toString() + "n");
      }
      if (typeof x22 === "number") {
        if (x22 === Infinity) {
          return '"Symbol(@Infinity)"';
        }
        if (x22 === -Infinity) {
          return '"Symbol(@NegativeInfinity)"';
        }
        if (isNaN(x22)) {
          return '"Symbol(@NaN)"';
        }
        return x22.toString();
      }
      if (typeof x22 === "string") {
        return JSON.stringify("Symbol(@String):" + x22);
      }
      if (typeof x22 === "boolean") {
        return x22.toString();
      }
      if (typeof x22 === "undefined") {
        return '"Symbol(@undefined)"';
      }
      if (typeof x22 === "symbol") {
        return JSON.stringify(x22.toString());
      }
      if (typeof x22 === "function") {
        return JSON.stringify(x22.toString());
      }
      if (x22 instanceof RegExp) {
        return x22.toString();
      }
      if (typeof x22 === "object") {
        if (x22 === null) {
          return "null";
        }
        if (isDate23(x22)) {
          return JSON.stringify(x22.toJSON());
        }
        if (isArray23(x22)) {
          if (x22.length === 0) {
            return prefix2(indent3, depth - 1) + "[]";
          }
          if (!(x22 instanceof Array)) {
            return helper522(convertTypedArrayToObject2(x22), null, indent3);
          }
          return prefix2(indent3, depth - 1) + "[" + newline + x22.map((v) => {
            let child = (() => {
              try {
                return helper522(convertTypedArrayToObject2(v), indent3, depth + 1);
              } catch (e28) {
                return helper522(v, indent3, depth + 1);
              }
            })();
            if (isString23(child))
              child = child.trim();
            return prefix2(indent3, depth + 1) + child;
          }).join("," + newline) + newline + prefix2(indent3, depth) + "]";
        }
        if (Object.keys(x22).length + Object.getOwnPropertySymbols(x22).length === 0) {
          return prefix2(indent3, depth - 1) + "{}";
        }
        return prefix2(indent3, depth - 1) + "{" + newline + Object.keys(x22).concat(Object.getOwnPropertySymbols(x22)).map((key) => {
          let child = (() => {
            try {
              return helper522(convertTypedArrayToObject2(x22[key]), indent3, depth + 1);
            } catch (e28) {
              return helper522(x22[key], indent3, depth + 1);
            }
          })();
          if (isString23(child))
            child = child.trim();
          const stringifiedKey = typeof key === "symbol" ? helper522(key) : JSON.stringify(key);
          return prefix2(indent3, depth + 1) + stringifiedKey + ":" + (indent3 ? " " : "") + child;
        }).join("," + newline) + newline + prefix2(indent3, depth) + "}";
      }
      return "undefined";
    }
    return helper522(decycle23(x6), indent22);
  }
  function unindent2(text) {
    const lines = text.split("\n");
    const indentations = lines.filter((line) => line.trim().length > 0).map((line) => line.split("").findIndex((char) => !char.match(/\s/g)));
    const minIndentation = Math.min(...indentations);
    return lines.map((line) => line.substring(minIndentation)).join("\n");
  }
  function wrap2(raw, maxLineLength) {
    if (typeof raw !== "string") {
      throw new Error("The first argument to the `wrap` function must be a string!");
    }
    if (typeof maxLineLength === "undefined" || maxLineLength === null) {
      if (typeof process !== "undefined" && typeof process.stdout !== "undefined" && typeof process.stdout.columns === "number") {
        maxLineLength = process.stdout.columns > 80 ? 80 : process.stdout.columns;
      } else {
        maxLineLength = 80;
      }
    }
    if (isNaN(maxLineLength) || typeof maxLineLength !== "number") {
      throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");
    }
    const out222 = [];
    raw.split("\n").forEach((line) => {
      if (line.trim().length === 0) {
        return out222.push("");
      }
      const indentation = line.split(/[^\s]/g)[0];
      const words = line.replace(indentation, "").split(" ");
      let temp = indentation;
      words.forEach((word) => {
        const newLine = temp + (temp.trim().length > 0 ? " " : "") + word;
        if (newLine.length > maxLineLength) {
          out222.push(temp);
          temp = indentation + word;
        } else {
          temp = newLine;
        }
      });
      if (temp.length > 0) {
        out222.push(temp);
      }
    });
    return out222.join("\n");
  }
  if (typeof window !== "undefined") {
    window.JSTextTools = {
      camelify: camelify23,
      convertObjectToTypedArray: convertObjectToTypedArray2,
      convertTypedArrayToObject: convertTypedArrayToObject2,
      indent: indent2,
      isANumberString: isANumberString2,
      kebabify: kebabify2,
      parse: parse2,
      pascalify: pascalify2,
      punctuation: punctuation2,
      replaceAll: replaceAll2,
      snakeify: snakeify2,
      stringify: stringify2,
      strip: strip2,
      unindent: unindent2,
      wrap: wrap2
    };
  }
  function convertToNumerical(df2, config) {
    config = config || {};
    const maxUniqueValues = isNumber3(config.maxUniqueValues) ? config.maxUniqueValues : 7;
    const minNonMissingValues = isNumber3(config.minNonMissingValues) ? config.minNonMissingValues : 15;
    const maxCorrelationThreshold = isNumber3(config.maxCorrelationThreshold) ? config.maxCorrelationThreshold : 1 - 1e-5;
    const progress2 = config.progress || null;
    if (isArray3(df2)) {
      assert3(
        shape3(df2).length === 2 && !isJagged3(df2),
        "The `convertToNumerical` function only works on non-jagged 2-dimensional arrays and DataFrames!"
      );
      return convertToNumerical(new DataFrame3(df2));
    }
    assert3(
      isDataFrame3(df2),
      "You must pass a DataFrame into the `convertToNumerical` function!"
    );
    assert3(
      isWholeNumber23(maxUniqueValues),
      "`maxUniqueValues` must be a whole number!"
    );
    assert3(
      isWholeNumber23(minNonMissingValues),
      "`minNonMissingValues` must be a whole number!"
    );
    assert3(
      isNumber3(maxCorrelationThreshold),
      "`maxCorrelationThreshold` must be a number!"
    );
    if (!isUndefined3(progress2)) {
      assert3(isFunction3(progress2), "If defined, `progress` must be a function!");
    }
    const out32 = {};
    const shouldIgnoreNaNs = true;
    df2.apply((col, colIndex) => {
      if (progress2) {
        progress2(colIndex / df2.columns.length);
      }
      const inferred = inferType3(col.values);
      if (inferred.type === "boolean") {
        inferred.values = inferred.values.map((v) => v ? 1 : 0);
      }
      if (inferred.type === "date") {
        inferred.values = inferred.values.map((v) => {
          try {
            return v.getTime();
          } catch (e28) {
            return NaN;
          }
        });
      }
      if (inferred.type === "null") {
        return;
      }
      if (inferred.type === "number" || inferred.type === "bigint") {
      }
      if (inferred.type === "object") {
        inferred.values = inferred.values.map((v) => stringify2(v));
      }
      if (inferred.type === "string") {
      }
      const nonMissingValues = inferred.values.filter((v) => !isUndefined3(v));
      if (inferred.values.length - nonMissingValues.length > minNonMissingValues.length) {
        return;
      }
      if (inferred.type !== "boolean") {
        const counts = sort3(
          count3(nonMissingValues).toArray().filter((item) => !isUndefined3(item.value) && isNumber3(item.count)),
          (a, b) => b.count - a.count
        );
        const topNPercent = sum3(
          counts.slice(0, maxUniqueValues).map((item) => item.count),
          shouldIgnoreNaNs
        ) / nonMissingValues.length;
        if (topNPercent >= 0.9) {
          if (counts.length < 2) {
            return;
          }
          const oneHotEncodings = getOneHotEncodings(col.name, inferred.values);
          while (Object.keys(oneHotEncodings).length > 0) {
            const key = Object.keys(oneHotEncodings)[0];
            const values = oneHotEncodings[key];
            delete oneHotEncodings[key];
            const otherColNames = Object.keys(out32);
            for (let i = 0; i < otherColNames.length; i++) {
              const otherColValues = out32[otherColNames[i]];
              const r = correl3(values, otherColValues, shouldIgnoreNaNs);
              if (r > maxCorrelationThreshold) {
                return;
              }
            }
            out32[key] = values;
          }
          return;
        }
        if (inferred.type === "object" || inferred.type === "string") {
          return;
        }
      }
      if (inferred.type === "boolean" || inferred.type === "date" || inferred.type === "number" || inferred.type === "bigint") {
        const otherColNames = Object.keys(out32);
        for (let i = 0; i < otherColNames.length; i++) {
          const otherColValues = out32[otherColNames[i]];
          const r = correl3(inferred.values, otherColValues, shouldIgnoreNaNs);
          if (r > maxCorrelationThreshold) {
            return;
          }
        }
        out32[col.name] = inferred.values;
      }
    });
    return new DataFrame3(out32);
  }
  function diagonalize(x6) {
    if (isSeries3(x6)) {
      const out4 = new DataFrame3(diagonalize(x6.values));
      out4.index = x6.index.slice();
      out4.columns = x6.index.slice();
      return out4;
    }
    assert3(
      isArray3(x6),
      "The `diagonalize` function only works on 1-dimensional arrays and Series!"
    );
    const xShape = shape3(x6);
    assert3(
      xShape.length === 1,
      "The `diagonalize` function only works on 1-dimensional arrays and Series!"
    );
    const isAllBigInts = x6.every((v) => typeof v === "bigint");
    const out32 = zeros3([xShape[0], xShape[0]]);
    x6.forEach((v, i) => out32[i][i] = v);
    if (isAllBigInts) {
      for (let i = 0; i < out32.length; i++) {
        for (let j = 0; j < out32[i].length; j++) {
          try {
            out32[i][j] = BigInt(out32[i][j]);
          } catch (e28) {
          }
        }
      }
    }
    return out32;
  }
  function stamp(x6) {
    const prop = "@jrc03c/js-data-science-helpers/get-correlation-matrix";
    Object.defineProperty(x6, prop, {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Symbol.for(prop)
    });
    return x6;
  }
  function getCorrelationMatrix(a, b, shouldIgnoreNaNs) {
    if (isUndefined3(b)) {
      b = a;
    }
    if (isDataFrame3(a)) {
      const out4 = new DataFrame3(getCorrelationMatrix(a.values, b));
      out4.index = a.columns.slice();
      out4.columns = isDataFrame3(b) ? b.columns.slice() : new DataFrame3(b).columns.slice();
      return stamp(out4);
    }
    if (isDataFrame3(b)) {
      const out4 = new DataFrame3(getCorrelationMatrix(a, b.values));
      out4.index = isDataFrame3(a) ? a.columns.slice() : new DataFrame3(a).columns.slice();
      out4.columns = b.columns.slice();
      return stamp(out4);
    }
    assert3(
      isArray3(a) && isArray3(b),
      "The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"
    );
    assert3(
      !isJagged3(a) && !isJagged3(b),
      "The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"
    );
    assert3(
      a.length === b.length,
      `The dimensions of the matrices you passed into the \`getCorrelationMatrix\` function aren't compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you'll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.`
    );
    const out32 = ndarray3([a[0].length, b[0].length]);
    for (let i = 0; i < a[0].length; i++) {
      const acol = a.map((row) => row[i]);
      for (let j = 0; j < b[0].length; j++) {
        const bcol = b.map((row) => row[j]);
        if (shouldIgnoreNaNs) {
          out32[i][j] = correl3(...dropNaNPairwise3(acol, bcol));
        } else {
          out32[i][j] = correl3(acol, bcol);
        }
      }
    }
    return stamp(vclamp3(out32, -1, 1));
  }
  function getHighlyCorrelatedColumns(x6, threshold, shouldIgnoreNaNs) {
    threshold = isUndefined3(threshold) ? 1 - 1e-5 : threshold;
    if (!isDataFrame3(x6)) {
      x6 = new DataFrame3(x6);
    }
    const xshape = shape3(x6);
    assert3(
      (isArray3(x6) || isDataFrame3(x6)) && xshape.length === 2,
      "The first argument passed into the `getHighlyCorrelatedColumns` function must be a 2-dimensional array or DataFrame!"
    );
    assert3(
      isNumber3(threshold) && threshold >= -1 && threshold <= 1,
      "The second argument passed into the `getHighlyCorrelatedColumns` must be a number in the range [-1, 1] representing the threshold above which two columns will be considered to be highly correlated!"
    );
    const out32 = {};
    if (shouldIgnoreNaNs) {
      x6 = x6.dropNaN();
    }
    for (let i = 0; i < xshape[1] - 1; i++) {
      for (let j = i + 1; j < xshape[1]; j++) {
        const col1 = x6.columns[i];
        const col2 = x6.columns[j];
        const r = correl3(x6.get(col1), x6.get(col2));
        if (r > threshold) {
          if (!out32[col1]) {
            out32[col1] = [];
          }
          out32[col1].push({ column: col2, correlation: r });
          if (!out32[col2]) {
            out32[col2] = [];
          }
          out32[col2].push({ column: col1, correlation: r });
        }
      }
    }
    Object.keys(out32).forEach((key) => {
      out32[key] = sort3(out32[key], (a, b) => a.column < b.column ? -1 : 1);
    });
    return out32;
  }
  function getMagnitude(x6, shouldIgnoreNaNs) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return getMagnitude(x6.values);
    }
    if (isNumber3(x6)) {
      return vabs3(x6);
    }
    if (isArray3(x6)) {
      if (shouldIgnoreNaNs) {
        x6 = dropNaN3(x6);
      }
      return vsqrt3(sum3(vpow3(x6, 2)));
    }
    return NaN;
  }
  function getPercentages(x6, shouldIgnoreNaNs) {
    const results = stats3(x6, { shouldDropNaNs: shouldIgnoreNaNs });
    const n = shouldIgnoreNaNs ? results.nWithoutNaNs : results.n;
    return results.counts.values.filter((v) => isNumber3(v) || !shouldIgnoreNaNs).map((v) => {
      const c = results.counts.get(v);
      return { value: v, count: c, percentage: c / n };
    });
  }
  var zTable = [
    0.5,
    0.49601,
    0.49202,
    0.48803,
    0.48405,
    0.48006,
    0.47608,
    0.4721,
    0.46812,
    0.46414,
    0.46017,
    0.4562,
    0.45224,
    0.44828,
    0.44433,
    0.44038,
    0.4364,
    0.43251,
    0.42858,
    0.42465,
    0.42074,
    0.41683,
    0.41294,
    0.40905,
    0.40517,
    0.40129,
    0.39743,
    0.39358,
    0.38974,
    0.38591,
    0.38209,
    0.37828,
    0.37448,
    0.3707,
    0.36693,
    0.36317,
    0.35942,
    0.35569,
    0.35197,
    0.34827,
    0.34458,
    0.3409,
    0.33724,
    0.3336,
    0.32997,
    0.32636,
    0.32276,
    0.31918,
    0.31561,
    0.31207,
    0.30854,
    0.30503,
    0.30153,
    0.29806,
    0.2946,
    0.29116,
    0.28774,
    0.28434,
    0.28096,
    0.2776,
    0.27425,
    0.27093,
    0.26763,
    0.26435,
    0.26109,
    0.25785,
    0.25463,
    0.25143,
    0.24825,
    0.2451,
    0.24196,
    0.23885,
    0.23576,
    0.2327,
    0.22965,
    0.22663,
    0.22363,
    0.22065,
    0.2177,
    0.21476,
    0.21186,
    0.20897,
    0.20611,
    0.20327,
    0.20045,
    0.19766,
    0.19489,
    0.19215,
    0.18943,
    0.18673,
    0.18406,
    0.18141,
    0.17879,
    0.17619,
    0.17361,
    0.17106,
    0.16853,
    0.16602,
    0.16354,
    0.16109,
    0.15866,
    0.15625,
    0.15386,
    0.15151,
    0.14917,
    0.14686,
    0.14457,
    0.14231,
    0.14007,
    0.13786,
    0.13567,
    0.1335,
    0.13136,
    0.12924,
    0.12714,
    0.12507,
    0.12302,
    0.121,
    0.119,
    0.11702,
    0.11507,
    0.11314,
    0.11123,
    0.10935,
    0.10749,
    0.10565,
    0.10383,
    0.10204,
    0.10027,
    0.09853,
    0.0968,
    0.0951,
    0.09342,
    0.09176,
    0.09012,
    0.08851,
    0.08692,
    0.08534,
    0.08379,
    0.08226,
    0.08076,
    0.07927,
    0.0778,
    0.07636,
    0.07493,
    0.07353,
    0.07215,
    0.07078,
    0.06944,
    0.06811,
    0.06681,
    0.06552,
    0.06426,
    0.06301,
    0.06178,
    0.06057,
    0.05938,
    0.05821,
    0.05705,
    0.05592,
    0.0548,
    0.0537,
    0.05262,
    0.05155,
    0.0505,
    0.04947,
    0.04846,
    0.04746,
    0.04648,
    0.04551,
    0.04457,
    0.04363,
    0.04272,
    0.04182,
    0.04093,
    0.04006,
    0.0392,
    0.03836,
    0.03754,
    0.03673,
    0.03593,
    0.03515,
    0.03438,
    0.03362,
    0.03288,
    0.03216,
    0.03144,
    0.03074,
    0.03005,
    0.02938,
    0.02872,
    0.02807,
    0.02743,
    0.0268,
    0.02619,
    0.02559,
    0.025,
    0.02442,
    0.02385,
    0.0233,
    0.02275,
    0.02222,
    0.02169,
    0.02118,
    0.02068,
    0.02018,
    0.0197,
    0.01923,
    0.01876,
    0.01831,
    0.01786,
    0.01743,
    0.017,
    0.01659,
    0.01618,
    0.01578,
    0.01539,
    0.015,
    0.01463,
    0.01426,
    0.0139,
    0.01355,
    0.01321,
    0.01287,
    0.01255,
    0.01222,
    0.01191,
    0.0116,
    0.0113,
    0.01101,
    0.01072,
    0.01044,
    0.01017,
    99e-4,
    964e-5,
    939e-5,
    914e-5,
    889e-5,
    866e-5,
    842e-5,
    82e-4,
    798e-5,
    776e-5,
    755e-5,
    734e-5,
    714e-5,
    695e-5,
    676e-5,
    657e-5,
    639e-5,
    621e-5,
    604e-5,
    587e-5,
    57e-4,
    554e-5,
    539e-5,
    523e-5,
    508e-5,
    494e-5,
    48e-4,
    466e-5,
    453e-5,
    44e-4,
    427e-5,
    415e-5,
    402e-5,
    391e-5,
    379e-5,
    368e-5,
    357e-5,
    347e-5,
    336e-5,
    326e-5,
    317e-5,
    307e-5,
    298e-5,
    289e-5,
    28e-4,
    272e-5,
    264e-5,
    256e-5,
    248e-5,
    24e-4,
    233e-5,
    226e-5,
    219e-5,
    212e-5,
    205e-5,
    199e-5,
    193e-5,
    187e-5,
    181e-5,
    175e-5,
    169e-5,
    164e-5,
    159e-5,
    154e-5,
    149e-5,
    144e-5,
    139e-5,
    135e-5,
    131e-5,
    126e-5,
    122e-5,
    118e-5,
    114e-5,
    111e-5,
    107e-5,
    104e-5,
    1e-3,
    97e-5,
    94e-5,
    9e-4,
    87e-5,
    84e-5,
    82e-5,
    79e-5,
    76e-5,
    74e-5,
    71e-5,
    69e-5,
    66e-5,
    64e-5,
    62e-5,
    6e-4,
    58e-5,
    56e-5,
    54e-5,
    52e-5,
    5e-4,
    48e-5,
    47e-5,
    45e-5,
    43e-5,
    42e-5,
    4e-4,
    39e-5,
    38e-5,
    36e-5,
    35e-5,
    34e-5,
    32e-5,
    31e-5,
    3e-4,
    29e-5,
    28e-5,
    27e-5,
    26e-5,
    25e-5,
    24e-5,
    23e-5,
    22e-5,
    22e-5,
    21e-5,
    2e-4,
    19e-5,
    19e-5,
    18e-5,
    17e-5,
    17e-5,
    16e-5,
    15e-5,
    15e-5,
    14e-5,
    14e-5,
    13e-5,
    13e-5,
    12e-5,
    12e-5,
    11e-5,
    11e-5,
    1e-4,
    1e-4,
    1e-4,
    9e-5,
    9e-5,
    8e-5,
    8e-5,
    8e-5,
    8e-5,
    7e-5,
    7e-5,
    7e-5,
    6e-5,
    6e-5,
    6e-5,
    6e-5,
    5e-5,
    5e-5,
    5e-5,
    5e-5,
    5e-5,
    4e-5,
    4e-5,
    4e-5,
    4e-5,
    4e-5,
    4e-5,
    3e-5,
    3e-5,
    3e-5,
    3e-5,
    3e-5,
    3e-5,
    3e-5,
    3e-5,
    2e-5,
    2e-5,
    2e-5,
    2e-5
  ];
  function probability(z10) {
    if (vabs3(z10) > 4.1) return 0;
    return zTable[vround3(remap3(vabs3(z10), 0, 4.1, 0, zTable.length))];
  }
  function ttest(a, b, shouldIgnoreNaNs) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return ttest(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return ttest(a, b.values);
    }
    assert3(
      isArray3(a) && isArray3(b) && isEqual3(shape3(a), shape3(b)),
      "You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!"
    );
    const [aTemp, bTemp] = shouldIgnoreNaNs ? dropNaNPairwise3(flatten3(a), flatten3(b)) : [flatten3(a), flatten3(b)];
    if (aTemp.length === 0 || bTemp.length === 0) {
      return NaN;
    }
    const astats = stats3(aTemp, { stdev: true });
    const bstats = stats3(bTemp, { stdev: true });
    const m12 = astats.mean;
    const m22 = bstats.mean;
    const s12 = astats.stdev;
    const s222 = bstats.stdev;
    const n12 = aTemp.length;
    const n22 = bTemp.length;
    const t = (m12 - m22) / vsqrt3(s12 * s12 / n12 + s222 * s222 / n22);
    return 2 * probability(t);
  }
  function stamp2(x6) {
    const prop = "@jrc03c/js-data-science-helpers/get-p-value-matrix";
    Object.defineProperty(x6, prop, {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Symbol.for(prop)
    });
    return x6;
  }
  function getPValueMatrix(a, b, shouldIgnoreNaNs) {
    if (isUndefined3(b)) {
      b = a;
    }
    if (isDataFrame3(a)) {
      const out4 = new DataFrame3(getPValueMatrix(a.values, b));
      out4.index = a.columns.slice();
      out4.columns = isDataFrame3(b) ? b.columns.slice() : new DataFrame3(b).columns.slice();
      return stamp2(out4);
    }
    if (isDataFrame3(b)) {
      const out4 = new DataFrame3(getPValueMatrix(a, b.values));
      out4.index = isDataFrame3(a) ? a.columns.slice() : new DataFrame3(a).columns.slice();
      out4.columns = b.columns.slice();
      return stamp2(out4);
    }
    assert3(
      isArray3(a) && isArray3(b),
      "The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"
    );
    assert3(
      !isJagged3(a) && !isJagged3(b),
      "The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"
    );
    assert3(
      a.length === b.length,
      `The dimensions of the matrices you passed into the \`getPValueMatrix\` function aren't compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you'll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.`
    );
    const out32 = ndarray3([a[0].length, b[0].length]);
    for (let i = 0; i < a[0].length; i++) {
      const acol = a.map((row) => row[i]);
      for (let j = 0; j < b[0].length; j++) {
        const bcol = b.map((row) => row[j]);
        if (shouldIgnoreNaNs) {
          out32[i][j] = ttest(...dropNaNPairwise3(acol, bcol));
        } else {
          out32[i][j] = ttest(acol, bcol);
        }
      }
    }
    return stamp2(vclamp3(out32, 0, 1));
  }
  function hunterChainSort(c) {
    if (isArray3(c)) {
      assert3(
        shape3(c).length === 2 && !isJagged3(c),
        "The `hunterChainSort` function only works on non-jagged 2-dimensional arrays and DataFrames!"
      );
      const temp = new DataFrame3(c);
      temp.index = temp.columns.slice();
      return hunterChainSort(temp).values;
    }
    assert3(
      isDataFrame3(c),
      "You must pass a 2-dimensional array or DataFrame into the `hunterChainSort` function!"
    );
    const shouldIgnoreNaNs = true;
    const freeRows = c.index.slice();
    const fixedRows = [];
    while (freeRows.length > 1) {
      if (fixedRows.length === 0) {
        const firstRowName = freeRows[argmax3(
          freeRows.map(
            (rowName) => sum3(vpow3(c.values[c.index.indexOf(rowName)], 2), shouldIgnoreNaNs)
          ),
          shouldIgnoreNaNs
        )];
        freeRows.splice(freeRows.indexOf(firstRowName), 1);
        fixedRows.push(firstRowName);
      } else {
        const lastRowName = fixedRows.at(-1);
        const lastRow = c.values[c.index.indexOf(lastRowName)].filter(
          (v, i) => freeRows.includes(c.index[i])
        );
        const nextRowName = freeRows[argmax3(lastRow, shouldIgnoreNaNs)];
        freeRows.splice(freeRows.indexOf(nextRowName), 1);
        fixedRows.push(nextRowName);
      }
    }
    fixedRows.push(freeRows[0]);
    const reversedFixedRows = reverse3(fixedRows);
    const out32 = c.get(reversedFixedRows, null);
    return out32;
  }
  var IndexMatcher32 = class _IndexMatcher32 {
    static DROP_NAN_MODE = "DROP_NAN_MODE";
    static DROP_MISSING_MODE = "DROP_MISSING_MODE";
    constructor(mode32) {
      const self2 = this;
      assert3(
        isUndefined3(mode32) || mode32 === _IndexMatcher32.DROP_NAN_MODE || mode32 === _IndexMatcher32.DROP_MISSING_MODE,
        "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"
      );
      self2.mode = !isUndefined3(mode32) ? mode32 : _IndexMatcher32.DROP_MISSING_MODE;
      self2.index = null;
    }
    fit() {
      const self2 = this;
      const indices = [];
      Object.values(arguments).forEach((x6) => {
        assert3(
          isDataFrame3(x6) || isSeries3(x6),
          "The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."
        );
        if (self2.mode === _IndexMatcher32.DROP_MISSING_MODE) {
          indices.push(x6.dropMissing().index);
        } else {
          indices.push(x6.dropNaN().index);
        }
      });
      self2.index = intersect3(...indices);
      return self2;
    }
    transform() {
      const self2 = this;
      assert3(
        !!self2.index,
        "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method."
      );
      const out32 = Object.values(arguments).map((x6) => {
        assert3(
          isDataFrame3(x6) || isSeries3(x6),
          "The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."
        );
        return x6.get(self2.index, null);
      });
      return out32.length === 1 ? out32[0] : out32;
    }
    fitAndTransform() {
      const self2 = this;
      return self2.fit(...arguments).transform(...arguments);
    }
  };
  function isBinary(x6, shouldIgnoreNaNs) {
    if (typeof x6 === "number") {
      return x6 === 0 || x6 === 1;
    }
    if (typeof x6 === "bigint") {
      return x6 === 0n || x6 === 1n;
    }
    if (isDataFrame3(x6) || isSeries3(x6)) {
      return isBinary(x6.values, shouldIgnoreNaNs);
    }
    if (isArray3(x6)) {
      if (shouldIgnoreNaNs) {
        x6 = dropNaN3(x6);
      }
      const counts = count3(x6);
      const values = counts.values.toSorted();
      return values.length === 2 && Number(values[0]) === 0 && Number(values[1]) === 1 || values.length === 1 && (Number(values[0]) === 0 || Number(values[0]) === 1);
    }
    return false;
  }
  function isCorrelationMatrix(x6) {
    try {
      const prop = "@jrc03c/js-data-science-helpers/get-correlation-matrix";
      if (x6[prop] === Symbol.for(prop)) {
        return true;
      }
      const s32 = stats3(x6, { shouldDropNaNs: true });
      return s32.min >= -1 && s32.max <= 1;
    } catch (e28) {
      return false;
    }
  }
  function accuracy(yTrue, yPred) {
    if (isDataFrame3(yTrue) || isSeries3(yTrue)) {
      yTrue = yTrue.values;
    }
    if (isDataFrame3(yPred) || isSeries3(yPred)) {
      yPred = yPred.values;
    }
    assert3(
      isEqual3(shape3(yTrue), shape3(yPred)),
      "`yPred` and `yTrue` must have the same shape!"
    );
    const yTrueFlat = flatten3(yTrue);
    const yPredFlat = flatten3(yPred);
    let correct = 0;
    yTrueFlat.forEach((v, i) => {
      if (v === yPredFlat[i]) correct++;
    });
    return correct / yTrueFlat.length;
  }
  function isMatrix(x6) {
    return isArray3(x6) && shape3(x6).length === 2;
  }
  function orderCentroids(ctrue, cpred) {
    return ctrue.map((c12) => {
      return cpred[argmin3(cpred.map((c22) => sse(c12, c22)))];
    });
  }
  function sse(xtrue, xpred) {
    const shouldIgnoreNaNs = true;
    return sum3(vpow3(subtract3(xtrue, xpred), 2), shouldIgnoreNaNs);
  }
  var KMeansNaive = class {
    constructor(config) {
      assert3(
        typeof config === "object",
        "`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."
      );
      assert3(isWholeNumber23(config.k), "`k` must be a whole number!");
      assert3(
        isWholeNumber23(config.maxIterations) || isUndefined3(config.maxIterations),
        "`maxIterations` must be a whole number or undefined!"
      );
      assert3(
        isWholeNumber23(config.maxRestarts) || isUndefined3(config.maxRestarts),
        "`maxRestarts` must be a whole number or undefined!"
      );
      assert3(
        typeof config.tolerance === "number" || isUndefined3(config.tolerance),
        "`tolerance` must be a number or undefined!"
      );
      this.k = config.k;
      this.maxRestarts = config.maxRestarts || 25;
      this.maxIterations = config.maxIterations || 100;
      this.tolerance = config.tolerance || 1e-4;
      this.centroids = null;
    }
    initializeCentroids(x6) {
      return shuffle3(x6).slice(0, this.k);
    }
    getFitStepFunction(x6, progress2) {
      assert3(isMatrix(x6), "`x` must be a matrix!");
      if (isDataFrame3(x6)) {
        x6 = x6.values;
      }
      if (!isUndefined3(progress2)) {
        assert3(isFunction3(progress2), "If defined, `progress` must be a function!");
      }
      const centroids = this.initializeCentroids(x6);
      const state = {
        currentRestart: 0,
        currentIteration: 0,
        currentCentroids: centroids,
        bestCentroids: centroids,
        bestScore: -Infinity,
        isFinished: false
      };
      return () => {
        const labels = this.predict(x6, state.currentCentroids);
        const sums = [];
        const counts = zeros3(this.k);
        x6.forEach((p, i) => {
          const k6 = labels[i];
          if (!sums[k6]) {
            sums[k6] = zeros3(p.length);
          }
          sums[k6] = vadd3(sums[k6], p);
          counts[k6]++;
        });
        const newCentroids = range3(0, this.k).map((k6) => {
          if (counts[k6] === 0) {
            return vadd3(
              state.currentCentroids[Math.floor(random3() * state.currentCentroids.length)],
              scale3(1e-3, normal3(state.currentCentroids[0].length))
            );
          } else {
            return divide3(sums[k6], counts[k6]);
          }
        });
        if (sse(state.currentCentroids, newCentroids) < this.tolerance) {
          state.currentIteration = this.maxIterations - 1;
        } else {
          state.currentCentroids = newCentroids;
        }
        if (progress2) {
          progress2(
            (state.currentRestart + state.currentIteration / this.maxIterations) / this.maxRestarts,
            this
          );
        }
        state.currentIteration++;
        if (state.currentIteration >= this.maxIterations) {
          const score = this.score(x6, state.currentCentroids);
          if (score > state.bestScore) {
            state.bestScore = score;
            state.bestCentroids = copy3(state.currentCentroids);
          }
          state.currentIteration = 0;
          state.currentRestart++;
          if (state.currentRestart >= this.maxRestarts) {
            state.isFinished = true;
            this.centroids = state.bestCentroids;
            if (progress2) {
              progress2(1, this);
            }
          } else {
            const newCentroids2 = this.initializeCentroids(x6);
            state.currentCentroids = newCentroids2;
          }
        }
        return state;
      };
    }
    fit(x6, progress2) {
      const fitStep = this.getFitStepFunction(x6, progress2);
      let state;
      while (!state || !state.isFinished) {
        state = fitStep();
      }
      return this;
    }
    predict(x6, centroids) {
      centroids = centroids || this.centroids;
      if (!centroids) {
        throw new Error(
          "No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!"
        );
      }
      return x6.map((p) => argmin3(centroids.map((c) => sse(p, c))));
    }
    score(x6, centroids) {
      centroids = centroids || this.centroids;
      if (!centroids) {
        throw new Error(
          "No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!"
        );
      }
      const labels = this.predict(x6, centroids);
      const assigments = labels.map((k6) => centroids[k6]);
      return -sse(x6, assigments);
    }
  };
  var KMeansPlusPlus = class extends KMeansNaive {
    initializeCentroids(x6) {
      const shouldIgnoreNaNs = true;
      const centroids = [x6[Math.floor(random3() * x6.length)]];
      while (centroids.length < this.k) {
        const distances = x6.map(
          (p) => sse(
            p,
            centroids[argmin3(
              centroids.map((c) => sse(p, c)),
              shouldIgnoreNaNs
            )]
          )
        );
        const probabilities = divide3(distances, max3(distances, shouldIgnoreNaNs));
        centroids.push(x6[probabilities.findIndex((v) => random3() < v)]);
      }
      return centroids;
    }
  };
  var KMeansMeta = class {
    constructor(config) {
      if (isUndefined3(config)) {
        config = {};
      }
      assert3(
        typeof config === "object",
        "`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."
      );
      if (isUndefined3(config.ks)) {
        config.ks = range3(1, 16);
      }
      assert3(isArray3(config.ks), "`ks` must be an array of whole numbers!");
      config.ks.forEach((k6) => {
        assert3(isWholeNumber23(k6), "`ks` must be an array of whole numbers!");
      });
      assert3(
        isWholeNumber23(config.maxIterations) || isUndefined3(config.maxIterations),
        "`maxIterations` must be a whole number or undefined!"
      );
      assert3(
        isWholeNumber23(config.maxRestarts) || isUndefined3(config.maxRestarts),
        "`maxRestarts` must be a whole number or undefined!"
      );
      assert3(
        typeof config.tolerance === "number" || isUndefined3(config.tolerance),
        "`tolerance` must be a number or undefined!"
      );
      this.ks = config.ks;
      this.maxRestarts = config.maxRestarts || 25;
      this.maxIterations = config.maxIterations || 100;
      this.tolerance = config.tolerance || 1e-4;
      this.scoreStopRatio = config.scoreStopRatio || 0.85;
      this.modelClass = config.modelClass || KMeansPlusPlus;
      this.fittedModel = null;
    }
    getFitStepFunction(x6, progress2) {
      assert3(isMatrix(x6), "`x` must be a matrix!");
      if (isDataFrame3(x6)) {
        x6 = x6.values;
      }
      if (!isUndefined3(progress2)) {
        assert3(isFunction3(progress2), "If defined, `progress` must be a function!");
      }
      const state = {
        isFinished: false,
        lastScore: -Infinity,
        currentIndex: 0
      };
      return () => {
        const k6 = this.ks[state.currentIndex];
        const model = new this.modelClass({
          k: k6,
          maxRestarts: 10,
          maxIterations: 20
        });
        model.fit(
          x6,
          (p) => progress2 ? progress2((state.currentIndex + p) / (this.ks.length + 1)) : null
        );
        const score = model.score(x6);
        if (score / state.lastScore > this.scoreStopRatio) {
          state.isFinished = true;
          state.currentIndex--;
        } else {
          state.lastScore = score;
          if (state.currentIndex + 1 >= this.ks.length) {
            state.isFinished = true;
          } else {
            state.currentIndex++;
          }
        }
        if (state.isFinished) {
          this.fittedModel = new this.modelClass({
            k: this.ks[state.currentIndex],
            maxRestarts: this.maxRestarts,
            maxIterations: this.maxIterations
          });
          this.fittedModel.fit(
            x6,
            (p) => progress2 ? progress2((this.ks.length + p) / (this.ks.length + 1)) : null
          );
          if (progress2) {
            progress2(1);
          }
        }
        return state;
      };
    }
    fit(x6, progress2) {
      const fitStep = this.getFitStepFunction(x6, progress2);
      let state;
      while (!state || !state.isFinished) {
        state = fitStep();
      }
      return this;
    }
    predict(x6, centroids) {
      return this.fittedModel.predict(x6, centroids);
    }
    score(x6, centroids) {
      return this.fittedModel.score(x6, centroids);
    }
    get k() {
      return this.fittedModel.k;
    }
    set k(value) {
      throw new Error(
        "You can't set the k-value manually! It has to be set automatically via the `fit` method."
      );
    }
    get centroids() {
      return this.fittedModel.centroids;
    }
    set centroids(centroids) {
      assert3(
        isEqual3(shape3(centroids), shape3(this.fittedModel.centroids)),
        "When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"
      );
      this.fittedModel.centroids = centroids;
    }
  };
  var helpers = { accuracy, isMatrix, orderCentroids, sse };
  var KMeans = { helpers, KMeansMeta, KMeansNaive, KMeansPlusPlus };
  function normalize(x6, shouldIgnoreNaNs) {
    if (isDataFrame3(x6) || isSeries3(x6)) {
      const out32 = x6.copy();
      out32.values = normalize(out32.values);
      return out32;
    }
    assert3(
      isArray3(x6),
      "The `normalize` function only works on arrays, Series, and DataFrames!"
    );
    const results = stats3(x6, { shouldDropNaNs: shouldIgnoreNaNs, stdev: true });
    const m = results.mean;
    const s32 = results.stdev;
    return vapply3(x6, (v) => (Number(v) - m) / s32);
  }
  function project(v, u) {
    if (isSeries3(v)) {
      if (isSeries3(u)) {
        return new Series3(project(v.values, u.values));
      } else {
        const out32 = v.copy();
        out32.values = project(v.values, u);
        return out32;
      }
    }
    if (isSeries3(u)) {
      const out32 = u.copy();
      out32.values = project(v, u.values);
      return out32;
    }
    assert3(isArray3(v), "`project` only works on vectors!");
    assert3(isArray3(u), "`project` only works on vectors!");
    assert3(shape3(v).length === 1, "`project` only works on vectors!");
    assert3(shape3(u).length === 1, "`project` only works on vectors!");
    return scale3(Number(dot4(u, v)) / Number(dot4(u, u)), u);
  }
  function orthonormalize(x6) {
    if (isDataFrame3(x6)) {
      const out4 = new DataFrame3(orthonormalize(x6.values));
      out4.index = x6.index.slice();
      out4.columns = x6.columns.slice();
      return out4;
    }
    assert3(
      isArray3(x6) && !isJagged3(x6) && shape3(x6).length === 2,
      "`orthonormalize` only works on matrices!"
    );
    const temp = transpose3(x6);
    const bases = [];
    temp.forEach((v) => {
      let temp2 = v;
      bases.forEach((basis) => {
        temp2 = subtract3(temp2, project(temp2, basis));
      });
      bases.push(temp2);
    });
    const shouldIgnoreNaNs = true;
    const out32 = bases.map(
      (basis) => divide3(basis, getMagnitude(basis, shouldIgnoreNaNs))
    );
    return transpose3(out32);
  }
  function isBinary2(stats32) {
    const xset = stats32.counts.values;
    return xset.length < 3 && (xset.length === 2 && isEqual3(xset.toSorted(), [0, 1]) || xset.length === 1 && (xset[0] === 0 || xset[0] === 1));
  }
  function getNumericalValues(stats32) {
    const out32 = [];
    stats32.counts.values.forEach((value) => {
      if (isNumber3(value)) {
        const count32 = stats32.counts.get(value);
        for (let i = 0; i < count32; i++) {
          out32.push(value);
        }
      }
    });
    return out32;
  }
  var OutlierMitigator = class {
    constructor(options) {
      options = options || {};
      this.isAllowedToClip = !isUndefined3(options.isAllowedToClip) ? options.isAllowedToClip : true;
      this.isAllowedToTakeTheLog = !isUndefined3(options.isAllowedToTakeTheLog) ? options.isAllowedToTakeTheLog : false;
      this.maxScore = options.maxScore || 5;
      assert3(
        isBoolean3(this.isAllowedToClip),
        "The `isAllowedToClip` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"
      );
      assert3(
        isBoolean3(this.isAllowedToTakeTheLog),
        "The `isAllowedToTakeTheLog` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"
      );
      assert3(
        isNumber3(this.maxScore) && this.maxScore >= 0,
        "The `maxScore` property on the options object passed into the `OutlierMitigator` constructor must have a non-negative number value!"
      );
      this.mad = 0;
      this.median = 0;
    }
    fit(x6) {
      if (isDataFrame3(x6) || isSeries3(x6)) {
        return this.fit(x6.values);
      }
      assert3(
        isArray3(x6),
        "The `OutlierMitigator.fit` method only works on arrays, Series, and DataFrames!"
      );
      if (x6.length === 0) {
        return;
      }
      const results = stats3(x6, {
        shouldDropNaNs: true,
        median: true
      });
      if (isBinary2(results)) {
        return this;
      }
      const xnums = getNumericalValues(results);
      this.median = Number(results.median);
      this.mad = Number(
        stats3(vabs3(subtract3(xnums, this.median)), { median: true }).median
      );
      return this;
    }
    fitAndTransform() {
      return this.fit(arguments[0]).transform(...arguments);
    }
    transform() {
      if (arguments.length > 1) {
        return Array.from(arguments).map((a) => this.transform(a));
      }
      const x6 = arguments[0];
      if (isDataFrame3(x6) || isSeries3(x6)) {
        return this.transform(x6.values);
      }
      assert3(
        isArray3(x6),
        "The `OutlierMitigator.transform` method only works on arrays, Series, and DataFrames!"
      );
      const results = stats3(x6, { shouldDropNaNs: true });
      const xnums = getNumericalValues(results);
      let outlierIsImmediatelyAboveOrBelowMedian = false;
      if (this.mad === 0) {
        const low = [];
        const high = [];
        let highestLowValue = -Infinity;
        let lowestHighValue = Infinity;
        xnums.forEach((value) => {
          if (value < this.median) {
            low.push(value);
            if (value > highestLowValue) {
              highestLowValue = value;
            }
          } else if (value > this.median) {
            high.push(value);
            if (value < lowestHighValue) {
              lowestHighValue = value;
            }
          }
        });
        let before = this.median;
        let after = this.median;
        if (low.length > 0) before = highestLowValue;
        if (high.length > 0) after = lowestHighValue;
        this.mad = (after - before) / 2;
        if (this.mad === 0) {
          return x6;
        }
        outlierIsImmediatelyAboveOrBelowMedian = (this.median - before) / this.mad > this.maxScore || (after - this.median) / this.mad > this.maxScore;
      }
      const score = stats3(divide3(vabs3(subtract3(xnums, this.median)), this.mad)).max;
      if (score > this.maxScore || outlierIsImmediatelyAboveOrBelowMedian) {
        let outMin = null;
        let out32 = copy3(x6);
        if (this.isAllowedToClip) {
          out32 = vapply3(out32, (v) => {
            v = isNumber3(v) ? vclamp3(
              v,
              this.median - this.maxScore * this.mad,
              this.median + this.maxScore * this.mad
            ) : v;
            if (this.isAllowedToTakeTheLog && isNumber3(v) && (outMin === null || v < outMin)) {
              outMin = v;
            }
            return v;
          });
        }
        if (this.isAllowedToTakeTheLog) {
          if (outMin === null) {
            outMin = stats3(out32).min;
          }
          out32 = vapply3(out32, (v) => {
            if (isNumber3(v)) {
              return vlog3(v - outMin + 1);
            } else {
              return v;
            }
          });
        }
        return out32;
      } else {
        return x6;
      }
    }
  };
  function rSquared(xTrue, xPred, shouldIgnoreNaNs) {
    if (isDataFrame3(xTrue) || isSeries3(xTrue)) {
      return rSquared(xTrue.values, xPred);
    }
    if (isDataFrame3(xPred) || isSeries3(xPred)) {
      return rSquared(xTrue, xPred.values);
    }
    assert3(
      isArray3(xTrue),
      "You must pass two same-shaped numerical arrays into the `rSquared` function!"
    );
    assert3(
      isArray3(xPred),
      "You must pass two same-shaped numerical arrays into the `rSquared` function!"
    );
    assert3(
      isEqual3(shape3(xTrue), shape3(xPred)),
      "You must pass two same-shaped numerical arrays into the `rSquared` function!"
    );
    if (shouldIgnoreNaNs) {
      const results = dropNaNPairwise3(xTrue, xPred);
      xTrue = results[0];
      xPred = results[1];
    }
    const num = Number(sum3(vpow3(subtract3(xTrue, xPred), 2)));
    const den = Number(sum3(vpow3(subtract3(xTrue, mean3(xTrue)), 2)));
    if (den === 0) return NaN;
    return 1 - num / den;
  }
  function rScore(yTrue, yPred, shouldIgnoreNaNs) {
    const r22 = rSquared(yTrue, yPred, shouldIgnoreNaNs);
    return vsign3(r22) * vsqrt3(vabs3(r22));
  }
  function standardize() {
    return normalize(...arguments);
  }
  var StandardScaler = class {
    constructor(options) {
      options = options || {};
      this.means = [];
      this.stdevs = [];
      this.wasFittedOnAVector = false;
      this.hasBeenFitted = false;
      this.shouldIgnoreNaNs = typeof options.shouldIgnoreNaNs === "undefined" ? false : options.shouldIgnoreNaNs;
    }
    _getDataArrayAndShape(x6) {
      if (isDataFrame3(x6)) {
        return [x6.values, x6.shape];
      }
      if (isSeries3(x6)) {
        const out32 = transpose3([x6.values]);
        return [out32, shape3(out32)];
      }
      assert3(
        isArray3(x6),
        "`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"
      );
      const xShape = shape3(x6);
      assert3(
        xShape.length < 3,
        "`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"
      );
      if (xShape.length === 1) {
        xShape.push(1);
        x6 = transpose3([x6]);
      }
      return [x6, xShape];
    }
    fit(x6) {
      const results = this._getDataArrayAndShape(x6);
      x6 = results[0];
      const xShape = results[1];
      this.wasFittedOnAVector = xShape.indexOf(1) > -1;
      this.means = [];
      this.stdevs = [];
      range3(0, xShape[1]).forEach((j) => {
        const values = x6.map((row) => row[j]);
        const results2 = stats3(values, {
          shouldDropNaNs: this.shouldIgnoreNaNs,
          stdev: true
        });
        this.means.push(results2.mean);
        this.stdevs.push(results2.stdev);
      });
      this.hasBeenFitted = true;
      return this;
    }
    fitAndTransform() {
      return this.fit(arguments[0]).transform(...arguments);
    }
    transform() {
      const datas = Array.from(arguments);
      if (datas.length > 1) {
        return datas.map((data) => this.transform(data));
      }
      let x6 = datas[0];
      if (!this.hasBeenFitted) {
        throw new Error(
          "This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method."
        );
      }
      if (isDataFrame3(x6)) {
        const out4 = new DataFrame3(this.transform(x6.values));
        out4.columns = x6.columns;
        out4.index = x6.index;
        return out4;
      }
      if (isSeries3(x6)) {
        const out4 = new Series3(this.transform(x6.values));
        out4.name = x6.name;
        out4.index = x6.index;
        return out4;
      }
      const results = this._getDataArrayAndShape(x6);
      x6 = results[0];
      const xShape = results[1];
      assert3(
        xShape[1] === this.means.length,
        "The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!"
      );
      const out32 = x6.map((row) => {
        return row.map((v, j) => {
          return (Number(v) - Number(this.means[j])) / Number(this.stdevs[j]);
        });
      });
      if (this.wasFittedOnAVector) {
        return flatten3(out32);
      } else {
        return out32;
      }
    }
    untransform(x6) {
      if (!this.hasBeenFitted) {
        throw new Error(
          "This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method."
        );
      }
      if (isDataFrame3(x6)) {
        const out4 = new DataFrame3(this.untransform(x6.values));
        out4.columns = x6.columns;
        out4.index = x6.index;
        return out4;
      }
      if (isSeries3(x6)) {
        const out4 = new Series3(this.untransform(x6.values));
        out4.name = x6.name;
        out4.index = x6.index;
        return out4;
      }
      const results = this._getDataArrayAndShape(x6);
      x6 = results[0];
      const xShape = results[1];
      assert3(
        xShape[1] === this.means.length,
        "The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!"
      );
      const out32 = x6.map((row) => {
        return row.map((v, j) => {
          return v * this.stdevs[j] + this.means[j];
        });
      });
      if (this.wasFittedOnAVector) {
        return flatten3(out32);
      } else {
        return out32;
      }
    }
  };
  function trainTestSplit() {
    const args = Array.from(arguments);
    const datasets = args.filter((a) => isArray3(a) || isDataFrame3(a) || isSeries3(a));
    const options = args.find((a) => !datasets.includes(a) && typeof a === "object") || {};
    const shouldShuffle = isUndefined3(options.shouldShuffle) ? true : options.shouldShuffle;
    const testSize = isUndefined3(options.testSize) ? 0.1 : options.testSize;
    assert3(
      isBoolean3(shouldShuffle),
      "If passing an options object to the `trainTestSplit` function and including a `shouldShuffle` property on that object, then the value of that property must be a boolean!"
    );
    assert3(
      isNumber3(testSize) && testSize > 0 && testSize < 1,
      "If passing an options object to the `trainTestSplit` function and including a `testSize` property on that object, then the value of that property must be a number between 0 and 1 (exclusive on both ends)!"
    );
    assert3(
      datasets.length > 0,
      "You must pass at least one dataset into the `trainTestSplit` function!"
    );
    const shapes = datasets.map((d) => shape3(d)[0]);
    assert3(
      set4(shapes).length === 1,
      `All datasets passed into the \`trainTestSplit\` function must have the same length at their shallowest dimension! The lengths of the datasets you provided, though, are: ${shapes.join(
        ", "
      )}`
    );
    const out32 = [];
    const index = shouldShuffle ? shuffle3(range3(0, shapes[0])) : range3(0, shapes[0]);
    const split = vint3((1 - testSize) * index.length);
    const trainIndex = index.slice(0, split);
    const testIndex = index.slice(split);
    datasets.forEach((d) => {
      if (isDataFrame3(d)) {
        out32.push(d.get(trainIndex, null));
        out32.push(d.get(testIndex, null));
      } else if (isSeries3(d)) {
        out32.push(d.get(trainIndex));
        out32.push(d.get(testIndex));
      } else {
        const train = [];
        const test2 = [];
        d.forEach((v, i) => {
          if (trainIndex.includes(i)) {
            train.push(v);
          } else {
            test2.push(v);
          }
        });
        out32.push(train);
        out32.push(test2);
      }
    });
    return out32;
  }
  if (typeof window !== "undefined") {
    window.JSDataScienceHelpers = {
      cohensd,
      convertToNumerical,
      diagonalize,
      getCorrelationMatrix,
      getHighlyCorrelatedColumns,
      getMagnitude,
      getOneHotEncodings,
      getPercentages,
      getPValueMatrix,
      hunterChainSort,
      IndexMatcher: IndexMatcher32,
      isBinary,
      isCorrelationMatrix,
      isWholeNumber: isWholeNumber23,
      KMeans,
      MathError: MathError3,
      normalize,
      orthonormalize,
      OutlierMitigator,
      project,
      pValue: ttest,
      rScore,
      rSquared,
      standardize,
      StandardScaler,
      trainTestSplit
    };
  }

  // tests/browser/src/tests-worker.mjs
  var { accuracy: accuracy2 } = Vot;
  var { orderCentroids: orderCentroids2 } = Bot;
  var { TFKMeansMeta } = Got;
  var test = (desc, fn2) => fn2();
  function expect(value) {
    return {
      toBe(x6) {
        if (x6 !== value) {
          throw new Error(`We expected ${value} but received ${x6}!`);
        }
      },
      toBeGreaterThan(x6) {
        if (value <= x6) {
          throw new Error(
            `Expected ${value} to be greater than ${x6}, but it's not!`
          );
        }
      },
      toBeLessThan(x6) {
        if (value >= x6) {
          throw new Error(`Expected ${value} to be less than ${x6}, but it's not!`);
        }
      }
    };
  }
  function createGenericTest(progFn) {
    test("tests that the`TFKMeansMeta` model works correctly", async () => {
      const centroidsTrue = normal([5, 10]);
      const labels = [];
      const x6 = range(0, 500).map(() => {
        const index = vint(random() * centroidsTrue.length);
        const c = centroidsTrue[index];
        labels.push(index);
        return vadd(c, scale(0.1, normal(shape(c))));
      });
      const [xTrain, xTest, labelsTrain, labelsTest] = trainTestSplit(x6, labels);
      const model = new TFKMeansMeta();
      const fitStep = model.getFitStepFunction(xTrain, progFn);
      let state;
      while (!state || !state.isFinished) {
        state = await fitStep(xTrain, progFn);
      }
      model.centroids = orderCentroids2(centroidsTrue, model.centroids);
      const labelsTrainPred = model.predict(xTrain);
      const labelsTestPred = model.predict(xTest);
      expect(model.k).toBe(5);
      expect(rScore(centroidsTrue, model.centroids)).toBeGreaterThan(0.95);
      expect(accuracy2(labelsTrain, labelsTrainPred)).toBeGreaterThan(0.95);
      expect(accuracy2(labelsTest, labelsTestPred)).toBeGreaterThan(0.95);
    });
  }
  var drone = new Bee.Drone();
  var progress;
  var startTime;
  drone.on("start-tests", (request, response) => {
    console.log("drone is starting tests...");
    response.send(true);
    startTime = /* @__PURE__ */ new Date();
    progress = 0;
    createGenericTest((p) => progress = p);
  });
  drone.on("get-progress", (request, response) => {
    console.log("drone is getting progress...");
    return response.send(progress);
  });
  drone.on("get-results", (request, response) => {
    console.log("drone is getting results...");
    return response.send(/* @__PURE__ */ new Date() - startTime);
  });
})();
/*! Bundled license information:

@tensorflow/tfjs-core/dist/backends/backend.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/util_base.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/environment.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/global_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/log.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/kernel_registry.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/platforms/is_typed_array_browser.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/hash_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/profiler.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tape.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor_format.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/types.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/engine.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/device_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/flags.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor_util_env.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/operation.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/complex.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/types.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/globals.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/io_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/router_registry.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/indexed_db.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/local_storage.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/model_management.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/platforms/platform_browser.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/platforms/platform_node.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/buffer.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cast.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/clone.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/print.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/base_side_effects.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/floorDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/div.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/abs.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/acos.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/acosh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/all.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/any.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/arg_max.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/arg_min.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/asin.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/asinh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/atan.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/atan2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/atanh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/avg_pool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/avg_pool_3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/concat.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mat_mul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sigmoid.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tanh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/batch_to_space_nd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/batchnorm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/broadcast_to.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ceil.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fill.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/clip_by_value.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv2d_backprop_input.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv3d_backprop_input.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cos.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cosh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cumprod.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the 'License');
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cumsum.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dense_bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depth_to_space.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depthwise_conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dilation2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/broadcast_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/where.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/zeros_like.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/div_no_nan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/einsum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/elu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/erf.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/axis_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/min.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/pow.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/scalar.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sqrt.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/square.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sum.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/norm.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/euclidean_norm.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/exp.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/expand_dims.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/expm1.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tile.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/eye.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/floor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/gather.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/greater_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/imag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/is_finite.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/is_inf.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/is_nan.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/leaky_relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/less_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/local_response_normalization.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log1p.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/neg.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/softplus.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log_sigmoid.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log_softmax.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log_sum_exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_and.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_not.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_or.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_xor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool_3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mean.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/zeros.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ones.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mirror_pad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/moments.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/not_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/one_hot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ones_like.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/pad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/pool.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/prelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rand_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/random_normal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/random_uniform.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/range.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/real.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reciprocal.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/relu6.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reverse.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/round.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rsqrt.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/selu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sign.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sin.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sinh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice1d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice2d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice3d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice4d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/softmax.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/fft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/ifft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/irfft.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/split.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/rfft.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/squared_difference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/squeeze.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/stack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/step.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/strided_slice.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tan.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor1d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor2d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/topk.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/truncated_normal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/unique.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/unsorted_segment_sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/unstack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/variable.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/where_impl.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/transpose.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dropout_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dropout.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv2d_backprop_filter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused/conv2d.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_filter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_input.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused/depthwise_conv2d.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused/mat_mul.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused_ops.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/crop_and_resize.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/flip_left_right.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/grayscale_to_rgb.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/rgb_to_grayscale.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/rotate_with_offset.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/nonmax_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/resize_bilinear.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/resize_nearest_neighbor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/threshold.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/transform.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linalg/band_part.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linalg/gram_schmidt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linalg/qr.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ops.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/serialization.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adadelta_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adagrad_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adam_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adamax_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/sgd_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/momentum_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/rmsprop_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/register_optimizers.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/browser_files.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/progress.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/weights_loader.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/http.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/passthrough.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/io.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/optimizer_constructors.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/train.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/browser_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/concat_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ragged_to_dense_util.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reduce_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rotate_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/array_ops_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/selu_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/erf_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/complex_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/einsum_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_reduction_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/segment_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/backend_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/kernel_impls.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/base.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Abs_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Acos_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Acosh_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Add_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/AddN_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ArgMax_grad.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ArgMin_grad.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Asin_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Asinh_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Atan2_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Atan_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Atanh_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/avg_pool_3d_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/AvgPool3D_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/avg_pool_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/AvgPool_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/BatchMatMul_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/BatchToSpaceND_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/BroadcastTo_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Cast_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Ceil_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ClipByValue_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ComplexAbs_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Concat_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Conv2D_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Conv2DBackpropInput_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv3d_backprop_filter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Conv3D_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Cos_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Cosh_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Cumsum_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/DepthwiseConv2dNative_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Dilation2D_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Elu_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Erf_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Exp_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ExpandDims_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Expm1_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Floor_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/FloorDiv_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/FusedBatchNorm_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/GatherV2_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/GreaterEqual_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Identity_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/IsFinite_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/IsInf_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/IsNan_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/LeakyRelu_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Log1p_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Log_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/LogSoftmax_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/local_response_normalization_backprop.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/LRN_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/min_max_grad_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Max_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Maximum_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool_3d_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/MaxPool3D_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/MaxPool_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Mean_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Min_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Minimum_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/MirrorPad_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Mod_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Multiply_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Neg_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/OneHot_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/OnesLike_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Pack_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/PadV2_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Pow_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Prelu_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Prod_grad.js:
  (**
   * @license
   * Copyright 2022 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/RealDiv_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Reciprocal_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Relu6_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Relu_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Reshape_grad.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ResizeBilinear_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ResizeNearestNeighbor_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Reverse_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Round_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Rsqrt_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Select_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Selu_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sigmoid_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sign_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sin_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sinh_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Slice_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Softmax_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Softplus_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/SpaceToBatchND_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/SplitV_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sqrt_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Square_grad.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/SquaredDifference_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Step_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sub_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Sum_grad.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Tan_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Tanh_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Tile_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Transpose_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/Unpack_grad.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/UnsortedSegmentSum_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients/ZerosLike_grad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/register_all_gradients.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/abs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/acos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/acosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/all.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/any.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/arg_max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/arg_min.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as_scalar.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as_type.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as1d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as4d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/as5d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/asin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/asinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/atan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/atan2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/atanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/batch_to_space_nd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/batchnorm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/broadcast_to.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/cast.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/ceil.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/clip_by_value.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/concat.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/conv1d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/conv2d_transpose.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/cos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/cosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/cumprod.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the 'License');
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/cumsum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/depth_to_space.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/depthwise_conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/dilation2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/div_no_nan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/div.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/dot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/elu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/erf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/euclidean_norm.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/expand_dims.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/expm1.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/fft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/flatten.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/floor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/floorDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/gather.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/greater_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/ifft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/irfft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/is_finite.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/is_inf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/is_nan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/leaky_relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/less_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/local_response_normalization.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/log_sigmoid.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/log_softmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/log_sum_exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/log.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/log1p.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/logical_and.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/logical_not.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/logical_or.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/logical_xor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/mat_mul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/mean.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/min.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/mirror_pad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/mod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/mul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/neg.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/norm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/not_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/one_hot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/ones_like.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/pad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/pow.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/prelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/reciprocal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/relu6.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/reshape_as.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/resize_bilinear.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/resize_nearest_neighbor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/reverse.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/rfft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/round.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/rsqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/selu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/separable_conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sigmoid.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sign.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/slice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/softmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/softplus.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/space_to_batch_nd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/split.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/square.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/squared_difference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/squeeze.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/stack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/step.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/strided_slice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/tan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/tanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/tile.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/to_bool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/to_float.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/to_int.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/topk.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/transpose.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/unique.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/unsorted_segment_sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/unstack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/where.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/zeros_like.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/public/chained_ops/register_all_chained_ops.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/errors.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/executor_utils.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/generic_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/backend/state.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/keras_format/common.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/common.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/math_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/backend/common.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/keras_format/initializer_config.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/initializers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/types_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/variable_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/variables.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/topology.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/input_layer.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/flags_layers.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/constraints.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/exports_constraints.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/exports_initializers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/logs.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/base_callbacks.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/serialization.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/losses.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/metrics.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/optimizers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/user_defined_metadata.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/layer_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/serialization_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/version.js:
  (** @license See the LICENSE file. *)

@tensorflow/tfjs-layers/dist/engine/container.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/training_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/training_dataset.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/training_tensors.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/training.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/models.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/exports.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/activations.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/regularizers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/advanced_activations.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/utils/conv_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/convolutional.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/convolutional_depthwise.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/recurrent.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/core.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/embeddings.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/merge.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/noise.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/normalization.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/padding.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/pooling.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/wrappers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/preprocessing/image_preprocessing.js:
  (**
   * @license
   * Copyright 2022 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/preprocessing/center_crop.js:
  (**
   * @license
   * Copyright 2022 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/preprocessing/preprocessing_utils.js:
  (**
   * @license
   * Copyright 2022 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/preprocessing/category_encoding.js:
  (**
   * @license
   * Copyright 2022 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/preprocessing/image_resizing.js:
  (**
   * @license
   * Copyright 2022 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/backend/random_seed.js:
  (**
   * @license
   * Copyright 2023 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/engine/base_random_layer.js:
  (**
   * @license
   * Copyright 2023 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/layers/preprocessing/random_width.js:
  (**
   * @license
   * Copyright 2023 CodeSmith LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/exports_layers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/exports_models.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/exports_regularizers.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/callbacks.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/index.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Use of this source code is governed by an MIT-style
   * license that can be found in the LICENSE file or at
   * https://opensource.org/licenses/MIT.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/flags.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/data/compiled_api.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/custom_op/register.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/arithmetic.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/basic_math.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/control.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/convolution.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/creation.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/dynamic.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/evaluation.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/graph.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/hash_table.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/image.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/logical.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/matrices.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/normalization.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/reduction.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/slice_join.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/sparse.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/spectral.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/string.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/transformation.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/operation_mapper.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/custom_op/node_value_impl.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/arithmetic_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/basic_math_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/tensor_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/tensor_array.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/tensor_list.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/convolution_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/creation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/dynamic_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/evaluation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/graph_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/hash_table.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/hash_table_executor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/image_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/logical_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/matrices_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/normalization_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/ragged_executor.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/reduction_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/sparse_executor.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/spectral_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/string_executor.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/transformation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/operation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/model_analysis.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/graph_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/graph_model.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/version.js:
  (** @license See the LICENSE file. *)

@tensorflow/tfjs-converter/dist/index.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/util/deep_map.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/util/deep_clone.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/util/ring_buffer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/util/growing_ring_buffer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/lazy_iterator.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/dataset.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/datasets/text_line_dataset.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/datasets/csv_dataset.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/microphone_iterator.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/webcam_iterator.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/datasource.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/string_iterator.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/byte_chunk_iterator.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/file_chunk_iterator.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/iterators/url_chunk_iterator.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/util/source_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/sources/file_data_source.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/sources/url_data_source.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/readers.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/version.js:
  (** @license See the LICENSE file. *)

@tensorflow/tfjs-data/dist/index.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/cpu_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/BitwiseAnd.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/FloorDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd_Impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GreaterEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LessEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Scatter_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sigmoid.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StaticRegexReplace.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/shared.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/base.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Elu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LeakyRelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Prelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Relu6.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/fused_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/BatchMatMul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/_FusedMatMul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Acos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Acosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/AddN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/All.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Any.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ArgMax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ArgMin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Asin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Asinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Atan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Atan2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Atanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/pool_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool3DGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPoolGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/BatchNorm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/BatchToSpaceND.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/BroadcastArgs.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ClipByValue.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ComplexAbs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Imag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Concat.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2DBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2DBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3DBackpropFilterV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3DBackpropInputV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Cos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Cosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/CropAndResize.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Cumprod.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Cumsum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/DenseBincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/DepthToSpace.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNative.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNativeBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Diag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2DBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2DBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Draw.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Einsum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/EluGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Erf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ExpandDims.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RealDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/fft_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/FFT.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Fill.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/FlipLeftRight.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/FusedConv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/FusedDepthwiseConv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/IFFT.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/IsFinite.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/IsInf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/IsNaN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Log1p.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalAnd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalNot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalOr.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LRN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LRNGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool3DGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolWithArgmax_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolWithArgmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Mean.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Min.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/MirrorPad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Mod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Softmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Multinomial.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV3.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV4.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV5.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/OneHot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ZerosLike.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/OnesLike.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Pack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/PadV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Pow.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Range.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Reciprocal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinear.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinearGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighbor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighborGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Reverse.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RotateWithOffset.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Round.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/ScatterNd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SearchSorted_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SearchSorted.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Select.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Selu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sign.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Softplus.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SpaceToBatchND.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentMean.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentSum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseToDense.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SplitV.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Square.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Step.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Tan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Tanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/TensorScatterUpdate.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Tile.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/TopK.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Transform.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Unique.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Unpack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/UnsortedSegmentSum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/register_all_kernels.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/index.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/canvas_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/tex_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/webgl_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/glsl_version.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/packing_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/texture_manager.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/base.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/All.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BitwiseAnd.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BroadcastArgs.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_backprop_packed_gpu.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cum_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cumprod.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Einsum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedGather.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedRange.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedTensorToTensor.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/scatter_packed_gpu.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/search_sorted_gpu.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SearchSorted.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/select_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseFillEmptyRows.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseReshape.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentMean.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentSum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StaticRegexReplace.js:
  (**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StringNGrams.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StringSplit.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StringToHashBucketFast.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/TensorScatterUpdate.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/transform_gpu.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Transform.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/index.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs/dist/version.js:
  (** @license See the LICENSE file. *)

@tensorflow/tfjs/dist/index.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
